<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-19T11:53:04.512Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一封信</title>
    <link href="http://yoursite.com/2019/09/14/%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/09/14/一封信/</id>
    <published>2019-09-13T16:00:00.000Z</published>
    <updated>2019-10-19T11:53:04.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一封信"><a href="#一封信" class="headerlink" title="一封信"></a>一封信</h2><p>我们相遇已经2284天啦~<br>虽然我文笔不好,但你也要把这封信读完喔~</p><p>作为你的男朋友,我很荣幸. 时间,无法冲淡我对你的感情.<br>“一想到你,我这张丑脸就泛起微笑.”</p><p>准确的来说  ,  我们是高一下学期开始交流的, 开始喜欢你的日子已经不记得了, 那段时间,一门心思想和你走近, 自顾自的要送你回家, 和你坐一班公交, 与其说是送你回家不如说是满足自己的欲望, 记得第一次, 坐了反向的公交…</p><p>第一次和你散步,第一次和你写纸条,第一次和你坐公车,第一次和你写信,第一次和你吃牛排, 第一次和你去KTV…</p><p>不知道是哪件事成了导火索, 开启了冷战时期, 断断续续,那段时间可以说是我的黑暗时期啦,浑浑噩噩的<br>那时候的我也实在是幼稚啊.</p><p>我跟你好像A股, 跌宕起伏,但好在总体是往好的趋势.</p><p>分班的时候看到你的名字和我的名字出现在同一张上, 我真的特别开心.<br>班主任也换了, 不再是恶心人的小王, 老零太好了.<br>距离近了, 缺点也暴露出来了, 我的缺陷一一在你面前暴露, 虽然我还喜欢你, 但是有谁会喜欢一个一无是处的混小子呢.<br>那时候我对于爱的定义真的很幼稚, 我借作业给你抄 而不是耐心教你, 你高考没考好我有很大的责任.</p><p>高考考完, 你没告诉我报了哪里, 只说浙江, 我便去了杭州, 你在绍兴, 很近.</p><p>我好像从来不是一个主动的人. 我们的关系也变得疏远.<br>后来是你主动来了杭州,于是 每隔一段时间 要不是你来杭州, 便是我去绍兴</p><p>在去年6月25日, 我们在一起了, 但是时间不长, 一个月   </p><p>这个暑假,你在银行暑期实践, 我在驾校学车.</p><p>随后没有联系,除了一两句问候.</p><p>好在 冬季来临前, 我们缓和了, 又成了朋友.<br>又一次你来杭州, 吃了烤肉,吃了青疏, 你告诉我你有男朋友,不过准备分手.那时候我有点接受不了, 我连你什么时候有男朋友 我都不知道. 难过又心疼.</p><p>今年刚开年, 发了点不愉快, 我很蠢,感谢你没有放弃我</p><p>今年3月11日夜晚, 顺其自然, 在一起了.<br>整个2019都变得不一样了.<br>我们牵手,拥抱,睡觉, 我们聊天,谈心,思考<br>我们见面,约会,小小旅行</p><p>今年的生日也是我最难忘的一个, 小王子的情书, 小王子的蛋糕, 还有情侣款的书包.</p><p>我知道我不完美, 我有各种各样的小毛病, 有时候会让你伤心, 我会努力变好, 也请你要一直和我在一起啊</p><p>你身体不好, 我不在你身边,你一定要好好照顾自己, 不好喝酒, 不要熬夜, 不要不吃早饭. 要按时吃饭,天冷了记得添衣服, 下雨要撑伞,出去玩要注意安全, 身体最重要<br>你是我的铠甲,也是我的软肋,所以我不在的时候, 要好好照顾自己.</p><p>宝贝,我们在一起已经187天啦,但我们的故事才刚刚开了头, 我会珍惜未来的每一天,爱你就像爱生命,并且让自己越来越好<br>人生还很长,我想陪你走完<br>我爱你,宝贝,生日快乐!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100010101100001011101000110100101101110011001110010000001001001001000000110110001101111011101100110010100100000011110010110111101110101001000000111010001101000011100100110010101100101001000000111010001101000011011110111010101110011011000010110111001100100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一封信&quot;&gt;&lt;a href=&quot;#一封信&quot; class=&quot;headerlink&quot; title=&quot;一封信&quot;&gt;&lt;/a&gt;一封信&lt;/h2&gt;&lt;p&gt;我们相遇已经2284天啦~&lt;br&gt;虽然我文笔不好,但你也要把这封信读完喔~&lt;/p&gt;
&lt;p&gt;作为你的男朋友,我很荣幸. 时间,无法冲淡
      
    
    </summary>
    
    
      <category term="生活方式" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="http://yoursite.com/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2019/07/30/JVM指令手册/</id>
    <published>2019-07-30T07:18:00.000Z</published>
    <updated>2019-10-19T00:10:20.374Z</updated>
    
    <content type="html"><![CDATA[<p>栈和局部变量操作<br>将常量压入栈的指令<br>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值<br>将栈中的值存入局部变量的指令<br>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中<br>wide指令<br>wide 使用附加字节扩展局部变量索引<br>通用(无类型）栈操作<br>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容<br>类型转换<br>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型<br>整数运算<br>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上<br>逻辑运算<br>移位操作<br>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作<br>按位布尔运算<br>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作<br>浮点运算<br>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反<br>对象和数组<br>对象操作指令<br>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型<br>数组操作指令<br>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组<br>控制流<br>条件分支指令<br>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转<br>比较指令<br>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）<br>无条件转移指令<br>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）<br>表跳转指令<br>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<br>异常<br>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回<br>方法调用指令<br>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法<br>方法返回指令<br>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void<br>线程同步<br>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><hr><p>JVM指令助记符<br>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈和局部变量操作&lt;br&gt;将常量压入栈的指令&lt;br&gt;aconst_null 将null对象引用压入栈&lt;br&gt;iconst_m1 将int类型常量-1压入栈&lt;br&gt;iconst_0 将int类型常量0压入栈&lt;br&gt;iconst_1 将int类型常量1压入栈&lt;br&gt;iconst_
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>系统开发和运行知识</title>
    <link href="http://yoursite.com/2018/01/13/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/01/13/系统开发和运行知识/</id>
    <published>2018-01-13T14:40:00.000Z</published>
    <updated>2019-10-19T00:10:01.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件工程、软件过程改进和软件开发项目管理知识"><a href="#1-软件工程、软件过程改进和软件开发项目管理知识" class="headerlink" title="1. 软件工程、软件过程改进和软件开发项目管理知识"></a>1. 软件工程、软件过程改进和软件开发项目管理知识</h3><ul><li>软件工程知识</li><li>软件开发生命周期各阶段的目标和任务</li><li>软件开发项目管理基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具</li><li>主要的软件开发方法（生命周期法、原型法、面向对象法、CASE）</li><li>软件开发工具与环境知识</li><li>软件过程改进知识</li><li>软件质量管理知识</li><li>软件开发过程评估、软件能力成熟评估基础知识<h3 id="2-系统分析基础知识"><a href="#2-系统分析基础知识" class="headerlink" title="2. 系统分析基础知识"></a>2. 系统分析基础知识</h3></li><li>系统分析的目的和任务</li><li>结构化分析方法（数据流图（DFD）、数据字典（DD）、实体关系图（ERD）、描述加工处理的结构化语言）</li><li>统一建模语言（UML）</li><li>系统规格说明书<h3 id="3-系统设计知识"><a href="#3-系统设计知识" class="headerlink" title="3. 系统设计知识"></a>3. 系统设计知识</h3></li><li>系统设计的目的和任务</li><li>结构化设计方法和工具（系统流程图、HIPO图、控制流程图）</li><li>系统总体结构设计（总体布局、设计原则、模块结构设计、数据存储设计、系统配置方案）</li><li>系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计）</li><li>系统设计说明书<h3 id="4-系统实施知识"><a href="#4-系统实施知识" class="headerlink" title="4. 系统实施知识"></a>4. 系统实施知识</h3></li><li>系统实施的主要任务</li><li>结构化程序设计、面向对象程序设计、可视化程序设计</li><li>程序设计风格</li><li>程序设计语言的选择</li><li>系统测试的目的、类型，系统测试方法（黑盒测试、白盒测试、灰盒测试）</li><li>测试设计和管理（错误曲线、错误排除、收敛、注入故障、测试用例设计、系统测试报告）</li><li>系统转换基础知识<h3 id="5-系统运行和维护知识"><a href="#5-系统运行和维护知识" class="headerlink" title="5. 系统运行和维护知识"></a>5. 系统运行和维护知识</h3></li><li>系统运行管理基础知识</li><li>系统维护基础知识</li><li>系统评价基础知识<h3 id="6-面向对象开发方法"><a href="#6-面向对象开发方法" class="headerlink" title="6. 面向对象开发方法"></a>6. 面向对象开发方法</h3></li><li>面向对象开发概念（类、对象、属性、封装性、继承性、多态性、对象之间的引用）</li><li>面向对象开发方法的优越性以及有效领域</li><li>面向对象设计方法（体系结构、类的设计、用户接口设计）</li><li>面向对象实现方法（选择程序设计语言、类的实现、方法的实现、用户接口的实现、准备测试数据）</li><li>面向对象程序设计语言（如C++、Java、Visual、Bsasic、Visual C++）的基本机制</li><li>面向对象数据库、分布式对象的概念</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;a href=&quot;#1-软件工程、软件过程改进和软件开发项目管理知识&quot; class=&quot;headerlink&quot; title=&quot;1. 软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;/a&gt;1. 软件工程、软件过程改
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统知识</title>
    <link href="http://yoursite.com/2017/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2017/12/30/计算机系统知识/</id>
    <published>2017-12-30T14:36:00.000Z</published>
    <updated>2019-10-19T00:09:45.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-硬件知识"><a href="#1-硬件知识" class="headerlink" title="1. 硬件知识"></a>1. 硬件知识</h3><h4 id="1-1-计算机系统的组成、体系结构分类及特性"><a href="#1-1-计算机系统的组成、体系结构分类及特性" class="headerlink" title="1.1 计算机系统的组成、体系结构分类及特性"></a>1.1 计算机系统的组成、体系结构分类及特性</h4><ul><li>CPU和存储器的组成、性能和基本工作原理</li><li>常用I/O设备、通信设备的性能，以及基本工作原理</li><li>I/O接口的功能、类型和特性</li><li>I/O控制方式（中断系统、DMA、I/O处理机方式）</li><li>CISC/RISC，流水线操作，多处理机，并行处理<h4 id="1-2-存储系统"><a href="#1-2-存储系统" class="headerlink" title="1.2 存储系统"></a>1.2 存储系统</h4></li><li>主存-Cache存储系统的工作原理</li><li>虚拟存储器基本工作原理，多级存储体系的性能价格</li><li>RAID类型和特性<h4 id="1-3-安全性、可靠性与系统性能评测基础知识"><a href="#1-3-安全性、可靠性与系统性能评测基础知识" class="headerlink" title="1.3 安全性、可靠性与系统性能评测基础知识"></a>1.3 安全性、可靠性与系统性能评测基础知识</h4></li><li>诊断与容错</li><li>系统可靠性分析评价</li><li>计算机系统性能评测方式<h3 id="2-软件知识"><a href="#2-软件知识" class="headerlink" title="2. 软件知识"></a>2. 软件知识</h3><h4 id="2-1-操作系统知识"><a href="#2-1-操作系统知识" class="headerlink" title="2.1 操作系统知识"></a>2.1 操作系统知识</h4></li><li>操作系统的内核（中断控制）、进程、线程概念</li><li>处理机管理（状态转换、共享与互斥、分时轮转、抢占、死锁）</li><li>存储管理（主存保护、动态连接分配、分段、分页、虚存）</li><li>设备管理（I/O控制、假脱机）</li><li>文件管理（文件目录、文件组织、存取方法、存取控制、恢复处理）</li><li>作业管理（作业调度、作业控制语言（JCL）、多道程序设计）</li><li>汉字处理，多媒体处理，人机界面</li><li>网络操作系统和嵌入式操作系统基础知识</li><li>操作系统的配置<h4 id="2-2-程序设计语言和语言处理程序的知识"><a href="#2-2-程序设计语言和语言处理程序的知识" class="headerlink" title="2.2 程序设计语言和语言处理程序的知识"></a>2.2 程序设计语言和语言处理程序的知识</h4></li><li>汇编、编译、解释系统的基础知识和基本工作原理</li><li>程序设计语言的基本成分：数据、运算、控制和传输，过程（函数）调用</li><li>各类程序设计语言主要特点和适用情况<h3 id="3-计算机网络知识"><a href="#3-计算机网络知识" class="headerlink" title="3. 计算机网络知识"></a>3. 计算机网络知识</h3></li><li>网络体系结构（网络拓扑、OSI/RM、基本的网络协议）</li><li>传输介质、传输技术、传输方法、传输控制</li><li>常用网络设备和各类通信设备</li><li>Client/Server结构、Browser/Server结构</li><li>LAN拓扑，存取控制，LAN的组网，LAN间连接，LAN-WAN连接</li><li>因特网基础知识以及应用</li><li>网络软件</li><li>网络管理</li><li>网络性能分析<h3 id="4-数据库知识"><a href="#4-数据库知识" class="headerlink" title="4. 数据库知识"></a>4. 数据库知识</h3></li><li>数据库管理系统的功能和特征</li><li>数据库模型（概念模式、外模式、内模式）</li><li>数据模型，ER图，第一范式、第二范式、第三范式</li><li>数据操作（集合运算和关系运算）</li><li>数据库语言（SQL）</li><li>数据库的控制功能（并发控制、恢复、安全性、完整性）</li><li>数据仓库和分布式数据库基础知识<h3 id="5-多媒体知识"><a href="#5-多媒体知识" class="headerlink" title="5. 多媒体知识"></a>5. 多媒体知识</h3></li><li>多媒体系统基础知识，多媒体设备的性能特性，常用多媒体文件格式</li><li>简单图形的绘制，图像文件的处理方法</li><li>音频和视频信息的应用</li><li>多媒体应用开发过程<h3 id="6-系统性能知识"><a href="#6-系统性能知识" class="headerlink" title="6. 系统性能知识"></a>6. 系统性能知识</h3></li><li>性能指标（响应时间、吞吐量、周转时间）和性能设计</li><li>性能测试和性能评估</li><li>可靠性指标及计算、可靠性设计</li><li>可靠性测试和可靠性评估<h3 id="7-计算机应用基础知识"><a href="#7-计算机应用基础知识" class="headerlink" title="7. 计算机应用基础知识"></a>7. 计算机应用基础知识</h3></li><li>信息管理、数据处理、辅助设计、自动控制、科学计算、人工智能等基础知识</li><li>远程通信服务基础知识</li><li>常用应用系统</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-硬件知识&quot;&gt;&lt;a href=&quot;#1-硬件知识&quot; class=&quot;headerlink&quot; title=&quot;1. 硬件知识&quot;&gt;&lt;/a&gt;1. 硬件知识&lt;/h3&gt;&lt;h4 id=&quot;1-1-计算机系统的组成、体系结构分类及特性&quot;&gt;&lt;a href=&quot;#1-1-计算机系统的组成、
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学基础</title>
    <link href="http://yoursite.com/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/12/27/计算机科学基础/</id>
    <published>2017-12-27T14:17:00.000Z</published>
    <updated>2019-10-19T00:09:42.314Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数制及其转换"><a href="#1-数制及其转换" class="headerlink" title="1. 数制及其转换"></a>1. 数制及其转换</h4><p>• 二进制、十进制和十六进制等常用制数制及其相互转换</p><h4 id="2-数据的表示"><a href="#2-数据的表示" class="headerlink" title="2. 数据的表示"></a>2. 数据的表示</h4><p>• 数的表示（原码、反码、补码、移码表示，整数和实数的机内表示，精度和溢出）<br>• 非数值表示（字符和汉字表示、声音表示、图像表示）<br>• 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码）</p><h4 id="3-算术运算和逻辑运算"><a href="#3-算术运算和逻辑运算" class="headerlink" title="3. 算术运算和逻辑运算"></a>3. 算术运算和逻辑运算</h4><p>• 计算机中的二进制数运算方法<br>• 逻辑代数的基本运算和逻辑表达式的化简</p><h4 id="4-数学基础知识"><a href="#4-数学基础知识" class="headerlink" title="4.  数学基础知识"></a>4.  数学基础知识</h4><p>• 命题逻辑、谓词逻辑、形式逻辑的基础知识<br>• 常用数值计算（误差、矩阵和行列式、近似求解方程、插值、数值积分）<br>• 排列组合、概率论应用、应用统计（数据的统计分析）<br>• 运算基本方法（预测与决策、线性规划、网络图、模拟）</p><h4 id="5-常用数据结构"><a href="#5-常用数据结构" class="headerlink" title="5. 常用数据结构"></a>5. 常用数据结构</h4><p>• 数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、线索树、堆）、图等的定义、存储和操作<br>• Hash（存储地址计算，冲突处理）</p><h4 id="6-常用算法"><a href="#6-常用算法" class="headerlink" title="6. 常用算法"></a>6. 常用算法</h4><p>• 排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法<br>• 算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-数制及其转换&quot;&gt;&lt;a href=&quot;#1-数制及其转换&quot; class=&quot;headerlink&quot; title=&quot;1. 数制及其转换&quot;&gt;&lt;/a&gt;1. 数制及其转换&lt;/h4&gt;&lt;p&gt;• 二进制、十进制和十六进制等常用制数制及其相互转换&lt;/p&gt;
&lt;h4 id=&quot;2-数据的
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Web开发入门</title>
    <link href="http://yoursite.com/2017/06/25/Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/06/25/Web开发入门/</id>
    <published>2017-06-25T09:12:00.000Z</published>
    <updated>2019-10-19T08:13:55.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="C-S-B-S网络应用"><a href="#C-S-B-S网络应用" class="headerlink" title="C/S B/S网络应用:"></a>C/S B/S网络应用:</h4><p><strong>C/S</strong>就是(<strong>客户机/服务器</strong>)的简称,桌面应用程序采用的多是这种结构.<br><strong>B/S</strong>就是(<strong>浏览器/服务器</strong>)的简称,特点是客户端无需安装特定的软件,只需要安装一个浏览器就可以与系统进行交互</p><h4 id="C-S优缺点"><a href="#C-S优缺点" class="headerlink" title="C/S优缺点:"></a>C/S优缺点:</h4><p>由于C/S结构没有像B/S（下一个基本概念介绍）结构中服务器向客户端发送的数据还包含了大量的非实际交换数据，比如请求响应头，还有页面数据等等，它的==相应时间还是相对较快==的；<br>由于C/S结构安装的客户端软件，很多的业务逻辑、算法逻辑处理都在客户端进行，这样就==减轻了服务器的压力==，这是优点，但是带来的问题也显而易见，不但==有被反编译的安全隐患==，而且不断的安装各种客户端软件，会使==客户端越来越臃肿==；<br>在升级维护等工作上带来的麻烦也是令人不愉快，因为每发生一次升级都需要重新更新客户端的软件，这样做的后果就是在==开发上的工作量加大==，而且用户每次都要更新自己终端上的软件，这些都是令人非常头疼的问题；<br>由于需要在客户端进行安装特定软件，因此==对操作系统有一定的限制==；</p><h4 id="Web站点、Web应用、HTTP服务器、Web应用服务器"><a href="#Web站点、Web应用、HTTP服务器、Web应用服务器" class="headerlink" title="Web站点、Web应用、HTTP服务器、Web应用服务器:"></a>Web站点、Web应用、HTTP服务器、Web应用服务器:</h4><p>==Web站点:==<br>即Web Site,也被成为Web网站;比如某公司逛完就是Web站点</p><p>==Web应用:==<br>即Web Application,简单来说,就是通过浏览器访问的应用程序,从而为客户提供相应服务</p><p>==Http服务器:==<br>即Web服务器,主要功能是提供网上信息浏览服务,例如Apache、Nginx、IIS是比较常用的HTTP服务器.</p><p>==Web应用服务器:==<br>Web应用服务器能够运行服务器上的应用程序,并将结果返回给客户端浏览器;例如Tomcat,通常Web应用服务器兼具部分Http服务器的功能.</p><p>==Servlet的概念及功能:==</p><ul><li>Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat；</li><li>可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器；</li><li>Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范，例如，必须继承于javax.servlet.http.HttpServlet类；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;C-S-B-S网络应用&quot;&gt;&lt;a href=&quot;#C-S-B-S网络应用&quot; class=&quot;headerlink&quot; title=&quot;C/S B/S网络应用:&quot;&gt;&lt;/a&gt;C/S B/S网络应用:&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;C/S&lt;/strong&gt;就是(&lt;strong&gt;客
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://yoursite.com/2017/04/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/04/30/Java多线程/</id>
    <published>2017-04-30T00:43:00.000Z</published>
    <updated>2019-10-19T11:49:14.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><h4 id="程序-进程和多任务"><a href="#程序-进程和多任务" class="headerlink" title="程序.进程和多任务:"></a>程序.进程和多任务:</h4><ul><li><strong>程序（program）</strong> 是对数据描述与操作的代码的集合，是应用程序执行的脚本。</li><li><strong>进程（process）</strong> 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li><strong>多任务（multi task）</strong> 在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序</li><li>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</li></ul><h4 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程:"></a>如何创建多线程:</h4><ul><li>创建 java.lang.Thread 类的子类，重写该类的 run方 法</li><li>创建 java.lang.Runnable接 口的实现类，实现接口中的 run 方法(用的更多)</li></ul><h4 id="Runnable-接口与-Thread-类之间的区别"><a href="#Runnable-接口与-Thread-类之间的区别" class="headerlink" title="Runnable 接口与 Thread 类之间的区别:"></a>Runnable 接口与 Thread 类之间的区别:</h4><ul><li>Runnable 接口必须实现 run 方法，而 Thread 类中的run 方法是一个空方法，可以不重写</li><li>Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必须依靠 Thread 类 </li><li>Runnable 接口适合于资源的共享</li></ul><h4 id="多线程的四种状态"><a href="#多线程的四种状态" class="headerlink" title="多线程的四种状态:"></a>多线程的四种状态:</h4><ul><li>新建（New）</li><li>可执行（Runnable）</li><li>运行（Running)</li><li>阻塞（Blocking)</li><li>死亡（Dead)</li></ul><h4 id="状态之间的相互转化可执行-lt-—-gt-阻塞"><a href="#状态之间的相互转化可执行-lt-—-gt-阻塞" class="headerlink" title="状态之间的相互转化可执行&lt;—-&gt;阻塞"></a>状态之间的相互转化可执行&lt;—-&gt;阻塞</h4><ul><li>wait()方法:<ul><li>中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。</li></ul></li><li>notify()方法：<ul><li>唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待</li></ul></li><li>notifyall()方法：<ul><li>唤醒所有由于使用这个同步方法而处于等待的线程结束等待</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java多线程&quot;&gt;&lt;a href=&quot;#Java多线程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程&quot;&gt;&lt;/a&gt;Java多线程&lt;/h3&gt;&lt;h4 id=&quot;程序-进程和多任务&quot;&gt;&lt;a href=&quot;#程序-进程和多任务&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>软件开发基础</title>
    <link href="http://yoursite.com/2017/04/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/04/25/软件开发基础/</id>
    <published>2017-04-25T07:18:00.000Z</published>
    <updated>2019-10-19T08:13:37.882Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算机工作的简单过程"><a href="#计算机工作的简单过程" class="headerlink" title="计算机工作的简单过程:"></a>计算机工作的简单过程:</h4><ol><li>将程序和数据通关输入设备送入存储器(可以理解为内存)</li><li>计算机从存储器中取出程序指令送到控制器(可以理解为CPU)</li><li>控制器更具指令的含义发出相应的命令(如加法,减法),将存储单元中存放的操作数据取出送往运算器进行运算,再把运算结果送回存储器指定的单元中<h4 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件:"></a>什么是软件:</h4> 软件=程序+文档</li></ol><h4 id="不同类型语言的编译与运行"><a href="#不同类型语言的编译与运行" class="headerlink" title="不同类型语言的编译与运行:"></a>不同类型语言的编译与运行:</h4><p>==编译型==语言是先把源程序的每一条语句都编译成机器语言,并保存成二进制文件,运行时计算机可以直接以机器语言来运行此程序,速度较快;<br>==解释型==语言在执行程序时才一条条的解释成机器语言给计算机来执行,所以运行速度会受到影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算机工作的简单过程&quot;&gt;&lt;a href=&quot;#计算机工作的简单过程&quot; class=&quot;headerlink&quot; title=&quot;计算机工作的简单过程:&quot;&gt;&lt;/a&gt;计算机工作的简单过程:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;将程序和数据通关输入设备送入存储器(可以理解为内存)&lt;/li
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SteamAPI</title>
    <link href="http://yoursite.com/2017/04/25/SteamAPI/"/>
    <id>http://yoursite.com/2017/04/25/SteamAPI/</id>
    <published>2017-04-25T03:30:00.000Z</published>
    <updated>2019-10-19T11:44:19.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>Stream位于包java.util.stream .* 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><h4 id="流-Stream-到底是什么呢"><a href="#流-Stream-到底是什么呢" class="headerlink" title="流(Stream)到底是什么呢?"></a>流(Stream)到底是什么呢?</h4><p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br><strong>集合讲的是数据，流讲的是计算！</strong></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>Stream 自己不会存储元素。 </li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h4 id="Stream的操作三步骤"><a href="#Stream的操作三步骤" class="headerlink" title="Stream的操作三步骤"></a>Stream的操作三步骤</h4><ol><li>创建Stream<br>一个数据源（如：集合、数组），获取一个流</li><li>中间操作<br>一个中间操作链，对数据源的数据进行处理</li><li>终止操作（终端操作）<br>一个终止操作，执行中间操作链，并产生结果</li></ol><h5 id="1-创建Stream"><a href="#1-创建Stream" class="headerlink" title="1. 创建Stream"></a>1. 创建Stream</h5><ol><li><p>可以通过<code>Collection</code>系列集合提供的<code>stream()</code>或<code>parallelStream()</code>方法<br><code>default Stream&lt; E&gt; stream()</code> : 返回一个顺序流<br><code>default Stream&lt; E&gt; parallelStream()</code> : 返回一个并行流</p></li><li><p>通过 <code>Arrays</code> 中的静态方法<code>stream()</code>获取数组流<br><code>static &lt;T&gt; Stream&lt;T&gt; stream( T[] array)</code>: 返回一个流<br>重载形式，能够处理对应基本类型的数组：<br><code>public static IntStream stream(int[] array)</code><br><code>public static LongStream stream(long[] array)</code><br><code>public static DoubleStream stream(double[] array)</code></p></li><li><p>通过Stream 类中的静态方法of()，通过显示值创建一个流。它可以接收任意数量的参数。<br><code>public static&lt; T&gt; Stream&lt; T&gt; of(T… values)</code> : 返回一个流</p></li><li><p>创建无限流<br>可以使用静态方法 <code>Stream.iterate()</code> 和<code>Stream.generate()</code>, 创建无限流。<br>迭代 <code>public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f)</code><br>生成 <code>public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s)</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Stream</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.可以通过Collection 系列集合提供的stream()或parallelStream()</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.通过 Arrays 中的静态方法stream()获取数组流</span></span><br><span class="line">    Employee[] emps=<span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">    Stream&lt;Employee&gt; stream2=Arrays.stream(emps);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.通过Stream 类中的静态方法of()</span></span><br><span class="line">    Stream&lt;String&gt; stream3=Stream.of(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.创建无限流</span></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    Stream&lt;Integer&gt; stream4=Stream.iterate(<span class="number">0</span>, (x) -&gt; x+<span class="number">2</span>);</span><br><span class="line">    stream4.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成</span></span><br><span class="line">    Stream.generate(() -&gt; Math.random()).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2.中间操作"></a>2.中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性处理，成为“惰性求值”。</p></li><li><p>筛选与切片<br><code>filter(Predicate p)</code>: 接收lambda,从流中排除某些元素<br><code>distinct()</code>: 筛选,通过流所生成元素的<code>hashCode()</code>和<code>equals</code>去除重复元素<br><code>limit(long maxSize)</code>: 截断流,使元素不超过给定数量<br><code>skip(long n)</code>: 跳过元素,返回一个扔掉了前n个元素的流,若流中元素不足n个,则返回一个空流,与<code>limit(n)</code>互补</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中间操作</span></span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; employees=Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">9999.99</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">58</span>,<span class="number">5555.55</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">26</span>,<span class="number">3333.33</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">36</span>,<span class="number">6666.66</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"田七"</span>,<span class="number">12</span>,<span class="number">8888.88</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"田七"</span>,<span class="number">12</span>,<span class="number">8888.88</span>)</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 筛选与切片</span></span><br><span class="line"><span class="comment">*  filter--接收Lambda，从流中排除某些元素。</span></span><br><span class="line"><span class="comment">*  limit--截断流，使其元素不超过给定数量。</span></span><br><span class="line"><span class="comment">*  skip(n)--跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补</span></span><br><span class="line"><span class="comment">*  distinct--筛选，通过流所生成元素的 hashCode() 和 equals() 去掉重复元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部迭代：迭代操作由 Stream API 完成</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//中间操作：不会执行任何操作</span></span><br><span class="line">    Stream&lt;Employee&gt; stream=employees.stream().filter((e) -&gt; e.getAge()&gt;<span class="number">35</span> );</span><br><span class="line">    <span class="comment">//终止操作：一次性执行全部内容，即 惰性求值</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部迭代</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Iterator&lt;Employee&gt; it=employees.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;<span class="comment">//发现“短路”只输出了两次，说明只要找到 2 个 符合条件的就不再继续迭代</span></span><br><span class="line">    employees.stream().filter((e)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"短路！"</span>);</span><br><span class="line">        <span class="keyword">return</span> e.getSalary()&gt;<span class="number">5000</span>;</span><br><span class="line">    &#125;).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    employees.stream().filter((e)-&gt;e.getSalary()&gt;<span class="number">5000</span>).skip(<span class="number">2</span>)<span class="comment">//跳过前两个</span></span><br><span class="line">    .distinct()<span class="comment">//去重，注意：需要Employee重写hashCode 和 equals 方法</span></span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 映射</span></span><br><span class="line"><span class="comment">* map--接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。</span></span><br><span class="line"><span class="comment">* flatMap--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"ddd"</span>);</span><br><span class="line">    list.stream() .map((str)-&gt;str.toUpperCase())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">    employees.stream().map(Employee::getName)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>); Stream&lt;Character&gt; sm=list.stream()</span><br><span class="line">    .flatMap(TestStream::filterChatacter);</span><br><span class="line">    sm.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterChatacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character ch : str.toCharArray()) &#123;</span><br><span class="line">        list.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排序</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*排序</span></span><br><span class="line"><span class="comment">* sorted()-自然排序（按照对象类实现Comparable接口的compareTo()方法 排序）</span></span><br><span class="line"><span class="comment">* sorted(Comparator com)-定制排序（Comparator）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=Arrays.asList(<span class="string">"ccc"</span>,<span class="string">"bbb"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">    employees.stream().sorted((e1,e2)-&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">            <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-终止操作"><a href="#3-终止操作" class="headerlink" title="3. 终止操作"></a>3. 终止操作</h4><p>终止操作会从流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。</p><ol><li>查找与匹配 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 查找与匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//allMatch-检查是否匹配所有元素</span></span><br><span class="line">    <span class="keyword">boolean</span> b1=employees.stream().allMatch((e)-&gt;e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b1);<span class="comment">//false</span></span><br><span class="line">    <span class="keyword">boolean</span> b2=employees.stream().anyMatch((e)-&gt;e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b2);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//noneMatch-检查是否没有匹配所有元素 </span></span><br><span class="line">    booleanb3=employees.stream().noneMatch((e)-&gt;e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b3);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//findFirst-返回第一个元素//Optional是Java8中避免空指针异常的容器类  </span></span><br><span class="line">    Optional&lt;Employee&gt; op=employees.stream().sorted((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).findFirst();</span><br><span class="line">    System.out.println(op.get());</span><br><span class="line">    <span class="comment">//findAny-返回当前流中的任意元素       </span></span><br><span class="line">    Optional&lt;Employee&gt; op2=employees.parallelStream().filter((e)-&gt;e.getStatus().equals(Status.FREE)).findAny();</span><br><span class="line">    System.out.println(op2.get());</span><br><span class="line">    <span class="comment">//count-返回流中元素的总个数</span></span><br><span class="line">    Long count=employees.stream().count();</span><br><span class="line">    System.out.println(count);<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//max-返回流中最大值</span></span><br><span class="line">    Optional&lt;Employee&gt; op3=employees.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">    System.out.println(op3.get());</span><br><span class="line">    <span class="comment">//min返回流中最小值</span></span><br><span class="line">    Optional&lt;Double&gt;op4=employees.stream().map(Employee::getSalary).min(Double::compare);</span><br><span class="line">        System.out.println(op4.get());<span class="comment">//3333.33</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>归约  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*归约</span></span><br><span class="line"><span class="comment">* reduce(T identity,BinaryOperator b) / reduce(BinaryOperator b)-可以将流中元素反复结合起来，得到一个值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    Integer sum=list.stream()</span><br><span class="line">    reduce(T identity,BinaryOperator b).reduce(<span class="number">0</span>, (x,y)-&gt;x+y);</span><br><span class="line">    <span class="comment">//0为起始值</span></span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">    Optional&lt;Double&gt; op=employees.stream().map(Employee::getSalary).reduce(Double::sum);</span><br><span class="line">    System.out.println(op.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>收集  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 收集</span></span><br><span class="line"><span class="comment">* collect-将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=employees.stream().map(Employee::getName).collect(Collectors.toList());</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    Set&lt;String&gt; set=employees.stream().map(Employee::getName).collect(Collectors.toSet());</span><br><span class="line">    set.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    <span class="comment">//总和</span></span><br><span class="line">    Long count=employees.stream().collect(Collectors.counting());</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    <span class="comment">//平均值</span></span><br><span class="line">    Double avg=employees.stream().collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line">    System.out.println(avg);</span><br><span class="line">    <span class="comment">//总和</span></span><br><span class="line">    Double sum=employees.stream().collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    Optional&lt;Employee&gt; max=employees.stream().collect(Collectors.maxBy((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line">    System.out.println(max.get());</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    Optional&lt;Double&gt; min=employees.stream().map(Employee::getSalary).collect(Collectors.minBy(Double::compare));</span><br><span class="line">    System.out.println(min.get());</span><br><span class="line">    System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    Map&lt;Status,List&lt;Employee&gt;&gt; map=employees.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="comment">//分区</span></span><br><span class="line">    Map&lt;Boolean,List&lt;Employee&gt;&gt; map3=employees.stream().collect(Collectors.partitioningBy((e)-&gt;e.getSalary()&gt;<span class="number">8000</span>));</span><br><span class="line">    System.out.println(map3);</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Stream-API&quot;&gt;&lt;a href=&quot;#Stream-API&quot; class=&quot;headerlink&quot; title=&quot;Stream API&quot;&gt;&lt;/a&gt;Stream API&lt;/h3&gt;&lt;p&gt;Stream位于包java.util.stream .* 是Java8 中处
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="http://yoursite.com/2017/04/18/Lambda/"/>
    <id>http://yoursite.com/2017/04/18/Lambda/</id>
    <published>2017-04-18T05:40:00.000Z</published>
    <updated>2019-10-19T11:14:14.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口:"></a>函数式接口:</h4><p>我们把只拥有一个方法的接口称为函数式接口.</p><p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个 Object 已经提供的方法，比如 toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过 @FunctionalInterface 注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p><p>函数式接口的实现引入了一个全新的结构化函数类型.我们也称为是”箭头”类型.</p><h5 id="Java8中加入新的包：java-util-function"><a href="#Java8中加入新的包：java-util-function" class="headerlink" title="Java8中加入新的包：java.util.function"></a>Java8中加入新的包：java.util.function</h5><p>它包含了常用的函数式接口:</p><ol><li><code>Predicate&lt;T&gt;</code>: 接收<code>T</code>并返回<code>boolean</code></li><li><code>Consumer&lt;T&gt;</code>: 接收<code>T</code>,不返回值</li><li><code>Function&lt;T, R&gt;</code>: 接收<code>T</code>,返回<code>R</code></li><li><code>Supplier&lt;T&gt;</code>: 提供<code>T</code>,不接收值</li><li><code>Unaryoperator&lt;T&gt;</code>: 接收<code>T</code>,返回<code>T</code></li><li><code>Binary0perator&lt;T&gt;</code>: 接收两个<code>T</code>,返回<code>T</code></li></ol><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式:"></a>Lambda表达式:</h4><p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的语法过于冗余.</p><ul><li><p>下面是一些表达式:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;x+y</span><br><span class="line">()-&gt;<span class="number">42</span></span><br><span class="line">(String s)-&gt;System.out.println(s);</span><br></pre></td></tr></table></figure></li><li><p>lambda 表达式的语法由参数列表、箭头符号 <code>-&gt;</code> 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p><ul><li>表达式:表达式会被执行然后返回执行结果.</li><li>语句块:语句块中的语句会被依次执行,就像方法中的语句一样<ul><li><code>return</code>语句会把控制权交给匿名方法的调用者</li><li><code>break</code>和<code>continue</code>只能在循环中使用</li><li>如果函数体有返回值,那么函数体内部的每一条路径都必须返回值</li></ul></li></ul></li><li><p>目标类型:</p><ul><li>编译器负责推导<strong>lambda</strong>表达式类型,它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导,这个<strong>被期待的类型</strong>被称为==目标类型==.<strong>lambda</strong>表达式只能出现在目标类型为函数式接口的上下文中.</li><li>当然<strong>lambda</strong>对于<strong>目标类型</strong>也是有要求的,编译器会检查lambda表达式的类型和目标类型的方法签名是否一致,当且仅当下面所有条件均满足时,lambda表达式才可以被赋给目标类型<code>T</code>:<ul><li><code>T</code>是一个函数式接口</li><li><code>lambda</code>表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li><li><code>lambda</code>表达式的返回值和<code>T</code>的方法返回值相兼容</li><li><code>lambda</code>表达式内锁抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li></ul></li></ul></li></ul><h4 id="Java内置函数式接口"><a href="#Java内置函数式接口" class="headerlink" title="Java内置函数式接口"></a>Java内置函数式接口</h4><p>为了免去用户每次使用Lamdba表达式时,都自行创建函数式接口,java中提供了四大核心内置函数式接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Consumer&lt;T&gt; :消费型接口</span></span><br><span class="line"><span class="comment">    *          void accept(T t);</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Supplier&lt;T&gt; :供给型接口</span></span><br><span class="line"><span class="comment">    *          T get();</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Function&lt;T,R&gt; :函数型接口</span></span><br><span class="line"><span class="comment">    *          R apply(T t);</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Predicate&lt;T&gt; :断言型接口</span></span><br><span class="line"><span class="comment">    *          boolean test(T t);</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Consumer&lt;T&gt; 消费型接口：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money,Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        happy(<span class="number">1000</span>,(m) -&gt;System.out.println(<span class="string">"消费："</span>+m+<span class="string">"元"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Supplier&lt;T&gt; 供给型接口:</span></span><br><span class="line">    <span class="comment">//需求：产生指定个数的整数，并放入集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num,Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Integer n=sup.get();</span><br><span class="line">            list.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numList=getNumList(<span class="number">10</span>, ()-&gt;(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (Integer num : numList) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Function&lt;T,R&gt; 函数型接口:</span></span><br><span class="line">    <span class="comment">//需求：处理字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str,Function&lt;String,String&gt; fun)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String newStr=strHandler(<span class="string">"\t\t\t 哈哈哈  "</span>, (str)-&gt;str.trim());</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line">        String subStr=strHandler(<span class="string">"abcdef"</span>, (str)-&gt;str.substring(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">        System.out.println(subStr);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Predicate&lt;T&gt; 断言型接口：</span></span><br><span class="line">    <span class="comment">//需求：将满足条件的字符串，放入集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list,Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; strList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( String str : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.test(str))&#123;</span><br><span class="line">                strList.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=Arrays.asList(<span class="string">"Hello"</span>,<span class="string">"jj"</span>,<span class="string">"Lambda"</span>,<span class="string">"www"</span>,<span class="string">"ok"</span>);</span><br><span class="line">        List&lt;String&gt; strList=filterStr(list, (s)-&gt;s.length()&gt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String string : strList) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;函数式接口&quot;&gt;&lt;a href=&quot;#函数式接口&quot; class=&quot;headerlink&quot; title=&quot;函数式接口:&quot;&gt;&lt;/a&gt;函数式接口:&lt;/h4&gt;&lt;p&gt;我们把只拥有一个方法的接口称为函数式接口.&lt;/p&gt;
&lt;p&gt;我们并不需要额外的工作来声明一个接口是函数式接口：编译
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java输入输出</title>
    <link href="http://yoursite.com/2017/04/14/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2017/04/14/Java输入输出/</id>
    <published>2017-04-14T02:01:00.000Z</published>
    <updated>2019-10-19T10:45:00.807Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第1节-文件"><a href="#第1节-文件" class="headerlink" title="第1节:文件"></a>第1节:文件</h4><ol><li><strong>File类型</strong></li></ol><ul><li><code>java.io.File</code>类的对象可以表示文件和目录，在程序中一个File类对象可以代表一个文件或目录</li><li>当创建一个File对象后，就可以利用它来对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等等</li><li>需要注意的是，File对象并不能直接对文件内容进行读/写操作，只能查看文件的属性</li></ul><h4 id="第2节-输出输出流"><a href="#第2节-输出输出流" class="headerlink" title="第2节:输出输出流"></a>第2节:输出输出流</h4><ol><li><strong>输入输出流的概念与作用</strong></li></ol><ul><li>流的特点:<ul><li>流是一串连续不断的数据的集合,只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的</li></ul></li><li>输入流：从外存读取数据到内存，输出流：将数据从内存写到外存中</li></ul><ol start="2"><li><strong>Java中输入输出流的类型</strong></li></ol><ul><li>对于输入和输出流，由于传输格式的不同，又分为字节流和字符流：</li></ul><ol start="3"><li><strong>Java的输入输出流的继承树</strong></li></ol><ul><li>Java I/O主要包括:<ul><li><strong>流式部分</strong>:IO的主体部分；</li><li><strong>非流式部分</strong>:主要包含一些辅助流式部分的类，如：File类、<code>RandomAccessFile</code>类和<code>FileDescriptor</code>等类；</li><li><strong>其他类</strong>:文件读取部分的与安全相关的类，如：<code>SerializablePermissio</code>n类，以及与本地操作系统相关的文件系统的类，如：<code>FileSystem</code>类和<code>Win32FileSystem</code>类和<code>WinNTFileSystem</code>类。</li></ul></li></ul><ol start="4"><li><strong>字节输出流</strong></li></ol><ul><li>OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的</li></ul><ol start="5"><li><strong>OutputStream</strong></li></ol><ul><li>OutputStream是一个抽象类，提供了Java向流中以字节为单位写入数据的公开接口，大部分字节输出流都继承自OutputStream类</li></ul><ol start="6"><li><strong>DataOutput</strong></li></ol><ul><li>DataOutput接口规定一组操作，用于直接向流中写入基本类型的数据和字符串：<ul><li>DataInput对基本数据类型的写入分别提供了不同的方法，方法名满足<code>writeXXX()</code>的规律,如<code>writeInt()</code>表示向流中写入一个int型数据，写入字符串的方法为<code>writeUTF()</code></li></ul></li></ul><ol start="7"><li><strong>常见字节输出流工具的作用与使用</strong></li></ol><ul><li>FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象。</li><li>创建一个文件流对象有以下方法:<ul><li>方式1：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(“d:/abc.txt”);</span><br><span class="line">FileOutputStream out=<span class="keyword">new</span> FileOutputStream (f);</span><br></pre></td></tr></table></figure></li><li>方式2：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream out=<span class="keyword">new</span> FileOutputStream(“d:/abc.txt”);</span><br></pre></td></tr></table></figure></li><li>方式3：构造函数将 FileDescriptor()对象作为其参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileDescriptor() fd=<span class="keyword">new</span> FileDescriptor();</span><br><span class="line">FileOutputStream f2=<span class="keyword">new</span> FileOutputStream(fd);</span><br></pre></td></tr></table></figure></li><li>方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream f=<span class="keyword">new</span> FileOutputStream(“d:/abc.txt”,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="8"><li><strong>字节输入流</strong></li></ol><ul><li>InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法.</li></ul><ol start="9"><li><strong>InputStream</strong></li></ol><ul><li>InputStream也是一个抽象类，提供了Java中从流中以字节为单位读取数据的公开接口，大部分字节输入流都继承自InputStream类</li></ul><ol start="10"><li><strong>DataInput</strong></li></ol><ul><li>DataInput接口规定一组操作，用于以一种与机器无关（当前操作系统等）的方式，直接在流中读取基本类型的数据和字符串：</li><li>DataInput对基本数据类型的读取分别提供了不同的方法，方法名满足readXXX()的规律,如readInt()表示从流中读取一个int型数据读取字符串的方法为readUTF()</li></ul><ol start="11"><li><strong>常见的字节输入流工具的作用与使用</strong></li></ol><ul><li>FileInputStream类是InputStream类的子类，用来处理以文件作为数据输入源的数据流。<ul><li>使用方法:<ul><li>方式1：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   File fin=<span class="keyword">new</span> File(“d:/abc.txt”);</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(fin);</span><br></pre></td></tr></table></figure></li><li>方式2：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(“d: /abc.txt”;</span><br></pre></td></tr></table></figure></li><li>方式3：构造函数将 FileDescriptor()对象作为其参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileDescriptor() fd=<span class="keyword">new</span> FileDescriptor();</span><br><span class="line">FileInputStream f2=<span class="keyword">new</span> FileInputStream(fd);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>程序对应的基本输入为键盘输入，基本输出为显示器输出。Java中，System类的in和out两个成员代表了基本输入输出的抽象</li></ul><p><strong>System.in</strong>:基本输入，对应InputStream<br><strong>System.out</strong>:基本输出，对应PrintStream    </p><ul><li><strong>RandomAccessFile</strong><ul><li>RandomAccessFile类可以在文件中==任何位置==查找或写入数据</li><li>RandomAccessFile==同时实现了DataInput和DataOutput接口==</li><li>磁盘文件都是可以随机访问的， 但是从网络而来的数据流却不是</li></ul></li></ul><ol start="12"><li><strong>ByteArrayOutpuStream/ByteArrayInputStream</strong></li></ol><ul><li>一对输入输出工具为我们提供了在内存中利用byte[]进行缓冲流操作的工具</li><li>ByteArrayOutputStream提供工具将内存中以串行序列存在的流式数据以一个字节为单位进行切分，形成一个byte[]数组</li><li>而ByteArrayInputStream则正好相反，提供工具将内存中的byte[]数组中的数据进行串行序列化拼接，形成一个可供操作的流式数据</li><li>从功能上看，ByteArrayOutpuStream可以将任意数据组合转换为byte[]，而ByteArrayInputStream可以将这个数组还原，从而以流的形式读取任意数据组合</li></ul><ol start="13"><li><strong>字符输出流</strong></li></ol><ul><li>考虑到Java是跨平台的语言，要经常操作Unicode编码的文件，使用基于字符为读、写基本单元的字符流操作文件是有必要的,以字符为单位进行数据输出的工具继承自Writer</li></ul><ol start="14"><li><strong>字符输出流的统一数据写入方法</strong></li></ol><ul><li>Writer和OutputStream类似也提供了统一的往流中写入数据的方法，和OutputStream不同的是，写入数据的单位由字节变成了字符</li></ul><ol start="15"><li><strong>字符输出流工具的作用与使用</strong></li></ol><ul><li>FileWriter类称为文件写入流，以字符流的形式对文件进行写操作</li><li>FileWriter将逐个向文件写入字符，效率比较低下，因此一般将该类对象包装到缓冲流中进行操作</li><li>还可以使用PrintWriter对流进行包装，提供更方便的字符输出格式控制</li></ul><ol start="16"><li><strong>字符输入流</strong></li></ol><ul><li>以字符为单位进行数据读取的工具继承自Reader，Reader会将读取到的数据按照标准的规则转换为Java字符串对象</li></ul><ol start="17"><li><strong>字符输入流的统一数据读取方法</strong></li></ol><ul><li>字符输入流Reader也提供的统一读取数据的方法（和InputStream不同，实际开发时更多的调用不同Reader提供的特殊读取方法，如BufferedReader的readLine()，能够简化操作）</li></ul><ol start="18"><li><strong>常见的字符输入流工具的作用与使用</strong></li></ol><ul><li>FileReader类称为文件读取流，允许以字符流的形式对文件进行读操作</li><li>与FileWriter相似，该类将从文件中逐个地读取字符，效率比较低下，因此一般也将该类对象包装到缓冲流中进行操作</li></ul><ol start="19"><li><strong>字节流与字符流的适配器</strong></li></ol><ul><li>在某些时候虽然我们操作的是字符串，但是不得不面对数据来源是InputStream（字节输入流）的情况，在这种情况下，Java提供了将InputStream和Reader之间进行转换的工具，事实上，字节输出流和字符输出流之间也存在这种工具，称为：字节流与字符流的适配器：<ul><li>InputStreamReader：<ul><li>字节流通向字符流的桥梁，它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集</li><li>每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节</li></ul></li><li>OutputStreamWriter： <ul><li>字符流通向字节流的桥梁，使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集</li><li>每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲</li></ul></li></ul></li></ul><h4 id="第3节-对象序列化"><a href="#第3节-对象序列化" class="headerlink" title="第3节:对象序列化"></a>第3节:对象序列化</h4><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能</p><ol><li>对象序列化的作用</li></ol><ul><li>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量</li><li>除了在持久化对象时会用到对象序列化之外，在网络中传递对象时，也会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制</li></ul><ol start="2"><li>序列化接口</li></ol><ul><li>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以被序列化</li><li><code>java.io.Serializable</code>是一个标识接口，即意味着它仅仅是为了说明类的可序列化属性，接口没有包含任何需要子类实现的抽象方法</li></ul><ol start="3"><li>对象序列化和反序列化</li></ol><ul><li>将对象的状态信息保存到流中的操作，称为序列化，可以使用Java提供的工具<code>ObjectOutputStream. writeObject(Serializable obj)</code>来完成</li><li>从流中读取对心状态信息的操作称为反序列化，可以使用Java提供的工具<code>ObjectInputStream.readObject()</code>来完成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第1节-文件&quot;&gt;&lt;a href=&quot;#第1节-文件&quot; class=&quot;headerlink&quot; title=&quot;第1节:文件&quot;&gt;&lt;/a&gt;第1节:文件&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;File类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java核心API</title>
    <link href="http://yoursite.com/2017/04/10/Java%E6%A0%B8%E5%BF%83API/"/>
    <id>http://yoursite.com/2017/04/10/Java核心API/</id>
    <published>2017-04-10T02:09:00.000Z</published>
    <updated>2019-10-19T08:54:51.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li><p>Object类是Java语言中所有类的根,所有的类都直接或间接的继承了Object类;</p></li><li><p><strong>数组</strong>也继承了Object类;</p></li><li><p>Object类中定义了<code>equals(Object obj)</code>方法,用来比较两个对象的虚拟地址,如果虚拟地址相同则返回true,否则返回false;</p><ul><li>Object类中的<code>equals()</code>方法的作用,与<code>==</code>相同,都是比较两个对象的虚地址</li><li>很多类覆盖了<code>equals</code>方法,用来比较两个对象的属性值,如果属性值相同,则认为两个对象相等,例如[String类就覆盖了equals方法,用来比较两个字符串的字符序列值]</li></ul></li><li><p>Object类中定义了<code>hashCode</code>方法<code>public int hashCode()</code>，用来返回对象的哈希码；</p><ul><li><code>hashCode</code>方法主要为了配合基于哈希的集合类一起工作，例如HashSet、HashMap等；</li><li>默认情况下(即没有重新hashCode方法时)，当两个引用的虚地址相同时，hashCode返回相同的值，否则返回不同的值；</li><li>事实上，基于哈希的集合在使用hashCode的时候，基本都是和equals一起使用；先用hashCode初步比较,再用equals比较</li><li><strong>注意</strong>:使用的时候一起使用,重写的时候也要一起重写</li></ul></li><li><p>Object类中定义了<code>toString</code>方法</p><ul><li>字符串类型是编程时最常用的类型，Object类中定义了toString方法<code>public String toString()</code>，可以把任意类型对象转换成字符串返回；</li><li>默认情况（没有重写Object类中的toString方法）下，返回字符串的格式为：对象类型@对象调用hashCode方法的返回值；</li><li>返回Object类中默认格式的字符串几乎没有实用意义，因此很多时候，都会重写一些实体类的toString方法，返回需要的字符串格式；</li></ul></li><li><p>Object类中定义了克隆方法<code>clone</code></p><ul><li><code>Clone</code>方法能够“复制”一个对象，生成一个新的引用，分配新的内存空间；</li><li>一个类必须实现Cloneable接口，才能被克隆，否则抛出异常；</li><li>克隆是生成了一个新的对象，然而，对象的属性如果有引用类型，实际上还是公用；</li><li>深克隆时，属性不仅值相同，同时又都存储在完全不同的内存中</li></ul></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习</p><ol><li>子串截取方法:<ol><li><code>String substring(int beginIndex)</code></li><li><code>String substring(int beginIndex,int endIndex)</code></li></ol></li><li>检索相关方法:<ol><li><code>int indexOf(int ch)</code></li><li><code>int indexOf(int ch,int fromIndex)</code></li><li><code>int indexOf(String str)</code></li><li><code>int indexOf(String str,int fromIndex)</code></li><li><code>int lastIndexOf(int ch)</code></li><li><code>int lastIndexOf(int ch,int fromIndex)</code></li><li><code>int lastIndexOf(String str)</code></li><li><code>int lastIndexOf(String str,int fromIndex)</code></li><li><code>char charAt(int index)</code></li></ol></li><li>类型转换相关的方法:<ol><li><code>static String valueOf(boolen b)</code></li><li><code>static String valueOf(char c)</code></li><li><code>static String valueOf(char[] data)</code></li><li><code>static String valueOf(char[] data,int offset,int count)</code></li><li><code>static String valueOf(double d)</code></li><li><code>static String valueOf(float f)</code></li><li><code>static String valueOf(int i)</code></li><li><code>static String valueOf(long l)</code></li><li><code>static String valueOf(Object obj)</code></li></ol></li><li>其他方法:<ol><li><code>int compareTo(String anotherString)</code></li><li><code>boolean endsWith(String suffix)</code></li><li><code>byte[] getBytes()</code></li><li><code>byte[] getBytes(Charset charset)</code></li><li><code>int length()</code></li><li><code>boolean startsWith(String prefix)</code></li><li><code>boolean startsWith(String prefix,int toffset)</code></li><li><code>String trim()</code></li></ol></li></ol><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式就是用来描述字符串逻辑规则的工具</p><ul><li>正则表达式本身也是个字符串，不过这些字符串是使用系列“元字符”组成；</li><li>所谓“元字符”就是预先定义的，有特殊意义的字符；例如\d用来匹配一个数字； \w用来匹配字母或数字或下划线或汉字等；</li><li>很多语言多对正则表达式提供了支持，例如JavaScript、Java等；</li><li>不同语言中使用正则表达式时，正则表达式的具体编写规则会有些小的差别，但是大体相同；</li></ul><h4 id="正大表达式在Java中的使用"><a href="#正大表达式在Java中的使用" class="headerlink" title="正大表达式在Java中的使用"></a>正大表达式在Java中的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String regex=<span class="string">"^((13[0-9])|(15[0-3,5-9])|(18[0,2,3,5-9])|(17[0-8])|(147))\\d&#123;8&#125;$"</span>;</span><br><span class="line"><span class="comment">//检验的手机号码</span></span><br><span class="line">String string=<span class="string">"15123569087"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//将正则表达式编译成Pattern对象</span></span><br><span class="line">Pattern pattern=Pattern.compile(regex);</span><br><span class="line"><span class="comment">//使用Pattern对象为每个手机号码产生一个匹配器</span></span><br><span class="line">Matcher matcher=pattern.matcher( string);</span><br><span class="line"><span class="keyword">boolean</span> flag=matcher.matches();</span><br><span class="line">System.out.println(flag==<span class="keyword">true</span>?<span class="string">"手机号正确"</span>:<span class="string">"手机号错误"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="comment">//将正则表法式编译成Pattern对象</span></span><br><span class="line">Pattern pattern2=Pattern.compile(regex);</span><br><span class="line"><span class="keyword">boolean</span> flag2=pattern2.matches(regex, string);</span><br><span class="line">System.out.println(flag2==<span class="keyword">true</span>?<span class="string">"手机号正确"</span>:<span class="string">"手机号错误"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="keyword">boolean</span> flag3=string.matches(regex);</span><br><span class="line">System.out.println(flag3==<span class="keyword">true</span>?<span class="string">"手机号正确"</span>:<span class="string">"手机号错误"</span>);</span><br></pre></td></tr></table></figure><h3 id="对象的自然比较"><a href="#对象的自然比较" class="headerlink" title="对象的自然比较"></a>对象的自然比较</h3><h5 id="内部比较器"><a href="#内部比较器" class="headerlink" title="内部比较器:"></a>内部比较器:</h5><ul><li>一个类如果想【支持排序】，那么就必须实现接口<code>Comparable&lt;T&gt;</code>，该接口被称为对象的内部比较器；</li><li>该接口中只有一个方法；<code>int compareTo(T o)</code></li></ul><h5 id="外部比较器"><a href="#外部比较器" class="headerlink" title="外部比较器:"></a>外部比较器:</h5><ul><li>一个类实现Comparable这个内部比较器后，该类支持排序，然而只能有一种排序逻辑，比较受限制；</li><li>可以使用外部比较器Comparator，灵活为类定义多种比较器，此时类本身不需要实现Comparable接口；</li><li>Comparator接口中有两个方法<code>int compareTo(T o1,T o2)</code>和<code>boolean equals(Object obj)</code></li></ul><h5 id="对象数组的排序"><a href="#对象数组的排序" class="headerlink" title="对象数组的排序:"></a>对象数组的排序:</h5><ul><li><code>java.util.Arrays</code>类是一个针对数组进行操作的工具类，其中提供了对对象数组进行排序的方法；</li><li>两个常用的对象数组排序方法如下：<br><code>static void sort(Object[] a)</code><br><code>static &lt;T&gt;void sort(T[] a,ComparaTor&lt;? super T?&gt; c)</code></li></ul><h3 id="数学API"><a href="#数学API" class="headerlink" title="数学API"></a>数学API</h3><p>Math类提供的数学运算方法:</p><ul><li>Math类位于java.lang包中，是一个final类，不能被继承；</li><li>Math类中所有方法都是static方法，可以直接使用类名Math调用；</li><li>Math中定义了大量与数学运算有关的方法，包括求绝对值、三角函数、平方根等；</li><li>Math类是final类，不能被继承，所有方法都是static方法，可以直接用类名调用；</li><li>Math中的round方法是四舍五入，ceil是返回大于参数且最接近参数的整数，floor是返回小于参数且最接近参数的整数；</li><li>Math中的random方法返回[0.0,1.0)范围的值；</li><li>Math类中还定义了很多数学计算方法；</li><li>Java中的大整数API:<ul><li>Java中整数最大范围是long型，64位，如果需要使用超过long范围的大整数，可以使用BigInteger类；</li><li>BigInteger位于java.math包中，定义了一系列的数学运算方法，调用这些方法可以进行计算，不能使用运算符计算；</li><li>java.math包中还有一个类叫BigDecimal，虽然和整数无关，我们也在此一起学习；</li><li>BigDecimal是用来针对浮点型进行精确运算的；</li><li>BigInteger用来对超过long范围整数进行运算；</li><li>BigDecimal用来对double、float类型进行精确计算；</li></ul></li></ul><h3 id="Java中的随机API"><a href="#Java中的随机API" class="headerlink" title="Java中的随机API"></a>Java中的随机API</h3><ul><li>Math类中的random方法可以产生随机数，然而，该方法只能生成[0.0,1.0)范围的double值；很多时候，可能需要生成不同类型不同范围的随机值；</li><li>java.util包中的Random类可以用来生成不同类型的随机值，功能更为强大；</li><li>Random类有两个构造方法，无参的构造方法创建对象后，每次都生成不同的随机数；有参的构造方法创建对象后，如果种子参数值一样，那么每次生成的随机数也相同；</li><li>Random类功能强大，能生成int,float,double,boolean各种类型的随机数；</li><li><code>random.nextInt</code>生成不定范围的int随机数，而带参数的nextInt生成的随机数有范围；</li></ul><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><ul><li>UUID指的是通用唯一识别码，常用于分布式系统；</li><li>有多种生成UUID的策略，包括基于时间、基于名字、随机等；</li><li>Java API中定义了java.util.UUID类，对UUID的生成提供了支持；</li></ul><h3 id="DateAPI"><a href="#DateAPI" class="headerlink" title="DateAPI"></a>DateAPI</h3><ul><li>java.util.Date类表示时间，不过由于对国际化支持有限，所以JDK1.1之后推荐使用java.util.Calendar类；</li><li>JDK1.1版本开始，增加Calendar类，建议使用Calendar类代替Date类；</li><li>Calendar是抽象类，不能直接使用new创建对象；<ul><li>Calendar类中定义了获得实例的方法<code>getInstance()</code>,得到的实际是子类<strong>GregorianCalendar</strong>的对象!!</li></ul></li><li>获得日历对象后，可以为该对象的年、月、日、时、分、秒等进行赋值：</li><li>实际编程中，往往需要对时间用不同的格式进行展示;<ul><li><strong>SimpleDateFormat</strong>中定义了对时间进行格式化的方法；该类继承了抽象父类DateFormat，某些方法在父类中定义，查阅API文档时注意；</li><li>可以自定义一个模式字符串来构建SimpleDateFormat对象：</li><li>通常使用format方法进行格式化；</li></ul></li></ul><h3 id="JDK8中的新API"><a href="#JDK8中的新API" class="headerlink" title="JDK8中的新API"></a>JDK8中的新API</h3><ul><li>JDK8中定义了<code>java.time.LocalDate</code>，用来表示日期，默认格式是yyyy-MM-dd；该类不包含时间信息；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object类是Java语言中所有类的根,所有的类都直接或间接的继承了Object类;&lt;/
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="http://yoursite.com/2017/04/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/04/03/Java异常处理/</id>
    <published>2017-04-03T10:14:00.000Z</published>
    <updated>2019-10-19T08:11:35.203Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常处理和错误的区别"><a href="#异常处理和错误的区别" class="headerlink" title="异常处理和错误的区别:"></a>异常处理和错误的区别:</h4><p><strong>异常:</strong> 异常指的是程序运行时发生的不正常的时间;异常能够被程序处理,保证程序继续运行下去;例如除数为0,文件没有找到,输入的数字格式不对;<br><strong>错误:</strong> 错误程序没法处理,例如内存泄漏,发生错误后,一般虚拟机会选择终止程序运行,程序员需要修改代码才能解决相关错误;</p><h4 id="运行时异常与非运行时异常"><a href="#运行时异常与非运行时异常" class="headerlink" title="运行时异常与非运行时异常:"></a>运行时异常与非运行时异常:</h4><p>Exception有很多子类,这些子类又可以分为两大类;即<strong>运行时异常</strong>和<strong>非运行时异常</strong><br><strong>运行时异常:</strong> 也称为非检测异常,这些异常在编译期不检测,程序中可以选择处理,也可以不处理,如果不处理运行时会中断,但编译没问题.<br><strong>非运行时异常:</strong> 也称为检测异常,是必须进行处理的异常,如果不处理,将发生编译期错误.</p><h4 id="异常处理的标准流程"><a href="#异常处理的标准流程" class="headerlink" title="异常处理的标准流程:"></a>异常处理的标准流程:</h4><ol><li><strong>抛出异常</strong><br>运行时异常JVM自行抛出,非运行时异常使用<code>throw</code>抛出</li><li><strong>捕获异常</strong><br><code>catch</code>语句捕获异常</li><li>如<strong>捕获成功</strong>,异常被处理,程序继续运行<br><code>catch</code>的异常类型与抛出的异常类型匹配时</li><li>如<strong>捕获失败</strong>,异常未被处理,程序中断运行<br><code>catch</code>的异常类型与抛出的异常类型不匹配</li></ol><h4 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h4><ul><li><strong>Exception</strong>: 异常层次结构的父类</li><li><strong>ArithmeticException</strong>:算术错误情况,如以0作除数</li><li><strong>ArrayIndexOutOfBoundsException</strong>: 数组下标越界</li><li><strong>NullPointerException</strong>: 尝试访问null对象成员</li><li><strong>ClassNotFoundException</strong>: 不能加载所需的类</li><li><strong>ClassCastException</strong>:对象强制类型转换出错</li><li><strong>NumberFormatException</strong>: 数字格式转换异常,如把”abc”转成数字了</li></ul><h4 id="Try-catch代码块"><a href="#Try-catch代码块" class="headerlink" title="Try-catch代码块:"></a>Try-catch代码块:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 代码段 1</span></span><br><span class="line">  <span class="comment">// 产生异常的代码段 2</span></span><br><span class="line">  <span class="comment">// 代码段 3</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">1</span> e) &#123;</span><br><span class="line">  <span class="comment">// 对异常进行处理的代码段4</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">2</span> e) &#123;</span><br><span class="line">  <span class="comment">// 对异常进行处理的代码段5</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 无论是否发生异常,代码总能执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Throw-Throws关键字"><a href="#Throw-Throws关键字" class="headerlink" title="Throw,Throws关键字"></a>Throw,Throws关键字</h4><ul><li><strong>throw</strong>: 抛出异常(一般用于代码块和方法中)</li><li><strong>throws</strong>: 声明异常(一般用于方法中)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(age&lt;=<span class="number">0</span>||age&gt;<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(); <span class="comment">//处理方法 try-catch</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常:"></a>自定义异常:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class AgeException extends <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言:"></a>断言:</h4><p>assert 5&lt;3==false “断言信息”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;异常处理和错误的区别&quot;&gt;&lt;a href=&quot;#异常处理和错误的区别&quot; class=&quot;headerlink&quot; title=&quot;异常处理和错误的区别:&quot;&gt;&lt;/a&gt;异常处理和错误的区别:&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;异常:&lt;/strong&gt; 异常指的是程序运行时发生的不正
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>集合框架</title>
    <link href="http://yoursite.com/2017/03/25/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/03/25/集合框架/</id>
    <published>2017-03-25T00:58:00.000Z</published>
    <updated>2019-10-19T00:09:37.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用:"></a>泛型的作用:</h3><h4 id="1-泛型的定义"><a href="#1-泛型的定义" class="headerlink" title="1. 泛型的定义:"></a>1. 泛型的定义:</h4><p>泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数.这种参数类型,可以在类 接口 和方法中创建,分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。</p><h4 id="2-泛型的作用"><a href="#2-泛型的作用" class="headerlink" title="2. 泛型的作用:"></a>2. 泛型的作用:</h4><p>引入泛型的好处是安全简单 可以将运行时类型相关错误提前到编译时错误.</p><h4 id="3-泛型的特点"><a href="#3-泛型的特点" class="headerlink" title="3. 泛型的特点:"></a>3. 泛型的特点:</h4><ul><li>所有的泛型类的参数在编译时都会被擦除,虚拟机运行时没有泛型.</li><li>java泛型不支持基本类型</li><li>在泛型内部,无法获得有关系泛型参数类型的信息,如果传入的类型参数为T,那么在泛型代码内部你不知道T有什么方法,属性,关于T 的一切信息都丢失了</li><li>创建泛型对象时,清指明类型.</li><li>java的泛型类型不能用于new构建对象,也不能用于初始化数组.</li></ul><h3 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口:"></a>集合接口:</h3><h4 id="1-为什么要使用集合接口"><a href="#1-为什么要使用集合接口" class="headerlink" title="1.为什么要使用集合接口:"></a>1.为什么要使用集合接口:</h4><p>如果并不知道程序运行时会需要多少对象，或者需要更复杂方式存储对象——可以使用Java集合框架</p><h4 id="2-集合框架组成"><a href="#2-集合框架组成" class="headerlink" title="2. 集合框架组成"></a>2. 集合框架组成</h4><ol><li>Collection接口是最基本的集合接口.</li><li>Map接口(实现类:HasMap . TreeMap)<br>Map是一系列键值对组成的集合,提供了key到Value的映射.同时它也没有继承Collection.在Map中保证了key和Vlaue之间的一一对应,所以它不能存在相同的key值.</li><li>List接口为Collection子接口。List所代表的是有序的Collection</li></ol><ul><li>它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置，和数组相似，从0开始，到元素个数-1）访问元素，并检索列表中的元素</li><li>实现类:<ul><li><strong>ArraryList</strong>是一个非线程安全的列表,在遍历元素效率比较高.线程不同步.</li><li><strong>LinkedList</strong>是一个双向链表,在添加和删除元素时效率比较高.线程不同步.</li><li><strong>Vector</strong>与ArrayList相似，但是Vector是同步的。所以说Vector是使用数组实现的线程安全的列表。它的操作与ArrayList几乎一样.</li></ul></li></ul><ol start="4"><li>Set是一种不包括重复元素的Collection:</li></ol><ul><li>它维持自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个</li><li>由于Set接口的特殊性，所有传入Set集合中的元素都必须不同</li><li>实现类:<ul><li><strong>EnumSet</strong>是枚举的专用Set。所有的元素都是枚举类型</li><li><strong>HashSet</strong> HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变</li><li><strong>TreeSet</strong>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法</li></ul></li></ul><ol start="5"><li>Queue</li></ol><ul><li>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作</li><li>方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。</li><li>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除</li></ul><ol start="6"><li>ArrayList</li></ol><ul><li>ArrayList是一个用数组实现的列表，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null</li><li>每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作（构建一个新的更大的数组并将之前的内容拷贝到新书组中）。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率</li><li>ArrayList的默认扩容扩展后数组大小为：(原数组长度*3)/2+1</li><li>ArrayList是一个非线程安全的列表</li></ul><ol start="7"><li>LinkedList</li></ol><ul><li>同样实现List接口的LinkedList与ArrayList不同，LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部</li><li>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作</li><li>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;泛型的作用&quot;&gt;&lt;a href=&quot;#泛型的作用&quot; class=&quot;headerlink&quot; title=&quot;泛型的作用:&quot;&gt;&lt;/a&gt;泛型的作用:&lt;/h3&gt;&lt;h4 id=&quot;1-泛型的定义&quot;&gt;&lt;a href=&quot;#1-泛型的定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面向接口编程</title>
    <link href="http://yoursite.com/2017/03/23/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/23/面向接口编程/</id>
    <published>2017-03-23T10:27:00.000Z</published>
    <updated>2019-10-19T00:09:49.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是接口-为什么要用接口"><a href="#什么是接口-为什么要用接口" class="headerlink" title="什么是接口,为什么要用接口?:"></a>什么是接口,为什么要用接口?:</h4><ul><li>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li><li>接口(interface)是抽象方法和常量值的定义的集合。</li><li>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</li><li>接口定义举例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点:"></a>接口的特点:</h4><ul><li>用 interface 来定义。</li><li>接口中的所有成员变量都默认是由public static final修饰的。</li><li>接口中的所有方法都默认是由public abstract修饰的。接口没有构造方法。</li><li>实现接口的类中必须提供接口中所有方法的具体实现内容。 </li><li>多个无关的类可以实现同一个接口</li><li>一个类可以实现多个无关的接口</li><li>与继承关系类似，接口与实现类之间存在多态性</li><li>接口也可以继承另一个接口，使用extends关键字</li><li>实现接口的类中必须提供接口中所有方法的具体实现内容。 </li><li>多个无关的类可以实现同一个接口</li><li>一个类可以实现多个无关的接口</li><li>与继承关系类似，接口与实现类之间存在多态性</li></ul><h4 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h4><ol><li>编写接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UsbInterface</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *USB接口提供服务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDisk</span> <span class="keyword">implements</span> <span class="title">UsbInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"连接USB口,开始传输数据."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UsbInterface uDisk = <span class="keyword">new</span> UDisk();</span><br><span class="line">uDisk.service();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是接口-为什么要用接口&quot;&gt;&lt;a href=&quot;#什么是接口-为什么要用接口&quot; class=&quot;headerlink&quot; title=&quot;什么是接口,为什么要用接口?:&quot;&gt;&lt;/a&gt;什么是接口,为什么要用接口?:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;有时必须从几个类中派生出一个子类
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入面向对象</title>
    <link href="http://yoursite.com/2017/03/15/%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/03/15/深入面向对象/</id>
    <published>2017-03-15T01:13:00.000Z</published>
    <updated>2019-10-19T08:14:21.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的三个基本特征-封装-继承-多态"><a href="#面向对象的三个基本特征-封装-继承-多态" class="headerlink" title="面向对象的三个基本特征:封装 . 继承 . 多态"></a>面向对象的三个基本特征:封装 . 继承 . 多态</h3><h4 id="封装-属性-对象"><a href="#封装-属性-对象" class="headerlink" title="封装(属性 . 对象):"></a>封装(属性 . 对象):</h4><ul><li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象<h4 id="继承"><a href="#继承" class="headerlink" title="继承:"></a>继承:</h4></li><li>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法</li><li>一个新类可以从现有的类中派生，这个过程称为类继承，新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）</li><li>派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要<h4 id="多态"><a href="#多态" class="headerlink" title="多态:"></a>多态:</h4></li><li>多态性是指允许不同类的对象对同一消息作出响应</li><li>多态性语言具有灵活、抽象、行为共享、代码共享的优势<h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义:"></a>封装的意义:</h4></li><li>适当的封装可以让代码更容易理解和维护，也加强了代码的安全性。<h4 id="包机制"><a href="#包机制" class="headerlink" title="包机制:"></a>包机制:</h4></li><li>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间<h4 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用:"></a>包的作用:</h4></li><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li><li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>包也提供了限定了访问权限的一个控制范围，拥有包访问权限的类才能访问某个包中的类</li></ul><h4 id="类的访问控制符"><a href="#类的访问控制符" class="headerlink" title="类的访问控制符:"></a>类的访问控制符:</h4><ul><li>default: 默认的（不提供访问控制符）仅可被同包的其他代码访问</li><li>public：可以被任何代码访问</li><li>protected: </li><li>private: 私有的</li></ul><h4 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义:"></a>继承的意义:</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的数据或新的功能,也可以用父类的功能,通过使用继承,我们能够非常方便的复用代码,大大提高开发效率</p><ul><li>对象向上造型:<br>所谓的向上造型就是父类的引用指向子类的对象</li><li>instanceof运算符:<br>instanceof运算符用来判断对象是否属于某个类的实例</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象的三个基本特征-封装-继承-多态&quot;&gt;&lt;a href=&quot;#面向对象的三个基本特征-封装-继承-多态&quot; class=&quot;headerlink&quot; title=&quot;面向对象的三个基本特征:封装 . 继承 . 多态&quot;&gt;&lt;/a&gt;面向对象的三个基本特征:封装 . 继承 . 
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类的基本结构</title>
    <link href="http://yoursite.com/2017/03/06/Java%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/03/06/Java类的基本结构/</id>
    <published>2017-03-06T02:13:00.000Z</published>
    <updated>2019-10-19T00:10:08.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念:"></a>面向对象的概念:</h3><h4 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类?"></a>什么是类?</h4><p>同时将具有相同特征的对象抽象成一种新的数据类型—-类<br>(具有相同特征和行为的多个对象的集合)</p><h4 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处:"></a>封装的好处:</h4><p>一个类把属性算法(逻辑处理)封装起来,只留必要的方法(接口)让用户使用,一个类该暴露什么,不该暴露什么,由类的设计者更具需求设计决定的.private属性用户不能直接访问,如果设计者提供相应的接口方法,那么用户可以通过该接口方法访问.<br>一个类,不直接修改属性而通过方法来修改,可以在方法里做相应的处理避免用户输入的一些非法数据而造成系统故障</p><h3 id="什么是构造方法"><a href="#什么是构造方法" class="headerlink" title="什么是构造方法:"></a>什么是构造方法:</h3><ul><li>构造方法是与类同名的方法</li><li>没返回值，也不能写void</li><li>主要作用是完成新建对象的初始化工作</li><li>一般不能显式地直接调用，而是用new来调用（后面会存在使用this/super调用）</li><li>创建一个类的新对象的同时，系统自动调用该类的构造函数，为新建对象的初始化</li></ul><h3 id="构造方法重载"><a href="#构造方法重载" class="headerlink" title="构造方法重载:"></a>构造方法重载:</h3><ul><li>构造方法是一种特殊的方法，它也能重载</li><li>构造函数的重载是指同一个类中存在着若干个具有不同参数列表的构造函数</li></ul><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字:"></a>this关键字:</h3><p>this用于表示当前对象自身的引用，可以用于访问被局部变量隐藏的成员变量，也可以将本对象作为参数传递给其他对象操作</p><h3 id="类初始化代码块static"><a href="#类初始化代码块static" class="headerlink" title="类初始化代码块static:"></a>类初始化代码块static:</h3><p>####static代码块的执行时机: </p><ul><li>用Class.forName(类名)显式加载的时候（反射、JDBC时详细讲解）</li><li>new或反射实例化一个类的对象时候</li><li>调用类的static方法的时候（后续详细讲解）</li><li>调用类的static变量的时候（后续详细讲解）</li><li>调用类的静态常量（后续详细讲解）的时候，是不会加载类的，即不会执行static{}语句块当访问类的静态常量时，如果编译器可以计算出常量的值，则不会加载类，否则会加载类</li><li>用Class.forName()形式的时候，也可以自己设定要不要加载类，如将<code>Class.forName(&quot;Test&quot;</code>)改为 <code>Class.forName(&quot;Test&quot;,false,StaticBlockTest.class.getClassLoader())</code>，你会发现Test没有被加载，static{}没有被执行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象的概念&quot;&gt;&lt;a href=&quot;#面向对象的概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象的概念:&quot;&gt;&lt;/a&gt;面向对象的概念:&lt;/h3&gt;&lt;h4 id=&quot;什么是类&quot;&gt;&lt;a href=&quot;#什么是类&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java数组</title>
    <link href="http://yoursite.com/2017/03/05/Java%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/03/05/Java数组/</id>
    <published>2017-03-05T08:21:00.000Z</published>
    <updated>2019-10-19T00:10:13.302Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组"><a href="#数组" class="headerlink" title="数组:"></a>数组:</h4><ul><li>数组是一组类型相同的数据的集合</li><li>数组可以存储多个数据,但类型必须相同</li><li>数组能作为数据的容器使用,把多个数据集中存储</li><li>存储在数组中的数据,都有相应的索引值,可以方便获取或修改</li><li>当需要同时保存多个类型相同的变量并进行处理时,可以考虑用数组<h5 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性:"></a>数组的特性:</h5></li><li>Java的数组是引用类型，</li><li>数组与类、接口、枚举、注解并列，是引用类型中的一种，</li><li>Java的数组长度一经确定不能改变； </li><li>数组在内存中是连续分配，所以读取速度快</li><li>实际应用中，常常无法确定变量的数量，后续我们将学习集合框架，实现可变长度的数据容器；<h5 id="数组的元素"><a href="#数组的元素" class="headerlink" title="数组的元素:"></a>数组的元素:</h5></li><li>数组中存储的数据称为数组的元素(Element)，</li><li>数组本身是引用类型，但是数组中的元素可以是基本数也可以是引用类型，<ul><li>也就是说，即可以有存储基本数据类型int的数组，也可以有存储引用类型String的数组，但是数组本身是引用类型</li></ul></li><li>数组中的元素有索引值，索引值从0开始<ul><li>也就是说，如果一个数组的长度是10，那么索引值就是0-9，也就是第一个元素的索引值是0，第二个的索引值是1，以此类准，通过索引值可以方便访问元素</li></ul></li></ul><h5 id="数组的维数"><a href="#数组的维数" class="headerlink" title="数组的维数:"></a>数组的维数:</h5><ul><li>如果一个数组中存储数据结构如下所示，元素都是单个数据，称为一维数组，<br>67 78 54 89 12 45 87 97 79 9</li><li>其中，67被称为第0个元素，78称为第1个元素……</li><li>如果个数组中存储数据结构如下所示，元素是一维数组，称为二维数组，<br>[67 78 54] [89 12] [45 87 79] [3] </li></ul><h5 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明:"></a>数组声明:</h5><p>一维数组的声明:<br><code>数组元素类型[] 变量名称</code>     或<br><code>数组元素类型 变量名称[]</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组:&quot;&gt;&lt;/a&gt;数组:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数组是一组类型相同的数据的集合&lt;/li&gt;
&lt;li&gt;数组可以存储多个数据,但类型必须相同&lt;/li&gt;
&lt;li&gt;数组能作为数据的容
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2017/03/05/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/03/05/Java基础/</id>
    <published>2017-03-05T05:43:00.000Z</published>
    <updated>2019-10-19T00:10:05.277Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么学习java"><a href="#为什么学习java" class="headerlink" title="为什么学习java:"></a>为什么学习java:</h4><p>Java是Sun Microsystems于1995年推出的<strong>高级编程语言</strong><br>Java 领域的JavaSE、JavaEE技术已发展成为同C#和.NET平分天下的应用软件开发平台和技术</p><h4 id="java语言的特点"><a href="#java语言的特点" class="headerlink" title="java语言的特点:"></a>java语言的特点:</h4><ul><li><strong>跨平台性</strong>;一处编写,处处运行.</li><li><strong>面向对象</strong>(三大特征);<strong><em>封装</em></strong>.<strong><em>继承</em></strong>.<strong><em>多态</em></strong>.</li><li><strong>健壮性</strong>;<strong><em>强类型机制</em></strong>,<strong><em>异常处理机制</em></strong>,<strong><em>自动垃圾回收机制</em></strong></li><li><strong>分布式</strong>;</li><li><strong>多线程</strong>;</li><li><strong>动态性</strong>;</li></ul><h4 id="JVM-Java-Virtual-Machine-介绍"><a href="#JVM-Java-Virtual-Machine-介绍" class="headerlink" title="JVM(Java Virtual Machine)介绍:"></a>JVM(Java Virtual Machine)介绍:</h4><p>JVM称为java虚拟机;<br>JVM可以理解为Java编译器和操作系统之间的虚拟处理器;</p><ul><li>编译器编译的字节码只要JVM认识即可</li><li>JVM再将字节码解释成操作系统认识的机器码   </li></ul><p>只要需要运行Java程序的设备,都需要安装JVM</p><h4 id="JDK与JRE"><a href="#JDK与JRE" class="headerlink" title="JDK与JRE:"></a>JDK与JRE:</h4><ul><li>JDK是Java开发工具包(Java Development Kit)的简称,是一个软件;<br>如果要用Java语言编写程序,就必须在计算机上安装JDK;</li><li>JRE是Java运行环境(Java Runtime Environment)的简称<br>如果要在机器上运行Java程序,就必须要有JRE;</li></ul><h4 id="JDK的一些常用工具"><a href="#JDK的一些常用工具" class="headerlink" title="JDK的一些常用工具:"></a>JDK的一些常用工具:</h4><ul><li>javac: 编译器,将源程序转为字节码;</li><li>java: 运行编译后的java程序(.class后缀的);</li><li>jar: 打包工具,将相关的类文件打包成一个文件;</li><li>javadoc: 文档生成器,从源码注释中提取文档;</li></ul><h4 id="Java项目结构"><a href="#Java项目结构" class="headerlink" title="Java项目结构:"></a>Java项目结构:</h4><p><strong>src目录</strong>：存放包和源文件<br><strong>JRE系统库目录</strong>：存放程序运行必须的系统库文件<br><strong>bin目录</strong>：存放可执行的字节码文件</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释:"></a>注释:</h4><p>文本注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* version ycj</span></span><br><span class="line"><span class="comment">* data 2017-03-05</span></span><br><span class="line"><span class="comment">* /</span></span><br></pre></td></tr></table></figure><h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则:"></a>标识符命名规则:</h4><ul><li>某一个区域中是唯一的，在不同的区域中可以使用同一名字</li><li>必须由字母、数字、下划线和$符号组成</li><li>不能以数字开头</li><li>不能使非法的字符，如：#，％……“&amp;等 </li><li>不能使系统关键字</li><li>不能使空格来分隔</li><li>长度无限制</li><li>严格区分大小写</li><li>不同的标识符有一定的命名规矩，后续学习    </li></ul><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别:"></a>成员变量和局部变量的区别:</h4><p>成员变量是作用于整个类,局部变量作用于某个方法,局部变量没有默认值,必须初始化,成员变量有默认值.</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型:"></a>数据类型:</h4><p>数据类型分为基本数据类型和引用数据类型;</p><ol><li>数据类型(8个基本数据类型):byte, short, int, long, float, double, boolean, char    </li><li>引用数据类型:String, 数组, 接口, 类, 枚举, 包装类型<h5 id="String、StringBufferStringBuilder的区别"><a href="#String、StringBufferStringBuilder的区别" class="headerlink" title="String、StringBufferStringBuilder的区别:"></a>String、StringBufferStringBuilder的区别:</h5></li></ol><p><strong>String</strong>类是不可变的，对象一旦被创建，就不能被修改；可以使用=直接赋值，此时使用常量池；也可以使用new创建，不使用常量池；<br><strong>StringBuffer</strong>是可变的，对象创建后，可以修改；必须使用new关键字；<br><strong>StringBuilder</strong>是不同步的，在单线程情况下使用比StringBuffer高效；必须使用new关键字；</p><h4 id="堆-栈-常量池-方法区"><a href="#堆-栈-常量池-方法区" class="headerlink" title="堆,栈,常量池,方法区:"></a>堆,栈,常量池,方法区:</h4><p>基本数据类型保存在栈中,引用数据类型保存在堆中;<br><strong>堆</strong>:存放所有new出来的对象<br><strong>栈</strong>:存放基本类型的变量数据和对象的应用<br><strong>方法区</strong>:包含所有的class和static变量<br><strong>常量区</strong>:存放基本类型和字符串常量        </p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符:"></a>运算符:</h4><p>从功能角度分，Java中的运算符可以分为算术、关系、位、逻辑运算符四类<br><strong>算术运算符</strong>:用来对操作数进行数学运算.<br><strong>关系运算符</strong>:又叫比较运算符,用来运算操作两个数的大小关系.<br><strong>位运算符</strong>:针对操作数的二进制位进行运算<br><strong>逻辑运算符</strong>:针对布尔值或返回值为布尔值的表达式进行运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么学习java&quot;&gt;&lt;a href=&quot;#为什么学习java&quot; class=&quot;headerlink&quot; title=&quot;为什么学习java:&quot;&gt;&lt;/a&gt;为什么学习java:&lt;/h4&gt;&lt;p&gt;Java是Sun Microsystems于1995年推出的&lt;strong&gt;高级
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
