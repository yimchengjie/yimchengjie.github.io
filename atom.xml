<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yimchengjie.github.io/"/>
  <updated>2020-01-03T09:29:49.349Z</updated>
  <id>https://yimchengjie.github.io/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型模式</title>
    <link href="https://yimchengjie.github.io/2019/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yimchengjie.github.io/2019/08/27/设计模式/原型模式/</id>
    <published>2019-08-27T14:09:01.000Z</published>
    <updated>2020-01-03T09:29:49.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://yimchengjie.github.io/2019/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yimchengjie.github.io/2019/08/18/设计模式/工厂模式/</id>
    <published>2019-08-18T12:31:20.000Z</published>
    <updated>2020-01-03T07:48:47.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>属于创建型模式</p><p>专门定义一个类来负责创建一个接口的一系列实现类的实例;即负责创建一些列有公共父类或者实现接口的对象</p><h3 id="为什么使用工厂模式"><a href="#为什么使用工厂模式" class="headerlink" title="为什么使用工厂模式"></a>为什么使用工厂模式</h3><ol><li>使用工厂模式, 将创建实例和使用实例进行分离, 更便于后期的维护和扩展;实现了<strong>解耦</strong></li><li>工厂模式可以减少重复代码, 创建实例的代码只要重复调用工厂模式中的创建方法就行了</li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式又叫<strong>静态工厂方法模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String kindName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKindName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kindName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKindName</span><span class="params">(String kindName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kindName = kindName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"呼吸中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗啃骨头..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类cat</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">getAnimal</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name==<span class="string">"dog"</span>||name==<span class="string">"Dog"</span>)&#123;</span><br><span class="line">            Animal dog=<span class="keyword">new</span> Dog();</span><br><span class="line">            dog.setKindName(<span class="string">"dog"</span>);</span><br><span class="line">            <span class="keyword">return</span> dog;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name==<span class="string">"cat"</span>||name==<span class="string">"Cat"</span>) &#123;</span><br><span class="line">            Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">            cat.setKindName(<span class="string">"dog"</span>);</span><br><span class="line">            <span class="keyword">return</span> cat;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"出错"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当简单工厂模式要创建的对象非常多, 或者工厂类有它自己的实现类了,代码量也会增多, 不易维护.<br>上述代码的例子下, <code>AnimalFactory</code>有了继承它的<code>DogFactory</code>, <code>CatFactory</code>创建的对象变成ChinaDog<br> ChinaCat EnglishDog EnglishCat..怎么办呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    AbstractAnimalFactory abstractAnimalFactory=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimal</span><span class="params">(String country,String kind)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kind==<span class="string">"dog"</span>)&#123;</span><br><span class="line">            abstractAnimalFactory=<span class="keyword">new</span> DogFactoryAbstract();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (kind==<span class="string">"cat"</span>)&#123;</span><br><span class="line">            abstractAnimalFactory=<span class="keyword">new</span> CatFactoryAbstract();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"工厂错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        abstractAnimalFactory.createAnimal(country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Animal <span class="title">createAnimal</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类实现工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactoryAbstract</span> <span class="keyword">extends</span> <span class="title">AbstractAnimalFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">(String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (country == <span class="string">"chinese"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseCat();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (country == <span class="string">"english"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EnglishCat();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"错误"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactoryAbstract</span> <span class="keyword">extends</span> <span class="title">AbstractAnimalFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">(String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (country == <span class="string">"chinese"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseDog();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (country == <span class="string">"english"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EnglishDog();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"错误"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;属于创建型模式&lt;/p&gt;
&lt;p&gt;专门定义一个类来负责创建一个接口的一系列实现类的实例;即负责创建一些列有公共父类或者实现接口的
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://yimchengjie.github.io/2019/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yimchengjie.github.io/2019/08/10/设计模式/单例模式/</id>
    <published>2019-08-10T10:55:45.000Z</published>
    <updated>2020-01-03T04:50:38.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>属于创建型模式</p><p>单例模式,就是采取一定的方法保证在整个系统中,对于某个类,只存在一个实例对象.</p><h3 id="为什么使用单例模式"><a href="#为什么使用单例模式" class="headerlink" title="为什么使用单例模式"></a>为什么使用单例模式</h3><ol><li>使用单例模式,对于那些经常使用的实例, 可以减少创建对象的开销</li><li>实例化减少,可能减少虚拟机垃圾回收的压力</li></ol><h3 id="使用单例模式的几种方法"><a href="#使用单例模式的几种方法" class="headerlink" title="使用单例模式的几种方法"></a>使用单例模式的几种方法</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器, 防止外部进行new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//synchronized保证线程安全性, 但是会影响效率,存在实例时也要进行同步, 这是不必要的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h4><p>在静态方法保证线程安全的基础上,提高了系统效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证可见性,一但有实例时,所有线程都会知道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheck.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> instance=<span class="keyword">new</span> DoubleCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>比较推荐的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类装载时,静态内部类不会被加载, 保证了懒加载</span></span><br><span class="line">    <span class="comment">// 静态内部类装载时, JVM提供了线程安全, 保证了线程安全</span></span><br><span class="line">    <span class="comment">// 类的静态属性,只在类装载时被加载,保证了单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassIntance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClass INTANCE = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClass <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticInnerClassIntance.INTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举方法"><a href="#枚举方法" class="headerlink" title="枚举方法"></a>枚举方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTACNE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTACNE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举方法是最好的一种,也是官方推荐的一种, 它完美的解决了懒加载, 线程安全, 单例等问题</p><p>而且他不会被反射影响, 上面几种方法都可以通过反射的方式, 破坏单例, 而枚举类型是无法通过反射创建实例的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;属于创建型模式&lt;/p&gt;
&lt;p&gt;单例模式,就是采取一定的方法保证在整个系统中,对于某个类,只存在一个实例对象.&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>6大设计原则</title>
    <link href="https://yimchengjie.github.io/2019/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://yimchengjie.github.io/2019/08/10/设计模式/6大设计原则/</id>
    <published>2019-08-10T04:45:11.000Z</published>
    <updated>2020-01-01T09:20:39.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6大设计原则"><a href="#6大设计原则" class="headerlink" title="6大设计原则"></a>6大设计原则</h2><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h3><p>SRP(Single Responsiblity Principle)</p><p><strong>核心定义</strong>:一个接口或者一个类或者一个方法,只负责一件事;</p><p>就像流水线生产,分工合作, 每个人只负责一件事情, 一个人不能负责太多事情, 否则效率低下,而且可能会出问题</p><p>在java程序中, 特别要注意接口的设计, 要遵循单一职责原则, 定义所有实现类通用的职责, 不能把实现类特有的职责放在接口上,否则所有实现类都会受到影响; 但要注意, 要根据业务合理划分责任, 过于细分,会导致类的数量非常庞大, 而且需要相互的耦合, 造成不必要的负责度</p><h3 id="2-里式替换原则"><a href="#2-里式替换原则" class="headerlink" title="2. 里式替换原则"></a>2. 里式替换原则</h3><p>LSP(Liskov Substitution Principle)</p><p><strong>核心定义</strong>:子类应该是可以替换父类,并且在所有使用父类的地方都能够换成子类;</p><p>在java中,子类必须完全实现父类的方法;父类出现的地方换成子类,程序依然能正常运行;子类可以在父类基础上增加新的行为.</p><h3 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3. 依赖倒置原则"></a>3. 依赖倒置原则</h3><p>DIP(Dependence Inversion Principle)</p><p><strong>核心定义</strong>:就是面向接口(或抽象类)编程,各个模块之间不能直接进行依赖, 要通过接口的方式,使各个模块相互独立</p><p>在java中,每个类都尽量继承一个接口;依赖的变量尽量使用接口而不是实现类(比如service依赖dao层,在service接口定义中,只是用dao接口而不是dao实现类);如果基类是抽象类或类,且实现了一些方法,那么尽量不要覆写基类的方法;</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>ISP(Interface Segregation Principle)</p><p><strong>核心定义</strong>:接口的方法要少,类之间的关系要建立在最小接口上;这个单一职责要区分开, 单一职责讲的是类的业务功能单一</p><p>在java中体现为接口的拆分,接口方法尽量定义的少,不要定义没意义的接口</p><h3 id="5-开放封闭原则"><a href="#5-开放封闭原则" class="headerlink" title="5. 开放封闭原则"></a>5. 开放封闭原则</h3><p>OCP(Open Close Principle)</p><p><strong>核心定义</strong>:一个模块的扩展性方面应该是开放的, 而在更改性方面应该是封闭的</p><p>一个网络模块, 原来只有服务端功能,现在要加入客户端功能,那么在不需要修改服务端代码的前提下, 就能扩展客户端, 这样就是前后端分离,在设计之初, 将服务端和客户端分开</p><h3 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6. 迪米特法则"></a>6. 迪米特法则</h3><p>LOD(Law Of Demter)</p><p><strong>核心定义</strong>:一个类应该对自己需要耦合或者调用的类保持最少的了解,也就是低耦合,高内聚</p><p>类与类之间不能有过多的耦合,在系统设计时,不要让一个类依赖太多其他的类, 尽量减少依赖关系</p><h2 id="设计模式概览"><a href="#设计模式概览" class="headerlink" title="设计模式概览"></a>设计模式概览</h2><h3 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h3><p>用于描述”怎样创建对象”,它的主要特点是”将对象的创建与使用分离”</p><p>有<strong>单例</strong>,<strong>原型</strong>,<strong>工厂方法</strong>,<strong>抽象工厂</strong>,<strong>建造者</strong> 5种创造型模式</p><h3 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2. 结构型模式"></a>2. 结构型模式</h3><p>用于描述”如何将对象按某种布局组成更大的结构”</p><p>有<strong>代理</strong>,<strong>适配器</strong>,<strong>桥接</strong>,<strong>装饰</strong>,<strong>外观</strong>,<strong>享元</strong>,<strong>组合</strong> 7种结构型模式</p><h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3. 行为型模式"></a>3. 行为型模式</h3><p>用于描述”类或对象之间怎么相互协作共同完成单个对象无法单独完成的任务,以及怎么样分配职责”</p><p>有<strong>模板方法</strong>,<strong>策略</strong>,<strong>命令</strong>,<strong>责任链</strong>,<strong>状态</strong>,<strong>观察者</strong>,<strong>中介者</strong>,<strong>迭代器</strong>,<strong>访问者</strong>,<strong>备忘录</strong>,<strong>解释器</strong> 11种行为型模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;6大设计原则&quot;&gt;&lt;a href=&quot;#6大设计原则&quot; class=&quot;headerlink&quot; title=&quot;6大设计原则&quot;&gt;&lt;/a&gt;6大设计原则&lt;/h2&gt;&lt;h3 id=&quot;1-单一职责原则&quot;&gt;&lt;a href=&quot;#1-单一职责原则&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ高可用集群方案</title>
    <link href="https://yimchengjie.github.io/2019/08/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"/>
    <id>https://yimchengjie.github.io/2019/08/03/消息中间件/ActiveMQ高可用集群方案/</id>
    <published>2019-08-03T08:25:10.000Z</published>
    <updated>2020-01-01T07:41:26.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ高可用集群方案"><a href="#ActiveMQ高可用集群方案" class="headerlink" title="ActiveMQ高可用集群方案"></a>ActiveMQ高可用集群方案</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ高可用集群方案&quot;&gt;&lt;a href=&quot;#ActiveMQ高可用集群方案&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ高可用集群方案&quot;&gt;&lt;/a&gt;ActiveMQ高可用集群方案&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="ActiveMQ" scheme="https://yimchengjie.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ支持的协议</title>
    <link href="https://yimchengjie.github.io/2019/07/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yimchengjie.github.io/2019/07/30/消息中间件/ActiveMQ支持的协议/</id>
    <published>2019-07-30T11:40:31.000Z</published>
    <updated>2019-12-31T09:13:13.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ支持的协议"><a href="#ActiveMQ支持的协议" class="headerlink" title="ActiveMQ支持的协议"></a>ActiveMQ支持的协议</h2><p>ActiveMQ支持多种协议传输和传输方式,允许客户端使用多种协议连接.</p><p>ActiveMQ支持的协议: AUTO、OpenWire、AMQP、Stomp、MQTT等<br>在<code>${ACTIVE_HOME}/conf/activemq.xml</code>中, 通过配置<code>&lt;transportConnectors&gt;</code>就可以使用多种传输方式(==注意配置文件中可能会用到转义字符串, 比如&amp;要用&amp;来表示==)</p><p>ActiveMQ支持的基础传输方式有: VM、TCP、SSL、UDP、Peer、Multicast、HTTP(S)等</p><p>由于TCP的稳定性, 它也是ActiveMQ中最常用的一种传输方式. 在默认的设置中, TCP连接的端口为61616</p><h3 id="OpenWire协议"><a href="#OpenWire协议" class="headerlink" title="OpenWire协议"></a>OpenWire协议</h3><p>OpenWire协议是Apache的一种跨语言的协议,允许从不同的语言和平台访问ActiveMQ<br>默认就是使用这种协议, 功能很全面</p><p>OpenWire支持TCP、SSL、NIO、UDP、VM等传输方式，但URL只配置传输方式时，默认就是使用OpenWire协议</p><h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>全称Message Queuing Telemetry Transport，即消息队列遥测传输，由IBM开发， 已成为物联网通信的标准</p><p>它结构简单，相比其他的协议更加轻量级</p><h4 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布-订阅模型"></a>发布-订阅模型</h4><p>MQTT协议使用发布-订阅模型<br>提供者发布消息到主题topic上, 只要订阅了这个topic的消费者,都能收到这条消息</p><p>消费者无法收到启动前topic上的消息</p><h4 id="MQTT中的服务质量-QoS"><a href="#MQTT中的服务质量-QoS" class="headerlink" title="MQTT中的服务质量(QoS)"></a>MQTT中的服务质量(QoS)</h4><p>服务质量(QoS)级别 是一种关于发送者和接受者之间信息传递的保证协议</p><p>MQTT支持三种QoS<br>至多一次(0)客户端只发布一次消息到服务器<br>至少一次(1)客户端发送消息,直到服务器返回成功<br>只有一次(2)在(1)的前提下, 客户端继续发送, 客户端查看是否存在, 有就删除</p><p>QoS是的在不可靠的网络下进行通信变得更加简单,因为即使是在非常不可靠的网络下,协议也可以掌控是否需要重发消息, 并保证消息到达</p><h4 id="ActiveMQ中使用MQTT协议"><a href="#ActiveMQ中使用MQTT协议" class="headerlink" title="ActiveMQ中使用MQTT协议"></a>ActiveMQ中使用MQTT协议</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> qos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String broker = <span class="string">"tcp://activemq.tony.com:1883"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"admin"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"admin"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MqttClient <span class="title">connect</span><span class="params">(String clientId, String userName,String password)</span> <span class="keyword">throws</span> MqttException </span>&#123;</span><br><span class="line">        MemoryPersistence persistence = <span class="keyword">new</span> MemoryPersistence();</span><br><span class="line">        MqttConnectOptions connOpts = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">        connOpts.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line">        connOpts.setUserName(userName);</span><br><span class="line">        connOpts.setPassword(password.toCharArray());</span><br><span class="line">        connOpts.setConnectionTimeout(<span class="number">10</span>);</span><br><span class="line">        connOpts.setKeepAliveInterval(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// connOpts.setServerURIs(uris);  //这个是mqtt客户端实现的负载均衡和容错</span></span><br><span class="line">        <span class="comment">// String[] uris = &#123;"tcp://10.100.124.206:1883","tcp://10.100.124.207:1883"&#125;;</span></span><br><span class="line">        MqttClient mqttClient = <span class="keyword">new</span> MqttClient(broker, clientId, persistence);</span><br><span class="line">        mqttClient.setCallback(<span class="keyword">new</span> PushCallback(<span class="string">"test"</span>));</span><br><span class="line">        mqttClient.connect(connOpts);</span><br><span class="line">        <span class="keyword">return</span> mqttClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pub</span><span class="params">(MqttClient sampleClient, String msg, String topic)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MqttMessage message = <span class="keyword">new</span> MqttMessage(msg.getBytes());</span><br><span class="line">        message.setQos(qos);</span><br><span class="line">        message.setRetained(<span class="keyword">false</span>);</span><br><span class="line">        sampleClient.publish(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String str, String clientId, String topic)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MqttClient mqttClient = connect(clientId, userName, passWord);</span><br><span class="line">        <span class="keyword">if</span> (mqttClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pub(mqttClient, str, topic);</span><br><span class="line">            System.out.println(<span class="string">"pub--&gt;"</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqttClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mqttClient.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        publish(<span class="string">"message content"</span>, <span class="string">"producer-client-id-0"</span>, <span class="string">"x/y/z"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PushCallback</span> <span class="keyword">implements</span> <span class="title">MqttCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String threadId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PushCallback</span><span class="params">(String threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadId = threadId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionLost</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliveryComplete</span><span class="params">(IMqttDeliveryToken token)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器是否正确接收---------"</span> + token.isComplete());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getPayload());</span><br><span class="line">        System.out.println(threadId + <span class="string">" "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> qos = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String broker = <span class="string">"tcp://activemq.tony.com:1883"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"admin"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passWord = <span class="string">"admin"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MqttClient <span class="title">connect</span><span class="params">(String clientId)</span> <span class="keyword">throws</span> MqttException </span>&#123;</span><br><span class="line">        MemoryPersistence persistence = <span class="keyword">new</span> MemoryPersistence();</span><br><span class="line">        MqttConnectOptions connOpts = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">        connOpts.setCleanSession(<span class="keyword">false</span>);</span><br><span class="line">        connOpts.setUserName(userName);</span><br><span class="line">        connOpts.setPassword(passWord.toCharArray());</span><br><span class="line">        connOpts.setConnectionTimeout(<span class="number">10</span>);</span><br><span class="line">        connOpts.setKeepAliveInterval(<span class="number">20</span>);</span><br><span class="line">        MqttClient mqttClient = <span class="keyword">new</span> MqttClient(broker, clientId, persistence);</span><br><span class="line">        mqttClient.connect(connOpts);</span><br><span class="line">        <span class="keyword">return</span> mqttClient;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(MqttClient mqttClient, String topic)</span> <span class="keyword">throws</span> MqttException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] Qos = &#123;qos&#125;;</span><br><span class="line">        String[] topics = &#123;topic&#125;;</span><br><span class="line">        mqttClient.subscribe(topics, Qos, <span class="keyword">new</span> IMqttMessageListener[]&#123;(s, mqttMessage) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"收到新消息"</span> + s + <span class="string">" &gt; "</span> + mqttMessage.toString());</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runsub</span><span class="params">(String clientId, String topic)</span> <span class="keyword">throws</span> MqttException </span>&#123;</span><br><span class="line">        MqttClient mqttClient = connect(clientId);</span><br><span class="line">        <span class="keyword">if</span> (mqttClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sub(mqttClient, topic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MqttException </span>&#123;</span><br><span class="line">        runsub(<span class="string">"consumer-client-id-1"</span>, <span class="string">"x/y/z"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AUTO协议"><a href="#AUTO协议" class="headerlink" title="AUTO协议"></a>AUTO协议</h3><p>AUTO自动检测协议,可以自动检测ActiveMQ支持的所有协议, 允许使用各种协议的客户端,使用同一个传输</p><h3 id="Stomp协议"><a href="#Stomp协议" class="headerlink" title="Stomp协议"></a>Stomp协议</h3><p>可以使用webSocket传输协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ支持的协议&quot;&gt;&lt;a href=&quot;#ActiveMQ支持的协议&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ支持的协议&quot;&gt;&lt;/a&gt;ActiveMQ支持的协议&lt;/h2&gt;&lt;p&gt;ActiveMQ支持多种协议传输和传输方式,允许客户
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="ActiveMQ" scheme="https://yimchengjie.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>深入理解SpringAOP</title>
    <link href="https://yimchengjie.github.io/2019/07/21/JavaWeb%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/"/>
    <id>https://yimchengjie.github.io/2019/07/21/JavaWeb框架/深入理解SpringAOP/</id>
    <published>2019-07-21T13:30:45.000Z</published>
    <updated>2019-12-26T09:12:34.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解-SpringAOP"><a href="#深入理解-SpringAOP" class="headerlink" title="深入理解 SpringAOP"></a>深入理解 SpringAOP</h2><p>AOP 是指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式</p><p>SpringAOP 的底层其实就是动态代理</p><h3 id="Spring-是如何使用动态代理的"><a href="#Spring-是如何使用动态代理的" class="headerlink" title="Spring 是如何使用动态代理的"></a>Spring 是如何使用动态代理的</h3><ol><li>将业务组件和切面组件添加到容器中,</li><li>创建对象的时候, 根据切入点表达式拦截的类, 加入通知,生成代理对象.</li><li>如果目标对象有实现接口就用 JDK 代理, 反之就用 CGLIB 代理.</li></ol><h3 id="SpringAOP-注解驱动原理"><a href="#SpringAOP-注解驱动原理" class="headerlink" title="SpringAOP 注解驱动原理"></a>SpringAOP 注解驱动原理</h3><p>IoC容器启动中,创建了哪些和AOP有关的组件? 这些组件什么时候工作? 工作内容是什么?</p><h4 id="1-实现入口-EnableAspectJAutoProxy"><a href="#1-实现入口-EnableAspectJAutoProxy" class="headerlink" title="1. 实现入口@EnableAspectJAutoProxy"></a>1. 实现入口@EnableAspectJAutoProxy</h4><p>主要工作:</p><ul><li>@Import(AspectJAutoProxyRegistrar.class)给容器导入 <code>AspectJAutoProxyRegistrar</code> 组件(切面自动代理注册器)</li><li>利用 AspectJAutoProxyRegistrar 给容器中注册一个切面相关的 bean<code>AnnotationAwareAspectJAutoProxyCreator</code>(支持注解的 AspectJ 自动代理创建器)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *代码跟进演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//出发点</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">//跟进</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AspectJAutoProxyRegistrar.class&#125;)</span><br><span class="line"><span class="comment">//点进AspectJAutoProxyRegistrar</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"><span class="comment">//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary方法</span></span><br><span class="line"><span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary</span></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line"><span class="comment">//点进AnnotationAwareAspectJAutoProxyCreator</span></span><br></pre></td></tr></table></figure><h4 id="2-AnnotationAwareAspectJAutoProxyCreator-创建过程"><a href="#2-AnnotationAwareAspectJAutoProxyCreator-创建过程" class="headerlink" title="2. AnnotationAwareAspectJAutoProxyCreator 创建过程"></a>2. AnnotationAwareAspectJAutoProxyCreator 创建过程</h4><p><img src="/2019/07/21/JavaWeb%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/AnnotationAwareAspectJAutoProxyCreator%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="AnnotationAwareAspectJAutoProxyCreator继承关系"></p><p>主要关注的是它继承了BeanFactoryAware和BeanPostProcessor接口,</p><p>所以它的创建是在BeanFactory进行初始化,注册BeanPostProcessor阶段(也就是BeanFactoryPostProcessor注册完成之后)</p><p>registerBeanPostProcessors(beanFactory);注册 BeanPostProcessor 来处理拦截 bean 的创建(在bean创建前后执行)；</p><ol><li>先获取 IOC 容器已经定义的需要创建对象的所有 BeanPostProcessor</li><li>注册 BeanPostProcessor,实际上就是创建 BeanPostProcessor 对象，保存在容器中；<br>创建 internalAutoProxyCreator 的 BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】<ol><li>创建 Bean 的实例</li><li>populateBean；给 bean 的各种属性赋值</li><li>initializeBean</li><li>invokeAwareMethods()：处理 Aware 接口的方法回调</li><li>applyBeanPostProcessorsBeforeInitialization();应用后置处理器的 postProcessBeforeInitialization();</li><li>invokeInitMethods()；执行自定义的初始化方法</li><li>applyBeanPostProcessorsAfterInitialization()；执行后置处理器的 postProcessAfterInitialization();</li><li>BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–》aspectJAdvisorsBuilder</li></ol></li><li>把 BeanPostProcessor 注册到 BeanFactory 中；<br>beanFactory.addBeanPostProcessor(postProcessor);</li></ol><h4 id="3-起作用阶段"><a href="#3-起作用阶段" class="headerlink" title="3. 起作用阶段"></a>3. 起作用阶段</h4><p>BeanPostProcessor是在bean实例化前后起作用的, 所以它的执行是在beanFactroy对bean实例化的阶段进行</p><p>finishBeanFactoryInitialization(beanFactory);实例化所有单例 bean</p><ol><li>遍历所有Bean,依次创建对象,使用getBean(beanName);方法</li><li>创建bean<ol><li>先看看容器中是否存在bean,如果存在直接使用,没有再创建</li><li>创建bean;<ol><li>resolveBeforeInstantiation解析,如果能返回一个代理对象则直接用,不能继续</li><li>createBean<ol><li>拿到所有BeanPostProcessor并执行postProcessBeforeInstantiation</li><li>doCreateBean真正的创建bean</li><li>创建完,执行</li></ol></li></ol></li></ol></li></ol><h4 id="4-AnnotationAwareAspectJAutoProxyCreator的作用"><a href="#4-AnnotationAwareAspectJAutoProxyCreator的作用" class="headerlink" title="4. AnnotationAwareAspectJAutoProxyCreator的作用"></a>4. AnnotationAwareAspectJAutoProxyCreator的作用</h4><h5 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h5><p>每一个bean创建之前,调用postProcessBeforeInstantiation</p><p>前提: 容器加载了@AspectJ注解的类,并加载了信息,再匹配切入点表达式与哪些类、方法匹配</p><ol><li>判断当前的bean是否在advisedBeans中(里面保存了所有需要增强的bean)</li><li>判断当前bean是否Advice、Pointcut、Advisor、AopInfrastructureBean、被@Aspect注解的类型 或者是设置了跳过自动代理</li><li>是否配置了跳过通知</li></ol><h5 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h5><p>前提：bean实例化完成</p><ol><li>获取bean的所有通知器</li><li>找到当前bean所匹配的通知器</li><li>对通知器进行优先级排序</li><li>将通知器存入adviseBeans</li><li>如果当前的bean需要注入切面,创建bean的代理对象(jdk代理或者cglib代理)</li><li>向容器返回增强后的代理对象</li></ol><h4 id="代理对象如何工作"><a href="#代理对象如何工作" class="headerlink" title="代理对象如何工作"></a>代理对象如何工作</h4><p>容器中保存了基础组件的代理对象</p><ol><li>拦截器拦截目标方法的执行</li><li>根据ProxyFactory对象获取将要执行的目标方法的增强器链</li><li>以任务栏的形式执行通知和目标方法</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>@EnableAspectJAutoProxy</code> 开启AOP功能<br>会在容器启动阶段注册一个组件 <code>AnnotationAwareAspectJAutoProxyCreator</code></li><li>容器开始创建</li><li>容器注册后置处理器;<br><code>AnnotationAwareAspectJAutoProxyCreator</code> 继承了后置处理器接口. 被创建并注册进容器</li><li>容器开始创建bean;<ol><li>创建业务逻辑bean;和切面bean</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>拦截组件创建,如果有已代理对象,直接返回</li><li>组件创建</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>执行postProcessBeforeInstantiation,给需要增强bean创建代理对象<br>获取目标对象以及advisor(增强器,切面的通知方法) 创建代理</li></ol></li><li>执行目标方法<ol><li>CglibAopProxy.intercept();拦截</li><li>执行通知任务链和目标方法</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入理解-SpringAOP&quot;&gt;&lt;a href=&quot;#深入理解-SpringAOP&quot; class=&quot;headerlink&quot; title=&quot;深入理解 SpringAOP&quot;&gt;&lt;/a&gt;深入理解 SpringAOP&lt;/h2&gt;&lt;p&gt;AOP 是指在程序运行期间动态的将某段代码切
      
    
    </summary>
    
    
      <category term="JavaWeb框架" scheme="https://yimchengjie.github.io/categories/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaWeb框架" scheme="https://yimchengjie.github.io/tags/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yimchengjie.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringIoC详解</title>
    <link href="https://yimchengjie.github.io/2019/07/10/JavaWeb%E6%A1%86%E6%9E%B6/SpringIoC%E8%AF%A6%E8%A7%A3/"/>
    <id>https://yimchengjie.github.io/2019/07/10/JavaWeb框架/SpringIoC详解/</id>
    <published>2019-07-10T08:30:45.000Z</published>
    <updated>2019-12-26T09:12:31.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringIoC详解"><a href="#SpringIoC详解" class="headerlink" title="SpringIoC详解"></a>SpringIoC详解</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>对于SpringIoC来说,最重要的就是容器了,容器管理这所有的Bean,控制这Bean的依赖注入</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>早期基础容器, 可以理解成一个HashMap,key是BeanName,value是Bean实例.</p><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>应用上下午,高级容器,相比BeanFactory功能全面很多</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>Bean对象在Spring中是以BeanDefinition来描述的</p><p>Bean的解析主要就是对配置文件或者配置类的解析</p><h3 id="SpringIoC注解驱动初始化过程"><a href="#SpringIoC注解驱动初始化过程" class="headerlink" title="SpringIoC注解驱动初始化过程"></a>SpringIoC注解驱动初始化过程</h3><p>SpringIoC的初始化过程也是ApplicationContext容器的初始化过程</p><p>入口:<code>AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);</code></p><ol><li><p>调用AnnotationConfigApplicationContext构造函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先执行父类构造方法,再执行本类无参构造方法</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 2. 注册带注解的类</span></span><br><span class="line">    <span class="keyword">this</span>.register(annotatedClasses);</span><br><span class="line">    <span class="comment">// 3. 更新容器</span></span><br><span class="line">    <span class="keyword">this</span>.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this(); 默认先调用父类无参构造函数,构建初始对象<strong>DefaultListableBeanFactory</strong>,最基础的BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.customClassLoader = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">this</span>.refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">     <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>再调用当前类this();创建读取器和扫描器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//BeanDefinition解析器; 用来解析带注解的bean</span></span><br><span class="line">     <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">//ClassPath下的BeanDefinition的扫描器(用来扫描类)</span></span><br><span class="line">     <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建注解模式下的BeanDefinition解析器AnnotatedBeanDefinitionReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// BeanName产生器</span></span><br><span class="line">     <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">     <span class="comment">// 作用域元数据解析器</span></span><br><span class="line">     <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">     Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">     <span class="keyword">this</span>.registry = registry;</span><br><span class="line">     <span class="comment">// @Conditionl条件表达式鉴别器</span></span><br><span class="line">     <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, (ResourceLoader)<span class="keyword">null</span>);</span><br><span class="line">     AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">     DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">     <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">             beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">             beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet(<span class="number">4</span>);</span><br><span class="line">     RootBeanDefinition def;</span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册主配置类的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理@Autowired注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理@Required注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理JSR规范注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册处理jpa的后置处理器</span></span><br><span class="line">     <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             def.setBeanClass(ClassUtils.forName(<span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>, AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassNotFoundException var6) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot load optional framework class: org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>, var6);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册处理事件监听方法的处理器</span></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册事件监听工厂</span></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//完成spring自身的后置处理器注册</span></span><br><span class="line">     <span class="comment">//到这一步, BeanDefinitionMap中已经保存了一些spring自带的后置处理器的定义信息了</span></span><br><span class="line">     <span class="keyword">return</span> beanDefs;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建ClassPath下的BeanDefinition的扫描器ClassPathBeanDefinitionScanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters, Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.beanDefinitionDefaults = <span class="keyword">new</span> BeanDefinitionDefaults();</span><br><span class="line">     <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">     <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">     <span class="keyword">this</span>.includeAnnotationConfig = <span class="keyword">true</span>;</span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">     <span class="comment">//设置加载BeanDefinition的注册器</span></span><br><span class="line">     <span class="keyword">this</span>.registry = registry;</span><br><span class="line">     <span class="comment">//是否使用默认的过滤规则</span></span><br><span class="line">     <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">         <span class="keyword">this</span>.registerDefaultFilters();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//设置环境</span></span><br><span class="line">     <span class="keyword">this</span>.setEnvironment(environment);</span><br><span class="line">     <span class="comment">//设置资源加载器</span></span><br><span class="line">     <span class="keyword">this</span>.setResourceLoader(resourceLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进this.registerDefaultFilters();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 向includeFilters中添加所有@Component注解的类(其他的一些Bean注解也都有@Component)</span></span><br><span class="line">     <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">     ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl), <span class="keyword">false</span>));</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="function">AnnotationTypeFil        <span class="title">ter</span><span class="params">(ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)</span>, <span class="keyword">false</span>))</span>;</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>注册Bean配置类register(annotatedClasses)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, String name, Class... qualifiers)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将Bean配置信息转换成AnnotatedGenericBeanDefinition  注解通用BeanDefinition</span></span><br><span class="line">     AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">     <span class="comment">// 判断@Conditionl条件是否有跳过注册的</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">         <span class="comment">// 解析@Scope作用域, 没有则默认Singleton</span></span><br><span class="line">         ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">         <span class="comment">// 将作用域信息添加到BeanDefinition</span></span><br><span class="line">         abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">         <span class="comment">// 设置beanName</span></span><br><span class="line">         String beanName = name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry);</span><br><span class="line">         AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">         <span class="comment">// 解析@Qualifier</span></span><br><span class="line">         <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Class[] var7 = qualifiers;</span><br><span class="line">             <span class="keyword">int</span> var8 = qualifiers.length;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> var9 = <span class="number">0</span>; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">                 Class&lt;? extends Annotation&gt; qualifier = var7[var9];</span><br><span class="line">                 <span class="comment">// 如果有@Primary注解,向BeanDefinition中写入首选bean</span></span><br><span class="line">                 <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">                     abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">                 <span class="comment">// 如果有@Lazy注解, 设置懒加载</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">                     abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 封装一个BeanName和BeanDefinition之间的映射关系</span></span><br><span class="line">         BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">         <span class="comment">// 创建代理对象</span></span><br><span class="line">         definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">         <span class="comment">// 按BeanName将BeanDefinition注册到容器中</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>refresh();  IoC容器启动的核心</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">         <span class="comment">// 1. 刷新上下文之前的准备工作</span></span><br><span class="line">         <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">         <span class="comment">// 2. 获取初始化BeanFactory</span></span><br><span class="line">         ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">         <span class="comment">// 3. 对BeanFactory进行属性填充</span></span><br><span class="line">         <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 4. 模板方法，注册自己添加的BeanPostFactoryProcessor</span></span><br><span class="line">             <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">             <span class="comment">// 5. 执行BeanFactory后置处理器</span></span><br><span class="line">             <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">             <span class="comment">// 6. 注册Bean后置注册器</span></span><br><span class="line">             <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">             <span class="comment">// 7. 初始化国际化资源处理器</span></span><br><span class="line">             <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">             <span class="comment">// 8. 初始化应用事件多播器</span></span><br><span class="line">             <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">             <span class="comment">// 9. 模板方法，调用某些特殊的bean的初始化，springboot中在这个地方启动tomcat</span></span><br><span class="line">             <span class="keyword">this</span>.onRefresh();</span><br><span class="line">             <span class="comment">// 10. 注册监听器到多播器上</span></span><br><span class="line">             <span class="keyword">this</span>.registerListeners();</span><br><span class="line">             <span class="comment">// 11. 实例化所有非懒加载的单例Bean</span></span><br><span class="line">             <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">             <span class="comment">// 12. 初始化容器生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">             <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                 <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">             <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">             <span class="keyword">throw</span> var9;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对代码进行进一步跟进,看看每一步中都做了什么</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1. prepareRefresh()</span></span><br><span class="line"><span class="comment">    1. this.startupDate = System.currentTimeMillis();设置启动时间</span></span><br><span class="line"><span class="comment">    2. initPropertySources();自定义属性设置</span></span><br><span class="line"><span class="comment">    3. getEnvironment().validateRequiredProperties();检验属性的合法性</span></span><br><span class="line"><span class="comment">    4. earlyApplicationEvents = new LinkedHashSet();创建早期应用事件集合</span></span><br><span class="line"><span class="comment"> 2. beanFactory = this.obtainFreshBeanFactory();</span></span><br><span class="line"><span class="comment">    1. this.beanFactory.setSerializationId(this.getId());设置BeanFactoryID</span></span><br><span class="line"><span class="comment"> 3. prepareBeanFactory(beanFactory);</span></span><br><span class="line"><span class="comment">    1. addBeanPostProcessor(new ApplicationContextAwareProcessor(this));添加一个ApplicationContextAwareProcessor</span></span><br><span class="line"><span class="comment">    2. ignoreDependencyInterface(XXX.class); 设置忽略注入的接口实现类</span></span><br><span class="line"><span class="comment">    3. registerResolvableDependency(XXX.class,beanFactory); 注册可解析的注入的组件</span></span><br><span class="line"><span class="comment">    4. 添加编译时的AOP组件</span></span><br><span class="line"><span class="comment">    5. 注册环境组件,系统属性组件,系统环境组件</span></span><br><span class="line"><span class="comment"> 4. postProcessBeanFactory(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 子类重写这个方法,在BeanFactory准备完成创建之前做最后的步骤</span></span><br><span class="line"><span class="comment"> 5. invokeBeanFactoryPostProcessors(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 执行BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       1. 获取所有BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       2. 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       3. 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       4. 最后执行其他的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    2. 执行BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       1. 获取所有BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       2. 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       3. 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       4. 最后执行其他的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> 6. registerBeanPostProcessors(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 获取所有的BeanPostProcessor</span></span><br><span class="line"><span class="comment">    2. 先BeanPostProcessor</span></span><br><span class="line"><span class="comment">    3. 注册MergedBeanDefinitionPostProcessor</span></span><br><span class="line"><span class="comment">    4. 最后创建一个ApplicationListenerDetector;检查是ApplicationListener的bean</span></span><br><span class="line"><span class="comment"> 7. initMessageSource();</span></span><br><span class="line"><span class="comment">    1. 获取BeanFactory</span></span><br><span class="line"><span class="comment">    2. 判断容器中是否有MessageSource的组件</span></span><br><span class="line"><span class="comment">    3. 如果有则取用, 没有则创建DelegatingMessageSource</span></span><br><span class="line"><span class="comment">    4. 将国际化组件祖册到容器</span></span><br><span class="line"><span class="comment"> 8. initApplicationEventMulticaster();</span></span><br><span class="line"><span class="comment">    1. 获取BeanFactory</span></span><br><span class="line"><span class="comment">    2. 判断容器是否有ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">    3. 如果有取用, 没有则创建SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">    4. 将ApplicationEventMulticaster组件添加到BeanFactory</span></span><br><span class="line"><span class="comment"> 9. onRefresh();</span></span><br><span class="line"><span class="comment">    1.  留给子类,子类重写这个方法, 在容器刷新时可以自定义一些逻辑</span></span><br><span class="line"><span class="comment"> 10. registerListeners();</span></span><br><span class="line"><span class="comment">     1.  获取容器中的ApplicationListener</span></span><br><span class="line"><span class="comment">     2.  将所有ApplicationListener添加到ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">     3.  派发早期事件earlyApplicationEvents</span></span><br><span class="line"><span class="comment"> 11. finishBeanFactoryInitialization(beanFactory);</span></span><br><span class="line"><span class="comment">     1.  preInstantiateSingletons;初始化剩下的所有单实例Bean</span></span><br><span class="line"><span class="comment">         1.  获取容器中的单例beanName</span></span><br><span class="line"><span class="comment">         2.  如果beanName对应的bean不是抽象不是懒加载不是多实例的</span></span><br><span class="line"><span class="comment">         3.  getBean(beanName);</span></span><br><span class="line"><span class="comment">         4.  doGetBean(beanName);</span></span><br><span class="line"><span class="comment">         5.  标记要创建bean了,保证线程安全</span></span><br><span class="line"><span class="comment">         6.  getMergedLocalBeanDefinition(beanName);获得BeanDefinition</span></span><br><span class="line"><span class="comment">         7.  getDependsOn();获取依赖</span></span><br><span class="line"><span class="comment">         8.  递归getBean;创建所依赖Bean</span></span><br><span class="line"><span class="comment">         9.  将获取的依赖bean注册到denpendsOn集合</span></span><br><span class="line"><span class="comment">         10. createBean(beanName, ex1, args);创建bean</span></span><br><span class="line"><span class="comment">         11. doCreateBean(beanName, mbdToUse, args);</span></span><br><span class="line"><span class="comment">             1.  createBeanInstance(beanName, mbd, args);</span></span><br><span class="line"><span class="comment">             2.  调用前置处理器</span></span><br><span class="line"><span class="comment">             3.  属性赋值</span></span><br><span class="line"><span class="comment">             4.  执行初始化</span></span><br><span class="line"><span class="comment">             5.  执行后置处理器</span></span><br><span class="line"><span class="comment">             6.  注册bean销毁方法</span></span><br><span class="line"><span class="comment">             7.  添加到单例bean集合</span></span><br><span class="line"><span class="comment"> 12. finishRefresh();</span></span><br><span class="line"><span class="comment">     1.  初始化生命周期有关后置处理器</span></span><br><span class="line"><span class="comment">     2.  执行容器刷新完成事件</span></span><br><span class="line"><span class="comment">     3.  将ApplicationContext注册到视图中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><blockquote><ol><li>Spring容器在启动时,会先加载有关Bean定义信息的配置文件或者配置类(xml注册bean/注解注册bean)</li><li>BeanDefinitionReader将配置文件或者配置类解析成BeanDefinition,并存入容器中BeanDefinitionRegistry</li><li>Spring容器扫描BeanDefinitionRegistry中的所有BeanDefinition,使用BeanFactoryPostProcessor对它们进行加工, 主要是依赖处理和属性赋值</li><li>实例化Bean时,封装Bean然后完成对Bean的属性设置工作</li><li>利用Bean后置处理器,对完成的Bean进行加工</li></ol></blockquote><h5 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h5><ol><li><p>Resource<br>xml、properties资源文件的抽象</p></li><li><p>ResourceLoader<br>资源的加载, 解析xml、properties返回Resource</p></li><li><p>BeanDefinition<br>保存了从配置文件中读取到的bean的各种信息,一个bean对应一个BeanDefinition<br>有beanClass、scope、lazyInit等属性</p></li><li><p>BeanDefinitionReader<br>定义读取组件，从Resource资源中读取出BeanDefinition</p></li><li><p>BeanDefinitionRegistry<br>BeanFactory的实现类需要实现这个接口，所以所有BeanFactory都有注册BeanDefinition的功能<br>其内部维护了一个Map，可以将BeanDefinition和beanName的对应关系添加进去</p></li><li><p>Enviroment<br>环境，保存了程序运行的环境参数（JDK版本，jre等等）</p></li><li><p>BeanFactoryPostProcessor接口<br>BeanFactory后置处理器, 扩展切口, 允许它的实现类在容器初始化前后进行相应操作<br>典型的有PropertyPlaceholderConfigurer,占位符配置处理器</p></li><li><p>Aware接口<br>对于实现了XXXXAware的bean,spring会注入相应的XXXX, 通过重写setXXXX的方法</p></li><li><p>BeanPostProcessor接口<br>允许实现它的bean,在实例化前后做相应操作,在最前最后位置</p></li><li><p>InitializingBean接口<br>允许实现它的bean,在实例化前后做相应操作, 在处理器before之后和after之前</p></li><li><p>DisposableBean接口<br>允许实现它的bean,在摧毁前后做相应操作</p></li><li><p>FactoryBean接口<br>允许实现它的bean,在beanFactory.getBean()获取该bean时, 会调用这个bean中重写的方法getObject,而不是直接返回该bean<br>工厂模式的体现</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringIoC详解&quot;&gt;&lt;a href=&quot;#SpringIoC详解&quot; class=&quot;headerlink&quot; title=&quot;SpringIoC详解&quot;&gt;&lt;/a&gt;SpringIoC详解&lt;/h2&gt;&lt;h3 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="JavaWeb框架" scheme="https://yimchengjie.github.io/categories/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaWeb框架" scheme="https://yimchengjie.github.io/tags/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://yimchengjie.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://yimchengjie.github.io/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yimchengjie.github.io/2019/07/02/设计模式/代理模式/</id>
    <published>2019-07-02T11:35:45.000Z</published>
    <updated>2020-01-03T04:51:06.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p>属于结构型模式</p><p>Proxy-代理模式是指为其他对象提供一种代理,来控制对这个对象的访问</p><p>即对A对象进行代理后, 本来A对象的功能交给代理B来做; 代理就是原实例前后添加一层处理.</p><h3 id="为什么使用代理模式"><a href="#为什么使用代理模式" class="headerlink" title="为什么使用代理模式"></a>为什么使用代理模式</h3><ul><li>授权机制: 不同级别的用户对于同一对象的访问权限是不同的, 要用代理实现对不同用户的访问权限的控制</li><li>某个客户端不能直接操作一个对象, 但又要和那个对象互动, 也要通过代理实现间接互动</li><li>代理类为委托类预处理消息,过滤消息,把消息传递给委托类, 以及事后对返回结果的处理等.</li></ul><h3 id="3种代理模式"><a href="#3种代理模式" class="headerlink" title="3种代理模式"></a>3种代理模式</h3><h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h4><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:创建服务类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:实现服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步:创建代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(<span class="keyword">final</span> UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService=userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备登录"</span>);</span><br><span class="line">        userService.login();</span><br><span class="line">        System.out.println(<span class="string">"登录完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步:测试运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy userServiceProxy=<span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理可以做到符合开闭原则的对目标对象进行功能扩展, 但是工作量大, 要给每个对象创建代理类, 而且不易管理, 接口发生改变, 代理类也要改变</p><h4 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2. JDK动态代理"></a>2. JDK动态代理</h4><p>动态代理中, 不需要手动创建代理类了, 只要编写一个动态处理器就OK了</p><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:编写动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] agrs)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">        Object result=method.invoke(Object,args);</span><br><span class="line">        System.out.println(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:编写测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService userServiceProxy=(UserService)Proxy.newProxyInstnce(UserService.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;UserService.class&#125;,<span class="keyword">new</span> DynamicProxyHandler(userService));</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-CGLIB代理"><a href="#3-CGLIB代理" class="headerlink" title="3. CGLIB代理"></a>3. CGLIB代理</h4><p>JDK实现动态代理需要实现类通过接口定义业务的方法, 对于没有接口的类就不能实现代理.这就需要CGLIB了</p><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:创建CGLIB代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object</span></span></span><br><span class="line"><span class="function"><span class="params">    target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(This.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args,MeyhodProxy methodProxy)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">        Object result=method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:创建测试类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        CglibProxy cglibProxy=<span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserService userServiceProxy=(UserService)cglibProxy.getInstance(userService1;)</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLIB代理比JDK代理的性能更高,但是CGLIB比JDK创建代理的耗时要更高,所以单例对象CGLIB更合适, 反之JDK更合适.</p><p><img src="/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="CGLIB动态代理执行流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式-Proxy&quot;&gt;&lt;a href=&quot;#代理模式-Proxy&quot; class=&quot;headerlink&quot; title=&quot;代理模式(Proxy)&quot;&gt;&lt;/a&gt;代理模式(Proxy)&lt;/h2&gt;&lt;p&gt;属于结构型模式&lt;/p&gt;
&lt;p&gt;Proxy-代理模式是指为其他对象提供一种
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ入门</title>
    <link href="https://yimchengjie.github.io/2019/06/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://yimchengjie.github.io/2019/06/30/消息中间件/ActiveMQ入门/</id>
    <published>2019-06-30T14:10:45.000Z</published>
    <updated>2019-12-31T09:12:58.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ入门"><a href="#ActiveMQ入门" class="headerlink" title="ActiveMQ入门"></a>ActiveMQ入门</h2><p>ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现<br>尽管JMS已经出台很久, 但在J2EE中仍然扮演者重要角色</p><h3 id="ActiveMQ特性"><a href="#ActiveMQ特性" class="headerlink" title="ActiveMQ特性"></a>ActiveMQ特性</h3><ol><li>支持多种编程语言</li><li>支持多种传输协议</li><li>支持多种持久化方式(文件系统/数据库)</li></ol><h3 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h3><ol><li>从官网下载ActiveMQ</li><li>利用Xftp将文件传到服务器</li><li>解压到<code>/var</code>目录下</li><li>修改文件名为<code>activemq</code></li></ol><h3 id="ActiveMQ启动"><a href="#ActiveMQ启动" class="headerlink" title="ActiveMQ启动"></a>ActiveMQ启动</h3><p>在activemq文件下使用命令<code>./bin/activemq start</code> 后台启动ActiveMQ</p><p>但最好是将ActiveMQ作为一个服务来启动,这样可以使activemq在系统启动时自动启动</p><h4 id="创建ActiveMQ服务"><a href="#创建ActiveMQ服务" class="headerlink" title="创建ActiveMQ服务"></a>创建ActiveMQ服务</h4><ol><li><p>使用vim创建一个服务文件<br><code>vi /usr/lib/systemd/system/activemq.service</code></p></li><li><p>输入内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ActiveMQ service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/var/activemq/bin/activemq start</span><br><span class="line">ExecStop=/var/activemq/bin/activemq stop</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=9</span><br><span class="line">StandardOutput=syslog</span><br><span class="line">StandardError=syslog</span><br><span class="line">SyslogIdentifier=activemq</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>修改<code>/var/activemq/bin/env</code>文件<br> 将JAVA_HOME的注释删除,然后填入系统jdk的安装路径</p></li><li><p>启动ActiveMQ服务<br> 使用<code>systemctl start activemq</code>来启动服务</p></li><li><p>查看服务状态<br> 使用命令<code>systemctl status activemq</code></p></li><li><p>设置开机自动启动<br> <code>ln -s /usr/lib/systemd/system/activemq.service/etc/systemd/system/multi-user.target.wants/activemq.service</code><br> <code>systemctl enable activemq</code></p></li><li><p>在防火墙添加ActiveMQ的Web管理端口和通讯端口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Web管理端口默认为8161,通讯端口默认为61616</span><br><span class="line">ufw allow 8161</span><br><span class="line">ufw allow 61616</span><br><span class="line"># 部分服务器需要在对应的服务提供商管理页面修改出入站规则</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问<code>http://服务IP:8161/admin</code>进入管理平台<br>账户默认:admin<br>密码默认:admin</p></li></ol><h4 id="Web管理平台配置"><a href="#Web管理平台配置" class="headerlink" title="Web管理平台配置"></a>Web管理平台配置</h4><p>ActiveMQ的Web管理平台是基于jetty运行,因此在/var/activemq/conf目录可以查看jetty的配置文件</p><p>在<code>/var/activemq/conf/jetty.xml</code>文件中,可以进行修改端口,密码等内容</p><h3 id="使用ActiveMQ"><a href="#使用ActiveMQ" class="headerlink" title="使用ActiveMQ"></a>使用ActiveMQ</h3><p>在Java中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProducerThread(<span class="string">"tcp://119.3.218.159:61616"</span>, <span class="string">"queue1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        String brokerUrl;</span><br><span class="line">        String destinationUrl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// brokerUrl中间件url地址, destinationUrl队列url</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProducerThread</span><span class="params">(String brokerUrl, String destinationUrl)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerUrl = brokerUrl;</span><br><span class="line">            <span class="keyword">this</span>.destinationUrl = destinationUrl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ActiveMQConnectionFactory connectionFactory;</span><br><span class="line">            Connection conn;</span><br><span class="line">            Session session;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1、创建连接工厂</span></span><br><span class="line">                connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(brokerUrl);</span><br><span class="line">                <span class="comment">// 2、创建连接对象md</span></span><br><span class="line">                conn = connectionFactory.createConnection();</span><br><span class="line">                conn.start();</span><br><span class="line">                <span class="comment">// 3、创建会话</span></span><br><span class="line">                session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">                <span class="comment">// 4、创建点对点发送的目标</span></span><br><span class="line">                Destination destination = session.createQueue(destinationUrl);</span><br><span class="line">                <span class="comment">// 5、创建生产者消息</span></span><br><span class="line">                MessageProducer producer = session.createProducer(destination);</span><br><span class="line">                <span class="comment">// 设置生产者的模式，有两种可选 持久化 / 不持久化</span></span><br><span class="line">                producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br><span class="line">                <span class="comment">// 6、创建一条文本消息</span></span><br><span class="line">                String text = <span class="string">"Hello world!"</span>;</span><br><span class="line">                TextMessage message = session.createTextMessage(text);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 7、发送消息</span></span><br><span class="line">                    producer.send(message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 8、 关闭连接</span></span><br><span class="line">                session.close();</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// http://activemq.apache.org/consumer-features.html</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ConsumerThread(<span class="string">"tcp://119.3.218.159:61616"</span>, <span class="string">"queue1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ConsumerThread(<span class="string">"tcp://119.3.218.159:61616"</span>, <span class="string">"queue1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String brokerUrl;</span><br><span class="line">        String destinationUrl;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(String brokerUrl, String destinationUrl)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerUrl = brokerUrl;</span><br><span class="line">            <span class="keyword">this</span>.destinationUrl = destinationUrl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ActiveMQConnectionFactory connectionFactory;</span><br><span class="line">            Connection conn;</span><br><span class="line">            Session session;</span><br><span class="line">            MessageConsumer consumer;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// brokerURL http://activemq.apache.org/connection-configuration-uri.html</span></span><br><span class="line">                <span class="comment">// 1、创建连接工厂</span></span><br><span class="line">                connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="keyword">this</span>.brokerUrl);</span><br><span class="line">                <span class="comment">// 2、创建连接对象</span></span><br><span class="line">                conn = connectionFactory.createConnection();</span><br><span class="line">                conn.start(); <span class="comment">// 一定要启动</span></span><br><span class="line">                <span class="comment">// 3、创建会话（可以创建一个或者多个session）</span></span><br><span class="line">                session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">                <span class="comment">// 4、创建点对点接收的目标，queue - 点对点</span></span><br><span class="line">                Destination destination = session.createQueue(destinationUrl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5、创建消费者消息 http://activemq.apache.org/destination-options.html</span></span><br><span class="line">                consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6、接收消息(没有消息就持续等待)</span></span><br><span class="line">                Message message = consumer.receive();</span><br><span class="line">                <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"收到文本消息："</span> + ((TextMessage) message).getText());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                consumer.close();</span><br><span class="line">                session.close();</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-broker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>geronimo-jms_1.1_spec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.apache.geronimo.specs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="web控制台"><a href="#web控制台" class="headerlink" title="web控制台"></a>web控制台</h3><p>activemq支持web控制台<br><code>http://host:8161/admin</code> 默认账号admin,密码admin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ入门&quot;&gt;&lt;a href=&quot;#ActiveMQ入门&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ入门&quot;&gt;&lt;/a&gt;ActiveMQ入门&lt;/h2&gt;&lt;p&gt;ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="ActiveMQ" scheme="https://yimchengjie.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="https://yimchengjie.github.io/2019/06/27/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8CPU100%25%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://yimchengjie.github.io/2019/06/27/Java系统调优/内存爆炸CPU100%问题分析/</id>
    <published>2019-06-27T13:36:45.000Z</published>
    <updated>2019-12-22T06:45:07.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存爆炸和CPU100-问题分析"><a href="#内存爆炸和CPU100-问题分析" class="headerlink" title="内存爆炸和CPU100%问题分析"></a>内存爆炸和CPU100%问题分析</h2><p>当线上的系统突然请求缓慢, CPU100%, 内存占用巨大, 当JVM出现问题时,应该如何排查问题呢</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>登录服务器, 使用<code>top</code>命令查看系统资源使用情况<br>一般出问题时java程序的占用是最高的</p></li><li><p>找到CPU或者内存占用高的java进程PID, 使用命令<code>top -Hp 进程ID</code>, <strong>查询该进程中线程的运行情况</strong></p></li><li><p>使用<code>printf &quot;%x\n&quot; 线程ID</code><strong>查看线程PID的16进制</strong>形式<br> 因为在java日志中记录的PID是16进制的形式</p></li><li><p><code>jstack 进程ID &gt; ./threadDump.log</code> <strong>打印JVM堆栈信息</strong>到文件threadDump.log中<br>在该堆栈信息文件中,找到第3步的线程, 查看具体信息</p></li><li><p>使用<code>jstat -gcutil 进程号 统计间隔时间 统计次数</code><strong>查看GC的变化情况</strong>, 当发现<code>FGC</code>的值一直增大时, 继续使用<code>jmap -heap 进程ID</code> 查看进程堆内存的情况, 特别是老年代的使用情况.<br>老年代内存占用达到阈值时就会触发Full GC</p></li><li><p><code>jmap -dump:format=b,file=filename 进程ID</code> ,导出Java进程下内存堆到文件中, 再把内存镜像dump文件传到本地, 利用工具进行分析<br>可以使用<code>jhat</code>、<code>VisualVM</code>等工具分析dump文件</p></li></ol><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h4 id="Full-GC次数过多"><a href="#Full-GC次数过多" class="headerlink" title="Full GC次数过多"></a>Full GC次数过多</h4><ol><li>jstat命令发现GC次数很多,并且不断增加</li><li>分析dump文件,查看具体对象的内存占用情况<br>如果内存占用情况不多, 说明代码中频繁使用了System.gc()</li></ol><h4 id="代码中消耗CPU的操作太多"><a href="#代码中消耗CPU的操作太多" class="headerlink" title="代码中消耗CPU的操作太多"></a>代码中消耗CPU的操作太多</h4><p>比如复杂的算法,递归的循环等,甚至是代码BUG</p><h4 id="锁的使用不正确-造成死锁"><a href="#锁的使用不正确-造成死锁" class="headerlink" title="锁的使用不正确, 造成死锁"></a>锁的使用不正确, 造成死锁</h4><p>分析JVM堆栈信息,看是否有死锁deadlock</p><h4 id="不定期的接口耗时现象"><a href="#不定期的接口耗时现象" class="headerlink" title="不定期的接口耗时现象"></a>不定期的接口耗时现象</h4><p>这主要是因为不定期的高并发带来的问题, 要通过压测工具不断加大访问力度, 发现某个接口某个位置响应缓慢, 再查看堆栈日志, 发现大量线程被阻塞在同一位置, 就能查到我们哪个业务代码出了问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存爆炸和CPU100-问题分析&quot;&gt;&lt;a href=&quot;#内存爆炸和CPU100-问题分析&quot; class=&quot;headerlink&quot; title=&quot;内存爆炸和CPU100%问题分析&quot;&gt;&lt;/a&gt;内存爆炸和CPU100%问题分析&lt;/h2&gt;&lt;p&gt;当线上的系统突然请求缓慢, 
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://yimchengjie.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://yimchengjie.github.io/tags/Java/"/>
    
      <category term="JDK" scheme="https://yimchengjie.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>分布式消息中间件</title>
    <link href="https://yimchengjie.github.io/2019/06/27/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://yimchengjie.github.io/2019/06/27/消息中间件/分布式消息中间件/</id>
    <published>2019-06-27T13:36:45.000Z</published>
    <updated>2019-12-31T08:24:25.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h2><p><strong>生产者</strong>(客户端)–发送消息–&gt;<strong>消息中间件</strong>–分发消息–&gt;<strong>消费者</strong>(服务器)</p><h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><ol><li>利用高效可靠的消息传递机制进行平台无关的数据交互;<br> 把用户消息暂存到消息中间件, 消息中间件在把消息分发到对应分布式模块</li><li>基于数据通信来集成分布式系统<br> 分布式系统之间完全通过数据来连接,后台系统之间不需要接口调用</li><li>通过提供消息传递和消息队列模型, 它可以在分布式环境下扩展进程间的通信<br> 跨系统跨进程通信</li></ol><h4 id="消息中间件的应用场景"><a href="#消息中间件的应用场景" class="headerlink" title="消息中间件的应用场景"></a>消息中间件的应用场景</h4><p>跨系统数据传递、高并发流量削峰填谷、数据异步处理…等等</p><h4 id="常用的消息中间件"><a href="#常用的消息中间件" class="headerlink" title="常用的消息中间件"></a>常用的消息中间件</h4><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ</p><h3 id="消息中间件的核心设计"><a href="#消息中间件的核心设计" class="headerlink" title="消息中间件的核心设计"></a>消息中间件的核心设计</h3><h4 id="消息中间件的本质"><a href="#消息中间件的本质" class="headerlink" title="消息中间件的本质"></a>消息中间件的本质</h4><p>一种具备<strong>接收请求、保存数据、发送数据</strong>等功能的网络应用；和一般网络应用的区别是它主要负责数据的接收和传递，所以性能一般高于普通程序</p><h4 id="消息中间件的5大核心组成"><a href="#消息中间件的5大核心组成" class="headerlink" title="消息中间件的5大核心组成"></a>消息中间件的5大核心组成</h4><h5 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h5><p>计算机之间通信共同遵循的一组约定<br>协议三要素:</p><ol><li>语法</li><li>语义</li><li>时序</li></ol><p><strong>消息中间件常用的协议:</strong> OpenWire、AMQP、MQTT、Kafka、OpenMessage(由国内发起)</p><h5 id="2-持久化机制"><a href="#2-持久化机制" class="headerlink" title="2. 持久化机制"></a>2. 持久化机制</h5><p>简单来说就是将数据存入磁盘,而不是在内存中,不会因为服务器宕机而丢失数据,能够让数据永久保存就叫持久化</p><p>常用持久化方式就是文件系统</p><h5 id="3-消息分发机制"><a href="#3-消息分发机制" class="headerlink" title="3. 消息分发机制"></a>3. 消息分发机制</h5><p>为什么要有消息分发策略</p><ol><li>消息要被特定的系统接收到, 其他的系统不需要接收</li><li>试错机制:后台出错,需要重新发送消息</li></ol><p>要解决的问题:</p><ol><li>消息传递是推还是拉</li><li>是主动分发还是轮询分发</li><li>有无重发功能</li></ol><h5 id="4-高可用设计"><a href="#4-高可用设计" class="headerlink" title="4. 高可用设计"></a>4. 高可用设计</h5><p>指服务可用性,保持能够使用的状态, 避免服务中断.消息中间件可以使用集群部署, 来达到高可用</p><p>分布式消息中间件实现方式:</p><ol><li>Master-Slave主从共享数据<br>服务器共用同一份数据</li><li>Master-Slave主从同步部署方式<br>主服务器同步数据到所有服务器</li><li>Broker-Cluster多主集群同步<br>所有服务器都可以进行同步数据</li><li>Broker-Cluster多主集群转发<br>只同步数据信息,不同步数据内容, 服务器将请求转发给存有消息内容的服务器</li><li>Master-Slave与Broker-Cluster结合<br>分区同步数据</li></ol><h5 id="5-高可靠设计"><a href="#5-高可靠设计" class="headerlink" title="5. 高可靠设计"></a>5. 高可靠设计</h5><p>消息传输可靠:通过协议保证系统数据解析的正确性<br>消息存储可靠:通过持久化保证存储消息的可靠性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式消息中间件&quot;&gt;&lt;a href=&quot;#分布式消息中间件&quot; class=&quot;headerlink&quot; title=&quot;分布式消息中间件&quot;&gt;&lt;/a&gt;分布式消息中间件&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;生产者&lt;/strong&gt;(客户端)–发送消息–&amp;gt;&lt;strong&gt;消息中
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="https://yimchengjie.github.io/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <id>https://yimchengjie.github.io/2019/06/18/Java系统调优/JDK内置命令工具/</id>
    <published>2019-06-18T06:56:05.000Z</published>
    <updated>2019-12-19T11:09:06.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK内置命令工具"><a href="#JDK内置命令工具" class="headerlink" title="JDK内置命令工具"></a>JDK内置命令工具</h2><h3 id="javap命令"><a href="#javap命令" class="headerlink" title="javap命令"></a>javap命令</h3><p>java反编译工具, 主要用于根据Java字节码文件反汇编为Java源代码文件.</p><h3 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h3><p>显示当前所有java进程pid的命令</p><h3 id="jstat命令"><a href="#jstat命令" class="headerlink" title="jstat命令"></a>jstat命令</h3><p>监视Java虚拟机统计信息</p><h3 id="jcmd命令"><a href="#jcmd命令" class="headerlink" title="jcmd命令"></a>jcmd命令</h3><p>可以替代jps工具查看本地的jvm信息</p><h3 id="jinfo命令"><a href="#jinfo命令" class="headerlink" title="jinfo命令"></a>jinfo命令</h3><p>可以查看运行中的jvm的全部参数, 还可以设置部分参数</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>分析java堆的命令,可以将堆中的对象以html的形式展现出来,支持对象查询语言SQL</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>打印出java进程内存中对象的情况,或者将JVM中的堆,以二进制输出成文本</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于打印出给定的java进程ID或core file或远程调试服务的堆栈信息, 如果在64位机器, 需要指定选项<code>-J-d64</code></p><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h3><p>可视化的监视管理控制台</p><h3 id="JvisualVM"><a href="#JvisualVM" class="headerlink" title="JvisualVM"></a>JvisualVM</h3><p>可视化的JVM监控工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK内置命令工具&quot;&gt;&lt;a href=&quot;#JDK内置命令工具&quot; class=&quot;headerlink&quot; title=&quot;JDK内置命令工具&quot;&gt;&lt;/a&gt;JDK内置命令工具&lt;/h2&gt;&lt;h3 id=&quot;javap命令&quot;&gt;&lt;a href=&quot;#javap命令&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://yimchengjie.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://yimchengjie.github.io/tags/Java/"/>
    
      <category term="JDK" scheme="https://yimchengjie.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数以及调优</title>
    <link href="https://yimchengjie.github.io/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
    <id>https://yimchengjie.github.io/2019/06/18/Java系统调优/JVM参数以及调优/</id>
    <published>2019-06-18T06:56:05.000Z</published>
    <updated>2019-12-20T06:17:18.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM参数以及调优"><a href="#JVM参数以及调优" class="headerlink" title="JVM参数以及调优"></a>JVM参数以及调优</h2><h3 id="JVM调优基本概念"><a href="#JVM调优基本概念" class="headerlink" title="JVM调优基本概念"></a>JVM调优基本概念</h3><ol><li>堆大小调整</li><li>垃圾收集器调整</li><li>JIT编译器</li></ol><p>大多数调优选项都与调整堆大小和根据情况选择最合适的垃圾收集器有关.</p><h4 id="调优的主要目标"><a href="#调优的主要目标" class="headerlink" title="调优的主要目标"></a>调优的主要目标</h4><p><strong>响应性:</strong> 应用程序或系统对请求的数据进行响应的速度, 对于响应性要求高的程序,重点是在短时间内做出回应, 不接受长暂停.</p><p><strong>吞吐量:</strong> 侧重于在特定时间段内最大化应用程序的工作量. 高暂停是可接受的.</p><p><strong>系统瓶颈核心还是在应用代码, 一般情况下无需过多调优, JVM本身在不断优化.</strong></p><h3 id="GC调优思路"><a href="#GC调优思路" class="headerlink" title="GC调优思路"></a>GC调优思路</h3><ol><li>分析场景</li><li>确定目标<br>内存占用、低延时、吞吐量</li><li>收集日志<br>通过参数配置收集GC日志; 通过JVM分析GC状态看GC状态</li><li>分析日志<br>使用工具辅助分析日志, 查看GC次数, GC时间</li><li>调整参数<br>切换垃圾收集器或者调整垃圾收集器参数</li></ol><h4 id="通用GC参数"><a href="#通用GC参数" class="headerlink" title="通用GC参数"></a>通用GC参数</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM参数以及调优&quot;&gt;&lt;a href=&quot;#JVM参数以及调优&quot; class=&quot;headerlink&quot; title=&quot;JVM参数以及调优&quot;&gt;&lt;/a&gt;JVM参数以及调优&lt;/h2&gt;&lt;h3 id=&quot;JVM调优基本概念&quot;&gt;&lt;a href=&quot;#JVM调优基本概念&quot; class
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://yimchengjie.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://yimchengjie.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="https://yimchengjie.github.io/2019/06/10/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://yimchengjie.github.io/2019/06/10/Java系统调优/JVM垃圾回收机制/</id>
    <published>2019-06-10T09:23:11.000Z</published>
    <updated>2019-12-19T08:46:04.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><h3 id="自动垃圾收集"><a href="#自动垃圾收集" class="headerlink" title="自动垃圾收集"></a>自动垃圾收集</h3><p>自动垃圾收集是<strong>查看堆内存</strong>,<strong>识别正在使用哪些对象</strong>以及<strong>哪些对象未被删除</strong>以及<strong>删除未使用对象</strong>的过程</p><p>正在使用的对象是指,程序的某些部分仍然维护指向该对象的指针<br>未使用的对象是指,程序的任何部分都不再引用的对象,因此需要回收未引用对象的内存</p><p>自动垃圾收集机制也是java非常重要的一大特性</p><h3 id="如何确定内存需要被回收"><a href="#如何确定内存需要被回收" class="headerlink" title="如何确定内存需要被回收"></a>如何确定内存需要被回收</h3><p>第一步,称为<strong>标记</strong>.这是垃圾收集器识别哪些内存正在使用而哪些不在使用的</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>就是将对象及其引用关系看做一个图,选定<strong>活动的对象</strong>作为GC Roots;<br>然后跟踪引用链,如果一个对象和GC Roots之间没有连通性,也就是不存在引用,那么可以认为是可回收对象.</p><h5 id="可以用作GC-Root的对象"><a href="#可以用作GC-Root的对象" class="headerlink" title="可以用作GC Root的对象"></a>可以用作GC Root的对象</h5><ol><li>虚拟机栈中正在引用的对象</li><li>本地方法栈中正在引用的对象</li><li>静态属性引用的对象</li><li>方法区常量引用的对象</li></ol><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ol><li>强引用:最常见的普通对象引用,只要还有强引用指向一个对象,就不会回收(new出来的对象)</li><li>软引用:JVM认为内存不足,才会去试图回收软引用指向的对象.(缓存场景)</li><li>弱引用:虽然是引用,但随时可能被回收掉</li><li>虚引用:不能通过它访问对象. 通常是在GC时做一些操作</li></ol><h5 id="可达性级别"><a href="#可达性级别" class="headerlink" title="可达性级别"></a>可达性级别</h5><ol><li>强可达:一个对象可以有一个或多个线程可以通过各种引用访问</li><li>软可达:只能通过软引用才能访问</li><li>弱引用:只能通过弱引用访问</li><li>幻象可达:不存在其他引用,并且finalize过了,只有虚引用指向它</li><li>不可达:意味着可以被GC了</li></ol><h3 id="怎么清楚垃圾"><a href="#怎么清楚垃圾" class="headerlink" title="怎么清楚垃圾"></a>怎么清楚垃圾</h3><p>第二步, 定义如何清除垃圾</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除-mark-sweep-算法"><a href="#标记-清除-mark-sweep-算法" class="headerlink" title="标记-清除(mark-sweep)算法"></a>标记-清除(mark-sweep)算法</h5><p>首先标识出所有要回收的对象,然后清除,标记-清除算法效率优先,有内存碎片化问题,不适合特别大的堆;分代收集算法基本基于标记-清除算法的思路改进.</p><h5 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h5><p>划分两块同等大小的区域,收集时将活着的对象复制到另一块区域. 拷贝过程中将对象顺序放置,就可以避免内存碎片化. 复制+预留内存, 有一定的资源浪费.</p><h5 id="标记-整理-mark-compact"><a href="#标记-整理-mark-compact" class="headerlink" title="标记-整理(mark-compact)"></a>标记-整理(mark-compact)</h5><p>类似于标记-清除,但是为了避免内存碎片化,会在清理过程中将对象移动,已确保对象占用连续的内存空间.</p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前商业虚拟机常用的算法,根据对象存活周期的不同,将内存划分为几块,一般是把堆划分为新生代和老年代,这样就可以根据各个年代的特点采用最适合的收集算发.<br>在新生代中,每次垃圾收集都有大量对象死去,少量存活,就用复制算法,只需要付出少量存活对象的复制成本就可以完成收集,<br>而老年代中因为对象存活率高,没有额外的空间对它进行分配担保,必须使用标记-清除或者标记-整理算法来回收,不需要大量的移动对象.</p><p>新对象会被分配到新生代(Eden),如果超过<code>-XX:+PretenureSizeThreshold</code>:设置的大对象直接进入老年代的阈值, 直接存放到老年代</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h4><h5 id="Serial-GC-XX-UseSerialGC"><a href="#Serial-GC-XX-UseSerialGC" class="headerlink" title="-Serial GC -XX:UseSerialGC"></a>-Serial GC -XX:UseSerialGC</h5><p>单个线程来执行所有垃圾收集工作,适合单处理器机器,Glient模式下JVM的默认选项</p><h5 id="Serial-Old-XX-UseSeriaOldlGC"><a href="#Serial-Old-XX-UseSeriaOldlGC" class="headerlink" title="-Serial Old -XX:UseSeriaOldlGC"></a>-Serial Old -XX:UseSeriaOldlGC</h5><p>Serial的老年代版本,可以在老年代使用, 它采用了标记-整理(Mark-Compact)算法,区别于新生代的复制算法</p><h4 id="并行收集器Parallel"><a href="#并行收集器Parallel" class="headerlink" title="并行收集器Parallel"></a>并行收集器Parallel</h4><h5 id="Parallel-GC-XX-UseParallelGC"><a href="#Parallel-GC-XX-UseParallelGC" class="headerlink" title="-Parallel GC -XX:+UseParallelGC"></a>-Parallel GC -XX:+UseParallelGC</h5><h5 id="Parallel-Old-GC-XX-UseParallelGC"><a href="#Parallel-Old-GC-XX-UseParallelGC" class="headerlink" title="-Parallel Old GC -XX:+UseParallelGC"></a>-Parallel Old GC -XX:+UseParallelGC</h5><p>server模式JVM的默认GC选择,整体算法和Serial类似,区别是新生代和老年代GC都是并行进行;<br>可以设置GC时间或吞吐量等,可以自动进行适应性调整Eden,Survivor大小和MaxTenuringThreshold的值.</p><p>也称为吞吐量优先的GC: 吞吐量=用户代码运行时间/(用户代码运行时间+GC时间)</p><p>-XX:ParallelGCThreads: 设置用于垃圾回收的线程数. 通常和CPU数相等<br>-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间. 值是大于0的整数.<br>-XX:GCTimeRatio: 设置吞吐量大小,它的值是一个0-100之间的整数.<br>-XX:+UseAdaptiveSizePolicy: 打开自适应GC策略. 以达到在堆大小,吞吐量和停顿时间之间的平衡点</p><h5 id="ParNew-GC-XX-UseParNewGC"><a href="#ParNew-GC-XX-UseParNewGC" class="headerlink" title="-ParNew GC -XX:+UseParNewGC"></a>-ParNew GC -XX:+UseParNewGC</h5><p>新生代GC的实现, 它实际是Serial GC的多线程版本. 可以控制线程数量, 参数: -XX:ParallelGCThreads<br>最常见的场景是配合老年代的CMS GC工作. 参数: -XX:+UseConcMarkSweepGC</p><h4 id="并发收集器CMS-Concurrent-Mark-Sweep"><a href="#并发收集器CMS-Concurrent-Mark-Sweep" class="headerlink" title="并发收集器CMS(Concurrent Mark Sweep)"></a>并发收集器CMS(Concurrent Mark Sweep)</h4><h5 id="CMS-GC-XX-UseConcMarkSweepGC"><a href="#CMS-GC-XX-UseConcMarkSweepGC" class="headerlink" title="-CMS GC -XX:+UseConcMarkSweepGC"></a>-CMS GC -XX:+UseConcMarkSweepGC</h5><p>专用老年代,基于标记-清除算法,设计目标是尽量减少停顿时间.<br>但会占用更多的CPU资源,并和用户线程争抢</p><h5 id="G1-XX-UseG1GC"><a href="#G1-XX-UseG1GC" class="headerlink" title="-G1 -XX:+UseG1GC"></a>-G1 -XX:+UseG1GC</h5><p>针对大堆内存设计的收集器,兼顾吞吐量和停顿时间, JDK9后为默认选项, 目标是替代GMC;<br>G1将堆分为多个固定大小, 堆之间是复制算法, 但整体上可以理解为标记-整理算法,可以有效避免内存碎片化.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM垃圾回收机制&quot;&gt;&lt;a href=&quot;#JVM垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾回收机制&quot;&gt;&lt;/a&gt;JVM垃圾回收机制&lt;/h2&gt;&lt;h3 id=&quot;自动垃圾收集&quot;&gt;&lt;a href=&quot;#自动垃圾收集&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://yimchengjie.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://yimchengjie.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="https://yimchengjie.github.io/2019/06/03/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://yimchengjie.github.io/2019/06/03/Java系统调优/类加载机制/</id>
    <published>2019-06-03T02:53:51.000Z</published>
    <updated>2019-12-19T08:19:01.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h2><p><strong>1. 加载</strong>:读取二进制内容<br><strong>2. 验证</strong>:验证class文件格式规范、语义分析、引用验证、字节码验证<br><strong>3. 准备</strong>:分配内存、设置类static修饰的变量初始值<br><strong>4. 解析</strong>:类、接口、字段、类方法等解析<br><strong>5. 初始化</strong>:为静态变量赋值；执行静态代码块<br><strong>6. 使用</strong>:创建实例对象<br><strong>7. 卸载</strong>:从JVM方法区中卸载</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器负责装入类,搜索各个位置的类资源.<br>一个Java程序运行,至少有三个类加载器实例,负责不同类的加载</p><ol><li><strong>Bootstrap Loader 核心类库加载器</strong>,由C语言实现,加载JDK核心类库</li><li><strong>Extension Class Loader 拓展类库加载器</strong>,加载JDK拓展包</li><li><strong>application class loader 用户应用程序加载器</strong>,加载classpath路径下的包</li></ol><h3 id="类不会重复加载"><a href="#类不会重复加载" class="headerlink" title="类不会重复加载"></a>类不会重复加载</h3><p>类的唯一性:同一个类加载器,类名一样,代表同一个类.</p><h4 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h4><p>某一个类加载器想要去加载一个类,并不会立刻去加载,而是委托给父亲,如果父亲上面还有父亲,则继续向上委托,最终到达核心类库加载器,如果核心类库无法记载,再向下一个个委托.<br><strong>即,有父类交给父类加载,没父类了开始加载,无法加载向下委托,全都不能加载则失败</strong></p><p>通过双亲委派机制</p><ol><li>建立类的层级关系可以避免类的重复加载,当父亲已经加载该类时,就没必要再加载一次了.</li><li>优先加载核心类库, 这样防止用户恶意的同名类,因为永远是核心的类先被加载.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类生命周期&quot;&gt;&lt;a href=&quot;#类生命周期&quot; class=&quot;headerlink&quot; title=&quot;类生命周期&quot;&gt;&lt;/a&gt;类生命周期&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 加载&lt;/strong&gt;:读取二进制内容&lt;br&gt;&lt;strong&gt;2. 验证&lt;/strong&gt;:验
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://yimchengjie.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://yimchengjie.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty网络编程框架</title>
    <link href="https://yimchengjie.github.io/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/"/>
    <id>https://yimchengjie.github.io/2019/05/07/网络编程/Netty网络编程框架/</id>
    <published>2019-05-07T12:59:55.000Z</published>
    <updated>2019-11-25T05:34:33.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty网络编程框架"><a href="#Netty网络编程框架" class="headerlink" title="Netty网络编程框架"></a>Netty网络编程框架</h2><p>Netty是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，它极大的简化了TCP和UDP客户端和服务器开发等网络编程</p><p>Netty支持BIO、NIO，支持各种协议</p><h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>Reactor模型也叫Dispatcher模式,服务器接收多路请求,并同步反派给请求对应的线程</p><h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty线程模型基于主从Reactor线程模型,有多个Reactor</p><h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul><li><strong>Bootstrap引导</strong>: 一个Netty应用通常由一个Bootstrap开始,主要作用是配置整个Netty程序,串联各个组件,Netty中Bootstrap类是客户端程序的启动引导类,ServerBootstrap是服务端启动引导类</li><li><strong>Future ChannelFuture</strong>: 可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</li><li><strong>Channel</strong>: 网络通信通道,发送接收数据</li><li><strong>Selector</strong>: 实现I/O多路复用,一个Selector线程可以监听多个线程的Channel事件</li><li><strong>NioEventLoop</strong>: 类似线程池,维护了一个线程和任务队列,支持异步提交执行,线程启动时,会调用run()方法,执行IO任务和非IO任务</li><li><strong>NioEventLoopGroup</strong>: 用于管理eventLoop的生命周期,可以理解为大线程池,内部维护了一组小线程池</li><li><strong>ChannelHandler</strong>: 处理IO事件或者拦截IO操作,并转发到ChannelPipeline(业务处理链)中<br>Handler可以被共享,但是要注意防止共享变量,比如解码器是不能被共享的<br>耗时的业务不要放在Handler,要单独交给指定的线程池中</li><li><strong>ChannelHandlerContext</strong>: 保存Channel相关的上下文信息,每一个ChannelHandlerContext关联一个ChannelHandler</li><li><strong>ChannelPipline</strong>: 责任链,业务处理链,保存了ChannelHandler的List,用于处理或拦截Channel的入站事件或者出站操作.</li></ul><p><img src="/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/netty%E6%B5%81%E7%A8%8B.jpg" alt="netty流程"></p><p><a href="https://luan.ma/post/netty-flow/" target="_blank" rel="noopener">netty服务端处理用户请求流程图解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netty网络编程框架&quot;&gt;&lt;a href=&quot;#Netty网络编程框架&quot; class=&quot;headerlink&quot; title=&quot;Netty网络编程框架&quot;&gt;&lt;/a&gt;Netty网络编程框架&lt;/h2&gt;&lt;p&gt;Netty是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Netty" scheme="https://yimchengjie.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>NIO网络编程</title>
    <link href="https://yimchengjie.github.io/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://yimchengjie.github.io/2019/04/30/网络编程/NIO网络编程/</id>
    <published>2019-04-30T14:19:55.000Z</published>
    <updated>2019-11-23T06:37:07.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO网络编程"><a href="#NIO网络编程" class="headerlink" title="NIO网络编程"></a>NIO网络编程</h2><p>非阻塞IO</p><p>NIO是Java提供的替代BIO的相关API</p><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p>Buffr 缓冲区<br>Channel 通道<br>Selector 选择器</p><h4 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h4><p>Java提供Buffer API, 可以让我们更轻松的使用内存块</p><p>使用Buffer对象,对数据进行写入和读取</p><ol><li>将数据写入缓冲区</li><li>调用buffer.flip(),转换为读取模式</li><li>缓冲区读取数据</li><li>调用buffer.clear()或buffer.compact() 清楚缓冲区</li></ol><p>Buffer的三个属性<br>capacity容量: 缓冲区内存块大小<br>position位置: 写入或读取时的位置<br>limit限制: 限制每次读取或者写入的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建一个byte字节缓冲区，容量是4</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认写入模式，查看三个重要的指标</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"初始化：capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line">        <span class="comment">// 写入2字节的数据</span></span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 再看数据</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对)</span></span><br><span class="line">        System.out.println(<span class="string">"#######开始读取"</span>);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="keyword">byte</span> a = byteBuffer.get();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">byte</span> b = byteBuffer.get();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(String.format(<span class="string">"读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据</span></span><br><span class="line">        <span class="comment">// clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式</span></span><br><span class="line">        byteBuffer.compact(); <span class="comment">// buffer : 1 , 3</span></span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">4</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">5</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"最终的情况，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rewind() 重置position为0</span></span><br><span class="line">        <span class="comment">// mark() 标记position的位置</span></span><br><span class="line">        <span class="comment">// reset() 重置position为上次mark()标记的位置</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer可以直接获取直接内存<br>ByteBuffer directByteBuffer=ByteBuffer.allocateDirect(n);<br>内部有一个回收对象, 可以进行垃圾回收, 否则JVM的垃圾回收无法管理堆外内存</p><p>否则使用JVM堆内存,写入时用堆内存会复制一份数据到堆外内存</p><h4 id="Channel通道"><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h4><p>通道从ByteBuffer中读取数据或者写入数据</p><h5 id="Channel四种实现类型"><a href="#Channel四种实现类型" class="headerlink" title="Channel四种实现类型"></a>Channel四种实现类型</h5><p><strong>1. FileChannel</strong>: 用于文件的数据读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FileChannel通道</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>，<span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure><p><strong>2. DatagramChannel</strong>: 用于UDP的数据读写。<br><strong>3. SocketChannel</strong>: 用于TCP的数据读写。<br><strong>4. ServerSocketChannel</strong>: 监听TCP链接请求，每个请求会创建会一个SocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h4><p>可以检查一个或多个NIO通道,实现单个线程管理多个通道,从而管理多个网络连接</p><p>比如:当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务,不会阻塞</p><p>一个通道继承了SelectableChannel,那么他就可以被Selector复用</p><p><strong>一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</strong><br>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上，在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。</p><p>使用Channel.register（Selector sel，int ops）方法, 将通道注册到选择器上,这里的操作指的是当前通道已经准备就绪,能够进行的操作类型<br>int ops包括</p><ol><li>可读 : SelectionKey.OP_READ</li><li>可写 : SelectionKey.OP_WRITE</li><li>连接 : SelectionKey.OP_CONNECT</li><li>接收 : SelectionKey.OP_ACCEPT</li></ol><p><code>selector.select();</code> 查找准备就绪的通道</p><h5 id="Selector使用流程"><a href="#Selector使用流程" class="headerlink" title="Selector使用流程"></a>Selector使用流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建通道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//设置非租塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定连接</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(SystemConfig.SOCKET_SERVER_PORT));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将通道注册到选择器,并指定为可接收</span></span><br><span class="line">serverSocketChannel.register(selector，SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用轮询的方式，查询获取“准备就绪”的注册过的操作</span></span><br><span class="line"><span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前选择器中所有注册的选择键（“已经准备就绪的操作”）</span></span><br><span class="line">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (selectedKeys.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取“准备就绪”的事件</span></span><br><span class="line">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class="line">        <span class="comment">// 判断key是具体的什么事件</span></span><br><span class="line">        <span class="keyword">if</span> (selectedKey.isAcceptable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若接受的事件是“接收就绪” 操作,就获取客户端连接</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">// 切换为非阻塞模式</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将该通道注册到selector选择器上,并指定为可读</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (selectedKey.isReadable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取该选择器上的“读就绪”状态的通道</span></span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = socketChannel.read(byteBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, length));</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除选择键</span></span><br><span class="line">        selectedKeys.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">serverSocketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:要注册到选择器, 通道必须是非租塞的</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>基于Java NIO, 在此基础, 抽象出来两个组件–Reactor和Handler</p><ol><li>Reactor: 负责响应IO事件,当检测到新的时间, 发送给相应的Handler</li><li>Handler: 执行处理</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO网络编程&quot;&gt;&lt;a href=&quot;#NIO网络编程&quot; class=&quot;headerlink&quot; title=&quot;NIO网络编程&quot;&gt;&lt;/a&gt;NIO网络编程&lt;/h2&gt;&lt;p&gt;非阻塞IO&lt;/p&gt;
&lt;p&gt;NIO是Java提供的替代BIO的相关API&lt;/p&gt;
&lt;h3 id=&quot;NI
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BIO网络编程</title>
    <link href="https://yimchengjie.github.io/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/BIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://yimchengjie.github.io/2019/04/30/网络编程/BIO网络编程/</id>
    <published>2019-04-30T11:29:55.000Z</published>
    <updated>2019-11-22T05:58:00.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BIO网络编程"><a href="#BIO网络编程" class="headerlink" title="BIO网络编程"></a>BIO网络编程</h2><p>同步阻塞网络编程</p><h3 id="阻塞IO的含义"><a href="#阻塞IO的含义" class="headerlink" title="阻塞IO的含义"></a>阻塞IO的含义</h3><p>阻塞IO: 资源不可用时,IO请求一直阻塞,直到有数据或者阻塞超时<br>非阻塞IO: 资源不可用时,IO请求离开返回,返回数据标识资源不可用<br>阻塞非阻塞描述请求,即如何获取数据</p><p>同步IO: 应用阻塞在发送或者接受数据的状态,直到数据成功传输或者返回失败<br>异步IO: 应用发送或接受数据后立刻返回,实际处理是异步执行<br>同步异步描述响应,即如何拿数据</p><p>Java中的<br>ServerSocket类的accept方法和InputStream类的read方法,都是阻塞API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="comment">// 初始化服务端Socket</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">System.out.println(<span class="string">"服务器启动成功"</span>);</span><br><span class="line"><span class="keyword">while</span> (!serverSocket.isClosed()) &#123;</span><br><span class="line">    Socket request = serverSocket.accept();<span class="comment">// 阻塞</span></span><br><span class="line">    System.out.println(<span class="string">"收到新连接 : "</span> + request.toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据、打印</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"utf-8"</span>));</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 没有数据，阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (msg.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"收到数据,来自："</span>+ request.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">serverSocket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">String msg = scanner.nextLine();</span><br><span class="line">out.write(msg.getBytes(charset)); <span class="comment">// 阻塞，写完成</span></span><br><span class="line">scanner.close();</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BIO网络编程&quot;&gt;&lt;a href=&quot;#BIO网络编程&quot; class=&quot;headerlink&quot; title=&quot;BIO网络编程&quot;&gt;&lt;/a&gt;BIO网络编程&lt;/h2&gt;&lt;p&gt;同步阻塞网络编程&lt;/p&gt;
&lt;h3 id=&quot;阻塞IO的含义&quot;&gt;&lt;a href=&quot;#阻塞IO的含义&quot; c
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://yimchengjie.github.io/2019/04/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yimchengjie.github.io/2019/04/27/网络编程/网络协议/</id>
    <published>2019-04-27T05:25:11.000Z</published>
    <updated>2019-11-23T09:26:07.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI网络七层模型"><a href="#OSI网络七层模型" class="headerlink" title="OSI网络七层模型"></a>OSI网络七层模型</h3><p><strong>物理层</strong>: 使原始的数据比特流能在物理介质上传输<br><strong>数据链路层</strong>: 封装成帧、透明传输、差错检测。<br><strong>网络层</strong>: 路由选择、流量控制（IP协议）</p><p><strong>传输层</strong>： 提供可靠的端口到端口的数据传输服务（TCP/UDP协议）</p><p><strong>会话层</strong>: 建立、管理、终止进程之间的会话和数据交换<br><strong>表示层</strong>: 数据格式转换，加密解密，压缩解压等<br><strong>应用层</strong>: 为用户的应用进程提供网络服务</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP提供面向连接、可靠、有序、字节流传输服务。<br>应用程序在使用TCP之前，必须先建立TCP连接。</p><h5 id="TCO三次握手"><a href="#TCO三次握手" class="headerlink" title="TCO三次握手"></a>TCO三次握手</h5><p>在正式发送数据之前，做的检验机制<br>通过以后就成功建立了TCP连接，然后开始传输数据</p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><p>在断开连接之前，做的确认机制</p><p>TCP三次握手和四次挥手，都是为了让连接的可靠性更高</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP提供无连接、不可靠、数据报尽力传输服务。</p><p>比如语言视频聊天， 日志上报等， 会用到</p><h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><p>一个http请求包含四个部分</p><ol><li>请求行: 请求类型,资源路径,以及http版本</li><li>请求头部: 用来说明服务器要使用的附加信息</li><li>空行: 请求头和数据主体之间必须有换行,作为分隔标记</li><li>主体: 即请求数据</li></ol><p>一个http响应数据包含</p><ol><li>状态行: HTTP版本、状态码、状态消息</li><li>响应报头部: 用来说明服务器要使用的附加信息</li><li>空行: 头部和数据之间的换行</li><li>响应正文: 即响应数据</li></ol><h4 id="HTTP协议响应状态码"><a href="#HTTP协议响应状态码" class="headerlink" title="HTTP协议响应状态码"></a>HTTP协议响应状态码</h4><ul><li>1XX: 临时响应<br>握手成功,TCP建立</li><li>2XX: 成功<br>表示已成功处理了请求</li><li>3XX: 重定向<br>表示要完成请求,需要进一步操作</li><li>4XX: 请求错误<br>请求可能出错</li><li>5XX: 服务器错误<br>服务器内部出错</li></ul><h4 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h4><p>WebSocket是基于TCP的一种新的网络协议<br>它实现了服务器和客户端全双工通信</p><p>支持多客服端,多语言,多服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OSI网络七层模型&quot;&gt;&lt;a href=&quot;#OSI网络七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI网络七层模型&quot;&gt;&lt;/a&gt;OSI网络七层模型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;: 使原始的数据比特流能在物理介质上传输&lt;b
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络协议" scheme="https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
