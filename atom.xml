<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuyiting.xyz/"/>
  <updated>2019-10-22T02:40:41.045Z</updated>
  <id>https://zhuyiting.xyz/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>嘉善立春</title>
    <link href="https://zhuyiting.xyz/2019/10/21/%E5%98%89%E5%96%84%E7%AB%8B%E6%98%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/21/嘉善立春/</id>
    <published>2019-10-21T09:06:16.000Z</published>
    <updated>2019-10-22T02:40:41.045Z</updated>
    
    <content type="html"><![CDATA[<p>节气之首是立春,<br>万物复苏很精神.<br>嘉善地方虽然小,<br>东西样样都不少.<br>初春温度还很低,<br>地嘉人善却不冷.<br>早晨起来还有露,<br>上学骑在阳光路.<br>几年发展太迅速,<br>日子过的真惬意.<br>不管我们去哪里,<br>嘉善永远是窝里.<br>车站路上哼小曲,<br>儿童公园有飞机.<br>白水塘里游大鱼,<br>大云还有巧克力.<br>西塘景区人密集,<br>灯火夜景很美丽.<br>现在还有新西塘,<br>小桥流水和人家.<br>看看嘉善的变化,<br>讲讲嘉善的闲话.<br>今年也要努努力,<br>明年定会更顺利.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;节气之首是立春,&lt;br&gt;万物复苏很精神.&lt;br&gt;嘉善地方虽然小,&lt;br&gt;东西样样都不少.&lt;br&gt;初春温度还很低,&lt;br&gt;地嘉人善却不冷.&lt;br&gt;早晨起来还有露,&lt;br&gt;上学骑在阳光路.&lt;br&gt;几年发展太迅速,&lt;br&gt;日子过的真惬意.&lt;br&gt;不管我们去哪里,&lt;br&gt;嘉善永远是
      
    
    </summary>
    
    
      <category term="生活方式" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>GitHub如何把已有项目上传</title>
    <link href="https://zhuyiting.xyz/2019/10/21/GitHub%E5%A6%82%E4%BD%95%E6%8A%8A%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0/"/>
    <id>https://zhuyiting.xyz/2019/10/21/GitHub如何把已有项目上传/</id>
    <published>2019-10-21T08:50:53.000Z</published>
    <updated>2019-10-21T08:50:53.573Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019双十一攻略</title>
    <link href="https://zhuyiting.xyz/2019/10/21/2019%E5%8F%8C%E5%8D%81%E4%B8%80%E6%94%BB%E7%95%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/21/2019双十一攻略/</id>
    <published>2019-10-21T01:49:00.000Z</published>
    <updated>2019-10-23T02:45:41.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h3><ol><li>每日任务领喵币</li><li>团队PK拉人助力</li></ol><h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><ol><li>每日任务领喵币</li><li>双十一7点领彩蛋</li><li>双十一7点钻石铂金会员领金手指</li></ol><h3 id="优酷"><a href="#优酷" class="headerlink" title="优酷"></a>优酷</h3><ol><li>每日进入APP获红包</li><li>每日视频观看3分钟获红包</li></ol><h3 id="UC"><a href="#UC" class="headerlink" title="UC"></a>UC</h3><ol><li>每日签到领红包</li><li>每日开启红包雨</li><li>每日可抽10次幸运好礼</li></ol><h3 id="高德"><a href="#高德" class="headerlink" title="高德"></a>高德</h3><ol><li>完成每日体验获红包</li></ol><h3 id="饿了吗"><a href="#饿了吗" class="headerlink" title="饿了吗"></a>饿了吗</h3><ol><li>每日心愿城打卡得红包</li><li>下单外卖获红包</li><li>每日三次掷骰子有机会获红包</li></ol><h3 id="口碑"><a href="#口碑" class="headerlink" title="口碑"></a>口碑</h3><ol><li>每日登陆领红包</li><li>掷骰子获得更多奖励</li><li>每天玩游戏5次可获得一个红包</li></ol><h3 id="飞猪"><a href="#飞猪" class="headerlink" title="飞猪"></a>飞猪</h3><ol><li>每日签到获红包</li><li>完成每日任务,打卡成功获红包</li></ol><h3 id="淘宝特价版"><a href="#淘宝特价版" class="headerlink" title="淘宝特价版"></a>淘宝特价版</h3><ol><li>登陆签到得红包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;淘宝&quot;&gt;&lt;a href=&quot;#淘宝&quot; class=&quot;headerlink&quot; title=&quot;淘宝&quot;&gt;&lt;/a&gt;淘宝&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;每日任务领喵币&lt;/li&gt;
&lt;li&gt;团队PK拉人助力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;支付宝&quot;&gt;&lt;a href=&quot;#支付宝&quot;
      
    
    </summary>
    
    
      <category term="生活方式" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>延期年金现值的计算</title>
    <link href="https://zhuyiting.xyz/2019/10/18/%E5%BB%B6%E6%9C%9F%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://zhuyiting.xyz/2019/10/18/延期年金现值的计算/</id>
    <published>2019-10-18T01:56:00.000Z</published>
    <updated>2019-10-21T03:58:39.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延期年金"><a href="#延期年金" class="headerlink" title="延期年金"></a>延期年金</h2><p>==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.<br>==延期年金现值计算==假定最初又m期没有收付款项,后面n期每年有等额的系列收付款项,则此延期年金的现值即为后n期年金先折现至n期期初(m期期末),再折现至第一期期初的现值.</p><p>==年金==是指定期定额的收付款项</p><p>==现值==成本或收益的价值以今天的现金来计量时,称为现值</p><p>==终值==是指现在某一时点上的一定量现金折合到未来的价值</p><ol><li>延期年金的==终值==大小和延期数m无关<br>所以延期m期之后的n期年金终值为<br>$ F=A\frac{(1+i)^n-1}{i} $</li><li>普通年金的==现值==计算<br>$ P=A\frac{1-\frac{1}{(1+i)^n}}{i}$</li><li>==延期年金==的现值计算<br>延期年金的现值与延期数m相关,m越长,现值越低.<ul><li>方法一:先当成n期普通年金,求出现值P1,在将P作为第m期终值,再折现到第一期的现值P2<br>$P1=A\frac{1-\frac{1}{(1+i)^n}}{i}$<br>$P2=P1\frac{1-\frac{1}{(1+i)^m}}{i} $</li><li>方法二:先计算m+n期现值,再减去m期年金现值<br>$P=A(\frac{1-\frac{1}{(1+i)^m(1+i)^n}}{i}-\frac{1-\frac{1}{(1+i)^m}}{i}) $</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;延期年金&quot;&gt;&lt;a href=&quot;#延期年金&quot; class=&quot;headerlink&quot; title=&quot;延期年金&quot;&gt;&lt;/a&gt;延期年金&lt;/h2&gt;&lt;p&gt;==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.&lt;br&gt;==延期年
      
    
    </summary>
    
    
      <category term="生活方式" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://zhuyiting.xyz/2019/07/30/JVM指令手册/</id>
    <published>2019-07-30T07:18:00.000Z</published>
    <updated>2019-10-20T00:56:02.507Z</updated>
    
    <content type="html"><![CDATA[<p>栈和局部变量操作<br>将常量压入栈的指令<br>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值<br>将栈中的值存入局部变量的指令<br>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中<br>wide指令<br>wide 使用附加字节扩展局部变量索引<br>通用(无类型）栈操作<br>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容<br>类型转换<br>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型<br>整数运算<br>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上<br>逻辑运算<br>移位操作<br>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作<br>按位布尔运算<br>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作<br>浮点运算<br>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反<br>对象和数组<br>对象操作指令<br>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型<br>数组操作指令<br>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组<br>控制流<br>条件分支指令<br>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转<br>比较指令<br>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）<br>无条件转移指令<br>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）<br>表跳转指令<br>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<br>异常<br>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回<br>方法调用指令<br>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法<br>方法返回指令<br>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void<br>线程同步<br>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><hr><p>JVM指令助记符<br>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈和局部变量操作&lt;br&gt;将常量压入栈的指令&lt;br&gt;aconst_null 将null对象引用压入栈&lt;br&gt;iconst_m1 将int类型常量-1压入栈&lt;br&gt;iconst_0 将int类型常量0压入栈&lt;br&gt;iconst_1 将int类型常量1压入栈&lt;br&gt;iconst_
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GitHub使用</title>
    <link href="https://zhuyiting.xyz/2018/04/03/GitHub%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhuyiting.xyz/2018/04/03/GitHub使用/</id>
    <published>2018-04-03T09:33:00.000Z</published>
    <updated>2019-10-24T01:13:24.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>GitHub可以用来托管代码,也可以用来进行版本控制,它相比与其他版本控制工具的优势在于,可以非常方便的进行分支操作</p><h4 id="1-注册账户"><a href="#1-注册账户" class="headerlink" title="1.注册账户"></a>1.注册账户</h4><h4 id="2-新建一个仓库-repository"><a href="#2-新建一个仓库-repository" class="headerlink" title="2.新建一个仓库(repository)"></a>2.新建一个仓库(repository)</h4><p><img src="/.xyz//newRepo.png" alt="新建仓库"></p><h4 id="3-配置GitHub公钥"><a href="#3-配置GitHub公钥" class="headerlink" title="3.配置GitHub公钥"></a>3.配置GitHub公钥</h4><p>在Git终端输入<code>ssh-keygen -t rsa -C &quot;email@email.com&quot;</code><br>在系统用户下的<code>/.ssh</code>目录,找到<code>id_rsa.pub</code>文件,其中存放的就是秘钥.</p><p>再进入github个人设置,选择SSH and GPG keys,将<code>id_rsa.pub</code>文件中的内容复制进去<br>如:<br><img src="/.xyz//setSSHKey.pn" alt="设置秘钥"></p><h4 id="4-clone仓库"><a href="#4-clone仓库" class="headerlink" title="4. clone仓库"></a>4. clone仓库</h4><p>使用 <code>git clone &lt;项目链接&gt;</code><br>将github仓库克隆到本地</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GitHub&quot;&gt;&lt;a href=&quot;#GitHub&quot; class=&quot;headerlink&quot; title=&quot;GitHub&quot;&gt;&lt;/a&gt;GitHub&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="工具" scheme="https://zhuyiting.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本控制" scheme="https://zhuyiting.xyz/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="代码托管" scheme="https://zhuyiting.xyz/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Git简单教程</title>
    <link href="https://zhuyiting.xyz/2018/03/31/Git%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2018/03/31/Git简单教程/</id>
    <published>2018-03-31T00:33:00.000Z</published>
    <updated>2019-10-21T08:00:57.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git?"></a>什么是Git?</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><h3 id="Git在Windows的安装和配置"><a href="#Git在Windows的安装和配置" class="headerlink" title="Git在Windows的安装和配置"></a>Git在Windows的安装和配置</h3><p>安装包下载地址：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p><p>在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><p>配置个人的用户名称和电子邮件地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --g user.name &quot;yanchengjie&quot;</span><br><span class="line">git config --g user.email ycj996425271@live.com</span><br></pre></td></tr></table></figure><h4 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h4><p>要检查已有的配置信息，可以使用 git config –list 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="Git的工作流程"><a href="#Git的工作流程" class="headerlink" title="Git的工作流程"></a>Git的工作流程</h3><p>Git工作的一般流程为:</p><ol><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ol><h3 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h3><p><strong>工作区</strong>：就是你在电脑里能看到的目录。<br><strong>暂存区</strong>：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><h3 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h3><p>Git 使用 <code>git init</code> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <code>git init</code> 是使用 Git 的第一个命令。</p><h3 id="Git克隆仓库"><a href="#Git克隆仓库" class="headerlink" title="Git克隆仓库"></a>Git克隆仓库</h3><p>我们使用 git clone 从现有 Git 仓库中拷贝项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/XXXX/XXX</span><br></pre></td></tr></table></figure><h3 id="Git添加文件到缓存"><a href="#Git添加文件到缓存" class="headerlink" title="Git添加文件到缓存"></a>Git添加文件到缓存</h3><p>使用命令 <code>git add &lt;fileName&gt;</code></p><h3 id="Git移除缓存中的文件"><a href="#Git移除缓存中的文件" class="headerlink" title="Git移除缓存中的文件"></a>Git移除缓存中的文件</h3><p>使用命令 <code>git rm &lt;fileName&gt;</code></p><h3 id="Git将缓存区添加到仓库"><a href="#Git将缓存区添加到仓库" class="headerlink" title="Git将缓存区添加到仓库"></a>Git将缓存区添加到仓库</h3><p>使用命令<code>git commit -m &quot;备注信息&quot;</code></p><h3 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h3><p>列出分支命令:<code>git branch</code>(master为主分支)<br>创建分支命令:<code>git branch (branchName)</code><br>切换分支命令:<code>git checkout (branchNaem)</code><br>删除分支命令:<code>git branch -d (branchName)</code><br>合并分支命令:<code>git merge (branchName)</code></p><h3 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h3><p>使用命令 <code>git log</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Git&quot;&gt;&lt;a href=&quot;#什么是Git&quot; class=&quot;headerlink&quot; title=&quot;什么是Git?&quot;&gt;&lt;/a&gt;什么是Git?&lt;/h3&gt;&lt;p&gt;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="工具" scheme="https://zhuyiting.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本控制" scheme="https://zhuyiting.xyz/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://zhuyiting.xyz/2018/03/05/Ajax/"/>
    <id>https://zhuyiting.xyz/2018/03/05/Ajax/</id>
    <published>2018-03-05T08:25:00.000Z</published>
    <updated>2019-10-21T08:35:18.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h3 id="1-Ajax的作用"><a href="#1-Ajax的作用" class="headerlink" title="1.Ajax的作用"></a>1.Ajax的作用</h3><p>获取服务器的数据</p><h3 id="2-Ajax的效果"><a href="#2-Ajax的效果" class="headerlink" title="2.Ajax的效果"></a>2.Ajax的效果</h3><p>在不刷新整个页面的情况下,通过一个url地址获取服务器的数据,然后进行页面的局部刷新. 异布加载,</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h3><p>Ajax的全称: Asychronous JavaScript And XML,就是使用js代码获取服务器数据.      </p><h3 id="4-Ajax的使用"><a href="#4-Ajax的使用" class="headerlink" title="4.Ajax的使用"></a>4.Ajax的使用</h3><p>Ajax简单的来说,就是一个异布的JavaScript请求,用来获取后台服务端的数据,而并不是整个界面进行跳转.    </p><p> 在元素js中来实现AJax主要的类就是XMLHttpRequest,它的使用一般有四个步骤;</p><ol><li>创建XMLHttpRequest对象</li><li>准备发送网络请求</li><li>开始发送网络请求</li><li>指定回调函数</li></ol><p><strong>注意:</strong> </p><blockquote></blockquote><ol><li>需要注意兼容处理.低版本浏览器不支持XMLHttpRequest对象,需要创建ActiveXObject对象;</li><li>指定请求方式,请求地址以及指定是否异步刷新</li><li>执行发送,<strong>POST请求方式</strong>时,数据不写在地址中,放在请求数据体中.需要发送给服务器,同时设置请求头</li><li>异步的原理是通过请求浏览器进行网络数据的请求   </li></ol><h3 id="5-数据格式"><a href="#5-数据格式" class="headerlink" title="5. 数据格式"></a>5. 数据格式</h3><ol><li>Xml数据格式<br>Xml数据格式是将数据以标签的方式进行组装,必须以<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</code>开头,标签必须成对出现,xml是一个通用标准,任何人都知道如何解析它;</li></ol><p><strong>缺点:</strong>体积太大,传播慢,元数据太多,解析不方便,目前使用很少    </p><ol start="2"><li>JSON数据格式<br>Json数据格式类似于js中的对象方式,通过key-value的形式组装,是一个通用的标准,任何人都知道如何解析它;</li></ol><p><strong>优点:</strong>体积小,传输快,解析方便    </p><ol start="3"><li>解析Xml数据格式<br>获取Xml对象,在通过getElementsBtTagName获取标签内元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=xhr.responseXML;</span><br><span class="line"><span class="keyword">var</span> books=result.getElementsByTagName(<span class="string">"booklist"</span>)[<span class="number">0</span>].getElementsByTagName(<span class="string">"book"</span>);</span><br><span class="line"><span class="keyword">var</span> newHtml=<span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;books.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> itemBook=books[i];</span><br><span class="line"><span class="keyword">var</span> name=itemBook.getElementsByTagName(<span class="string">"name"</span>)[<span class="number">0</span>].textContent;</span><br><span class="line"><span class="keyword">var</span> author=itemBook.getElementsByTagName(<span class="string">"author"</span>)[<span class="number">0</span>].textContent;</span><br><span class="line"><span class="keyword">var</span> desc=itemBook.getElementsByTagName(<span class="string">"desc"</span>)[<span class="number">0</span>].textContent;</span><br><span class="line"><span class="keyword">var</span> tempHtml=<span class="string">"&lt;tr&gt;&lt;td&gt;"</span>+name+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+author+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+desc+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>;</span><br><span class="line">newHtml += tempHtml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml = newHtml;</span><br></pre></td></tr></table></figure></li><li>解析Json数据格式<br>获取Json对象,再通过对象直接获取对象的属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=xhr.responseTest;</span><br><span class="line"><span class="comment">//responseTest获取的是字符串,要转换成JSON对象</span></span><br><span class="line">result=<span class="built_in">JSON</span>.parse(result);</span><br><span class="line"><span class="keyword">var</span> newHtml=<span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> item=result[i];</span><br><span class="line"><span class="keyword">var</span> name=item.name;</span><br><span class="line"><span class="keyword">var</span> author=item.author;</span><br><span class="line"><span class="keyword">var</span> desc=item.desc;</span><br><span class="line"><span class="keyword">var</span> tempHtml=<span class="string">"&lt;tr&gt;&lt;td&gt;"</span>+name+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+author+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+desc+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>;</span><br><span class="line">newHtml += tempHtml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml = newHtml;</span><br></pre></td></tr></table></figure><h3 id="6-封装Ajax"><a href="#6-封装Ajax" class="headerlink" title="6.封装Ajax"></a>6.封装Ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span>(<span class="params">type,url,params,callback,async</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="string">"get"</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(params &amp;&amp; params!=<span class="string">""</span>)&#123;</span><br><span class="line">url += <span class="string">"?"</span> + params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(type,url,<span class="keyword">async</span>);</span><br><span class="line"><span class="keyword">if</span>(type == <span class="string">"get"</span>)&#123;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">"post"</span>)&#123;</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Contend-Type"</span>,<span class="string">"application/x-www-from-urlencoded"</span>);</span><br><span class="line">xhr.send(params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">async</span>)&#123;</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(dataType == <span class="string">"json"</span>)&#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">result = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataType == <span class="string">"xml"</span>)&#123;</span><br><span class="line">result = xhr.responseXML;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(callback)&#123;</span><br><span class="line">callback(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(dataType == <span class="string">"json"</span>)&#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">result = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataType == <span class="string">"xml"</span>)&#123;</span><br><span class="line">result = xhr.responseXML;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(callback)&#123;</span><br><span class="line">callback(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-用jQuery实现Ajax"><a href="#7-用jQuery实现Ajax" class="headerlink" title="7 用jQuery实现Ajax"></a>7 用jQuery实现Ajax</h3>jQuery对Ajex操作进行了封装,在jQuery中最底层的方法是<code>$.ajax()</code>,第二层是<code>$.load()</code>、<code>$.get()</code> 、<code>$.post()</code>  第三层是<code>$.getJSON()</code>、<code>$.getScript()</code></li></ol><ul><li><code>$.ajax()</code>用法:<ul><li><strong>type</strong>：指定数据提交的方式</li><li><strong>url</strong>：提交数据的路径</li><li><strong>cache</strong>:是否存在缓存</li><li><strong>data</strong>：向后台发送的数据</li><li><strong>dataType</strong>：服务器端返回的数据类型，比如：xml，text，json, html，script</li><li><strong>success</strong>：响应成功后执行的函数</li><li><strong>error</strong>：响应失败后执行的函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subData=&#123;</span><br><span class="line">name:<span class="string">'张三'</span></span><br><span class="line">&#125; <span class="comment">//提交的数据</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url : <span class="string">"IndexController/getIndexImages.html"</span>,</span><br><span class="line">type : <span class="string">"POST"</span>,</span><br><span class="line"><span class="keyword">async</span> : <span class="literal">true</span>,<span class="comment">//表示进行异步获取</span></span><br><span class="line">data:subData,<span class="comment">//提交的数据</span></span><br><span class="line">dataType : <span class="string">'json'</span>,</span><br><span class="line">contentType : <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>, <span class="comment">//contentType很重要   </span></span><br><span class="line">success : <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = $.parseJSON(result); </span><br><span class="line"><span class="comment">//在这里对返回的数据进行处理</span></span><br><span class="line">&#125;</span><br><span class="line">error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//请求失败执行这个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AJAX&quot;&gt;&lt;a href=&quot;#AJAX&quot; class=&quot;headerlink&quot; title=&quot;AJAX&quot;&gt;&lt;/a&gt;AJAX&lt;/h1&gt;&lt;h3 id=&quot;1-Ajax的作用&quot;&gt;&lt;a href=&quot;#1-Ajax的作用&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="前端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaScrpit" scheme="https://zhuyiting.xyz/tags/JavaScrpit/"/>
    
  </entry>
  
  <entry>
    <title>EL与JSTL表达式</title>
    <link href="https://zhuyiting.xyz/2018/01/30/EL%E4%B8%8EJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2018/01/30/EL与JSTL表达式/</id>
    <published>2018-01-30T06:15:00.000Z</published>
    <updated>2019-10-20T14:59:58.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式:"></a>EL表达式:</h4><p>EL表达式的功能:(让JSP编写更为简单)</p><ol><li>EL是Expression Language的简称，即表达式语言；</li><li>EL在JSP中使用，服务器会对其进行解析翻译，生成相应的Java代码；</li><li>EL的作用是用来在JSP页面输出动态内容，可以替代JSP中的表达式元素&lt;%=%&gt;</li></ol><p><strong>EL表达式的一般格式:</strong><br> <code>${EL表达式}</code><br>    例如:<code>${param.username}</code><br>    等同于:<code>&lt;%=request.getParameter(&quot;username&quot;)%&gt;</code></p><h4 id="EL表达式的内置对象"><a href="#EL表达式的内置对象" class="headerlink" title="EL表达式的内置对象:"></a>EL表达式的内置对象:</h4><p>其中</p><ul><li>2个内置对象为了方便输出请求参数： param/paramValues；<ul><li>内置对象param：用来输出请求参数的值，格式为${param.请求参数名字}</li><li>内置对象paramValues：用来获取一对多的参数值，返回一个数组。</li></ul></li><li>4个内置对象为了方便输出各个范围的属性： pageScope/ requestScope /sessionScope /applicationScope<ul><li>获取四个范围的属性数据</li><li>检索顺序：当不指定范围时，例如，${user.pwd}，将自动从pageScope开始查找，直到applicationScope，如果没查到，则什么也不显示</li></ul></li><li>2个与请求头有关的内置对象：header/headerValues<ul><li>内置对象header：用来输出输出某一个请求头的值，格式为${header.请求头名字}</li><li>内置对象headerValues：如果某个请求头的值有多个，则使用headerValues返回一个数组。</li></ul></li><li>2个其他内置对象：cookie/initParam<ul><li>内置对象cookie：用来获取cookie的值</li><li>内置对象initParam：用来输出上下文参数;</li></ul></li><li>1个特殊的内置对象pageContext<ul><li>内置对象pageContext：EL中的pageContext对象可以调用PageContext类中所有符合规范的getXxx方法</li></ul></li></ul><h4 id="使用-EL-取出内置对象的数据。"><a href="#使用-EL-取出内置对象的数据。" class="headerlink" title="使用 EL 取出内置对象的数据。"></a>使用 EL 取出内置对象的数据。</h4><ol><li>普通对象和对象属性。<br> 服务器端：<pre><code>`request.setAttribute(&quot;student&quot;, student);`</code></pre> 在浏览器上打印出服务器端绑定的数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; student &#125;  <span class="comment">&lt;!-- 相当于执行了 student.toString(); --&gt;</span></span><br><span class="line">$&#123; student.name &#125;  <span class="comment">&lt;!-- 相当于执行了 student.getName(); --&gt;</span></span><br><span class="line">$&#123; student.teacher.name &#125;  <span class="comment">&lt;!-- 相当于执行了 student.getTeacher().getName(); --&gt;</span></span><br></pre></td></tr></table></figure></li><li>数组中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] nameArray = <span class="keyword">new</span> String[]&#123;<span class="string">"Tom"</span>, <span class="string">"Lucy"</span>, <span class="string">"Lilei"</span>&#125;;</span><br><span class="line">request.setAttribute(“nameArray”,nameArray);</span><br><span class="line">Student[] students = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">students[<span class="number">0</span>] = stu1;</span><br><span class="line">students[<span class="number">1</span>] = stu2;</span><br><span class="line">students[<span class="number">2</span>] = stu3;</span><br><span class="line">request.setAttribute(“students”,students);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的数组数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123; nameArray[0] &#125;   <span class="comment">&lt;!-- Tom --&gt;</span></span><br><span class="line">$&#123; nameArray[1] &#125;   <span class="comment">&lt;!-- Lucy --&gt;</span></span><br><span class="line">$&#123; nameArray[2] &#125;   <span class="comment">&lt;!-- Lilei --&gt;</span></span><br><span class="line">$&#123; students[0].id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; students[1].name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">$&#123; students[2].teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure></li><li>List中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList=<span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">studentList.add(stu1);</span><br><span class="line">studentList.add(stu2);</span><br><span class="line">studentList.add(stu3);</span><br><span class="line">request.setAttribute(“studentList”,studentList);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的List数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; studentList[0].id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; studentList[1].name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">$&#123; studentList[2].teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure></li><li>Map中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Student&gt; studentMap = <span class="keyword">new</span> HashMap&lt;String, Student&gt;();</span><br><span class="line">studentMap.put(<span class="string">"Tom"</span>, stu1);</span><br><span class="line">studentMap.put(<span class="string">"Lucy"</span>, stu2);</span><br><span class="line">studentMap.put(<span class="string">"Lilei"</span>, stu3);</span><br><span class="line">request.setAttribute(“studentMap”,studentMap);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的Map数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; studentMap.Tom.id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; studentMap.Lucy.name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">   $&#123; studentMap.Lilei.teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符:"></a>EL运算符:</h4>EL中提供了多种运算符，可以对变量或常量进行运算，输出运算结果；<br>EL中的运算符包括：</li><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>其他运算符</li></ol><h4 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL:"></a>JSTL:</h4><p>JSTL是一套定义好的标签库，可以直接使用；<br>JSTL的全称是Jsp  Standard Tag Library，即JSP标准标签库；<br>JSTL包含很多标签，根据其作用可以分为：属性相关的标签、条件分支相关的标签、迭代标签、其他标签；<br>标签库包括标签处理器类及描述文件tld文件，JSTL也一样：</p><ul><li>使用JSTL首先需要下载相关的jar文件并保存到工程的lib目录下；在JSP中使用taglib指令引入需要使用的标签库；</li><li>forEach、set、if等是JSTL中常用的标签；</li><li>JSTL标签库的使用是为类弥补html表的不足，规范自定义标签的使用而诞生的。在告别modle1模式开发应用程序后，人们开始注重软件的分层设计，不希望在jsp页面中出现java逻辑代码，同时也由于自定义标签的开发难度较大和不利于技术标准化产生了自定义标签库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;EL表达式&quot;&gt;&lt;a href=&quot;#EL表达式&quot; class=&quot;headerlink&quot; title=&quot;EL表达式:&quot;&gt;&lt;/a&gt;EL表达式:&lt;/h4&gt;&lt;p&gt;EL表达式的功能:(让JSP编写更为简单)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EL是Expression Languag
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式</title>
    <link href="https://zhuyiting.xyz/2018/01/19/MVC%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2018/01/19/MVC模式/</id>
    <published>2018-01-19T06:15:00.000Z</published>
    <updated>2019-10-20T14:04:47.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MVC模式基本概念"><a href="#MVC模式基本概念" class="headerlink" title="MVC模式基本概念"></a>MVC模式基本概念</h4><p>MVC（Model-View-Controller）是一种软件架构设计模式，最初应用在桌面应用程序；</p><p>MVC模式将软件的代码按照模型（M）、视图（V）、控制器（C）三部分组织</p><p>MVC模式构建应用的优势:</p><ul><li>耦合性低：视图层和业务层分离，耦合性降低，可以独立修改；</li><li>重用性高：可以用不同的视图访问模型部分，实现在不同终端上访问应用；</li><li>可维护性高：视图与业务分离，降低了维护成本；</li></ul><h4 id="MVC模式中的三个角色"><a href="#MVC模式中的三个角色" class="headerlink" title="MVC模式中的三个角色:"></a>MVC模式中的三个角色:</h4><p>在控制器和视图之间共享数据:</p><ol><li>在控制器和视图之间，常常需要共享数据；例如从数据查出来的商品列表信息，需要从控制器发送到视图；</li><li>Servlet和JSP之间共享数据一般使用请求、会话、上下文范围的属性进行；</li><li>HttpServletRequest/HttpSession/ServletContext接口中都定义了存取、查询、删除属性的方法【前面已经学习过】；</li><li>使用原则：尽量用范围小的属性，即，请求范围内共享即可就用请求，以此类推；否则会造成资源浪费，降低安全性；</li></ol><h4 id="redirect-forward-include几种跳转方式的功能与差异"><a href="#redirect-forward-include几种跳转方式的功能与差异" class="headerlink" title="redirect\forward\include几种跳转方式的功能与差异:"></a>redirect\forward\include几种跳转方式的功能与差异:</h4><p>MVC模式中，控制器和视图之间需要进行跳转，Servlet规范中，有三种跳转方式：</p><ol><li>redirect：调用响应接口的sendRedirect方法，响应重定向，相当于重新请求新的资源，当前请求对象不会到目标资源；</li><li>forward: 调用请求转发器接口的forward方法，请求转发，将当前的请求、响应对象转发到目标资源；(最常用)</li><li>include：调用请求转发器接口的include方法，动态包含，将目标资源的请求、响应对象包含到当前资源；</li></ol><h4 id="forword带来的重复提交问题"><a href="#forword带来的重复提交问题" class="headerlink" title="forword带来的重复提交问题;"></a>forword带来的重复提交问题;</h4><ul><li><p>使用forward转发请求后，再次刷新当前页面，会进行重复提交；</p><ul><li>例如：使用LoginServlet进行登录，成功后跳转到loginsuccess.jsp页面：</li></ul></li><li><p>刷新当前页面，再次进行了登录</p></li><li><p>为了能够解决重复提交问题，关键在于：能够标志一次提交，从而识别出该提交已经处理；</p><ol><li>步骤一：在JSP中记录一个随机数，称为令牌（token），存储在session中<br><code>&lt;%session.setAttribute(&quot;token&quot;,System.nanoTime())+&quot;&quot;%&gt;</code></li><li>步骤二：将token值作为表单的一个隐藏域<br><code>&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;)%&gt;&quot; &gt;</code></li><li>步骤三：在LoginServlet中获取token值，并进行判断 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出存储在请求参数中的token</span></span><br><span class="line">String requestToken = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="comment">//取出存储在session中的token</span></span><br><span class="line">String sessionToken = (String)request.getSession().getAttribute(<span class="string">"token"</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li>步骤四：将token值从会话中删除 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getSession().removeAttribute(<span class="string">"token"</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MVC模式基本概念&quot;&gt;&lt;a href=&quot;#MVC模式基本概念&quot; class=&quot;headerlink&quot; title=&quot;MVC模式基本概念&quot;&gt;&lt;/a&gt;MVC模式基本概念&lt;/h4&gt;&lt;p&gt;MVC（Model-View-Controller）是一种软件架构设计模式，最初应用
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>系统开发和运行知识</title>
    <link href="https://zhuyiting.xyz/2018/01/13/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhuyiting.xyz/2018/01/13/系统开发和运行知识/</id>
    <published>2018-01-13T14:40:00.000Z</published>
    <updated>2019-10-19T00:10:01.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件工程、软件过程改进和软件开发项目管理知识"><a href="#1-软件工程、软件过程改进和软件开发项目管理知识" class="headerlink" title="1. 软件工程、软件过程改进和软件开发项目管理知识"></a>1. 软件工程、软件过程改进和软件开发项目管理知识</h3><ul><li>软件工程知识</li><li>软件开发生命周期各阶段的目标和任务</li><li>软件开发项目管理基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具</li><li>主要的软件开发方法（生命周期法、原型法、面向对象法、CASE）</li><li>软件开发工具与环境知识</li><li>软件过程改进知识</li><li>软件质量管理知识</li><li>软件开发过程评估、软件能力成熟评估基础知识<h3 id="2-系统分析基础知识"><a href="#2-系统分析基础知识" class="headerlink" title="2. 系统分析基础知识"></a>2. 系统分析基础知识</h3></li><li>系统分析的目的和任务</li><li>结构化分析方法（数据流图（DFD）、数据字典（DD）、实体关系图（ERD）、描述加工处理的结构化语言）</li><li>统一建模语言（UML）</li><li>系统规格说明书<h3 id="3-系统设计知识"><a href="#3-系统设计知识" class="headerlink" title="3. 系统设计知识"></a>3. 系统设计知识</h3></li><li>系统设计的目的和任务</li><li>结构化设计方法和工具（系统流程图、HIPO图、控制流程图）</li><li>系统总体结构设计（总体布局、设计原则、模块结构设计、数据存储设计、系统配置方案）</li><li>系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计）</li><li>系统设计说明书<h3 id="4-系统实施知识"><a href="#4-系统实施知识" class="headerlink" title="4. 系统实施知识"></a>4. 系统实施知识</h3></li><li>系统实施的主要任务</li><li>结构化程序设计、面向对象程序设计、可视化程序设计</li><li>程序设计风格</li><li>程序设计语言的选择</li><li>系统测试的目的、类型，系统测试方法（黑盒测试、白盒测试、灰盒测试）</li><li>测试设计和管理（错误曲线、错误排除、收敛、注入故障、测试用例设计、系统测试报告）</li><li>系统转换基础知识<h3 id="5-系统运行和维护知识"><a href="#5-系统运行和维护知识" class="headerlink" title="5. 系统运行和维护知识"></a>5. 系统运行和维护知识</h3></li><li>系统运行管理基础知识</li><li>系统维护基础知识</li><li>系统评价基础知识<h3 id="6-面向对象开发方法"><a href="#6-面向对象开发方法" class="headerlink" title="6. 面向对象开发方法"></a>6. 面向对象开发方法</h3></li><li>面向对象开发概念（类、对象、属性、封装性、继承性、多态性、对象之间的引用）</li><li>面向对象开发方法的优越性以及有效领域</li><li>面向对象设计方法（体系结构、类的设计、用户接口设计）</li><li>面向对象实现方法（选择程序设计语言、类的实现、方法的实现、用户接口的实现、准备测试数据）</li><li>面向对象程序设计语言（如C++、Java、Visual、Bsasic、Visual C++）的基本机制</li><li>面向对象数据库、分布式对象的概念</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;a href=&quot;#1-软件工程、软件过程改进和软件开发项目管理知识&quot; class=&quot;headerlink&quot; title=&quot;1. 软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;/a&gt;1. 软件工程、软件过程改
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统知识</title>
    <link href="https://zhuyiting.xyz/2017/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhuyiting.xyz/2017/12/30/计算机系统知识/</id>
    <published>2017-12-30T14:36:00.000Z</published>
    <updated>2019-10-19T00:09:45.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-硬件知识"><a href="#1-硬件知识" class="headerlink" title="1. 硬件知识"></a>1. 硬件知识</h3><h4 id="1-1-计算机系统的组成、体系结构分类及特性"><a href="#1-1-计算机系统的组成、体系结构分类及特性" class="headerlink" title="1.1 计算机系统的组成、体系结构分类及特性"></a>1.1 计算机系统的组成、体系结构分类及特性</h4><ul><li>CPU和存储器的组成、性能和基本工作原理</li><li>常用I/O设备、通信设备的性能，以及基本工作原理</li><li>I/O接口的功能、类型和特性</li><li>I/O控制方式（中断系统、DMA、I/O处理机方式）</li><li>CISC/RISC，流水线操作，多处理机，并行处理<h4 id="1-2-存储系统"><a href="#1-2-存储系统" class="headerlink" title="1.2 存储系统"></a>1.2 存储系统</h4></li><li>主存-Cache存储系统的工作原理</li><li>虚拟存储器基本工作原理，多级存储体系的性能价格</li><li>RAID类型和特性<h4 id="1-3-安全性、可靠性与系统性能评测基础知识"><a href="#1-3-安全性、可靠性与系统性能评测基础知识" class="headerlink" title="1.3 安全性、可靠性与系统性能评测基础知识"></a>1.3 安全性、可靠性与系统性能评测基础知识</h4></li><li>诊断与容错</li><li>系统可靠性分析评价</li><li>计算机系统性能评测方式<h3 id="2-软件知识"><a href="#2-软件知识" class="headerlink" title="2. 软件知识"></a>2. 软件知识</h3><h4 id="2-1-操作系统知识"><a href="#2-1-操作系统知识" class="headerlink" title="2.1 操作系统知识"></a>2.1 操作系统知识</h4></li><li>操作系统的内核（中断控制）、进程、线程概念</li><li>处理机管理（状态转换、共享与互斥、分时轮转、抢占、死锁）</li><li>存储管理（主存保护、动态连接分配、分段、分页、虚存）</li><li>设备管理（I/O控制、假脱机）</li><li>文件管理（文件目录、文件组织、存取方法、存取控制、恢复处理）</li><li>作业管理（作业调度、作业控制语言（JCL）、多道程序设计）</li><li>汉字处理，多媒体处理，人机界面</li><li>网络操作系统和嵌入式操作系统基础知识</li><li>操作系统的配置<h4 id="2-2-程序设计语言和语言处理程序的知识"><a href="#2-2-程序设计语言和语言处理程序的知识" class="headerlink" title="2.2 程序设计语言和语言处理程序的知识"></a>2.2 程序设计语言和语言处理程序的知识</h4></li><li>汇编、编译、解释系统的基础知识和基本工作原理</li><li>程序设计语言的基本成分：数据、运算、控制和传输，过程（函数）调用</li><li>各类程序设计语言主要特点和适用情况<h3 id="3-计算机网络知识"><a href="#3-计算机网络知识" class="headerlink" title="3. 计算机网络知识"></a>3. 计算机网络知识</h3></li><li>网络体系结构（网络拓扑、OSI/RM、基本的网络协议）</li><li>传输介质、传输技术、传输方法、传输控制</li><li>常用网络设备和各类通信设备</li><li>Client/Server结构、Browser/Server结构</li><li>LAN拓扑，存取控制，LAN的组网，LAN间连接，LAN-WAN连接</li><li>因特网基础知识以及应用</li><li>网络软件</li><li>网络管理</li><li>网络性能分析<h3 id="4-数据库知识"><a href="#4-数据库知识" class="headerlink" title="4. 数据库知识"></a>4. 数据库知识</h3></li><li>数据库管理系统的功能和特征</li><li>数据库模型（概念模式、外模式、内模式）</li><li>数据模型，ER图，第一范式、第二范式、第三范式</li><li>数据操作（集合运算和关系运算）</li><li>数据库语言（SQL）</li><li>数据库的控制功能（并发控制、恢复、安全性、完整性）</li><li>数据仓库和分布式数据库基础知识<h3 id="5-多媒体知识"><a href="#5-多媒体知识" class="headerlink" title="5. 多媒体知识"></a>5. 多媒体知识</h3></li><li>多媒体系统基础知识，多媒体设备的性能特性，常用多媒体文件格式</li><li>简单图形的绘制，图像文件的处理方法</li><li>音频和视频信息的应用</li><li>多媒体应用开发过程<h3 id="6-系统性能知识"><a href="#6-系统性能知识" class="headerlink" title="6. 系统性能知识"></a>6. 系统性能知识</h3></li><li>性能指标（响应时间、吞吐量、周转时间）和性能设计</li><li>性能测试和性能评估</li><li>可靠性指标及计算、可靠性设计</li><li>可靠性测试和可靠性评估<h3 id="7-计算机应用基础知识"><a href="#7-计算机应用基础知识" class="headerlink" title="7. 计算机应用基础知识"></a>7. 计算机应用基础知识</h3></li><li>信息管理、数据处理、辅助设计、自动控制、科学计算、人工智能等基础知识</li><li>远程通信服务基础知识</li><li>常用应用系统</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-硬件知识&quot;&gt;&lt;a href=&quot;#1-硬件知识&quot; class=&quot;headerlink&quot; title=&quot;1. 硬件知识&quot;&gt;&lt;/a&gt;1. 硬件知识&lt;/h3&gt;&lt;h4 id=&quot;1-1-计算机系统的组成、体系结构分类及特性&quot;&gt;&lt;a href=&quot;#1-1-计算机系统的组成、
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JSP扩展</title>
    <link href="https://zhuyiting.xyz/2017/12/29/JSP%E6%89%A9%E5%B1%95/"/>
    <id>https://zhuyiting.xyz/2017/12/29/JSP扩展/</id>
    <published>2017-12-29T02:25:00.000Z</published>
    <updated>2019-10-20T14:04:30.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象:"></a>JSP内置对象:</h4><ul><li>内置对象指的是服务器已经创建好的对象，可以直接使用；</li><li>9个内置对象:<ul><li>request</li><li>response</li><li>out<ul><li>out的类型是JspWriter</li><li>out可以用来输出内容到客户端，但是程序员一般不会使用，因为直接使用&lt;%=%&gt;即可以实现输出；</li></ul></li><li>page<ul><li>page即当前类对象</li><li>page也很少使用，与this相同</li></ul></li><li>pageContext<ul><li>其他多数内置对象都是通过它获得  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">        application = pageContext.getServletContext();</span><br><span class="line">        config = pageContext.getServletConfig();</span><br><span class="line">        session = pageContext.getSession();</span><br><span class="line">        out = pageContext.getOut();</span><br><span class="line">    + pageContext对象是JSP中一个非常重要的对象，是`javax.servlet.jsp.PageContext`类型的对象，指的是页面的上下文，封装了其他的内置对象，同时代表的是四大作用域【页面、请求、会话、上下文】中的页面作用域，也可以在页面上下文范围添加属性，`PageContext`中与属性相关方法如下：</span><br><span class="line"></span><br><span class="line">        |方法声明|方法描述|</span><br><span class="line">        |:---:|:---:|</span><br><span class="line">        |<span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(java.lang.String name, java.lang.Object o)</span> |将任意类型对象设置为属性，指定一个名字；|</span></span><br><span class="line"><span class="function">        |java.lang.Object <span class="title">getAttribute</span><span class="params">(java.lang.String name)</span>|通过属性的名字，获取属性的值；|</span></span><br><span class="line"><span class="function">        |<span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(java.lang.String name)</span>|通过属性的名字，删除属性；|</span></span><br><span class="line"><span class="function">    + session</span></span><br><span class="line"><span class="function">+ session是JSP中的另一个内置对象，是`HttpSession`类型的对象，可以在JSP中调用HttpSession接口中的任何方法；默认存在</span></span><br><span class="line"><span class="function">+ application</span></span><br><span class="line"><span class="function">+ application是JSP中的另一个内置对象，是`ServletContext`类型的对 象，可以在JSP中调用`ServlletContext`接口中的任何方法；</span></span><br><span class="line"><span class="function">+ exception</span></span><br><span class="line"><span class="function">+ 内置对象exception比较特殊，默认情况下不存在；只有当JSP中使用指令指定该页面作为错误页面使用时才会翻译生成该内置对象。</span></span><br><span class="line"><span class="function">+ config</span></span><br><span class="line"><span class="function">+ 在JSP中可以直接使用config对象调用ServletConfig接口中任意方法，例如，可以在web.xml中对JSP配置初始化参数，与前面学习的Servlet初始化参数相同的含义：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#### 指令与动作:</span></span><br><span class="line"><span class="function">+ JSP可以通过指令元素而影响容器翻译生成Java类的整体结构；</span></span><br><span class="line"><span class="function">+ 指令的语法为：`&lt;%@ directive </span>&#123;attr=“value”&#125;* %&gt;`；</span><br><span class="line">+ 其中，directive为指令名，attr指该指令对应的属性名，一个指令可能有多个属性；</span><br><span class="line">JSP中常用的指令有三个：page、include、taglib，前两个常用</span><br><span class="line">+ **page指令**作用于整个JSP页面，可以将指令放在JSP页面任何一个位置;</span><br><span class="line">  + <span class="keyword">import</span>属性:用来引入JSP文件需要使用的类；</span><br><span class="line">+ 可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用<span class="keyword">import</span>；</span><br><span class="line">+ 值得注意的是，<span class="keyword">import</span>是page指令中唯一一个可以在一个JSP文件中多次出现的属性，其他属性在一个JSP文件中只能出现一次；</span><br><span class="line">  + pageEncoding属性:用来设置JSP文件的页面编码格式；</span><br><span class="line">+ page指令的session属性：用来设置JSP页面是否生成session对象。该属性默认值为<span class="keyword">true</span>，可以设置成<span class="keyword">false</span>。</span><br><span class="line">+ session属性值设置为<span class="keyword">false</span>后，该JSP翻译生成的类中将没有内置对象session，该JSP不参与会话。</span><br><span class="line">  + errorPage属性:设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面；</span><br><span class="line">+ 访问该页面将发生数学异常，而且并没有对异常进行处理，那么将跳转到错误页面error.jsp</span><br><span class="line">  + isErrorPage属性默认值是<span class="keyword">false</span>，可以设置为<span class="keyword">true</span>。在JSP的错误页面中，将isErrorPage设置为<span class="keyword">true</span>，则该页面翻译生成的Java类中，将生成exception内置对象。在error.jsp中加入代码：`&lt;%<span class="meta">@page</span> isErrorPage=<span class="string">"true"</span>%&gt;`</span><br><span class="line">+ 上述代码将error.jsp页面设置为错误页面，所以，在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象</span><br><span class="line">    + 注意：即使一个页面没有设置isErrorPage=“<span class="keyword">true</span>”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。</span><br><span class="line"></span><br><span class="line">+ **include指令**是JSP中另外一个常用指令，用来静态包含其他页面；</span><br><span class="line">  + 在翻译期间，把包含的页面也翻译到当前页面的Java文件中，也就是Java源文件即实现“二合一”；</span><br><span class="line">  + `&lt;%<span class="meta">@include</span> file=<span class="string">"copyright.jsp"</span>%&gt;`</span><br><span class="line"></span><br><span class="line">+ **include动作标签**:</span><br><span class="line">  + JSP规范中定义了一系列的标准动作。Web容器按照规范进行了实现，可以解析并执行标准动作；</span><br><span class="line">  + 标准动作使用标准的XML语法。</span><br><span class="line">    ```jsp</span><br><span class="line">    &lt;jsp:action_name attribute1=<span class="string">"value1"</span> attribute2=<span class="string">"value2"</span>&gt;</span><br><span class="line">    &lt;/jsp:action_name&gt;</span><br><span class="line">    ```</span><br><span class="line">  + 其中action_name表示标准动作的名字，attribute1和attribute2是标准动作的若干个属性；</span><br><span class="line">  + include标准动作:`&lt;jsp:include&gt;`是动态包含，即在运行期访问被包含的页面，并将响应结果同包含页面的响应结果合并，生成最终响应。类似在Servlet中调用`RequestDispatcher`的`include`方法进行包含。</span><br><span class="line"></span><br><span class="line">+ **include标准动作和include指令的差异**;</span><br><span class="line">  + include标准动作与include指令都是实现包含其他页面的功能;</span><br><span class="line">  + include标准动作的属性是page，实现动态包含，发生在请求阶段；</span><br><span class="line">  + include指令的属性是file，实现静态包含，发生在翻译阶段。</span><br><span class="line"></span><br><span class="line">+ include其他动作</span><br><span class="line">  + forward动作：在JSP页面中进行请求转发，如下代码所示：</span><br></pre></td></tr></table></figure>  &lt;jsp:forward page=“loginsuccess.jsp”&gt;<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ param动作：往往作为子动作使用，为forward和include动作传递参数，如下代码所示：</span><br></pre></td></tr></table></figure>  &lt;jsp:forward page=”copyright.jsp”&gt;<br>  &lt;jsp:param name=”author” value=”etc”/&gt;<pre><code>&lt;/jsp:forward&gt;</code></pre>  &lt;jsp:include page=”copyright.jsp”&gt;     <pre><code>&lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt;</code></pre>  <br>  ```</li></ul></li><li>上述代码使用param为forward和include动作传递参数，参数将被作为请求参数传递。</li><li>使用标准动作时，一定注意正确结束标准动作，如<code>&lt;jsp:include&gt;</code>是标准动作的开始，一定要对应结束标记，如<code>&lt;/jsp:include&gt;</code>。</li></ul></li></ul><h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>JavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类，这些类遵循一定的编码规范：</p><ol><li>必须是public类 ；</li><li>必须有一个无参的public的构造方法； </li><li>返回属性的方法为getXxxx()格式 ；</li><li>设置属性的方法为setXxx(形式参数)格式；</li></ol><p>JSP中还提供了3个与JavaBean有关的动作；</p><ol><li>useBean动作：<code>&lt;jsp:useBean  id=“” class=“” scope=“”&gt;</code><ul><li>useBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性；</li><li>Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope内的一个属性，属性名为id；</li><li>其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。</li></ul></li><li>setProperty 动作：<code>&lt;jsp:setProperty name=“” property=“” param|value=“”/&gt;</code><ul><li>setProperty标准动作可以用来对JavaBean对象的属性赋值，替代调用setXxxx方法；</li><li>setProperty的name属性表示JavaBean对象的id值，property表示需要调用的setXxx方法中的Xxx部分，将首字母变小写。比如需要调用setCustname方法，则property即为Custname首字母变小写，即custname；</li><li>如果setXxx方法的参数是某一个请求参数的值，则使用param属性指定请求参数名字即可；</li><li>如果setXxx方法的参数是一个常量，则使用value属性指定即可。</li><li>同时，setProperty标准动作可以对一些常见数据类型直接转换，如字符串与Integer的转换就可以自动进行；</li></ul></li><li>getProperty动作：&lt;jsp:getProperty  name=”” property=””/&gt;<ul><li>getProperty标准动作用来调用JavaBean对象的getXxx方法，将其返回值在当前位置输出。</li><li>name是JavaBean对象的id值，property的值是getXxx方法中的Xxx部分，首字母变小写。假设需要调用getAddress方法显示其返回值，那么property的值就是Address的首字母变小写，即address。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JSP内置对象&quot;&gt;&lt;a href=&quot;#JSP内置对象&quot; class=&quot;headerlink&quot; title=&quot;JSP内置对象:&quot;&gt;&lt;/a&gt;JSP内置对象:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内置对象指的是服务器已经创建好的对象，可以直接使用；&lt;/li&gt;
&lt;li&gt;9个内置对象
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学基础</title>
    <link href="https://zhuyiting.xyz/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2017/12/27/计算机科学基础/</id>
    <published>2017-12-27T14:17:00.000Z</published>
    <updated>2019-10-20T00:44:59.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数制及其转换"><a href="#1-数制及其转换" class="headerlink" title="1. 数制及其转换"></a>1. 数制及其转换</h4><p>• 二进制、十进制和十六进制等常用制数制及其相互转换</p><h4 id="2-数据的表示"><a href="#2-数据的表示" class="headerlink" title="2. 数据的表示"></a>2. 数据的表示</h4><p>• 数的表示（原码、反码、补码、移码表示，整数和实数的机内表示，精度和溢出）<br>• 非数值表示（字符和汉字表示、声音表示、图像表示）<br>• 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码）</p><h4 id="3-算术运算和逻辑运算"><a href="#3-算术运算和逻辑运算" class="headerlink" title="3. 算术运算和逻辑运算"></a>3. 算术运算和逻辑运算</h4><p>• 计算机中的二进制数运算方法<br>• 逻辑代数的基本运算和逻辑表达式的化简</p><h4 id="4-数学基础知识"><a href="#4-数学基础知识" class="headerlink" title="4.  数学基础知识"></a>4.  数学基础知识</h4><p>• 命题逻辑、谓词逻辑、形式逻辑的基础知识<br>• 常用数值计算（误差、矩阵和行列式、近似求解方程、插值、数值积分）<br>• 排列组合、概率论应用、应用统计（数据的统计分析）<br>• 运算基本方法（预测与决策、线性规划、网络图、模拟）</p><h4 id="5-常用数据结构"><a href="#5-常用数据结构" class="headerlink" title="5. 常用数据结构"></a>5. 常用数据结构</h4><p>• 数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、线索树、堆）、图等的定义、存储和操作<br>• Hash（存储地址计算，冲突处理）</p><h4 id="6-常用算法"><a href="#6-常用算法" class="headerlink" title="6. 常用算法"></a>6. 常用算法</h4><p>• 排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法<br>• 算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-数制及其转换&quot;&gt;&lt;a href=&quot;#1-数制及其转换&quot; class=&quot;headerlink&quot; title=&quot;1. 数制及其转换&quot;&gt;&lt;/a&gt;1. 数制及其转换&lt;/h4&gt;&lt;p&gt;• 二进制、十进制和十六进制等常用制数制及其相互转换&lt;/p&gt;
&lt;h4 id=&quot;2-数据的
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Servlet上下文</title>
    <link href="https://zhuyiting.xyz/2017/12/25/JSP%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://zhuyiting.xyz/2017/12/25/JSP上下文/</id>
    <published>2017-12-25T10:47:00.000Z</published>
    <updated>2019-10-20T14:04:04.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文:"></a>什么是上下文:</h4><p>上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个上下文对象.</p><ul><li>当服务器启动的时候，就会为每一个应用创建一个上下文对象；</li><li>当服务器关闭的时候，上下文对象就销毁；</li></ul><h4 id="Servlet中的ServletContext接口"><a href="#Servlet中的ServletContext接口" class="headerlink" title="Servlet中的ServletContext接口:"></a>Servlet中的ServletContext接口:</h4><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">java.io.InputStream getResourceAsStream(java.lang.String path)</td><td align="center">将path所代表的资源以输入流返回，可以进一步进行读操作；可以用来读取服务器端的文件；</td></tr><tr><td align="center">RequestDispatcher getRequestDispatcher(java.lang.String path)</td><td align="center">返回RequestDispatcher 对象，路径是相对于上下文路径的；</td></tr></tbody></table><h4 id="上下文获取方法"><a href="#上下文获取方法" class="headerlink" title="上下文获取方法:"></a>上下文获取方法:</h4><p>Servlet规范中的多个接口中都定义了<code>getServletContext</code>方法获得上下文对象</p><h4 id="上下文参数"><a href="#上下文参数" class="headerlink" title="上下文参数:"></a>上下文参数:</h4><ul><li>在web.xml中可以配置上下文参数，使用<code>ServletContext</code>中的<code>getInitParameter</code>方法可以获取该参数；【之前学习过的Servlet初始化参数，只能在当前Servlet中使用】</li><li>上下文参数存储在上下文对象，所以应用下所有组件都可以使用；</li><li>获取上下文参数：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>version<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回ServletContext对象</span></span><br><span class="line">ServletContext ctxt=<span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//获取上下文参数</span></span><br><span class="line">String version=ctxt.getinitParameter(<span class="string">"version"</span>);</span><br><span class="line">System.out.println(<span class="string">"上下文参数version的值:"</span>+version);</span><br></pre></td></tr></table></figure></li></ul><h4 id="利用ServletContext在应用中共享数据"><a href="#利用ServletContext在应用中共享数据" class="headerlink" title="利用ServletContext在应用中共享数据:"></a>利用ServletContext在应用中共享数据:</h4><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">void setAttribute(java.lang.String name, java.lang.Object o)</td><td align="center">将任意类型对象设置为上下文属性，指定一个名字</td></tr><tr><td align="center">java.lang.Object getAttribute(java.lang.String name)</td><td align="center">通过属性的名字，获取属性的值；</td></tr><tr><td align="center">void removeAttribute(java.lang.String name)</td><td align="center">通过属性的名字，删除属性；</td></tr></tbody></table><h4 id="四大作用范围"><a href="#四大作用范围" class="headerlink" title="四大作用范围:"></a>四大作用范围:</h4><p>在Web应用中，有四大作用域范围</p><ul><li>页面范围<code>PageContext</code>：一个Servlet或JSP文件；</li><li>请求范围<code>ServletRequest</code>：一次请求中可以访问多个Servlet或JSP； 访问的Servlet或JSP能够包含其他资源；</li><li>会话范围<code>HttpSession</code>：一次会话中可以包含多个请求；</li><li>上下文范围<code>ServletContext</code>：上下文包含所有会话；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是上下文&quot;&gt;&lt;a href=&quot;#什么是上下文&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文:&quot;&gt;&lt;/a&gt;什么是上下文:&lt;/h4&gt;&lt;p&gt;上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>软件开发基础</title>
    <link href="https://zhuyiting.xyz/2017/12/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2017/12/25/软件开发基础/</id>
    <published>2017-12-25T07:18:00.000Z</published>
    <updated>2019-10-20T00:45:13.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算机工作的简单过程"><a href="#计算机工作的简单过程" class="headerlink" title="计算机工作的简单过程:"></a>计算机工作的简单过程:</h4><ol><li>将程序和数据通关输入设备送入存储器(可以理解为内存)</li><li>计算机从存储器中取出程序指令送到控制器(可以理解为CPU)</li><li>控制器更具指令的含义发出相应的命令(如加法,减法),将存储单元中存放的操作数据取出送往运算器进行运算,再把运算结果送回存储器指定的单元中<h4 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件:"></a>什么是软件:</h4> 软件=程序+文档</li></ol><h4 id="不同类型语言的编译与运行"><a href="#不同类型语言的编译与运行" class="headerlink" title="不同类型语言的编译与运行:"></a>不同类型语言的编译与运行:</h4><p>==编译型==语言是先把源程序的每一条语句都编译成机器语言,并保存成二进制文件,运行时计算机可以直接以机器语言来运行此程序,速度较快;<br>==解释型==语言在执行程序时才一条条的解释成机器语言给计算机来执行,所以运行速度会受到影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算机工作的简单过程&quot;&gt;&lt;a href=&quot;#计算机工作的简单过程&quot; class=&quot;headerlink&quot; title=&quot;计算机工作的简单过程:&quot;&gt;&lt;/a&gt;计算机工作的简单过程:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;将程序和数据通关输入设备送入存储器(可以理解为内存)&lt;/li
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>会话跟踪(前后端交互)</title>
    <link href="https://zhuyiting.xyz/2017/12/23/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA(%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92)/"/>
    <id>https://zhuyiting.xyz/2017/12/23/会话跟踪(前后端交互)/</id>
    <published>2017-12-23T06:01:00.000Z</published>
    <updated>2019-10-20T14:03:46.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="会话的概念和作用"><a href="#会话的概念和作用" class="headerlink" title="会话的概念和作用:"></a>会话的概念和作用:</h4><ul><li><strong>会话</strong>:    对于Web应用来说,会话就是浏览器与服务器之间的一次连续的通讯过程.</li><li>HTTP协议是无状态的，也就是说，一次请求结束后，HTTP协议就不再记录相关信息；</li><li>而实际应用中，却常常需要记住一些状态信息；</li><li>==会话跟踪==技术就是能够跟踪<strong>客户端和服务端的交互</strong>,保存和记忆相关信息,保存请求的状态信息.</li></ul><h4 id="常用的四种会话跟踪技术"><a href="#常用的四种会话跟踪技术" class="headerlink" title="常用的四种会话跟踪技术:"></a>常用的四种会话跟踪技术:</h4><ul><li><strong>URL方式</strong>：需要保存的信息直接追加到URL后，例如：<code>http://127.0.0.1:8080/chapter03/viewList?pageNo=12</code></li><li><strong>隐藏域方式</strong>：可以使用表单中的隐藏域保存相关信息， 例如：<br><code>&lt;input type=&quot;hidden&quot; name=“status&quot; value=“true&quot;&gt;</code></li><li><strong>Cookie方式</strong>：将状态信息保存到客户端，服务器能够获得相关信息进行分析，从而生成对客户端的响应；例如简化登录功能就可以使用Cookie实现；</li><li><strong>Session方式</strong>：将状态信息保存到服务器的会话对象中，通过唯一标记的ID值与客户端进行绑定使用；例如访问控制功能就可以使用Session实现；</li></ul><h4 id="Cookie的功能和特点"><a href="#Cookie的功能和特点" class="headerlink" title="Cookie的功能和特点:"></a>Cookie的功能和特点:</h4><ul><li>Cookie是一段保存在客户端的小文本；能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪到用户的状态；</li><li>Cookie包含一系列属性:如:<ul><li><strong>name</strong>：cookie的名字，每个cookie都有一个名字；<ul><li><strong>content</strong>：cookie的值，与名字一起作为键值对形式存在；</li><li><strong>domain</strong>：域，该cookie的域名，例如csdn.net，说明当前cookie来自csdn.net;</li><li><strong>path</strong>：路径，访问csdn.net下该路径时，当前cookie将被发送；</li><li><strong>created</strong>：cookie被创建的时间；</li><li><strong>Expired</strong>：cookie失效的时间；</li><li><strong>最大生命时间</strong>：失效时间和创建时间的时间差，就是cookie的最大生命时间，超过该时间，cookie将失效，不再被发送到相应的域地址；</li></ul></li></ul></li></ul><h4 id="创建cookie-设置cookie属性"><a href="#创建cookie-设置cookie属性" class="headerlink" title="创建cookie,设置cookie属性:"></a>创建cookie,设置cookie属性:</h4><p>Servlet规范中定了Cookie类，创建该类对象就可以创建Cookie，并可以调用其中方法为Cookie设置属性；</p><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">Cookie(java.lang.String name, java.lang.String value)</td><td align="center">创建Cookie对象，指定名字和对应的值；</td></tr><tr><td align="center">void setMaxAge(int expiry)</td><td align="center">设置最大生命时间（秒），如果不设置，当前浏览器关闭，cookie即失效；</td></tr><tr><td align="center">void setValue(java.lang.String newValue)</td><td align="center">设置Cookie的值；</td></tr><tr><td align="center">setDomain(java.lang.String domain)</td><td align="center">设置cookie的域名；</td></tr></tbody></table><p>cookie创建好后并不能存储到客户端,要将cookie保存到客户端,必须添加到响应对象中,响应接口中定义了Cookie的方法:<br>|方法声明|方法描述|<br>|:—:|:—:|<br>|void addCookie(Cookie cookie)|将Cookie对象保存到相应的响应对象中；|</p><p>当访问相同域名及路径时,没有超过有效时间的cookie将自动通关请求发送到网站;</p><p>Servlet在请求接口中定义了获取cookie的方法:<br>|方法声明|方法描述|<br>|:—:|:—:|<br>|Cookie[] getCookies()|获取请求中的所有Cookie对象，返回数组；|</p><h4 id="Session简介"><a href="#Session简介" class="headerlink" title="Session简介:"></a>Session简介:</h4><ul><li>Session是会话跟踪的另一种实现手段；</li><li>Session是存储在服务器上的对象，该对象由服务器创建并维护；</li><li>服务器为客户端与服务器的每一次会话过程都创建并维护一个Session对象；每个服务器对Session的创建和维护的底层实现有所区别；</li></ul><h5 id="session创建的时间"><a href="#session创建的时间" class="headerlink" title="session创建的时间:"></a>session创建的时间:</h5><p>一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用 <code>HttpServletRequest.getSession(true)</code>这样的语句时才被创建，注意如果JSP没有显示的使用 <code>&lt;% @page session=”false”%&gt;</code> 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句 <code>HttpSession session = HttpServletRequest.getSession(true);</code>这也是JSP中隐含的 session对象的来历。 </p><p>由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。</p><h5 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期:"></a>session的生命周期:</h5><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。 </p><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;会话的概念和作用&quot;&gt;&lt;a href=&quot;#会话的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;会话的概念和作用:&quot;&gt;&lt;/a&gt;会话的概念和作用:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会话&lt;/strong&gt;:    对于Web应用来说,会话就是
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>JSP</title>
    <link href="https://zhuyiting.xyz/2017/12/15/JSP/"/>
    <id>https://zhuyiting.xyz/2017/12/15/JSP/</id>
    <published>2017-12-15T06:37:00.000Z</published>
    <updated>2019-10-20T14:03:32.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h4><p>JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件。翻译和编译的过程遵守Servlet规范，因此说==JSP的本质也是Servlet==；</p><p>html和jsp的表头不一样，这个是JSP的头<code>&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;</code>在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。</p><p><u><strong>简单说，jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。</strong></u></p><h4 id="为什么要用JSP"><a href="#为什么要用JSP" class="headerlink" title="为什么要用JSP:"></a>为什么要用JSP:</h4><p>Servlet生成动态页面比较繁琐，使用JSP生成动态页面比较便捷，因为其中的静态内容可以使用HTML生成；</p><h4 id="JSP元素"><a href="#JSP元素" class="headerlink" title="JSP元素:"></a>JSP元素:</h4><ul><li><p>脚本元素可以用来包含任意Java代码,格式为：<code>&lt;%Java代码%&gt;</code></p><ul><li>服务器翻译脚本元素时，将把其中Java代码直接翻译到<code>jspService</code>方法中，如果语法错误，将在浏览器中提示错误；</li></ul></li><li><p>表达式元素用来向页面输出动态内容;格式为：<code>&lt;%=Java代码%&gt;</code></p><ul><li>服务器翻译表达式元素时，将把其中Java代码部分的返回值使用out.write语句输出</li></ul></li><li><p>模块元素指JSP中静态HTML或者XML内容</p></li><li><p>注释元素有三种情况：</p><ul><li>格式为<code>&lt;%--JSP注释--%&gt;</code>；JSP的注释只有在源代码中可见，翻译时已经忽略；</li><li>在JSP中，除了使用JSP注释外，还可以使用HTML注释，<code>&lt;!--HTML注释--&gt;</code>，HTML注释会被返回到客户端，但是不显示到页面中；</li><li>JSP中的Java代码部分，可以使用Java注释；Java注释会翻译到.java文件中，但是编译时忽略；</li></ul></li><li><p>声明元素:</p><ul><li>如果需要在JSP文件中定义类的成员变量或方法，可以使用声明元素，格式为<code>&lt;%! 声明语句%&gt;</code>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">private</span> String path=<span class="string">"WEB-INF"</span>; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPropertiesFile</span><span class="params">()</span></span>&#123;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li>声明元素被翻译到Java类中，而不是_jspService方法中；</li></ul></li></ul><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象:"></a>内置对象:</h4><p>内置对象指的是在JSP中<strong>可以直接使用的对象，不需要声明</strong>，直接使用固定的名字使用即可；例如<code>&lt;%=request.getRemoteAddr()%&gt;</code>中的<code>request</code>就是内置对象；</p><p>jsp中共有9种对象</p><ol><li><code>request</code>：用户端请求，此请求会包含来自GET/Post请求的参数；</li><li><code>response</code>：网页传回用户端的回应。</li><li><code>pageContext</code>：页面的属性是在这里管理</li><li><code>session</code>：与请求有关的回话期</li><li><code>application</code> ：Servlet正在执行的内容</li><li><code>out</code> ：用来传递回应的输出</li><li><code>config</code> ：servlet的构架部件</li><li><code>pagejsp</code>网页本身</li><li><code>exception</code> ：针对错误的网页。未捕捉的例外</li></ol><h4 id="Servlet和JSP的作用"><a href="#Servlet和JSP的作用" class="headerlink" title="Servlet和JSP的作用:"></a>Servlet和JSP的作用:</h4><p>实际应用中，Servlet是不会用来生成动态页面的，而是会用来接收来自JSP的请求，处理请求，然后调跳转到JSP页面把结果显示给客户端看；</p><h4 id="Servlet与JSP之间的跳转方式"><a href="#Servlet与JSP之间的跳转方式" class="headerlink" title="Servlet与JSP之间的跳转方式:"></a>Servlet与JSP之间的跳转方式:</h4><ol><li><p>跳转方式一:<strong>响应重定向</strong>,响应接口中提供了该方法    </p><ul><li><p><code>void sendRedirect(java.lang.String location)</code>:响应重定向到location，相当于客户端重新请求location所在的资源；    </p></li><li><p>第一个JSP页面发送请求<code>request</code>到<code>Servlet</code>,<code>Servlet</code>接收请求后,响应<code>response</code>重定向到目标JSP页面,但是请求并没有传递过来.(<strong>重定向相当于是产生一个新的请求</strong>)</p></li></ul></li><li><p>跳转方式二:<strong>请求转发</strong>,RequestDispatcher接口定义了请求转发的方法</p><ul><li><code>forward(ServletRequest request, ServletResponse response)</code>:将请求转发到服务器上的其他资源，包括其他的Servlet，JSP等；</li><li>要使用forward方法，需要先获得RequestDispatcher对象；请求接口(request)中提供了获得该对象的方法：<ul><li><code>RequestDispatcher getRequestDispatcher(java.lang.String path)</code>:使用path返回一个RequestDispatcher 对象</li></ul></li><li>请求转发把请求对象发送到了目标JSP页面,因此<strong>目标页面可以获得上一个页面的请求对象.</strong></li></ul></li></ol><h4 id="请求属性的使用"><a href="#请求属性的使用" class="headerlink" title="请求属性的使用:"></a>请求属性的使用:</h4><p>如果需要在Servlet，JSP之间跳转时，同时把一些自定义的、或者通过数据库查询的、或者调用其他资源获得的数据传递到下一个资源时，就可以把这些数据设置为请求的属性即可。</p><p>请求接口中定义了一系列与属性有关的方法。<br>|方法声明|方法描述|<br>|:——:|:—–:|<br>|void setAttribute(java.lang.String name, java.lang.Object o)|将任意类型对象设置为请求的属性，指定一个名字；|<br>|java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；|<br>|void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；|<br>可以将数据封装进请求对象中,在前后端传递<br>例如:后台Servlet中将数据保存进request(请求)中,跳转到前台JSP后,JSP可以用<code>&lt;%=request.getAttribute(&quot;name&quot;)%&gt;</code>来获取(直接输出)也可以<strong>保存为变量(前提是需要强转</strong>,因为获取的是Object类型)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是JSP&quot;&gt;&lt;a href=&quot;#什么是JSP&quot; class=&quot;headerlink&quot; title=&quot;什么是JSP&quot;&gt;&lt;/a&gt;什么是JSP&lt;/h4&gt;&lt;p&gt;JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://zhuyiting.xyz/2017/12/06/Servlet/"/>
    <id>https://zhuyiting.xyz/2017/12/06/Servlet/</id>
    <published>2017-12-06T09:12:00.000Z</published>
    <updated>2019-10-20T14:03:11.936Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h4><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><h4 id="Servlet的线程特性"><a href="#Servlet的线程特性" class="headerlink" title="Servlet的线程特性:"></a>Servlet的线程特性:</h4><p>Web应用服务器(Tomcat)将为每个客户端的连接启动一个线程来服务</p><p>第一次访问Servlet时，服务器将创建一个该Servlet类的对象，并调用doXXX方法生成响应；多个客户端访问同一个Servlet时，不再创建新的对象，而是共用同一个Servlet对象。可以说，Servlet是多线程单实例的。</p><h4 id="Servlet请求和响应接口"><a href="#Servlet请求和响应接口" class="headerlink" title="Servlet请求和响应接口:"></a>Servlet请求和响应接口:</h4><p>通过浏览器提交给服务端的所有数据,都称为<strong>请求数据</strong></p><p>通过服务器返回给客户端的所有数据,都称为<strong>响应数据</strong></p><p>ServletAPI中,定义了请求和响应接口,用来封装和操作请求和响应数据</p><ul><li>请求接口:<ul><li><code>javax.servlet.ServletRequest</code></li><li><code>javax.servlet.HttpServletRequest</code></li></ul></li><li>响应接口:<ul><li><code>javax.servlet.ServletResponse</code></li><li><code>javax.servlet.HttpServletResponse</code></li></ul></li></ul><p>Servlet类使用doXXX方法提供服务,这些方法继承于<code>HttpServlet</code><br>doXXX方法中都有两个参数,分别是请求和响应;<br>|方法|参数|作用|<br>|:–:|:–:|:–:|<br>|void doDelete|(HttpServletRequest request,HttpServletResponse response)|用来处理一个HTTP DELETE操作,这个操作允许客户端请求从服务器上删除URL|<br>|void doGet|(HttpServletRequest request,             HttpServletResponse response)|用来处理一个HTTP GET操作。这个操作允许客户端简单地从一个HTTP服务器“获得”资源|<br>|void doHead|(HttpServletRequest request,          HttpServletResponse response)|用来处理一个HTTP HEAD操作。默认的情况是，这个操作会按照一个无条件的GET方法来执行|<br>|void doOptions|(HttpServletRequest request,           HttpServletResponse response)|用来处理一个HTTP OPTION操作。这个操作自动地决定支持哪一种HTTP方法。例如，一个Servlet写了一个HttpServlet的子类并重载了doGet方法，doOption会返回下面的头：    Allow:GET,HEAD,TRACE,OPTIONS|<br>|void doPost|(HttpServletRequest request,             HttpServletResponse response)|用来处理一个HTTP POST操作。这个操作包含请求体的数据，Servlet应该按照他行事。|<br>|void doPut|(HttpServletRequest request,        HttpServletResponse response)|用来处理一个HTTP PUT操作。这个操作类似于通过FTP发送文件。|<br>|void doTrace|(HttpServletRequest request,            HttpServletResponse response)|用来处理一个HTTP TRACE操作。这个操作的默认执行结果是产生一个响应，这个响应包含一个反映trace请求中发送的所有头域的信息。|<br>|long getLastModified|(HttpServletRequest request)|返回这个请求实体的最后修改时间。|<br>|void service|(HttpServletRequest request,     HttpServletResponse response)|这是一个Servlet的HTTP-specific方案，它分配请求到这个类的支持这个请求的其他方法。当你开发Servlet时，在多数情况下你不必重载这个方法。|<br><strong><em>也就是说：服务器会创建请求对象和响应对象传递给doXXX方法，doXXX方法中可以直接使用请求和响应对象;</em></strong><br><strong>doXXX方法中可以使用方法参数request，response去调用请求和响应接口中的方法；</strong></p><h4 id="利用Servlet对客户端不同方式请求作出动态响应"><a href="#利用Servlet对客户端不同方式请求作出动态响应" class="headerlink" title="利用Servlet对客户端不同方式请求作出动态响应:"></a>利用Servlet对客户端不同方式请求作出动态响应:</h4><p>客户端访问服务器端Servlet的三种方式:</p><ol><li>直接从地址栏输入URL访问；是GET方式，调用doGet方法;</li><li>在网页中点击超级链接访问；是GET方式，调用doGet方法;</li><li>在网页中通过表单提交访问；取决form的method属性的值，默认是get，指定为post时，调用doPost方法;</li></ol><p>Servlet中获取请求参数的方法:</p><ol><li>可以在URL后使用name=value&amp;name=value的形式传递，例如： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">“TestPramServlet?page</span>=<span class="string">1&amp;author</span>=<span class="string">wangxh”</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 传递两个请求参数，名字分别为page和author，值分别为1和wangxh；--&gt;</span></span><br></pre></td></tr></table></figure></li><li>可以在使用表单提交，表单中的元素值将作为请求参数传递，元素的name是参数名字，value的值是参数的值</li></ol><p>当客户端请求服务器端的Servlet时，请求参数都会被发送到服务器，服务器会将请求参数封装到<strong>请求对象</strong>中；</p><h4 id="Servlet初始化参数"><a href="#Servlet初始化参数" class="headerlink" title="Servlet初始化参数:"></a>Servlet初始化参数:</h4><ol><li>如果某个Servlet需要使用一些可以配置的参数，可以在web.xml进行配置，称为初始化参数；</li><li>这些参数在服务器初始化Servlet实例时被初始化到配置信息中，可以在Servlet中获取并使用；</li><li>一个Servlet可以配置多个初始化参数，所有的初始化参数只能在当前Servlet类中使用；</li></ol><h4 id="Servlet加载启动选项"><a href="#Servlet加载启动选项" class="headerlink" title="Servlet加载启动选项:"></a>Servlet加载启动选项:</h4><ol><li>默认情况下，只有当第一次访问Servlet时，服务器才会初始化Servlet实例；</li><li>如果需要更早实例化Servlet，可以在web.xml中进行配置，使得在启动容器的时候就能初始化Servlet实例；</li></ol><h4 id="Servlet配置中通配符-的用法"><a href="#Servlet配置中通配符-的用法" class="headerlink" title="Servlet配置中通配符*的用法:"></a>Servlet配置中通配符*的用法:</h4><ul><li><em>.扩展名 ： 比如 *.do、</em>.action</li><li>以 / 开头，同时以 /* 结尾，比如  /*  、/admin/*</li></ul><h4 id="web-xml中首页及错误页面等其他配置信息"><a href="#web-xml中首页及错误页面等其他配置信息" class="headerlink" title="web.xml中首页及错误页面等其他配置信息"></a>web.xml中首页及错误页面等其他配置信息</h4><ul><li><strong>配置默认页面</strong>:当不指定具体访问路径时,默认访问默认页面<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>配置错误页面</strong>:当应用中出现响应错误或者异常时,可以跳转到错误页面;</li></ul><h4 id="Servlet中获取请求头属性的方法"><a href="#Servlet中获取请求头属性的方法" class="headerlink" title="Servlet中获取请求头属性的方法:"></a>Servlet中获取请求头属性的方法:</h4><p>客户端请求服务端的Servlet,会传递给服务器一系列的HTTP请求头属性,请求接口中定义了系列方法获取请求属性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Servlet&quot;&gt;&lt;a href=&quot;#什么是Servlet&quot; class=&quot;headerlink&quot; title=&quot;什么是Servlet&quot;&gt;&lt;/a&gt;什么是Servlet&lt;/h4&gt;&lt;p&gt;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://zhuyiting.xyz/2017/11/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2017/11/30/Java多线程/</id>
    <published>2017-11-30T00:43:00.000Z</published>
    <updated>2019-10-20T13:59:32.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><h4 id="程序-进程和多任务"><a href="#程序-进程和多任务" class="headerlink" title="程序.进程和多任务:"></a>程序.进程和多任务:</h4><ul><li><strong>程序（program）</strong> 是对数据描述与操作的代码的集合，是应用程序执行的脚本。</li><li><strong>进程（process）</strong> 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li><strong>多任务（multi task）</strong> 在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序</li><li>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</li></ul><h4 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程:"></a>如何创建多线程:</h4><ul><li>创建 java.lang.Thread 类的子类，重写该类的 run方 法</li><li>创建 java.lang.Runnable接 口的实现类，实现接口中的 run 方法(用的更多)</li></ul><h4 id="Runnable-接口与-Thread-类之间的区别"><a href="#Runnable-接口与-Thread-类之间的区别" class="headerlink" title="Runnable 接口与 Thread 类之间的区别:"></a>Runnable 接口与 Thread 类之间的区别:</h4><ul><li>Runnable 接口必须实现 run 方法，而 Thread 类中的run 方法是一个空方法，可以不重写</li><li>Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必须依靠 Thread 类 </li><li>Runnable 接口适合于资源的共享</li></ul><h4 id="多线程的四种状态"><a href="#多线程的四种状态" class="headerlink" title="多线程的四种状态:"></a>多线程的四种状态:</h4><ul><li>新建（New）</li><li>可执行（Runnable）</li><li>运行（Running)</li><li>阻塞（Blocking)</li><li>死亡（Dead)</li></ul><h4 id="状态之间的相互转化可执行-lt-—-gt-阻塞"><a href="#状态之间的相互转化可执行-lt-—-gt-阻塞" class="headerlink" title="状态之间的相互转化可执行&lt;—-&gt;阻塞"></a>状态之间的相互转化可执行&lt;—-&gt;阻塞</h4><ul><li>wait()方法:<ul><li>中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。</li></ul></li><li>notify()方法：<ul><li>唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待</li></ul></li><li>notifyall()方法：<ul><li>唤醒所有由于使用这个同步方法而处于等待的线程结束等待</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java多线程&quot;&gt;&lt;a href=&quot;#Java多线程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程&quot;&gt;&lt;/a&gt;Java多线程&lt;/h3&gt;&lt;h4 id=&quot;程序-进程和多任务&quot;&gt;&lt;a href=&quot;#程序-进程和多任务&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
</feed>
