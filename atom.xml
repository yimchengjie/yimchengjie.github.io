<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuyiting.xyz/"/>
  <updated>2019-11-15T05:11:22.909Z</updated>
  <id>https://zhuyiting.xyz/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>党的有关理论和习近平新时代中国特色社会主义思想</title>
    <link href="https://zhuyiting.xyz/2019/10/29/%E5%85%9A%E7%9A%84%E6%9C%89%E5%85%B3%E7%90%86%E8%AE%BA%E5%92%8C%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3/"/>
    <id>https://zhuyiting.xyz/2019/10/29/党的有关理论和习近平新时代中国特色社会主义思想/</id>
    <published>2019-10-29T13:17:00.000Z</published>
    <updated>2019-11-15T05:11:22.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="党的有关理论知识"><a href="#党的有关理论知识" class="headerlink" title="党的有关理论知识"></a>党的有关理论知识</h3><h4 id="端正入党动机"><a href="#端正入党动机" class="headerlink" title="端正入党动机"></a>端正入党动机</h4><h5 id="1-正确入党动机的内涵"><a href="#1-正确入党动机的内涵" class="headerlink" title="1. 正确入党动机的内涵"></a>1. 正确入党动机的内涵</h5><p>正确的入党动机,指争取入党的内在原因是忠诚地信仰共产主义,把最终实现共产主义社会制度作为自己的最高理想,决心为了壮丽的共产主义事业奋斗终生,全心全意的为人民服务,并随时准备为党和人民的利益牺牲一切.<br>入党,意味着要比群众多吃亏,争取入党就是要为党和人民的利益不怕吃亏.<br>入党,意味着比群众多挑重担,多做贡献.<br>入党,意味着比群众多做牺牲,争取入党就要有革命的自我牺牲精神.</p><h5 id="2-怎样端正入党动机"><a href="#2-怎样端正入党动机" class="headerlink" title="2. 怎样端正入党动机?"></a>2. 怎样端正入党动机?</h5><p>主要以下三个方面的内容:<br>第一,要有为共产主义和中国特色社会主义奋斗终身的坚定信念.<br>第二,要有全心全意为人民服务的思想.<br>第三,要有在生产,工作,学习和社会生活中起先锋模范作用的觉悟.</p><h4 id="党的基本理论知识"><a href="#党的基本理论知识" class="headerlink" title="党的基本理论知识"></a>党的基本理论知识</h4><h5 id="1-中国共产党性质"><a href="#1-中国共产党性质" class="headerlink" title="1. 中国共产党性质:"></a>1. 中国共产党性质:</h5><p>中国共产党是中国工人阶级的先锋队,同时是中国人民和中华民族的先锋队,是中国特色社会主义失业的领导核心,代表中国先进生产力的发展要求,代表中国先进文化的前进方向,代表中国最广大人民的根本利益.</p><h5 id="2-党的行动指南"><a href="#2-党的行动指南" class="headerlink" title="2. 党的行动指南:"></a>2. 党的行动指南:</h5><p>是以马克思列宁主义,毛泽东思想,邓小平理论和”三个代表”重要思想作为自己的行动指南</p><h5 id="3-党的最高理想和最终目标"><a href="#3-党的最高理想和最终目标" class="headerlink" title="3. 党的最高理想和最终目标:"></a>3. 党的最高理想和最终目标:</h5><p>实现共产主义</p><h5 id="4-党的基本路线"><a href="#4-党的基本路线" class="headerlink" title="4. 党的基本路线:"></a>4. 党的基本路线:</h5><p>领导和团结全国各族人民,以经济建设为中心,坚持四项基本原则,坚持改革开放,自力更生,艰苦创业,为把我国建设成为富强,民主,文明,和谐的社会主义现代化国家而奋斗.</p><h5 id="5-党的外交政策"><a href="#5-党的外交政策" class="headerlink" title="5. 党的外交政策:"></a>5. 党的外交政策:</h5><p>坚持独立自主的和平外交政策,维护我国的独立和主权,反对霸权主义和强权政治,维护世界和平,促进人类进步.</p><h5 id="6-党的四项基本原则"><a href="#6-党的四项基本原则" class="headerlink" title="6. 党的四项基本原则"></a>6. 党的四项基本原则</h5><p>坚持社会主义道路,坚持人民民主专政,坚持中国共产党的领导,坚持马克思列宁主义毛泽东思想</p><h5 id="7-党的建设必须坚决实现的四项基本要求"><a href="#7-党的建设必须坚决实现的四项基本要求" class="headerlink" title="7. 党的建设必须坚决实现的四项基本要求"></a>7. 党的建设必须坚决实现的四项基本要求</h5><p>(1)坚持党的基本路线,(2)坚持解放思想,实事求是,与时俱进,(3)坚持全心全意为人民服务,(4)坚持民主集中制</p><h5 id="8-党的工作路线"><a href="#8-党的工作路线" class="headerlink" title="8. 党的工作路线:"></a>8. 党的工作路线:</h5><p>一切为了群众,一切依靠群众,从群众中来,到群众中去,把党的正确主张变为群众的自觉行动</p><h5 id="9-党的最大优势"><a href="#9-党的最大优势" class="headerlink" title="9. 党的最大优势:"></a>9. 党的最大优势:</h5><p>密切联系群众</p><h5 id="10-党执政后的最大危险"><a href="#10-党执政后的最大危险" class="headerlink" title="10. 党执政后的最大危险:"></a>10. 党执政后的最大危险:</h5><p>脱离群众</p><h5 id="11-党员享有的八项权利"><a href="#11-党员享有的八项权利" class="headerlink" title="11. 党员享有的八项权利:"></a>11. 党员享有的八项权利:</h5><p>(1)参加党的有关会议,阅读党的有关文件,接收党的教育和培训<br>(2)在党的会议上和党报党刊上,参加关于党的政策问题的讨论<br>(3)对党的工作提出建议和倡议<br>(4)在党的会议上有根据的批评党的任何组织和任何党员,向党员负责的揭发,检举党的任何组织和任何党员违法乱纪的事实,要求处分违法乱纪的党员,要求罢免或撤换不称职的干部.<br>(5)行使表决权,选举权,有被选举权<br>(6)在党组织讨论决定对党员的党纪处分或作出鉴定时,本人有权参加和进行申辩,其他党员可以为他作证和辩护<br>(7)对党的决议和政策如有不同意见,在坚决执行的前提下,可以声明保留,并且可以把自己的意见向党的上级组织直至中央提出<br>(8)向党的上级组织直至中央给以负责的答复</p><h5 id="12-党员履行的八项义务"><a href="#12-党员履行的八项义务" class="headerlink" title="12. 党员履行的八项义务:"></a>12. 党员履行的八项义务:</h5><p>(1)认真学习马克思列宁主义,毛泽东思想,邓小平理论和”三个代表”重要思想,学习党的路线,方针,政策及决议,学习党的基本知识,学习科学,文化和业务知识,努力提高为人民服务的本领<br>(2)贯彻执行党的基本路线和方针,政策,带头参加改革开放和社会主义现代化建设,带动群众为经济发展和社会进步艰苦奋斗,在生产,工作,学习和社会生活中起先锋模范左右<br>(3)坚持党和人民的利益高于一切,个人利益服从党和人民的利益,吃苦在前,享受在后,克己奉公,多做贡献<br>(4)自觉遵守党的纪律,模范遵守国家的法律法规,严格保守党和国家的秘密,执行党的决定,服从组织分配,积极完成党的任务.<br>(5)维护党的团结和统一,对党忠诚老实,言行一致,坚决反对一切派别组织和小集团活动,反对阳奉阴违的两面派行为和一切阴谋诡计<br>(6)切实开展批评和自我批评,勇于揭露和纠正工作中的缺点,错误,坚决痛消极腐败现象做斗争<br>(7)密切联系群众,向群众宣传党的主张,即时同群众商量,即时向党反应群众的一件和要求,维护群众的正当利益<br>(8)发扬社会主义新风尚,提倡共产主义道德,为了保护国家和人民的利益,在一切困难和危险的时刻挺身而出,英勇斗阵,不怕牺牲.</p><h5 id="13-预备党员的权利"><a href="#13-预备党员的权利" class="headerlink" title="13. 预备党员的权利:"></a>13. 预备党员的权利:</h5><p>除了没有表决权,选举权和被选举权,其他和正式党员一样</p><h5 id="14-党员的党龄"><a href="#14-党员的党龄" class="headerlink" title="14. 党员的党龄:"></a>14. 党员的党龄:</h5><p>从预备期满转为正式党员之日算起.<br>党员如果没有正当理由连续六个月不参加党的组织生活,或不缴纳党费,或不做党所分配的工作,就认为是自行脱党</p><h5 id="15-党的民主集中制的基本原则是"><a href="#15-党的民主集中制的基本原则是" class="headerlink" title="15. 党的民主集中制的基本原则是:"></a>15. 党的民主集中制的基本原则是:</h5><p>党员个人服从党的组织,少数服从多数,下级组织服从上级组织,全党各个组织和全体党员服从党的全国代表大会和中央委员会.</p><h5 id="16-党的纪律处分有五种"><a href="#16-党的纪律处分有五种" class="headerlink" title="16. 党的纪律处分有五种:"></a>16. 党的纪律处分有五种:</h5><p>警告,严重警告,撤销党内职务,留党察看,开除党籍</p><h5 id="17-党的五个作风"><a href="#17-党的五个作风" class="headerlink" title="17. 党的五个作风:"></a>17. 党的五个作风:</h5><p>思想作风,工作作风,领导作风,学风,干部生活作风</p><h5 id="18-两个务必"><a href="#18-两个务必" class="headerlink" title="18. 两个务必:"></a>18. 两个务必:</h5><p>(1)务必继续地保持谦虚,谨慎,不骄,不躁的作风<br>(2)务必继续保持艰苦奋斗的作风</p><h5 id="19-四个人格形象"><a href="#19-四个人格形象" class="headerlink" title="19. 四个人格形象:"></a>19. 四个人格形象:</h5><p>诚实守信的人格形象,<br>公道正派的人格形象,<br>清正廉洁的人格形象,<br>敬业奉献的人格形象.</p><h5 id="20-四个高度认同"><a href="#20-四个高度认同" class="headerlink" title="20. 四个高度认同:"></a>20. 四个高度认同:</h5><p>对祖国的高度认同,<br>对中华民族的高度认同,<br>对中华文化的高度认同,<br>对中国社会主义的高度认同.</p><h5 id="21-四大纪律"><a href="#21-四大纪律" class="headerlink" title="21. 四大纪律:"></a>21. 四大纪律:</h5><p>政治纪律,<br>组织纪律,<br>经济工作纪律,<br>群众工作纪律.</p><h5 id="22-五种精神"><a href="#22-五种精神" class="headerlink" title="22. 五种精神"></a>22. 五种精神</h5><p>解放思想,实事求是;<br>紧跟时代,勇于创新;<br>艰苦奋斗,务求实效;<br>知难而进,一往无前;<br>淡泊名利,无私奉献.</p><h5 id="23-八个坚持-八个反对"><a href="#23-八个坚持-八个反对" class="headerlink" title="23. 八个坚持,八个反对"></a>23. 八个坚持,八个反对</h5><p>(1)坚持解放思想,实事求是,反对因循守旧,不思进取;<br>(2)坚持理论联系实际,反对照抄照搬、本本主义;<br>(3)坚持密切联系群众，反对形式主义、官僚主义;<br>(4)坚持民主集中制，反对独断专行、软弱涣散;<br>(5)坚持党的纪律，反对自由主义;<br>(6)坚持艰苦奋斗，反对享乐主义;<br>(7)坚持清正廉洁，反对以权谋私;<br>(8)坚持任人唯贤，反对用人上的不正之风.</p><h5 id="24-八项要求"><a href="#24-八项要求" class="headerlink" title="24. 八项要求"></a>24. 八项要求</h5><p>(1)要同党中央保持高度一致，不阳奉阴违、自行其是;<br>(2)要遵守民主集中制，不独断专行、软弱放任;<br>(3)要依法行使权力，不滥用职权、玩忽职守;<br>(4)要廉洁奉公，不接受任何影响公正执行公务的利益;<br>(5)要管好配偶、子女和身边工作人员，不允许他们利用本人的影响谋取私利;<br>(6)要公道正派用人，不任人唯亲、营私舞弊;<br>(7)要艰苦奋斗，不奢侈浪费、贪图享受;<br>(8)要务实为民，不弄虚作假、与民争利.</p><h5 id="25-科学发展观的具体内容包括"><a href="#25-科学发展观的具体内容包括" class="headerlink" title="25. 科学发展观的具体内容包括:"></a>25. 科学发展观的具体内容包括:</h5><p>第一要义是发展,<br>核心是以人为本,<br>基本要求是全面协调可持续,<br>根本方法是统筹兼顾.</p><h4 id="发展党员的程序和手续"><a href="#发展党员的程序和手续" class="headerlink" title="发展党员的程序和手续"></a>发展党员的程序和手续</h4><p>（1）要求入党的人自愿向党组织提出入党申请；<br>（2）党组织接到申请入党人的申请书后，应及时研究能否列为入党积极分子；<br>（3）申请入党人被列为入党积极分子后，党组织即应落实对其培养教育和考察的措施；<br>（4）入党积极分之经一年以上的培养教育和考察后，党组织要研究能否确定为发展对象；<br>（5）入党积极分子被确定为发展对象后，党组织要对其进行政治审查；<br>（6）党组织在进行政治审查的同时，要征求党内外群众对发展对象的意见；<br>（7）党组织在接受发展对象入党前，要对其进行入党前期短期集中培训；<br>（8）做完上述工作后，支部委员会要将发展对象的入党材料报上级党组织预审；<br>（9）经上级党组织预审同意后，支部委员会应通知发展对象确定两名正式党员作入党介绍人；<br>（10）入党介绍人或支部领导成员指导发展对象填写《入党志愿书》；<br>（11）支部委员会对《入党志愿书》进行审查，认为合格后，即可召开支部大会讨论，作出决议，并报上级党组织审批；<br>（12）上级党组织在批准申请人入党前要派人同他谈话，作进一步的了解；<br>（13）上级党组织召开委员会，在听取谈话人的汇报和组织部门的意见后，集体讨论审批<br>（14）被批准入党的预备党员接受党组织一年预备期的教育和考察；<br>（15）预备党员在预备期内要面向党旗进行入党宣誓；<br>（16）预备党员预备期满，主动向党组织提出转为正式党员的申请，党组织要及时讨论其能否转为正式党员。</p><h3 id="习近平新时代中国特色社会主义思想"><a href="#习近平新时代中国特色社会主义思想" class="headerlink" title="习近平新时代中国特色社会主义思想"></a>习近平新时代中国特色社会主义思想</h3><h4 id="八个明确"><a href="#八个明确" class="headerlink" title="八个明确"></a>八个明确</h4><p>第一，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国；</p><p>第二，明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕；</p><p>第三，明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信；</p><p>第四，明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化；</p><p>第五，明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家；</p><p>第六，明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队；</p><p>第七，明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体；</p><p>第八，明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。</p><h4 id="十四个坚持"><a href="#十四个坚持" class="headerlink" title="十四个坚持"></a>十四个坚持</h4><p>第一条，坚持党对一切工作的领导；</p><p>第二条，坚持以人民为中心；</p><p>第三条，坚持全面深化改革；</p><p>第四条，坚持新发展理念；</p><p>第五条，坚持人民当家作主；</p><p>第六条，坚持全面依法治国；</p><p>第七条，坚持社会主义核心价值体系；</p><p>第八条，坚持在发展中保障和改善民生；</p><p>第九条，坚持人与自然和谐共生；</p><p>第十条，坚持总体国家安全观；</p><p>第十一条，坚持党对人民军队的绝对领导；</p><p>第十二条，坚持“一国两制”和推进祖国统一；</p><p>第十三条，坚持推动构建人类命运共同体；</p><p>第十四条，坚持全面从严治党。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;党的有关理论知识&quot;&gt;&lt;a href=&quot;#党的有关理论知识&quot; class=&quot;headerlink&quot; title=&quot;党的有关理论知识&quot;&gt;&lt;/a&gt;党的有关理论知识&lt;/h3&gt;&lt;h4 id=&quot;端正入党动机&quot;&gt;&lt;a href=&quot;#端正入党动机&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>论市场化改革</title>
    <link href="https://zhuyiting.xyz/2019/10/24/%E8%AE%BA%E5%B8%82%E5%9C%BA%E5%8C%96%E6%94%B9%E9%9D%A9/"/>
    <id>https://zhuyiting.xyz/2019/10/24/论市场化改革/</id>
    <published>2019-10-24T12:42:13.000Z</published>
    <updated>2019-10-29T02:32:58.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇"><a href="#当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇" class="headerlink" title="当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?"></a>当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?</h4><p>最近，<u>全球掀起了一阵降息潮，全球的经济环境普遍不太理想</u>，全球正在经历一轮新的经济周期调整。以10年为周期的金融危机再一次来临。中美的贸易摩擦对于中国金融市场的影响冲击也是巨大的，<u>人民币一度破7，持续的贬值导致国内资金外逃</u>，也导致了人民币国际化的步伐放缓。<br><font color="red">1.<em>[为什么经济不理想的时候要加息?加息为什么可以调整经济]</em><br>因为经济不理想(经济衰退)是市场投资不足(市场中流动的钱少了,都存银行了),政府为了刺激市场,减少银行利息,这样本来钱存在银行的一部分人就会因为收益少了,把钱投向市场中(股票或者消费),都会促进市场健康发展,使经济复苏<br>2.<em>[为什么人民币破7会导致国内资金外逃,人民币破7由什么导致,为什么人民币破7会阻碍人民币国际化?]</em><br>因为人民币破7是1美元兑换7块多人民币,而国际上以美元为主,本来6块多可以买到的东西,现在要多花钱才能买到,这样中国人不愿意买国外的东西(进口不利,因为变贵了).但是相反,中国更愿意卖东西了(出口有利).然后来自国外的资金,会因为人民币不值钱了(能换到的美元变少了)而减少对国内的投资(资本外逃).人民币的贬值是由于美元强势造成的(美国降息,资本都进入市场,经济强势)<br></font></p><p>2019年来，中国的经济形式总体仍延续着2018年的情况，我国经济增速下滑已是事实。由政府主导的央企在2000年后改革缓慢，各大原材料行业都亏损很大，产业的利润下滑非常严重，产能过剩，中国的供需关系面临着很大的结构性失衡，总体上低端产品产能过剩，高端产品产能不足。其次，我国低附加值、高功耗、高污染的产业比重很大；区域人口分布不合理，城镇化率低，导致发展不平衡；随着人口、土地、环境等这些红利慢慢的消失，<u>人工成本的上涨，土地价格的升高，环境的恶化，导致中低端产业较多</u>；我国经济的增长过多的依靠”<u>三驾马车</u>“，我国城乡收入差距大，行业收入差距大，居民贫富差距大。这些问题就会束缚经济的发展。<br><font color="red">1.<em>[为什么会导致中低端产业较多]</em><br>因为红利的消失会导致企业成本的增加,产品价格上涨,高端产品竞争力变弱(比如国产车和进口车一个价格, 选择国产车的人大大减少)<br>2.<em>[三驾马车是什么]</em><br>三驾马车是投资,消费,进口; 三驾马车是用来计算GDP的三部分,是经济发展的结果,不是根本动力. 根本动力是靠企业靠市场自我的健康发展.<br></font></p><p>当前的市场化改革，正式由习近平提出的供给侧结构性改革，<u>供给侧结构性改革，就是从提高供给质量出发，用改革的办法推进结构调整，矫正要素配置扭曲，扩大有效供给，提高供给结构对需求变化的适应性和灵活性，提高全要素生产率</u>，更好满足广大人民群众的需要，促进经济社会持续健康发展。<br><font color="red">1.<em>[解释一下供给侧结构性改革]</em><br>供给侧结构性改革就是强调供给方(也就是企业),能够制造出物美价廉的商品,怎么改呢呢? 通过改革,减少税收,降低土地价格,给予政策福利支持等<br></font></p><p>强调供给侧改革，从生产、供给入手，调整供应结构，才能使经济健康稳固发展。提升居民消费以及当前的供给侧改革并不能完全改变经济下滑趋势，<u>还必须打通供给以及需求，这一层中间地带</u>，一是政府对企业的税收以及居民的社保缴费高，让企业无法生产，市场需求低。二是垄断性国企占有太多的社会资源而效率又太低，靠价格垄断生存，抬高了整个市场的生产成本，比如油价，房价。<br><font color="red">1.<em>[为什么中间地带很重要]</em><br>中间地带是商品产出到消费者买入之间的地带,是企业或者消费者,在商品之外承担的费用,比如企业的税,居民的五险一金. 企业会把这些费用加到商品的价格上或者自己承担损失, 居民手上钱少, 消费降低, 都不利于经济健康发展<br></font></p><p>供给侧结构性改革自2015年提出以后，其主要任务也在不断变化。最初的“<u>三去一降一补</u>”，通过关、停、并、转等方式去掉多余产能，稳定房价去房地产库存，去杠杆减少政府债务，降低企业各项成本，补充生态建设、完善产业链。<br><font color="red">1.<em>[三去一降一补]</em><br>去产能,去库存,去债务,降成本,补生态产业链<br></font></p><p>当前不仅需要优化供给，提高内需，还要解决供给与需求的中间地带，做好减税降费，优化市场生态。供给侧结构性改革是利好于我国经济发展的，在贸易战加剧，逆全球化回溯的国际背景下，我国的供给侧结构性改革要结合一带一路，深化与沿线国家的合作，强化和欧洲，拉美地区国家的科技合作，扩大开放，将中国制造带出国。</p><p>我国要吸取日本经济发展的教训，20世纪后期，日本大力发展建设，逐渐陷入了失控的建设狂奔，建设业创造了庞大的就业机会，并非来自于真正的经济增长，<u>而是人为制造出的就业机会。这大大削弱并延缓了日本高技术产业的发展</u>，但这种失控的建设无法停止，因为一旦停止公共建设，就会出现大量失业。更严重的是，公共建设积累的巨大负债让日本难堪重负。<u>日本的房价泡沫也重创了日本实体工业的发展，泡沫的破灭导致了大量企业倒闭，失业率狂升</u>。当下的日本，也还没有完全走出当年的阴影。日本经济衰退的20年，主要原因就是日本政府对经济把控出现了失误，制定了违背经济规律的政策。<br><font color="red">1.<em>[为什么这会阻碍日本高科技产业发展?]</em><br>因为大量的人口资金投入到了基础建设业,相应的高科技产业就会没钱没人<br>2.<em>[房价的泡沫破裂为什么影响这么大?]</em><br>房价泡沫破灭, 高价买地的开发商,会破产,很多大企业也会因为投资房地产而大出血,这会让市场严重下跌,这样所有人手上的资产都贬值了,同时企业大量倒闭,失业率也会大大提高,已经买房的人失业后也还要承担巨额贷款.整个国家的经济都会受损,日本房价泡沫当时特别高,政府为了防止泡沫更高影响更恶劣,采取了主动刺破的措施.单也还是经济大衰退<br></font><br>我国可以从日本的经济发展的教训中收益到：房地产不能长久作为支柱产业，必须防止货币超发和过度升值，在宏观调控上，政府不能过于频繁也不能过紧过松，政策引导着眼长远，统筹兼顾。<br>面对经济寒冬，我们个人也需要重视，不要觉得离我们很遥远，面对危机，我们要留好资金，节约开销，努力工作，提升个人能力。<br>我国的市场化改革也会带来巨大的机遇，站在风口上，猪都会飞。乱世出英雄，变革带来的巨大机遇可能产生意想不到的风云人物，不过代价也是巨大的，在改革中，抓住机会很重要，不过我们需要做好充足的准备，机会总是留给有准备的人。能力上的准备，思想上的准备，以及恰到好处的机会。<br>在危机来临初期持有货币，<u>在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了</u>，但这其中随便哪一步出错，都会损失惨重，即使每一个环节都准确无误，也可能因为突如其来的不可抗力，导致整个投资计划的泡汤。比如限购限售，比如失业，比如投资企业破产。<u>在危机时期，不要轻易触碰杠杆加大交易规模</u>，其次要勤于学习，要对未来的风险做准备。<br><font color="red">1.<em>[为什么在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了?]</em><br>通俗点说就是在商品最便宜的时候买进。接下来商品会因为市场规律或者政府调控回升。但是政府为了控制物价（控制通货膨胀），会加息，钱流进银行，商品需求变小。在政府调控的时候，可以看成物价比较理想（高）的时候。这时候卖出。获利就很客观（差价最大的时候）<br>2.<em>[为什么不要触碰杠杆]</em><br>触碰杠杆可以理解为贷款,因为在经济危机时期,银行出于安全考虑不可能把大量的钱借给你, 所以只能贷到很少的钱,而钱越少,承受意外的能力越低,而且贷款需要抵押,(房子或者股票,在危机时期看不到底,随时会被银行卖掉,因为银行不可能等你房子不值钱了再卖,那就失去了抵押的意义),而银行低价卖出也会导致市场供大于求,进一步下跌. 而你通过贷款买入的资产也可能会进一步下跌.很容易破产<br></font><br>在宏观经济下滑的趋势下，要合理分配资产，综合来看2019年上半年的投资者大多以<u>黄金、比特币为代表的避险资产</u>，这些产品或者说是资产的价格也一直在上高，在国际范围中，各大央行实行降息政策，促进经济发展的前提下，黄金和比特币的抗通胀能力就展现出来了。<u>但千万不能在不了解的情况下，进行投资。</u><br><font color="red">1.<em>[为什么黄金,比特币是避险资产?]</em><br>因为他们都有共同属性,价值不受政府调控影响(因为总量固定,且没法造假).这样不管经济怎么样,黄金比特币本来能换多少米还是能换多少米.举例:比如一块黄金本来换一代米,一百块也能换一袋米,但是经济变化,一百块只能买半袋米了,但是一快黄金还是能买一袋米.<br>2.<em>[为什么不了解不能投资呢]</em><br>正式因为他们总量固定 ,他们会被资本炒作,比如大量买入造成供不应求,价格高了以后再高价卖出, 不了解就很可能成了韭菜,承担了这部分人造差价<br></font><br>改革初期，商品紧缺，供不应求，是暴利的时代，后来，电子商务兴起以及产能过剩，商家开启价格战，于是进入了薄利时期，而当前，我国正在转变，产品开始个性化、定制化、高端化，提高增值空间，从而进入厚利时代。<br>2019年下半年，<u>各大二线城市的抢人大战也已经偃旗息鼓，但一线新一线仍然对人才有着很高的需求。这意味着，宏观上的城市化进程将会放缓，大城市的自我迭代会深度展开</u>。其次我国股市长期以来以房地产与科技相关的驱动，目前的房价以稳为主，<u>投资的机会在科技类企业。</u><br><font color="red">1.<em>[为什么二线城市不抢人了?]</em><br>因为人才需要高薪,需要好的企业,而好的企业需要政策扶持,它才愿意来,二线城市没有这样的实力,相反,一线城市企业多,对于人才的需求也大,大城市的建设需要人才.<br>2.<em>[为什么说投资机会在科技类企业]</em><br>因为国家需要发展科技类企业来促进产业升级,政策的支持以及资金的流入,就会让科技类企业更健康的发展<br></font><br>在我国市场化改革的背景下，勤于学习，不多弥补知识盲区，扩充个人知识领域，才能知道更多有用的信息，见多识广的人，更能规避风险，才有更大的机会抓住机遇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇&quot;&gt;&lt;a href=&quot;#当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇&quot; class=&quot;headerlink&quot; title=&quot;当前的市场化
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>TED不念过往,不惧将来</title>
    <link href="https://zhuyiting.xyz/2019/10/24/TED%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80,%E4%B8%8D%E6%83%A7%E5%B0%86%E6%9D%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/24/TED不念过往,不惧将来/</id>
    <published>2019-10-24T02:16:00.000Z</published>
    <updated>2019-10-24T14:19:31.012Z</updated>
    
    <content type="html"><![CDATA[<p><u>“These are the times” said Thomas Paine,”that try men’s souls.”</u><br>“这些时间考验着人们的灵魂”Thomas Paine说.<br><u>And they’re trying ours now.</u><br>现在它们在考验我们.<br><u>This is a fateful moment in the history of the West.</u><br>这是一个西方历史的命运时刻.<br><u>We’ve seen divisive elections and divided societies.</u><br>我们看到了分裂的选举和分裂的社会.<br><u>We’ve seen a growth of extremism in politics and religion,</u><br>我们看到了一群极端分子在政治上和宗教上,<br><u>all of it fueled by anxiety,uncertainty and fear,</u><br>所有的这些都是被焦虑,不确定和害怕所推动,<br><u>of a world that’s changing almost faster than we can bear,</u><br>因为世界几乎在以比我们能够承受的更快的速度在改变,<br><u>and the sure knowledge that it’s going to change faster still.</u><br>并且都知道它未来还会改变的这么快<br><u>I have a friend in Washington.</u><br>我有一个朋友在Washington<br><u>I asked him,what was it like being in America during the recent presidential election?</u><br>我问他,在最近的总统选举期间待在美国像是什么?<br><u>He said to me,”Well,it was like the man sitting on the deck of the Titanic with a glass of whiskey in his hand and he’s saying,’I know I asked for ice–,but this is ridiculous.’”</u><br>他告诉我,”哇,它就像一个人坐在泰坦尼克的甲板上,手里拿着威士忌说’我知道我要了冰,但这太疯狂了’”<br><u>So is there something we can do,each of us,to be able to face the future without fear?</u><br>所以有没有一些事我们每个人都可以做的,可以让我们能够对未来不感到恐惧?<br><u>I think there is.</u><br>我觉得是有的.<br><u>And one way into it is to see that perhaps the most simple way into a culture and into an age is to ask: What do people worship? </u><br>有一个方法 也许是最简单的方法 进入一个文化进入一个时代去问:人们崇拜什么?<br><u>People have worshipped so many different things–the sun,the stars,the storm.</u><br>人们过去崇拜很多不同的是–太阳,星型,风暴.<br><u>Some people worship many gods, some one,some none.</u><br>有些人崇拜很多神,有些人崇拜一个,有些人没有<br><u>In the 19th and 20th centuries,people worshipped the nation,the Aryan race,the communist state.</u><br>在19到20世纪,人们崇拜国家,崇拜Aryan种族,崇拜共产主义.<br><u>What do we worship?</u><br>那我们崇拜什么呢?<br><u>I think future anthropologists will take a look at the books we read on self-help,self-realization,self-esteem.</u><br>我觉得未来的人类学家会看看到我们读过的书,关于自我帮助,自我认识,自我尊重,<br><u>They’ll look at the way we talk about morality as being true to oneself, the way we talk about politics as a matter of individual rights,</u><br>他们会看我们谈论道德的行为当成对自己的正确,我们谈论政治的行为当成个人权利的问题.<br><u>and they’ll look at this wonderful new religious ritual we have created.</u><br>并且他们会看看这些很棒的我们创造的宗教利益</p><p><u>You know the one?</u><br>你知道那是什么嘛?<br><u>Called the “selfie”.</u><br>我们成为”自拍”.<br><u>And I think they’ll conclude that what we worship in our time is the self,the me,the I.</u><br>并且我觉得他们会得出结论 那就是我们在那时候崇拜的就是自我,是我<br><u>And this is great.</u><br>这是很棒的<br><u>It’s liberating.</u><br>这是自由的<br><u>It’s empowering.</u><br>这是有权利的.<br><u>It’s wonderful.</u><br>这是极好的.<br><u>But don’t forget that biologically,</u><br>但是不要在生物上忘了<br><u>we’re social animals.</u><br>我们是社交动物<br><u>We’ve spent most of our evolutionary history in small groups.</u><br>我们进化历史中的很多时间都花在小小的群体中<br><u>We need those face-to-face interactions,where we learn the choreography of altruism and where we create those spiritual goods like friendship and trust and loyalty and love that redeem our solitude.</u><br>我们需要面对面的交流,来学习利他主义并且创造精神上的就像友谊,信任,忠诚和爱的东西以此救赎我们的孤独.<br><u>When we have too much of the “I” and too little of the “we”,</u><br>当我们过于关注我的, 很少关注我们时,<br><u>we can find ourselves vulnerable,fearful and alone.</u><br>我们会发现有多点的,会恐惧的并且孤独的自己.<br><u>It was no accident that Sherry Turkle of MIT called the book she wrote on the impact of social media “Alone together”.</u><br>MIT的Sherry Turkle把他写的关于社交媒体的影响命名为”一起孤单”不是一个意外.<br><u>So I think the simplest way of safeguarding the future “you” is to strengthen the future “us” in three dimensions:</u><br>所以我认为,最简单的保障未来的”你”的方法就是从三个方面来加深未来的”我们”<br><u>the us of relationship,the us of identity and the us of responsibility.</u><br>我们的关系,我们的身份和我们的责任<br><u>So let me first take the us of relationship.</u><br>所以,首先让我谈谈我们的关系.<br><u>And here, forgive me if I get personal.</u><br>在这里,原谅我如果我谈自己的事.<br><u>Once upon a time,a very long time age,I was a 20-year-old undergraduate studying philosophy.</u><br>从前,很长一段时间之前,我是20岁的大学生在学习哲学.<br><u>I was into Nietzsche and Schopenhauer and Sartre and Camus.</u><br>我沉迷于Nietzsche,Schopenhauer,Sartre和Camus<br><u>I was full of ontological uncertainty and existential angst.</u><br>我充满了本体论的不确定性和存在的焦虑<br><u>It was terrific.</u><br>那是极好的.<br><u>I was self-obsessed and thoroughly unpleasant to know,</u><br>我是自恋的并且感到非常厌恶,<br><u>until one day I saw, across the courtyard, a girl who was everything that I wasn’t.</u><br>直到有一天我看到,穿过这院子,一个女孩一切都和我不一样.<br><u>She radiated sunshine.</u><br>她散发着阳光.<br><u>She emanated joy.</u><br>她散发着快乐.<br><u>I found out her name was Elaine.</u><br>我找到她的名字是Elaine.<br><u>We met,We talked,We married.</u><br>我们见面,我们聊天,我们结婚.<br><u>And 47 years,three children and eight grandchildren later,</u><br>47年 有了3个小孩,8个孙子 以后<br><u>I can safely say it was the best decision I ever took in my life,</u><br>我可以说,那是我生命中做的最好的决定.<br><u>because it’s the people not like us that make us grow.</u><br>因为和我们不一样的人会让我们成长.<br><u>And that is why I thik we have to do just that.</u><br>这就是为什么我认为我们必须这样做.<br><u>The trouble with Google filters,Facebook friends and reading the news by narrowcasting rather than broadcasting means that we’re surrounded almost entirely by people like us whose views,whose opinions,whose prejudices,even, are just like ours.</u><br>谷歌过滤,脸书朋友圈以及阅读新闻通过很窄的渠道而不是广播这些麻烦意味着我们几乎完全被那些观点,想法,甚至成见和我们的一样的人包围着.<br><u>And Cass Sunstein of Harvard has shown that if we surround ourselves with people with the same views as us,we get more extreme.</u><br>哈弗的Cass Sunstein展示了如果我们被那些观点和我们一样的自己人包围,我们会变得极端<br><u>I think we need to renew those face-to-face encounters with the people not like us.</u><br>我认为我们需要重新和那些跟我们不一样的人面对面的接触.<br><u>I think we need to do that in order to realize that we can disagree strongly and yet still stay friends.</u><br>我认为我们需要这样做,为了我们能意识到强烈地争执也仍然可以当朋友.<br><u>It’s in those face-to-face encounters that we discover that the people not like us are just people like us.</u><br>在面对面的接触中我们发现那些和我们不同的人就是和我们一样的人<br><u>And actually, every time we hold out the hand of friendship to somebody not like us,whose class or creed or color are different from ours,</u><br>事实上,每一次,我们向那些和我们有不一样种族或者不一样信条或者不一样的肤色的人伸出友谊的手,<br><u>we heal one of the fractures of our wounded world.</u><br>我们治愈了我们破裂世界的一刀伤痕.<br><u>That is the us of relationship.</u><br>这就是我们的关系.<br><u>Second is the us of identity.</u><br>第二点是我们的身份.<br><u>Let me give you a thought experiment.</u><br>让我给你做个思维实验.<br><u>Have you been to Washington?</u><br>你去过Washington嘛?<br><u>Have tou seen the memorials?</u><br>你看过纪念碑嘛?<br><u>Absolutely fascinating.</u><br>绝对让人神魂颠倒.<br><u>There’s the Lincoln Memorial:Gettysburg Address on one side,Second Inaugural on the other.</u><br>在林肯纪念碑,一边是Gettysburg演说,另一边是Inaugural.<br><u>You go to the Jefferson Memorial,screeds of text.</u><br>你去Jefferson纪念碑,有一段话.<br><u>Martin Luther King Memorial,more than a dozen quotes from his speeches.</u><br>马丁路德金纪念碑,超过12条他演讲的引用.<br><u>I didn’t realize,in America you read memorials.</u><br>我不认为,你在美国会读这些纪念碑.<br><u>Now go to the equivalent in London in Parliament Square and you will see that the monument to David Lloyd George contains three words:David Lloyd George.</u><br>现在 一样去了伦敦的国会广场并且你会看到David Lloyd George的纪念碑上包含了三个单词:David Lloyd George.<br><u>Nelson Mandela gets two.</u><br>Nelson Mandela有两个<br><u>Churchill gets just one:Chuichill.</u><br>Churchill只有一个:Chuichill<br><u>Why the difference?</u><br>为什么会有这样的差异呢<br><u>I’ll tell you why the difference.</u><br>我来告诉你们为什么会有这样的差异.<br><u>Because America was from the outset a nation of wave after wave of immigrants,</u><br>因为美国是一个从一波又一波的移民开始的国家<br><u>so it had to create an identity which it did by telling a story which you learned at school, you read on memorials and you heard repeated in presidential inaugural addresses.</u><br>因此,它必须创造一个形象,那个形象可以通过你学校学到的故事,你在纪念碑上读到东西和你反复在总统开幕演讲中听到的故事来讲的.<br><u>Britain until recently wasn’t a nation of immigrants,</u><br>不列颠直到最近也不是一个移民国家,<br><u>so it could take identity for granted.</u><br>所以它可以认为形象是理所当然的.<br><u>The trouble is now that two tings have happened which shouldn’t have happened together.</u><br>麻烦的是现在两件不应该同时发生的事发生了.<br><u>The first thing is in the West we’ve stopped telling this story of who we are and why,even in America</u><br>第一件事是在西方,我们停止讲述我是谁还有为什么的故事了,甚至是美国<br><u>And at the same time,immigration is higher than it’s ever been before.</u><br>同时,移民人口变得比以前更高了.<br><u>So when you tell a story and your identity is strong,you can welcome the stranger,</u><br>因此,当你们讲述一个故事并且你们形象很强的时候,你们能欢迎那些陌生人<br><u>but when you stop telling the story,your identity gets weak and you fell threatened by the stranger.</u><br>但是,当你们停止讲述故事,你们的形象变弱了,并且你们感到了陌生人的威胁<br><u>And that’s bad.</u><br>那就糟了<br><u>I tell you,Jews have been scattered and dispersed and exiled for 2000 years.</u><br>我告诉你们,犹太人已经被分开,被分散并且被流亡了2000多年.<br><u>We never lost our identity.</u><br>我们从来没有失去我们的形象.<br><u>Why?Because at least once a year,on the festival of Passover,</u><br>为什么? 因为么每年至少一次,在Passover节<br><u>we told our story and we taught it to our children and we ate the unleavened bread of affliction and tasted the bitter herbs of slavery.</u><br>我们谈论我们的故事并且我们教它给我们的孩子,并且我们吃过还没发酵的苦的面包并且吃过奴隶制的苦.<br><u>So we never lost our identity.</u><br>所以我们从来没有丢失我们的形象.<br><u>I think collectively we’ve got to get back to telling our story,who we are,where we came from,what ideals by which we live.</u><br>我认为共同的,我们必须回到的我们的故事上来说,我们是谁,我们来自哪里,我们生活的理想是什么<br><u>And if that happens,we will become strong enough to welcome the stranger and say,</u><br>如果发生这样的事,我们会变得强壮的足够欢迎陌生人并且说<br><u>“Come and share our lives,share our stories,share our aspirations and dreams.”</u><br>“过来并且分享我们的生活,分享我们的故事,分享我们的愿望和梦想”.<br><u>That is the us of identity.</u><br>这就是我们的形象.<br><u>And finally,the us of responsibility.</u><br>最后,是我们的责任.<br><u>Do you know something?</u><br>你知道嘛?<br><u>My favorite phrase in all of politics,very American phrase,is:”We the people.”</u><br>我最喜欢的一句话在所有的政治言论中,一句非常美国的话,就是”我们人”<br><u>Why “we the people?”</u><br>为什么是”我们人”?<br><u>Because it says that we all share collective responsibility for our collective future.</u><br>因为它表达了我们分享所有集体的责任为了我们集体的未来.<br><u>And that’s how things really are and should be.</u><br>并且那就是应该有的样子<br><u>Have you noticed how magical thinking has taken over our politics?</u><br>你有没有注意到多少神奇的思想占据着我们的政治?<br><u>So we say, all you’ve got to do is elect this strong leader and he or she will solve all our problems for us.</u><br>因此我们说,我们都要去选一个强力的领导并且他会为我们解决我们的问题.<br><u>Believe me, that is magical thinking.</u><br>相信我,那是幻想.<br><u>And then we get the extremes:the far right,the far left,the extreme religious and extreme anti-religious,</u><br>当我们变得极端以后:极右,极左,极端宗教注意或者极端反宗教,<br><u>the far right dreaming of a golden age that never was,</u><br>极端的右派梦想着一个从未有过的黄金时代,<br><u>the far left dreaming of a utopia that never will be,</u><br>极端的左派梦想着一个从未出现过的乌托邦,<br><u>and the religious and anti-religious equally convinced that all it takes id God or the absence of God to save us from ourselves.</u><br>宗教和反宗教同意相信上帝或者没有上帝来拯救我们.<br><u>That,too,is magical thinking,</u><br>这是非常神奇的想法.<br><u>because the only people who will save us from ourselves is we the people,all of us together.</u><br>因为可以拯救我们只有我们自己,所有的我们一起.<br><u>And when we do that,and when we move from the politics of me to the politics of all of us together,</u><br>并且当我们去做,当我们从我的政治中到所有的我们的政治中<br><u>we rediscover those beautiful,counterintuitive truths:</u><br>我们重新发现了那些美丽的,与直觉相反的事实:<br><u>that a nation is strong when it cares for the weak,</u><br>当一个国家关注弱者的时候它是强大的,<br><u>that it becomes rich when it cares for the poor,</u><br>当一个国家关心穷人的时候它是富裕的,<br><u>it becomes invulnerable when it cares about the vulnerable.</u><br>当一个国家开始关心那些有弱点的人的时候,它是无懈可击的.<br><u>That is what makes great nations.</u><br>这就是伟大的国家的形成.<br><u>So here is my simple suggestion.</u><br>因此,这有一个我的简单简易<br><u>It might just change your life,</u><br>它也许可以改变你的生活,<br><u>and it might just help to begin to change the world.</u><br>它也许可以帮助开始改变这个世界<br><u>Do a search and replace operation one the text of your mind,</u><br>做一个搜索和替换操作,一是你心中的文字,<br><u>and wherever you encounter the word “self”, substitute the word “other”.</u><br>并且无论在哪你遇到了单词”自己”,替换成单词”其他人”<br><u>So instead of self-help,other-help;</u><br>替代”自我帮助”为”他人帮助”<br><u>instead of self-esteem,other-esteem.</u><br>替代”自我尊重”为”他人尊重”<br><u>And if you do that,you will begin to fell the power of what for me is one of the most moving sentences in all of religious literature.</u><br>如果你这么做,你会开始感受到力量,这力量对我来说就是所有宗教文学中最动人的句子之一<br><u>“Though I walk through the valley of the shadow of death,I will fear no evil,for you are with me.”</u><br>虽然我在死亡的阴影的深渊里走,但是我不会害怕邪恶,因为你和我在一起<br><u>We can face any future without fear so long as we know we will not face it alone.</u><br>我们能够不害怕面对任何我们知道的我们不能独自面对的未来<br><u>So for the sake of the future “you”,together let us strengthen the future “us”.</u><br>为了未来的”你”,让我们一起加固未来的”我们”</p><p><u>Thank you.</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;“These are the times” said Thomas Paine,”that try men’s souls.”&lt;/u&gt;&lt;br&gt;“这些时间考验着人们的灵魂”Thomas Paine说.&lt;br&gt;&lt;u&gt;And they’re trying ours now.
      
    
    </summary>
    
    
      <category term="英语" scheme="https://zhuyiting.xyz/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="TED" scheme="https://zhuyiting.xyz/tags/TED/"/>
    
  </entry>
  
  <entry>
    <title>延期年金现值的计算</title>
    <link href="https://zhuyiting.xyz/2019/10/18/%E5%BB%B6%E6%9C%9F%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://zhuyiting.xyz/2019/10/18/延期年金现值的计算/</id>
    <published>2019-10-18T01:56:00.000Z</published>
    <updated>2019-10-29T02:32:30.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延期年金"><a href="#延期年金" class="headerlink" title="延期年金"></a>延期年金</h2><p>==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.<br>==延期年金现值计算==假定最初又m期没有收付款项,后面n期每年有等额的系列收付款项,则此延期年金的现值即为后n期年金先折现至n期期初(m期期末),再折现至第一期期初的现值.</p><p>==年金==是指定期定额的收付款项</p><p>==现值==成本或收益的价值以今天的现金来计量时,称为现值</p><p>==终值==是指现在某一时点上的一定量现金折合到未来的价值</p><ol><li>延期年金的==终值==大小和延期数m无关<br>所以延期m期之后的n期年金终值为<br>$ F=A\frac{(1+i)^n-1}{i} $</li><li>普通年金的==现值==计算<br>$ P=A\frac{1-\frac{1}{(1+i)^n}}{i}$</li><li>==延期年金==的现值计算<br>延期年金的现值与延期数m相关,m越长,现值越低.<ul><li>方法一:先当成n期普通年金,求出现值P1,在将P作为第m期终值,再折现到第一期的现值P2<br>$P1=A\frac{1-\frac{1}{(1+i)^n}}{i}$<br>$P2=P1\frac{1-\frac{1}{(1+i)^m}}{i} $</li><li>方法二:先计算m+n期现值,再减去m期年金现值<br>$P=A(\frac{1-\frac{1}{(1+i)^m(1+i)^n}}{i}-\frac{1-\frac{1}{(1+i)^m}}{i}) $</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;延期年金&quot;&gt;&lt;a href=&quot;#延期年金&quot; class=&quot;headerlink&quot; title=&quot;延期年金&quot;&gt;&lt;/a&gt;延期年金&lt;/h2&gt;&lt;p&gt;==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.&lt;br&gt;==延期年
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://zhuyiting.xyz/2019/07/30/JVM指令手册/</id>
    <published>2019-07-30T07:18:00.000Z</published>
    <updated>2019-11-17T09:34:44.959Z</updated>
    
    <content type="html"><![CDATA[<p>栈和局部变量操作<br>将常量压入栈的指令<br>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值<br>将栈中的值存入局部变量的指令<br>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中<br>wide指令<br>wide 使用附加字节扩展局部变量索引<br>通用(无类型）栈操作<br>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容<br>类型转换<br>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型<br>整数运算<br>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上<br>逻辑运算<br>移位操作<br>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作<br>按位布尔运算<br>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作<br>浮点运算<br>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反<br>对象和数组<br>对象操作指令<br>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型<br>数组操作指令<br>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组<br>控制流<br>条件分支指令<br>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转<br>比较指令<br>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）<br>无条件转移指令<br>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）<br>表跳转指令<br>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<br>异常<br>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回<br>方法调用指令<br>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法<br>方法返回指令<br>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void<br>线程同步<br>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><hr><p>JVM指令助记符<br>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈和局部变量操作&lt;br&gt;将常量压入栈的指令&lt;br&gt;aconst_null 将null对象引用压入栈&lt;br&gt;iconst_m1 将int类型常量-1压入栈&lt;br&gt;iconst_0 将int类型常量0压入栈&lt;br&gt;iconst_1 将int类型常量1压入栈&lt;br&gt;iconst_
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>并发容器类</title>
    <link href="https://zhuyiting.xyz/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/"/>
    <id>https://zhuyiting.xyz/2019/04/11/Java并发编程/并发容器类/</id>
    <published>2019-04-11T14:17:53.000Z</published>
    <updated>2019-11-20T04:02:03.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h4><p>HashMap是依据哈希表（数组和链表的结合）实现的<br><u>内部使用Node类型的数组，即一个数组，数组的元素是链表</u></p><p>每一个Node都存储着四个字段，如下：<br><img src="/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="数组链表结构图"></p><p>从next字段我们可以看出Node 是一个链表.即数组中的每一个位置存储一个链表的头结点,HashMap使用链表法来解决冲突,同一个链表中存放着 hash(key)%len( 元素key的哈希值和数组长度取模运算) 结果相同的元素</p><h4 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h4><p><strong>拉链法:</strong> 就是把具有相同哈希值的关键字值放在同一个单链表中<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个默认大小16的HashMap</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的下标 115%16=3。那么插入到数组下标为3的位置</span></span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line"><span class="comment">// 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。那么插入到数组下标为6的位置</span></span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line"><span class="comment">// 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，数组下标6的位置,即插在 &lt;K2,V2&gt; 前面。</span></span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure><h4 id="3-JDK1-7和JDK1-8中HashMap的区别"><a href="#3-JDK1-7和JDK1-8中HashMap的区别" class="headerlink" title="3. JDK1.7和JDK1.8中HashMap的区别"></a>3. JDK1.7和JDK1.8中HashMap的区别</h4><h5 id="单链表数组结构的缺陷"><a href="#单链表数组结构的缺陷" class="headerlink" title="单链表数组结构的缺陷"></a>单链表数组结构的缺陷</h5><p>JDK1.7采用的是单链表数组的结构,这样的结构,在查找的时候是分为两步的;</p><ol><li>先计算要查找的元素的键<code>key</code>所对应的hashCode,然后除留语法得到链表头所在数组的位置</li><li>然后从这个头结点,按顺序查找比对.</li></ol><p><u>所以,单链表数组结构的查询算法的时间复杂度与链表的长度成正比,和数组的长度无关.</u></p><h5 id="单链表数组的扩容机制"><a href="#单链表数组的扩容机制" class="headerlink" title="单链表数组的扩容机制"></a>单链表数组的扩容机制</h5><p>因为查询的时间复杂度与链表长度成正比, 所以需要尽量让链表保持较短<br>这就引入了扩容机制,扩大数组的长度,从而减少了链表的长度.</p><p>但是<strong>扩容机制成本非常大</strong>, 因为它需要新建一个长数组,然后把之前的每个节点都重新计算hash值,再复制到新数组中,构成新的链表数组</p><p>扩容机制的新数组长度为旧数组的两倍， 这就保证了旧数组中的节点所在位置index在新数组中，要么还是index，要么就是index+oldTable.lenth()</p><h5 id="JDK1-8的红黑树"><a href="#JDK1-8的红黑树" class="headerlink" title="JDK1.8的红黑树"></a>JDK1.8的红黑树</h5><p>由于扩容机制的成本太大，所以JDK1.8中引入了红黑树的数据结构，它是一种自平衡二叉树，它不要求平衡二叉树那样的绝对平衡，但是每次添加操作，都能保证只做三次旋转，就能达到自平衡二叉树的要求，而平衡二叉树插入新节点的旋转次数却不可预知。</p><p>红黑树保证了用少量的算力换取相对的平衡。</p><p>在JDK1.8中设计了每个链表长度都有阈值，超过阈值后，链表就会转换成红黑树。以降低时间复杂度和减少扩容次数。</p><h5 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h5><p>JDK1.7采用头插法，但是由于每次插入操作之前,都会遍历一遍链表,已判断是更新还是插入,所以头插法并没有提高插入效率 ,其次可能是考虑到新插入的元素更可能被先使用，所以使用头插法，让先头插法让新插入的元素更容易的被查找到</p><p>JDK1.8开始采用尾插法</p><ol><li>是因为JDK1.7中的扩容机制，是从表头开始复制到新数组,这就和原来的旧的链表相反了, 由于头插法, 后插入的数据本来应该在表头,可是复制到新数组中成了链表的尾结点. 这使得新插先用的想法成为了伪命题.</li><li>头插法在并发情况下,容易造成循环链<h5 id="HashMap在JDK1-8中的简单流程"><a href="#HashMap在JDK1-8中的简单流程" class="headerlink" title="HashMap在JDK1.8中的简单流程"></a>HashMap在JDK1.8中的简单流程</h5><img src="/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/HashMap%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="HashMap流程图"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发容器类&quot;&gt;&lt;a href=&quot;#并发容器类&quot; class=&quot;headerlink&quot; title=&quot;并发容器类&quot;&gt;&lt;/a&gt;并发容器类&lt;/h2&gt;&lt;h3 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java集合容器" scheme="https://zhuyiting.xyz/tags/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS抽象队列同步器详解</title>
    <link href="https://zhuyiting.xyz/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhuyiting.xyz/2019/03/25/Java并发编程/AQS抽象队列同步器详解/</id>
    <published>2019-03-25T14:17:53.000Z</published>
    <updated>2019-11-19T03:30:55.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS抽象队列同步器详解"><a href="#AQS抽象队列同步器详解" class="headerlink" title="AQS抽象队列同步器详解"></a>AQS抽象队列同步器详解</h2><h3 id="同步锁的本质是什么"><a href="#同步锁的本质是什么" class="headerlink" title="同步锁的本质是什么?"></a>同步锁的本质是什么?</h3><p>同步的方法:独享-单个排队窗口,共享-多个排队窗口<br>抢锁的方法:不公平-插队抢,公平-先来后到排队<br>没抢到锁怎么办:反复询问窗口是否有空(CAS自旋),等待叫号(阻塞等待)<br>唤醒阻塞线程:全部通知,通知下一个(叫号器)</p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS全称AbstractQueuedSynchronizer  被认为是J.U.C的核心，和CAS共同撑起了整个J.U.C包（java.util.concurrent）<br>J.U.C中的大多数同步器都是基于AQS来构建的.</p><p>抽象队列同步器AQS，用于解决的就是多线程并发访问控制问题，在传统的多线程编程中，如果有多个线程需要访问同一个变量，就需要使用sychronized来为临界值区加锁，但是这种方法即不优雅，也不高效，更重要的是，不能实现更细粒度的控制，这时候AQS提供了一种简洁优雅的机制来实现线程安全:<strong>管理同步状态、阻塞/唤醒线程、管理等待队列</strong></p><p>本质上来说，<u>AQS是构建（包括锁在内）大部分同步组件的基本基础框架</u>，它<strong>实现了对资源的占用,释放;线程的等待唤醒,等相关接口的实现。</strong></p><p>比如ReentrantLock、CountDownLatch、CyclicBarrier等同步起， 其实都是通过内部类实现了AQS框架暴露的API，以此实现各类同步器功能，这些同步器的主要区别其实就是对同步状态（synchronion state）的定义不同。</p><h3 id="AQS的作用"><a href="#AQS的作用" class="headerlink" title="AQS的作用"></a>AQS的作用</h3><p>AQS框架， 分裂了构建同步器时的一系列关注点，它的额所有操作都围绕着资源——同步状态（synchronization state）来展开，并且解决了如下问题</p><ol><li>资源时可以被同时访问？ 还是在同一时间只能被一个线程访问（共享/独占功能）</li><li>访问资源的线程如何进行并发管理？（等待队列）</li><li>如果线程等不及资源了，如何从等待队列退出（超时/中断）</li></ol><p>这相当于时<strong>模板方法设计模式</strong>， AQS作为父类 定义好框架和内部操作细节， 具体的<strong>实现则由子类来操作</strong></p><p>AQS框架将剩下的一个问题留给用户：<br>什么是资源？ 如何定义资源是否可以被访问？</p><p>以下则是具体同步器<br><img src="/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/%E5%85%B7%E4%BD%93%E5%90%8C%E6%AD%A5%E5%99%A8.png" alt="具体同步器"></p><p>综上所述：<br><strong>AQS提供了一套模板框架：</strong><br>由于并发的存在，需要考虑的情况很多，因此能否以一种相对简单的方法来完成这两个目标就非常重要， 因为对于用户（AQS框架的使用者），很多时候并不关心内部复杂的细节。而AQS其实就是利用模板方法来实现这一点，AQS中大多数方法都是final或者private的。<br>AQS通过暴露以下API来让用户自己解决上面提到的“什么是资源？ 如何定义资源是否可以被访问？”的问题。<br><img src="/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.png" alt="钩子方法"><br><strong>AQS支持中断、超时：</strong><br>使用了AQS框架的同步器，都支持下面的操作：<br>阻塞和非阻塞（例如tryLock）同步；<br>可选的超时设置，让调用者可以放弃等待；<br>可中断的阻塞操作。</p><p><strong>AQS支持独占模式和共享模式：</strong><br>AQS框架内部通过一个内部类ConditionObject，实现了Condition接口，以此来为子类提供条件等待的功能。</p><h3 id="AQS原理简述"><a href="#AQS原理简述" class="headerlink" title="AQS原理简述"></a>AQS原理简述</h3><p>AQS所有操作都围绕着资源——同步状态（synchronization state）来展开，围绕着资源，衍生出三个基本问题：</p><ol><li>同步状态（synchronization state）的管理</li><li>阻塞/唤醒线程的操作</li><li>线程等待队列的管理<h4 id="AQS内部主体"><a href="#AQS内部主体" class="headerlink" title="AQS内部主体"></a>AQS内部主体</h4></li></ol><p><strong>属性</strong><br>state:同步状态位,锁的数量,加锁+1,释放-1<br>owner:资源拥有者<br>node:锁的等待者<br><strong>方法</strong><br>acquire,acquireShared:定义了资源争用逻辑,如果没拿到,进入等待队列<br>tryAcquire,tryAcquireShared:实际占用资源的操作, 需要具体使用者来实现<br>release,releaseShared:定义了释放资源的逻辑,释放之后,通知队列进行争抢<br>tryRelease,tryReleaseShared:实际执行资源释放的操作,由具体使用者来实现</p><h4 id="AQS实现一把简单的独享锁流程图"><a href="#AQS实现一把简单的独享锁流程图" class="headerlink" title="AQS实现一把简单的独享锁流程图"></a>AQS实现一把简单的独享锁流程图</h4><p><img src="/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/AQS%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="独享锁流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AQS抽象队列同步器详解&quot;&gt;&lt;a href=&quot;#AQS抽象队列同步器详解&quot; class=&quot;headerlink&quot; title=&quot;AQS抽象队列同步器详解&quot;&gt;&lt;/a&gt;AQS抽象队列同步器详解&lt;/h2&gt;&lt;h3 id=&quot;同步锁的本质是什么&quot;&gt;&lt;a href=&quot;#同步锁的
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java锁" scheme="https://zhuyiting.xyz/tags/Java%E9%94%81/"/>
    
      <category term="AQS" scheme="https://zhuyiting.xyz/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Lock锁</title>
    <link href="https://zhuyiting.xyz/2019/03/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Lock%E9%94%81/"/>
    <id>https://zhuyiting.xyz/2019/03/17/Java并发编程/Lock锁/</id>
    <published>2019-03-17T10:17:53.000Z</published>
    <updated>2019-11-19T01:23:04.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock是一个锁的接口， 提供获取锁和解锁的方法（lock，trylock，unlock）<br>是一种用代码实现的锁<br><strong>注意:</strong>当Lock没有指向unlock释放锁的时候,即为可重入锁,其他线程在锁没有释放的时候还是无法获取锁,即使没有线程在使用锁, 但还是有一个线程在占用锁<br><strong>ReentrantLock</strong>是Lock接口的一个实现类， 它实现了Lock中的方法， 但是使用Lock的时候必须注意它不会像synchronized执行完后或者抛出异常后自动释放锁， 而是需要你主动释放锁， 所以我们必须在使用Lock时加上try{}catch{}finally{}块，并且在finally中释放占用的锁资源。</p><p>使用Lock和synchronized最大的区别就是当<strong>使用synchroniized时一个线程抢占资源，其他线程必须等待</strong>，而<strong>使用Lock，一个线程抢占到锁资源，其他的线程可以不等待或者设置等待时间</strong>， 实在抢不到可以去做其他的业务逻辑</p><h4 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a><strong>ReadWriteLock读写锁</strong></h4><p>它可以实现读写锁， 当读取的时候线程会获得read锁， 其他线程也可以获取read锁，同时并发的去读取，但是写程序运行获取到write锁时， 其他线程是不能进行操作的，因为write是排它锁，而上面介绍的两种Lock和synchronized不管是read还是write没有抢到锁的线程都会被阻塞或者中断，ReadWriteLock也是个接口，里面定义了两种方法readLock()和writeLock()，他的一个实现类是ReentrantReadWriteLock是ReadWriteLock的实现类<br><strong>注意</strong>读锁被占用的时候,写锁不能被占用</p><h3 id="小记"><a href="#小记" class="headerlink" title="小记:"></a><strong>小记:</strong></h3><p><strong>Lock比内置锁更具灵活性,可以设置方法不去等待锁,做其他的逻辑操作. 它具备和内置锁同样的内存语义</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h3&gt;&lt;p&gt;Lock是一个锁的接口， 提供获取锁和解锁的方法（lock，trylock，unlock）&lt;br&gt;是一种用代码实现的锁&lt;br
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java锁" scheme="https://zhuyiting.xyz/tags/Java%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java锁与synchronized</title>
    <link href="https://zhuyiting.xyz/2019/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E9%94%81%E4%B8%8Esynchronized/"/>
    <id>https://zhuyiting.xyz/2019/03/15/Java并发编程/Java锁与synchronized/</id>
    <published>2019-03-15T06:04:30.000Z</published>
    <updated>2019-11-19T01:26:04.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java锁与synchronized"><a href="#Java锁与synchronized" class="headerlink" title="Java锁与synchronized"></a>Java锁与synchronized</h2><p>Java内置锁synchronized是一把互斥锁, 这意味这同时只有一个线程能够进入锁</p><h3 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h3><ol><li>自旋锁: 为了不放弃CPU执行事件,循环的使用CAS技术对数据尝试进行更新,直到成功,本质上是乐观锁的一种实现</li><li>悲观锁: 假定会发生并发冲突,同步所有对数据的相关的操作,从读数据就开始上锁</li><li>乐观锁: 假定没有冲突,在修改数据时如果发现数据和之前不一致,则读最新数据,再重试修改</li><li>独享锁(写): 给资源加上写锁,只有一个线程可以修改,其他线程排队</li><li>共享锁(读): 给资源加上读锁,其他线程只能加读锁,不能加写锁</li><li>可重入锁、不可重入锁: 线程拿到锁后可以、不可以重用锁资源</li><li>公平锁、不公平锁: 争抢锁的顺序,如先来后到则是公平锁</li></ol><p><strong>注意</strong>:不同的锁应对不同的场景,没有优劣之分,只有最适合场景的锁.</p><h3 id="同步关键字synchronized："><a href="#同步关键字synchronized：" class="headerlink" title="同步关键字synchronized："></a>同步关键字synchronized：</h3><p>Java内置锁synchronized<br><strong>同步关键字synchronized属于悲观锁</strong><br>属于最基本的线程通信机制，基于对象监视器实现的。<br>Java中的每个对象都与一个监视器相关联，<br>一个线程可以锁定或解锁监视器，一次只有一个线程可以锁定监视器<br>特性：synchronized是一个可重入、独享、悲观锁</p><p>synchronized用于同步方法和代码块，执行完后自动释放锁</p><h4 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围:"></a><strong>锁的范围:</strong></h4><p>修饰类或静态方法,<strong>类锁</strong>, 同步的内容是class对象和静态方法</p><p>修饰非静态方法或者this,<strong>对象锁</strong>,同步的内容是单个对象资源</p><h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><h4 id="理解Java对象头与Monitor"><a href="#理解Java对象头与Monitor" class="headerlink" title="理解Java对象头与Monitor"></a>理解Java对象头与Monitor</h4><p>对象在内存中，有一块对象头区域，它是实现synchronized的基础，</p><p><strong>对象头区域</strong>有两个部分：<br>第一部分(markword)，存放<strong>hashCode值</strong>、<strong>锁状态</strong>、<strong>GC标志</strong>等信息<br>第二部分，存放<strong>类型指针</strong>，指向类元数据，表名该对象属于哪个类</p><p>第一部分除了锁状态，Java6还新增了轻量级锁和偏向锁。<br>synchronized属于重量级锁</p><h5 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h5><p>对象头中的锁状态，存放这锁的信息</p><ol><li><p>有一个<strong>线程ID</strong><br>是标记线程对象的<br>线程中也有一个锁记录,来标记到锁</p></li><li><p>有一个<strong>锁状态位</strong><br>标记当前锁的状态<br>01:unlocked(未锁定)<br>00:轻量级锁<br>10:重量级锁<br>11:要被GC回收<br><u>线程可以通过CAS机制来修改锁的状态位</u></p></li><li><p>有一个<strong>偏向锁锁状态位</strong><br>偏向锁锁状态位只有一位<br>0/1: 开启或者关闭</p></li><li><p>有一个<strong>锁监视器标志位</strong></p></li></ol><p><strong>锁监视器标志位</strong>中指针指向<strong>Monitor对象（锁监视器）</strong>的起始地址<br>每个对象都有一个<strong>Monitor对象（锁监视器）</strong>与其关联</p><h5 id="Monitor对象（锁监视器）"><a href="#Monitor对象（锁监视器）" class="headerlink" title="Monitor对象（锁监视器）"></a>Monitor对象（锁监视器）</h5><p>Monitor对象（锁监视器）中有一个指针，指向持有它的线程(_owner)<br>Monitor对象还拥有两个队列， 一个是<strong>线程排队队列(_EntryList)</strong>，一个是<strong>线程阻塞队列(_WaitList)</strong>。</p><p>当持有它的对象释放它的时候，指针会重制，指向等待队列中的下一个线程，</p><p>当线程执行wait时,它会进入阻塞队列_WaitList,唤醒后,进入排队队列_EntryList</p><p>synchronized就是通过这种方法来实现锁的， 这也是为什么Java中任意对象都可以是锁的原因。<br>监视器跟对象共同的生命周期,但是在没有开启重量级锁之前,监视器是空对象,_owner在开启重量级锁后才会指向线程</p><h3 id="偏向锁、轻量级锁、自旋锁、锁消除"><a href="#偏向锁、轻量级锁、自旋锁、锁消除" class="headerlink" title="偏向锁、轻量级锁、自旋锁、锁消除"></a>偏向锁、轻量级锁、自旋锁、锁消除</h3><p><strong>偏向锁</strong><br>偏向锁就是，当一个线程获得了锁，就会进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁(<strong>本质可以理解为单线程情况无锁</strong>)<br><u>(因为当只有一个线程反复操作锁的时候,不应该反复加锁, 这是额外的消耗,是需要尽量降低的)</u></p><p>当一个线程来获取锁,并不会第一时间修改锁状态位,而是先修改偏向锁的标志位,偏向锁默认为1 即开启状态,还有一个线程标记,指向获取偏向锁的线程,线程要获取偏向锁,修改线程标记指向自己, 操作成功即得到锁,第二次再来访问锁时,比较当前的线程标记是否是自己,如果是,就直接访问. 但如果是第二个线程想要来获取锁,发现线程标记不是自己,就会锁升级到轻量级锁,升级后,偏向锁改为0,即关闭偏向锁</p><p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，当每次申请锁的线程都是不相同的,每个线程都获得了偏向锁,就没有了偏向锁的效果了</p><p>偏向锁失败后，会升级为轻量级锁</p><p><strong>轻量级锁</strong><br>当一个线程进入锁,有线程来争抢锁时,偏向锁升级为轻量级锁<br>来争抢的线程会进入自旋,即循坏等待锁被释放,即<strong>自旋锁</strong></p><p>轻量级锁所适应的场景是线程交替执行同步块的场合</p><p>如果存在同一时间多个线程访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><p><strong>重量级锁</strong><br>重量级锁即synchronized实现的锁, 启用锁监视器Monitor对象<br>线程自旋次数增加后升级到重量级锁, 停止自旋, 监视器启动, 监视器中的_owner属性指向当前占有锁的线程,</p><p><u>锁升级是单向的,即从低到高,从轻到重,锁的等级是通过对象中的锁信息里的状态位来标识,而多线程争抢锁,就会改变这个状态位</u></p><p><strong>锁消除</strong><br>锁消除即消除不必要的锁,或者缩小锁的范围</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java锁与synchronized&quot;&gt;&lt;a href=&quot;#Java锁与synchronized&quot; class=&quot;headerlink&quot; title=&quot;Java锁与synchronized&quot;&gt;&lt;/a&gt;Java锁与synchronized&lt;/h2&gt;&lt;p&gt;Java内置
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java锁" scheme="https://zhuyiting.xyz/tags/Java%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>使用volatile解决可见性问题及阻止指令重排序</title>
    <link href="https://zhuyiting.xyz/2019/03/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BD%BF%E7%94%A8volatile%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E9%98%BB%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <id>https://zhuyiting.xyz/2019/03/03/Java并发编程/使用volatile解决可见性问题及阻止指令重排序/</id>
    <published>2019-03-03T14:52:41.000Z</published>
    <updated>2019-11-18T01:24:38.529Z</updated>
    
    <content type="html"><![CDATA[<h4 id="volatile解决可见性问题"><a href="#volatile解决可见性问题" class="headerlink" title="volatile解决可见性问题"></a>volatile解决可见性问题</h4><p>volatile关键字的作用之一，是系统每次使用被它修饰过的变量时都时直接从内存中提取，而不是从缓存Cache中提取，同时对于该变量的更改会马上刷新回主存，使得各个线程取出的值相同，这里的Cache可以理解为线程的工作内存。<br><strong>volatile可以解决可见性问题，但无法解决原子性问题</strong><br>（synchronized或其他的加锁，也能保证内存的可见性，但实现方式略有不同，<strong>volatile的使用成本更低，因为它不会引起线程上下文的切换和调度。</strong>）</p><h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p>对于volatile修饰的变量的写操作会有一行以lock作为前缀的汇编代码。这个指令在多核处理器下会引发两件事，</p><ol><li>将当前处理器缓存行的数据写回到主内存；</li><li>这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效(<strong>禁用缓存</strong>)<br>lock前缀的指令会锁住系统总线或者缓存，目的就是保证在同一时间只有一个CPU可以修改数据。</li></ol><h4 id="volatile解决指令重排序问题"><a href="#volatile解决指令重排序问题" class="headerlink" title="volatile解决指令重排序问题"></a>volatile解决指令重排序问题</h4><p>volatile的另外一个作用就是阻止指令重排序<br>JVM会在不改变数据依赖的前提下对指令进行任意排序以提高程序性能。如果不存在数据依赖性，处理器也可以改变语句对应机器指令的执行顺序；</p><p>volatile通过插入内存屏障来实现阻止指令重排序</p><p>happens-before原则：它保证了程序的有序性，它规定如果两个操作的执行顺序无法从happens-before原则中推出来，那么它们就不能保证有序性，可以随意进行重排序：</p><p><strong>总结:</strong> volatile可以保证可见性和有序性,但不能保证原子性.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;volatile解决可见性问题&quot;&gt;&lt;a href=&quot;#volatile解决可见性问题&quot; class=&quot;headerlink&quot; title=&quot;volatile解决可见性问题&quot;&gt;&lt;/a&gt;volatile解决可见性问题&lt;/h4&gt;&lt;p&gt;volatile关键字的作用之一，是
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="volatile" scheme="https://zhuyiting.xyz/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>了解原子性CAS操作</title>
    <link href="https://zhuyiting.xyz/2019/03/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%80%A7CAS%E6%93%8D%E4%BD%9C/"/>
    <id>https://zhuyiting.xyz/2019/03/03/Java并发编程/了解原子性CAS操作/</id>
    <published>2019-03-03T06:13:07.000Z</published>
    <updated>2019-11-17T10:09:54.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>Atomic相关的类采用CAS操作来实现原子性</p><p>CAS操作依赖底层硬件的CAS指令,CAS指令有两个步骤:冲突检测和更新操作,但是这两个步骤合起来成为    一个原子性操作</p><p>CAS指令需要3个操作数,:内存位置(V),旧的预期值(A),新值(B).CAS指令执行时,首先比较内存位置V处的值和A的值是否相等(冲突检测),如果相等,就用新值B覆盖A(更新操作),否则,就什么都不做,所以一般循环执行CAS操作,直到成功为止.</p><p>Unsafe类里面的compareAndSwapXXX 方法最后都会变成与硬件相关的CAS指令. 从Unsafe这个类名就可以看出, 作者不希望我们随便使用,因为这是不安全的,<br>为什么不安全:因为这个类可以直接操作内存;还有其他的一些底层操作, 比如将线程挂起,就是调用了Unsafe类的park方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAS操作&quot;&gt;&lt;a href=&quot;#CAS操作&quot; class=&quot;headerlink&quot; title=&quot;CAS操作&quot;&gt;&lt;/a&gt;CAS操作&lt;/h3&gt;&lt;p&gt;Atomic相关的类采用CAS操作来实现原子性&lt;/p&gt;
&lt;p&gt;CAS操作依赖底层硬件的CAS指令,CAS指令有两个步
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="原子性" scheme="https://zhuyiting.xyz/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础</title>
    <link href="https://zhuyiting.xyz/2019/02/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2019/02/23/Java并发编程/Java并发编程基础/</id>
    <published>2019-02-23T05:48:00.000Z</published>
    <updated>2019-11-17T10:20:01.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java并发编程研究的是什么"><a href="#Java并发编程研究的是什么" class="headerlink" title="Java并发编程研究的是什么"></a>Java并发编程研究的是什么</h2><p>解决三个问题<br>并发编程最先要解决的就是性能问题， 而引入多线程的概念带来了新的问题，即安全问题和活跃问题</p><h5 id="1-线程安全问题"><a href="#1-线程安全问题" class="headerlink" title="1. 线程安全问题"></a>1. 线程安全问题</h5><h5 id="2-活跃问题"><a href="#2-活跃问题" class="headerlink" title="2. 活跃问题"></a>2. 活跃问题</h5><p>死锁、活锁、饥饿</p><h5 id="3-性能问题"><a href="#3-性能问题" class="headerlink" title="3. 性能问题"></a>3. 性能问题</h5><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全就是线程同步的意思，当一个线程对一个线程安全的方法或者语句进行访问的时候，其他的线程不能在对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问。</p><p>多个线程同时运行时，这些线程可能会同时运行一个方法，如果每次运行的结果和单个线程运行的结果时一样的，而且其他的变量的值也和预期一样，就是线程安全的。线程安全的问题都是由全局变量及静态变量引起的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而没有写操作，一般来说，这个全局变量时线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能会影响线程安全。</p><h3 id="并发编程中的三大特性-重要概念"><a href="#并发编程中的三大特性-重要概念" class="headerlink" title="并发编程中的三大特性(重要概念)"></a>并发编程中的三大特性(重要概念)</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性:"></a><strong>1. 原子性:</strong></h4><p>Java内存模型保证了read，load，usee，assign，store，write，lock，unlock操作具有原子性，例如对一个int类型的变量执行assign赋值操作，这个操作就是原子性的。但Java内存模型允许虚拟机将没有被volatile修饰的64位数据（long，double）的读写操作划分为两次32位的操作来进行，即load，store，read和write操作可以不具备原子性。</p><p><strong>原子性</strong>是指该操作是不可再分的.不论是多核还是单核,具有原子性的量,同一时刻只能有一个线程来对它进行操作.<br><strong>竞态条件</strong>是指通过一个可能失效的观测结果来决定下一步的动作,比如A拿到数据n,将要执行++操作, 而B在A拿到数据后操作前, 做了一次n=n+1, 那么在A对n完成+1并写回n以后, B对n的操作就失效了.<br><strong>原子操作</strong>是一个步骤,也可以是多个步骤,但是其顺序是不可以被打乱的,也不可以被切割而只执行其中的一部分(不可中断性)<br>将操作视为一个整体,资源在该次操作中保持一致,这就是原子性的核心特征.<br>原子操作是不会被线程调度机制打断的操作;这种操作一旦开始,就一直运行到结束,中间不会有任何context switch(切换到另一个线程).</p><h4 id="2-可见性："><a href="#2-可见性：" class="headerlink" title="2. 可见性："></a><strong>2. 可见性：</strong></h4><p><strong>可见性：</strong> 可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立刻看到。</p><p>CPU从主存中读取数据的效率相对不高，现在主流的计算机中都会设有几级缓存，每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存中，修改变量后，CPU会立刻更新缓存，但并不一定会立即将其写回主存（写进主存的时间不可预期），此时其他线程（尤其时不再同一CPU上执行的线程）访问该变量时，从主存中读到的就是酒数据，而非第一个线程更新后的数据。</p><p>这点实在操作系统或者说时硬件层面的机制，所以很多应用开发人员经常会忽略。</p><p>可见性就是要让一个CPU核心对数据的修改，对其他CPU核心立即可见。<br>volatile关键词修饰的变量是指CPU从缓存读取数据时，其他CPU可见,然后都会从内存中读取数据</p><h4 id="3-有序性："><a href="#3-有序性：" class="headerlink" title="3. 有序性："></a><strong>3. 有序性：</strong></h4><p><strong>有序性:</strong> 是指在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序时因为发生了指令重排序。在java内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>volatile关键字通过添加内存屏障的方式来禁止指令重排序，即重排序时不能把后面的指令放到内存屏障之前。<br>也可以用synchronized来保证有序性， 它保证每个时刻只有一个线程可以执行同步代码，相当于是让线程顺序执行同步代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java并发编程研究的是什么&quot;&gt;&lt;a href=&quot;#Java并发编程研究的是什么&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程研究的是什么&quot;&gt;&lt;/a&gt;Java并发编程研究的是什么&lt;/h2&gt;&lt;p&gt;解决三个问题&lt;br&gt;并发编程最先要解决的就是
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="内存模型" scheme="https://zhuyiting.xyz/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型与内存区域</title>
    <link href="https://zhuyiting.xyz/2019/02/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://zhuyiting.xyz/2019/02/19/Java并发编程/JVM内存模型与内存区域/</id>
    <published>2019-02-19T05:38:15.000Z</published>
    <updated>2019-11-17T09:34:25.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p><img src="/2019/02/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="jvm内存模型"><br>1.类装载子系统把 .class 文件装载运行时数据区（内存模型）<br>2.执行引擎去数据区执行字节码文件</p><h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><h4 id="1-堆-共享"><a href="#1-堆-共享" class="headerlink" title="1. 堆(共享)"></a>1. <strong>堆(共享)</strong></h4><p><img src="/2019/02/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%A0%86%E5%86%85%E5%AD%98.png" alt="堆内存"><br>堆就是被所有线程共享的一块内存区域.这块内存区域的唯一目的就是存放内存实例.<br>几乎所有对象实例都在这里分配内存.<br>但不是所有对象都保存在堆中，如果java在必要的时候，可以把对象分配到栈中，从而自动<br>销毁对象，那必然能减少一些垃圾回收的开销，同时提高执行效率。<br>逃逸分析：它并不是直接优化代码的手段，而是为其他优化手段提高依据的分析技术，逃逸<br>分析的主要作用就是分析对象的作用域。<br>当一个对象在方法中被定义后，他可能被外部方法引用，例如作为调用参数传到其他方法，<br>这种行为叫做方法逃逸。甚至该对象可能被外部线程访问到，例如赋值被类变量或可以在其<br>他线程中访问的实例变量，称为线程逃逸，通过逃逸分析，把不逃逸的对象找出，并在栈中<br>分配内存，那他就可以随着方法桢出栈而销毁。这样大量的对象就不需要存放在堆中，垃圾<br>收集系统的压力也会变小很多。</p><p>线程共享的Java堆中可能还会为每个线程划分线程私有的分配缓冲区（Thread Local<br>Allocation Buffer，TLAB）,但存放的依旧是对象实例.对象被new出来的时候会同时生成一个<br>对象头信息,其中有一个类指针,指向方法区中的类元信息<br>对象创建的五种方式:</p><ol><li>new关键字(调用了构造方法)<br>User user=new User();</li><li>利用反射机制(调用了构造方法)<br>User user=User.class.newInstance();</li><li>利用Constructor类的newInstance()(调用了构造方法)<br>Constructor<User> constructor=User.class.getConstructor();<br>User user=constructor.newInstance();</User></li><li>使用clone方法(没有调用了构造方法)<br>User user2=user1.clone();</li><li>反序列化(没有调用了构造方法)<br>ObjectInputStream in=new ObjectInputStream(new FileInputStream(“user.obj”));<br>User user=(User) in.readObject();</li></ol><p><strong>对象创建的过程大致如下：</strong></p><ol><li>虚拟机遇到new指令，到常量池定位到到这个类的符号引用，</li><li>检查符号引用代表的类是否被加载、解析、初始化过，如果没有，那必须先执行相应<br>的类加载过程</li><li>虚拟机为对象分配内存</li><li>虚拟机将分配到的内存空间都初始化为0值</li><li>虚拟机对对象进行必要的设置</li><li>执行方法，成员变量进行初始化<br>新建出来的对象,存放在Eden,当Eden存满,会触发JVM的minor gc命令,会把Eden中没有引用的对象清理掉, 这些对象被转移到Survivor取,并且每经历一次minor gc 对象的分代年龄就会+1,当分代年龄达到15,就会存放到老年代中,当老年代中的对象存满时,会执行full gc,如果还是不能清理出内存空间,就会产生内存溢出</li></ol><h4 id="2-栈（线程栈-虚拟机栈）-私有"><a href="#2-栈（线程栈-虚拟机栈）-私有" class="headerlink" title="2. 栈（线程栈/虚拟机栈）(私有)"></a>2. <strong>栈（线程栈/虚拟机栈）(私有)</strong></h4><p>虚拟机栈符合栈数据结构的特征，先进后出（主方法进站子方法再进栈，先执行子方法，子方法执行完出栈，最后主方法再出栈）。<br>栈是线程私有的，每个线程有对应的独立栈区，它的生命周期与线程相同。栈是描述Java方法执行的内存模型，每个方法在执行的同时都会创建这个方法对应的栈帧，用于存储方法内部局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完的过程就对应着一个栈桢在栈中入栈到出栈的过程。</p><p><strong>栈帧内存模型：</strong></p><ol><li>局部变量表：存放了编译期可知的各种基本数据类型、以及对象变量和其对象的地址<br>(指向堆中), 内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配<br>多大的局部空间是完全确定的.</li><li>操作数栈：存放操作数,遇到运算符取数据</li><li>动态链接：存放线程中每个方法的指令码的内存地址</li><li>方法出口：方法执行完要返回到父方法(线程)中的哪一条指令</li></ol><h4 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. <strong>本地方法栈</strong></h4><p>本地方法栈也是线程私有的,用于存放系统本地的方法,一般用于java访问系统中的c语言写的方法.</p><h4 id="4-方法区（元空间）-共享"><a href="#4-方法区（元空间）-共享" class="headerlink" title="4. 方法区（元空间）(共享)"></a>4. <strong>方法区（元空间）(共享)</strong></h4><p>方法区存放在系统内存中,不在jvm虚拟机的内存中.<br>方法区存放常量,静态变量以及类元信息(类的方法,类的属性)<br>运行时常量池是方法区的一部分,《Java虚拟机规范》对于方法区的管理是最宽松的，这个区域可以不用实现垃圾回收，对于内存策略，方法区的大小可以是固定的也可以是可扩展的，不同的虚拟机对于方法区有不同的实现，HotSpot虚拟机在Java 8之前，方法区仅仅是逻辑上的空间，物理上位于堆中的永久代中。Java 8中HotSpot虚拟机移除了堆中的永久代，使<br>用本地内存存储类元信息，称为元空间</p><h4 id="5-程序计数器-私有"><a href="#5-程序计数器-私有" class="headerlink" title="5. 程序计数器(私有)"></a>5. <strong>程序计数器(私有)</strong></h4><p>程序计数器是线程私有的。存放线程正在执行或者将要执行的JVM指令存放的对应地址。</p><h4 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.<strong>直接内存</strong></h4><p>直接内存并不是虚拟机运行时数据区的一部分,也不是虚拟机规范中定义的内存区域,但也被频繁使用.</p><h3 id="JVM内存间交互操作"><a href="#JVM内存间交互操作" class="headerlink" title="JVM内存间交互操作"></a>JVM内存间交互操作</h3><p>Java内存模型中定义了8个操作来完成主内存和工作内存的交互操作.<br><img src="/2019/02/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/jvm%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C.png" alt="jvm内存操作"></p><ol><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在read之后执行，把read得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在store之后执行，把store得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/19/Java%E5%B9%B6%E5%8F%91%E7%BC
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池原理及应用</title>
    <link href="https://zhuyiting.xyz/2019/02/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://zhuyiting.xyz/2019/02/15/Java并发编程/线程池原理及应用/</id>
    <published>2019-02-15T02:31:21.000Z</published>
    <updated>2019-11-15T05:11:56.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、为什么要使用线程池"><a href="#一、为什么要使用线程池" class="headerlink" title="一、为什么要使用线程池"></a>一、为什么要使用线程池</h3><p>在一些需要使用线程去处理任务的业务场景中，如果每一个任务都创建一个线程去处理，任务处理完过后，把这个线程销毁，这样会产生大量的线程创建、销毁的资源开销，Java中更是如此，虚拟机将试图跟踪每一个对象。以便可以在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能降低创建和销毁对象的次数。使用线程池能够有效的控制这种线程的创建和销毁，而且能够对创建的线程进行有效的管理。</p><h4 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处:"></a>使用线程池的好处:</h4><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会<br>=降低系统稳定性，使用线程池可以进行统一分配、调优和监控。</li></ol><h4 id="线程池原理-概念"><a href="#线程池原理-概念" class="headerlink" title="线程池原理-概念"></a>线程池原理-概念</h4><ol><li>线程池管理器:用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务;</li><li>工作线程:线程池中线程,在没有任务时处于等待状态,可以循环的执行任务;</li><li>任务接口:每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入<br>口,任务执行后的首尾工作,任务的执行状态等;</li><li>任务队列:用于存放没有处理的任务.提供一种缓存机制.</li></ol><h3 id="二、Java线程池相关API介绍"><a href="#二、Java线程池相关API介绍" class="headerlink" title="二、Java线程池相关API介绍"></a>二、Java线程池相关API介绍</h3><ol><li><p>Executor接口<br>主要是用来执行提交的任务。<br>线程池会实现这个接口，并且使用exectue方法来提交一个任务。</p></li><li><p>ExecutorSevice接口<br>ExecutorService接口是Executor接口的一个子接口，它在Executor接口的基础上增加了一些方法，用来支持对任务的终止管理以及对异步任务的支持。</p></li></ol><ol start="3"><li><p>AbstractExecutorService抽象类<br>AbstractExecutorService实现了ExcutorService，并且基于模板方法模式对一些方法给出了实现。是后面提到的线程池类ThreadPoolExcutor的直接父类。</p></li><li><p>ThreadPoolExcutor类<br>ThreadPoolExcutor通常就是我们所说的线程池类，Java的线程池就是用这个类进行创建的。<br>在分析线程池的运行原理时，也是基于这个类来进行分析。</p></li><li><p>ScheduledExecutorService接口<br>ScheduledExecutorService接口时ExecutorService子接口，定义了线程池基于任务调度的一些方法。</p></li><li><p>ScheduledThreadPoolExecutor类<br>ScheduledThreadPoolExecutor集成了ThreadPoolExecutor类，并且实现了ScheduledExecutorService接口，对任务调度的功能进行了实现。</p></li><li><p>Executors类<br>Executors可以认为是线程池的工厂类，里面提供了静态方法对线程池进行创建。</p></li></ol><h3 id="三、Java线程池的运行原理"><a href="#三、Java线程池的运行原理" class="headerlink" title="三、Java线程池的运行原理"></a>三、Java线程池的运行原理</h3><h4 id="1-线程池的参数属性介绍"><a href="#1-线程池的参数属性介绍" class="headerlink" title="1. 线程池的参数属性介绍"></a>1. 线程池的参数属性介绍</h4><p><strong>核心线程数corePoolSize</strong>：核心线程池数量。<br>提交一个任务的时候，会对线程池里面的当前存活线程数量和这个corePoolSize进行比较，不同的情况下会有不同的操作。<br><strong>最大线程数maximumPoolSize</strong>：线程池所能创建的线程的最大数量。<br><strong>空闲线程的超时时间keepAliveTime</strong>：如果线程池当前的线程数大于corePoolSize，并且这些线程中是有空闲线程的，也就是说这些线程没有在执行任务，那么空闲时间超过keepAliveTime时间，这些线程也会被销毁，指代前线程代数等于corePoolsize，这时即便有空闲线程并且超时了，也不会进行线程销毁。<br><strong>任务队列workQueue</strong>：这是一个阻塞队列，用于存储提交的任务。<br><strong>线程工厂threadFactory</strong>：线程池会使用这个工厂类来创建线程，用户可以自己实现。<br><strong>任务的拒绝处理handler（RejectedExeutionHandler）</strong>：在线程数已经达到了最大线程数，而且任务队列也满了以后，提交的任务会使用这个handler来处理，用户也可以自己实现。默认是抛出一个异常RejectedExecutionException。</p><h4 id="2-线程池运行原理分析"><a href="#2-线程池运行原理分析" class="headerlink" title="2. 线程池运行原理分析"></a>2. 线程池运行原理分析</h4><p>分析当用户提交一个任务使，线程池内部使如何运行的。<br><img src="/2019/02/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.png" alt="线程池原理"></p><ol><li>创建一个线程池，在还没有任务提交的时候，默认线程池里面是没有线程的。当然，可以调用prestartCoreThread方法，来预先创建一个核心线程。</li><li>线程池里面还没有线程或者线程池里面存活的线程数小于核心线程数corePoolSize时，这时对于一个新提交的任务，线程池会创建一个线程去处理提交的任务。当线程池里面存活的线程数小于等于核心线程数corePoolSize时，线程池里面的线程会一直存活着，就算空闲时间超过了keepAliveTime，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。</li><li>当线程池里面存活的线程数已经等于corePoolSize了，这时对于一个新提交的任务，会被放进任务队列workQueue排队等待执行。而之前创建的线程并不会被销毁，而是不断的去拿阻塞队列里面的任务，当任务列表为空时，线程会阻塞，直到有任务被放进任务队列，线程拿到任务后继续执行，执行完了以后继续去拿任务，这也是为什么线程池队列要使用阻塞队<br>列。</li><li>当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列也满了，这里假设maximumPoolSize&gt;corePoolSize（如果等于的话，就直接拒绝了），这时如果再来新的任务，线程池就会继续创建新的线程来处理新任务，直到线程数达到maximumPoolSize，就不会再创建了。这些新创建的线程执行完了当前任务后，再任务队列里面还有任务的时候也不会销毁，而是去任务队列拿任务出来执行。在当前线程数大于corePoolSize过后，线程执行完当前任务，会有一个判断当前线程是否需要销毁的逻辑；如果能从任务队列中拿到任务，那么继续执行，如果拿任务时阻塞（说明队列中没有任务），那超过keepAliveTime时间就直接返回null并且销毁当前线程，直到线程池里面的线程数等于corePoolSize之后才不会进行线程销毁。</li><li>如果当前线程数达到了maximumPoolSize，并且任务队列也满了，这种情况下还有新的任务过来，那就直接采用拒绝的处理器进行执行，默认的处理器逻辑时抛出一个RejectedExcutionException异常。你也可以指定其他的处理器，或者自定义一个拒绝处理器来实现拒绝逻辑的处理（比如把任务存储起来）。JDK提供了四种拒绝策略处理类；<br>AbortPolicy（抛出一个异常，默认的），<br>DiscardPolicy（直接丢弃任务），<br>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池），<br>CallerRunPolicy（交给线程池调用的所在线程进行处理）。</li></ol><p><img src="/2019/02/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="图解线程池"></p><h4 id="3-线程池包含以下四个基本组成部分："><a href="#3-线程池包含以下四个基本组成部分：" class="headerlink" title="3. 线程池包含以下四个基本组成部分："></a><strong>3. 线程池包含以下四个基本组成部分：</strong></h4><ol><li><strong>线程池管理器（ThreadPool）</strong>：用于创建并管理线程池。包含创建线程池，销毁线程池，<br>加入新任务；</li><li><strong>工作线程（PoolWorker）</strong>：线程池中线程，在没有任务时处于等待状态。能够循环的运行<br>任务。</li><li><strong>任务接口（Task）</strong>：每一个任务必须实现的接口，以供工作线程调度任务的运行。它主要<br>规定了任务的入口。任务运行完成后的收尾工作，任务的运行状态等。</li><li><strong>任务队列（taskQueue）</strong>：用于存放没有处理的任务。提供一种缓冲机制。</li></ol><h4 id="4-常用的几种线程池以及使用场景"><a href="#4-常用的几种线程池以及使用场景" class="headerlink" title="4. 常用的几种线程池以及使用场景"></a>4. 常用的几种线程池以及使用场景</h4><ol><li><strong>SingleThreadExecutor:单个线程的线程池</strong><br>这种线程池主要适用于请求量非常小的场景，或者离线的数据处理等，只需要一个线程就够了。在持续的请求量比较大的情况下，不要使用这种线程池，单线程处理会使队列<br>不断变大，最终可能导致内存溢出。</li><li><strong>FixedThreadPool：固定线程大小线程池</strong><br>这种线程的额corePoolSize和maximumPoolSize是相等的，keepAliveTime设置为0，队列用的是LinkedBlockingQueue无界队列。适用于流量比较稳定的情况，不会说一段时间突然有大量的流量涌入，导致LinkedBlockingQueue越来越大最后导致内存溢出。</li><li><strong>CachedThreadPool：按需求创建线程数量线程池</strong><br>这种线程的corePoolSize=0，maximumPoolSize是Integer.MAX_VALUE，<br>keepAliveTime为60秒，队列使用SynchronousQueue同步队列，这个队列可以理解为没有容量的阻塞队列，只有有别的线程来拿任务时，当前线程才能插入成功，反过来也一样。所以这种线程池任务队列时不存任务的，任务全靠创建新的线程来处理，处理完了以后线程空闲超过60秒就会被自动销毁，所以这种线程池适合有一定高峰流量的场景。但是还是要慎用，如果瞬时流量过高会导致创建的线程过多，直接导致服务所在机器的CPU负载过高，然后卡死，所以使用这种线程池必须指代最高峰时的流量也不会导致CPU负载过高。</li><li><strong>ScheduledThreadPoolExecutor：任务调度线程池</strong><br>可以根据自己的需求，使用单线程调度（SingleThreadExecutor）,多线程调度（ScheduledThreadPool）。不过现在使用spring调度比较多，所以开发中比较少用。</li><li><strong>自定义线程池（推荐使用）</strong><br>根据实际的一个业务场景，自己new一个ThreadPoolExecutor，参数根据业务场景需要指定合适的参数，比如核心线程数设置多少合适，最大线程数设置多少合适，任务队列设置多大的有界合适，拒绝策略也可以自定义，一般采用离线存储啥的，完全根据业务场景来定制。这样可以保证不会发生无界队列导致内存溢出，也不会导致创建的线程过多而导致机器卡死。</li></ol><h4 id="5-线程池关闭"><a href="#5-线程池关闭" class="headerlink" title="5. 线程池关闭"></a>5. 线程池关闭</h4><ol><li>shutdown():调用后不允许提交新任务，所有调用之前提交的任务都会执行，等所有任务<br>执行完，才会真正关闭线程池。</li><li>shutdownNow():强制关闭。返回还没有执行的task列表，然后不让等待的task执行，尝试<br>停止正在执行的task。</li></ol><p>线程池的使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 线程池的使用 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadPoolExecutor 传入不同的线程池，看不同的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommon</span><span class="params">(ThreadPoolExecutor threadPoolExecutor)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = i;</span><br><span class="line">threadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + n);</span><br><span class="line">Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">System.err.println(<span class="string">"执行结束:"</span> + n);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"任务提交成功 :"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看线程数量，查看队列等待数量</span></span><br><span class="line">Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">System.out.println(<span class="string">"当前线程池线程数量为："</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">System.out.println(<span class="string">"当前线程池等待的数量为："</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line"><span class="comment">// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）</span></span><br><span class="line">Thread.sleep(<span class="number">15000L</span>);</span><br><span class="line">System.out.println(<span class="string">"当前线程池线程数量为："</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">System.out.println(<span class="string">"当前线程池等待的数量为："</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">testCommon(threadPoolExecutor);</span><br><span class="line"><span class="comment">// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span></span><br><span class="line"><span class="comment">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"有任务被拒绝执行了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">testCommon(threadPoolExecutor);</span><br><span class="line"><span class="comment">// 预计结果：</span></span><br><span class="line"><span class="comment">// 1、 5个任务直接分配线程开始执行</span></span><br><span class="line"><span class="comment">// 2、 3个任务进入等待队列</span></span><br><span class="line"><span class="comment">// 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)</span></span><br><span class="line"><span class="comment">// 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。</span></span><br><span class="line"><span class="comment">// 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 和Executors.newFixedThreadPool(int nThreads)一样的</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">testCommon(threadPoolExecutor);</span><br><span class="line"><span class="comment">// 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、 线程池信息：</span></span><br><span class="line"><span class="comment"> * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。</span></span><br><span class="line"><span class="comment">// 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，</span></span><br><span class="line"><span class="comment">// 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，</span></span><br><span class="line"><span class="comment">// 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。</span></span><br><span class="line"><span class="comment">// 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和Executors.newCachedThreadPool()一样的</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">testCommon(threadPoolExecutor);</span><br><span class="line"><span class="comment">// 预计结果：</span></span><br><span class="line"><span class="comment">// 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行</span></span><br><span class="line"><span class="comment">// 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0</span></span><br><span class="line">Thread.sleep(<span class="number">60000L</span>);</span><br><span class="line">System.out.println(<span class="string">"60秒后，再看线程池中的数量："</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 和Executors.newScheduledThreadPool()一样的</span></span><br><span class="line">ScheduledThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line">threadPoolExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"任务被执行，现在时间："</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">System.out.println(</span><br><span class="line"><span class="string">"定时任务，提交成功，时间是："</span> + System.currentTimeMillis() + <span class="string">", 当前线程池中线程数量："</span> + threadPoolExecutor.getPoolSize());</span><br><span class="line"><span class="comment">// 预计结果：任务在3秒后被执行一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ScheduledThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。</span></span><br><span class="line"><span class="comment">// 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别</span></span><br><span class="line"><span class="comment">// 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。</span></span><br><span class="line"><span class="comment">// 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）</span></span><br><span class="line">threadPoolExecutor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"任务-1 被执行，现在时间："</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。</span></span><br><span class="line"><span class="comment">// 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）</span></span><br><span class="line">threadPoolExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"任务-2 被执行，现在时间："</span> + System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span></span><br><span class="line"><span class="comment">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"有任务被拒绝执行了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = i;</span><br><span class="line">threadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + n);</span><br><span class="line">Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">System.err.println(<span class="string">"执行结束:"</span> + n);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"异常："</span> + e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"任务提交成功 :"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1秒后终止线程池</span></span><br><span class="line">Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line"><span class="comment">// 再次提交提示失败</span></span><br><span class="line">threadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"追加一个任务"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果分析</span></span><br><span class="line"><span class="comment">// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</span></span><br><span class="line"><span class="comment">// 2、调用shutdown后，不接收新的任务，等待13任务执行结束</span></span><br><span class="line"><span class="comment">// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadPoolExecutorTest8</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span></span><br><span class="line"><span class="comment">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"有任务被拒绝执行了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> n = i;</span><br><span class="line">threadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"开始执行："</span> + n);</span><br><span class="line">Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">System.err.println(<span class="string">"执行结束:"</span> + n);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"异常："</span> + e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"任务提交成功 :"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1秒后终止线程池</span></span><br><span class="line">Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">List&lt;Runnable&gt; shutdownNow = threadPoolExecutor.shutdownNow();</span><br><span class="line"><span class="comment">// 再次提交提示失败</span></span><br><span class="line">threadPoolExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"追加一个任务"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"未结束的任务有："</span> + shutdownNow.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果分析</span></span><br><span class="line"><span class="comment">// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</span></span><br><span class="line"><span class="comment">// 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止</span></span><br><span class="line"><span class="comment">// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest1();</span></span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest2();</span></span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest3();</span></span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest4();</span></span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest5();</span></span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest6();</span></span><br><span class="line"><span class="comment">//new Demo().threadPoolExecutorTest7();</span></span><br><span class="line"><span class="keyword">new</span> Demo().threadPoolExecutorTest8();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、为什么要使用线程池&quot;&gt;&lt;a href=&quot;#一、为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要使用线程池&quot;&gt;&lt;/a&gt;一、为什么要使用线程池&lt;/h3&gt;&lt;p&gt;在一些需要使用线程去处理任务的业务场景中，如果每一个任务都创建一个线
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程封闭之ThreadLocal和栈封闭</title>
    <link href="https://zhuyiting.xyz/2019/01/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/"/>
    <id>https://zhuyiting.xyz/2019/01/29/Java并发编程/线程封闭之ThreadLocal和栈封闭/</id>
    <published>2019-01-29T13:25:59.000Z</published>
    <updated>2019-11-15T05:12:05.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭:"></a>线程封闭:</h3><p>线程不安全是因为多线程在访问共享的可变数据时,会发生数据的不一致,结果不正确. 实现好的并发是一件困难的事情, 那么如何解决呢,一个是使用同步,但是同步需要占用资源,另外一种方式,如果一个线程访问这个数据,就不会出现问题, 所以很多时候我们都想躲避并发. 避免并发最简单的方法就是线程封闭. <strong>什么是线程封闭; 就是把对象封装到一个线程里,只有这个线程能看到此对象. 那么这个对象就算不是线程安全的也不会出现任何问题.</strong></p><h3 id="线程封闭的实现方式"><a href="#线程封闭的实现方式" class="headerlink" title="线程封闭的实现方式:"></a>线程封闭的实现方式:</h3><ol><li>Ad-hoc : 维护线程封闭性的职责完全由程序实现来承担,是非常脆弱的, 因为没有任何一种语言特性, 能将对象封闭到目标线程上.</li><li><strong>栈封闭 : 简单的来说就是局部变量.</strong> 多个线程访问一个方法,此方法中的局部变量都会拷贝一份到线程栈中,. 所以局部变量是不被多个线程所共享,也就不会出现并发问题,所以能用局部变量就别用全局变量, 全局变量容易引起并发问题.</li><li>ThreadLocal封闭 : 使用<strong>ThreadLocal是实现线程封闭的最好方法</strong>. ThreadLocal内部维护了一个Map, Map的key是每个线程对象,而Map的值就是我们要封闭的对象(数据) . 每个线程中的对象都对应这Map中的一个值, 也就是ThreadLocal利用Map实现了对象的线程封闭. </li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal是Java中的一种特殊变量<br>它是一个线程级别的变量,每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了,在并发模式下是绝对安全的变量.<br><strong>用法:</strong> ThreadLocal<T> var=new ThreadLocal<T>();<br>会自动在每一个线程上创建一个T的副本,副本之间彼此独立,互不影响.<br>可以再ThreadLocal中存储一些参数,以便在线程中多个方法中使用, 用来代替方法传参的做法. </T></T></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程封闭&quot;&gt;&lt;a href=&quot;#线程封闭&quot; class=&quot;headerlink&quot; title=&quot;线程封闭:&quot;&gt;&lt;/a&gt;线程封闭:&lt;/h3&gt;&lt;p&gt;线程不安全是因为多线程在访问共享的可变数据时,会发生数据的不一致,结果不正确. 实现好的并发是一件困难的事情, 那么如何
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程通信</title>
    <link href="https://zhuyiting.xyz/2019/01/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://zhuyiting.xyz/2019/01/23/Java并发编程/Java线程通信/</id>
    <published>2019-01-23T02:19:49.000Z</published>
    <updated>2019-11-15T04:52:57.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>线程与线程之间不是相互独立的个体，它们彼此之间需要相互通信和写作，最典型的例子就是生产者-消费者问题：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p><h3 id="线程之间的通信有以下"><a href="#线程之间的通信有以下" class="headerlink" title="线程之间的通信有以下"></a>线程之间的通信有以下</h3><ol><li>文件共享</li><li>网络共享</li><li>共享变量</li><li>jdk提供的线程协调API</li></ol><h4 id="1-文件共享"><a href="#1-文件共享" class="headerlink" title="1. 文件共享"></a>1. 文件共享</h4><p>线程1写入文件a.txt,线程2从a.txt中读取数据</p><h4 id="3-变量共享"><a href="#3-变量共享" class="headerlink" title="3. 变量共享"></a>3. 变量共享</h4><p>线程1写入公共变量线程2从公共变量读取数据</p><h4 id="4-jdk提供的线程协调API"><a href="#4-jdk提供的线程协调API" class="headerlink" title="4. jdk提供的线程协调API"></a>4. jdk提供的线程协调API</h4><p>多线程协作的典型场景:生产者-消费者模型</p><p>示例:线程1去买包子,没有包子,则不再执行.线程2生产出包子,通知线程1继续执行</p><p><strong>jdk已弃用的suspend/resume 挂起和唤醒</strong><br>被弃用的主要原因是,容易写出死锁的代码, </p><ol><li>在同步代码中使用,suspend挂起不会释放锁,产生死锁</li><li>suspend一定要在resumee之前执行,否则</li></ol><h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait/notify机制"></a><strong>wait/notify机制</strong></h4><p>在这之前，线程间通过共享数据来实现通信，即多个线程主动地读取一个共享数据，通过同步互斥访问机制来保证线程的安全性。等待/通知机制主要由Object类中的wait()、notify()和notifyAll()三个方法来实现，这三个方法均非Thread中所申明的方法，而是Object类中申明的方法。原因是每个对象都拥有monitor（锁），所以让但却概念线程等待某个对象的锁，当然应该通过这个对象来操作，而不是当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作就会非常复杂。<br><strong>wait()——让当前线程释放对象锁并进入等待（阻塞）状态</strong><br><strong>notify()——唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。</strong><br><strong>notifyAll()——唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。</strong></p><p>这些方法只能由同一对象锁的持有者线程调用,也就是<strong>必须写在同步块里</strong>,否则会抛出illegalMonitorStateException</p><p>wait会自动解锁,但对顺序调用还是有需求.不能再notify后调用</p><h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度，反之，当一个线程被wait之后，就会进入阻塞队列，等待被唤醒。 </p><h4 id="park-unpark机制"><a href="#park-unpark机制" class="headerlink" title="park/unpark机制"></a><strong>park/unpark机制</strong></h4><p>线程调用park则等待”许可”,unpark为指定线程提供”许可”</p><p>不要求park和unpark方法的调用顺序<br>多次调用unpark,再调用park,线程会直接运行,但不会叠加, 连续多次调用park,只有第一次能拿到”许可”<br>虽然没有顺序要求,但是park不会释放锁</p><p><strong>注意:</strong> 不要使用if语句来判断,是否进入等待状态,应该在循环中检测等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒,如果不在循环条件中检查等待条件,程序就会在没有满足结束条件的情况下退出.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;概述：&lt;/h2&gt;&lt;p&gt;线程与线程之间不是相互独立的个体，它们彼此之间需要相互通信和写作，最典型的例子就是生产者-消费者问题：当队列满时，生产者需要等待队列
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CPU多级缓存</title>
    <link href="https://zhuyiting.xyz/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://zhuyiting.xyz/2019/01/15/Java并发编程/CPU多级缓存/</id>
    <published>2019-01-15T10:31:16.000Z</published>
    <updated>2019-11-15T05:12:09.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h2><p><img src="/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="CPU多级缓存"><br><img src="/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8cpu_cache.png" alt="为何使用cpu_cache"><br><img src="/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/cpu_cache%E6%84%8F%E4%B9%89.png" alt="cpu_cache意义"></p><h3 id="cache带来的问题"><a href="#cache带来的问题" class="headerlink" title="cache带来的问题"></a>cache带来的问题</h3><p>cache 给系统带来性能上飞跃的同时，也引入了新的问题“<strong>缓存一致性问题</strong>”。设想如下场景（cpu一共有两个核，core1和core2）： 以i++为例，i的初始值是0.那么在开始每个核都存储了i的值0，当第core1块做i++的时候，其缓存中的值变成了1，即使马上回写到主内存，那么在回写之后core2缓存中的i值依然是0，其执行i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是1，而不是预期中的2。</p><p>缓存一致性<br>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。我们介绍其中最经典的MESI协议。<br>在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：<br>|状态| 描述|<br>|:–:|:–:|<br>|M(Modified)| 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。|<br>|E(Exclusive)| 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。|<br>|S(Shared)| 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。|<br>|I(Invalid)| 这行数据无效|</p><p><img src="/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/cpu%E8%AF%BB%E5%8F%96%E4%BA%8B%E4%BB%B6.png" alt="cpu读取事件"></p><table>  <tr>    <th>当前状态</th>    <th>事件</th>    <th>行为</th>    <th>下一状态</th>  </tr>  <tr>    <td rowspan="4">I(Invalid)</td>    <td>Local Read</td>    <td>如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E； 如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S； 如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S</td>    <td>E/S</td>  </tr>  <tr>    <td>Local Write</td>    <td>从内存中取数据，在Cache中修改，状态变成M； 如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存； 如果其它Cache有这份数据，则其它Cache的Cache line状态变成I</td>    <td>M</td>  </tr>  <tr>    <td>Remote Read</td>    <td>既然是Invalid，别的核的操作与它无关</td>    <td>I</td>  </tr>  <tr>    <td>Remote Write</td>    <td>既然是Invalid，别的核的操作与它无关</td>    <td>I</td>  </tr>  <tr>    <td rowspan="4">E(Exclusive)</td>    <td>Local Read</td>    <td>从Cache中取数据，状态不变</td>    <td>E</td>  </tr>  <tr>    <td>Local Write</td>    <td>修改Cache中的数据，状态变成M</td>    <td>M</td>  </tr>  <tr>    <td>Remote Read</td>    <td>数据和其它核共用，状态变成了S</td>    <td>S</td>  </tr>  <tr>    <td>Remote Write</td>    <td>数据被修改，本Cache line不能再使用，状态变成I</td>    <td>I</td>  </tr>  <tr>    <td rowspan="4">S(Shared)</td>    <td>Local Read</td>    <td>从Cache中取数据，状态不变</td>    <td>S</td>  </tr>  <tr>    <td>Local Write</td>    <td>修改Cache中的数据，状态变成M， 其它核共享的Cache line状态变成I</td>    <td>M</td>  </tr>  <tr>    <td>Remote Read</td>    <td>状态不变</td>    <td>S</td>  </tr>  <tr>    <td>Remote Write</td>    <td>数据被修改，本Cache line不能再使用，状态变成I</td>    <td>I</td>  </tr>  <tr>    <td rowspan="4">M(Modified)</td>    <td>Local Read</td>    <td>从Cache中取数据，状态不变</td>    <td>M</td>  </tr> <tr>    <td>Local Write</td>    <td>修改Cache中的数据，状态不变</td>    <td>M</td>  </tr>  <tr>    <td>Remote Read</td>    <td>这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S</td>    <td>S</td>  </tr>  <tr>    <td>Remote Write</td>    <td>这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据， 状态变成I</td>    <td>I</td>  </tr></table><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p><img src="/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/cpu%E4%B9%B1%E5%BA%8F%E4%BC%98%E5%8C%96.png" alt="cpu乱序优化"><br>指令重排场景:当CPU写缓存时发现缓存区块正被其他CPU占用,为了提高CPU处理性能,可能将后面的读缓存命令优先执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性，不能确保内存与CPU缓存数据一致性的指令也不能重排，内存屏障正式通过阻止屏障两边的指令重排序来避<br>免编译器和硬件的不正确优化而提出的一种解决办法。</p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>处理器提供了两个内存屏障指令用于解决以上问题</p><ol><li>写内存屏障(Store Memory Barrier)<br>能让写入缓存中的最新数据更新写入主内存, 让其他线程可见</li><li>读内存屏障(Load Memory Barrier)<br>让高速缓存中的数据失效,强制重新从主内存加载数据</li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>JAVA中的volatile关键字正是使用了内存屏障。如果字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着，如果你对一个volatile字段进行写操作，你必须知道：</p><ol><li>一旦你完成写入，任何访问这个字段的线程将会得到最新的值。</li><li>在你写入前，会保证所有之前发生的事已发生，并且任何更像过的数据值也是可见的。因为内存屏障会把之前的写入值都刷新到缓存。</li></ol><p><strong>注意</strong>: 内存屏障会导致不可以尽可能地高校利用CPU，另外刷新缓存亦会有开销。所以不要以为用volatile代替锁操作就一点事都没有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CPU多级缓存&quot;&gt;&lt;a href=&quot;#CPU多级缓存&quot; class=&quot;headerlink&quot; title=&quot;CPU多级缓存&quot;&gt;&lt;/a&gt;CPU多级缓存&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="cache" scheme="https://zhuyiting.xyz/tags/cache/"/>
    
      <category term="内存屏障" scheme="https://zhuyiting.xyz/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java线程状态和线程中止</title>
    <link href="https://zhuyiting.xyz/2019/01/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A2/"/>
    <id>https://zhuyiting.xyz/2019/01/09/Java并发编程/Java线程状态和线程中止/</id>
    <published>2019-01-09T01:19:46.000Z</published>
    <updated>2019-11-15T05:13:30.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程中止："><a href="#线程中止：" class="headerlink" title="线程中止："></a>线程中止：</h3><ol><li><strong>设置标记位</strong>(受限与线程中业务逻辑有循环条件)<br>thread.setFlag(false);</li><li><strong>使用stop()</strong>，不安全，已经被废弃<br>thread.stop()，因为stop()方法会解除由线程获得的所有锁，当在一个线程对象上调用stop()方法时，这个线程对象所运行的线程会立即停止</li><li><strong>使用Thread类的interrupt()</strong> 方法中断线程<br>调用interrupt()方法只会给线程设置一个为true的终端标志，而设置之后，则根据线程当前状态进行不同的后续操作</li></ol><h3 id="线程的五大状态及其转换"><a href="#线程的五大状态及其转换" class="headerlink" title="线程的五大状态及其转换"></a>线程的五大状态及其转换</h3><p>线程的五大状态分别为:<br><strong>创建状态（new）</strong>、<strong>就绪状态（Runnable）</strong>、<strong>运行状态（Running）</strong>、<strong>阻塞状态（Blocked）</strong>、<strong>死亡状态（Dead）</strong>。</p><p>五大状态之间的关系图：<br><img src="/2019/01/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A2/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="java线程状态"></p><h4 id="（1）新建状态：即单纯的创建一个线程"><a href="#（1）新建状态：即单纯的创建一个线程" class="headerlink" title="（1）新建状态：即单纯的创建一个线程"></a>（1）新建状态：即单纯的创建一个线程</h4><p><strong>创建线程有三种方式</strong>；<br><strong>1.集成Thread类创建线程</strong><br>使用集成Thread类创建线程时，首先需要创建一个类集成Thread类并覆写Thread类<br>run()方法，在run()方法中，需要写线程要执行的任务<br>但是调用run()方法并不是真正的启动一个线程，真正的启动线程，需要调用的时Thread类的start()方法，而start()方法会自动调用run()方法，从而启动一个线程。<br><strong>说明：</strong> main方法其实也是一个线程，是该进程的主线程。但是在使用多线程技术时，代码的运行结果与代码调用的顺序无关，因为线程是一个子任务，CPU以不确定的方式或者说以随机的时间来调用线程中的run()方法，所以会出现每次运行结果不同的情况。</p><p><strong>2.实现Runnable接口创建线程</strong><br>Thread类的核心功能就是进行线程的启动，但一个类为了实现多线程直接取继承Thread类时出现的问题就是：单集成的局限性！所以Java中还提供了另一种实现多线程的方法：实现Runnable接口来创建多线程。<br><strong>注意：</strong> 启动一个线程的唯一方法就是调用Thread类的start()方法，抓住这点去建立与Thread类之间的关系。<br>Runnable接口中只有一个抽象方法就是run()方法。那怎么使用Runnable接口去创建线程呢？（如何执行start()方法呢）<br><strong>第一步：定义一个类实现Runnable接口的抽象方法run()方法。</strong> 此时Thread类有一个Thread类的构造方法public Thread(Runnable target)方法，参数用于接收Runnable接口的实例化对象，所以在Runnable接口与Thread类之间就建立起了联系，从而可以调用Thread类的start()方法启动一个线程。所以<br> <strong>第二步：利用Thread类的public Thread(Runnable target)构造方法与Runnable接口建立关系实例化Thread类的对象</strong>；<br><strong>第三步：调用Thread类的start()方法启动线程。</strong></p><p><strong>3.实现Callable接口创建线程</strong><br>Runnable接口的run()方法没有返回值，而Callable接口中的call()方法有返回值，若某些线程执行完成后需要一些返回值的时候，就需要用Callable接口创建线程。<br>再次强调：<strong>启动一个线程的唯一方法就是调用Thread类的start()方法</strong>，那么，要想通过实现Callable接口创建线程，就需要找到Callable接口与Thread类之间的关系。首先FutureTask类提供了构造方法public FutureTask(Callable<V> callable)方法，而FutureTask类又实现了RunnableFuture接口，而RunnableFuture接口又继承了    Runnable接口，再通过public Thread(Runnable runnable)构造方法，使Callable接口与<br>Thread类之间建立了联系。</V></p><p>所以使用Callable接口创建线程的步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个类MyThread实现Callable接口，从而覆写call()方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Callable接口创建线程"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, </span></span><br><span class="line"><span class="function">ExecutionException </span>&#123;</span><br><span class="line"><span class="comment">//2.利用MyThread类实例化Callable接口的对象</span></span><br><span class="line">Callable callable=<span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//3.利用FutureTask类的构造方法public  FutureTask(Claaable&lt;V&gt; </span></span><br><span class="line">callable)</span><br><span class="line"><span class="comment">//将Callable接口的对象传给FutureTask类</span></span><br><span class="line">FutureTask task=<span class="keyword">new</span> FutureTask(callable);</span><br><span class="line"><span class="comment">//4.将FutureTask类的对象隐式地向上转型</span></span><br><span class="line"><span class="comment">//从而作为Thread类的public Thread(Runnable runnable)构造方法的</span></span><br><span class="line">参数</span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread(task);</span><br><span class="line"><span class="comment">//5.调用Thread类的start()方法</span></span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//FutureTask的get()方法用于获取FutureTask的call()方法的返回值，</span></span><br><span class="line">为了取得线程的执行结果</span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）就绪状态："><a href="#（2）就绪状态：" class="headerlink" title="（2）就绪状态："></a>（2）就绪状态：</h4><p>在创建了线程之后，调用了Thread类的start()方法来启动一个线程，即表示线程进入了就绪状态！</p><h4 id="（3）运行状态："><a href="#（3）运行状态：" class="headerlink" title="（3）运行状态："></a>（3）运行状态：</h4><p>当线程获得CPU时间，线程才从就绪状态进入到运行状态！</p><h4 id="（4）阻塞状态："><a href="#（4）阻塞状态：" class="headerlink" title="（4）阻塞状态："></a>（4）阻塞状态：</h4><p>线程进入运行状态后，可能由于多种原因让线程进入阻塞状态，如：调用sleep()方法，让线程睡眠，调用wait()方法让线程等待，调用join()方法以及阻塞式IO方法</p><p><strong>阻塞情况分为三种：</strong><br>（一）等待阻塞：运行中（running）的线程执行o.wait()方法，JVM会把该线程放入等待队列（waiting queue）中。<br>（二）同步阻塞：运行中（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。<br>（三）其他阻塞：运行中（running）的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行状态。</p><p><strong>阻塞方法的异同：</strong></p><ol><li>sleep、yield方法是静态方法；作用是当前执行的线程；</li><li>yield方法释放了cpu的执行权，但是保留了争夺cpu的资格，这也意味着，该线程可能马上会再次执行。yield()只能使同优先级或更高优先级的线程有执行的机会。</li><li>wait释放CPU资源，同时释放锁，只有执行notify/notifyAll()时，才会唤醒处于等待的线程，然后继续往下执行，直到执行完synchronized代码块的代码火种中途再次遇到wait()。一般配合synchronized关键字使用，即，一般在synchronized同步代码块中使用wait()、notify/notifyAll方法。</li><li>sleep释放CPU资源，但不释放锁</li><li>join把调用该方法的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B</li></ol><h4 id="（5）死亡状态："><a href="#（5）死亡状态：" class="headerlink" title="（5）死亡状态："></a>（5）死亡状态：</h4><p>run()方法的正常退出，就是让线程进入到死亡状态，还有当一个异常未被捕获而终止了run()方法的执行也会进入到死亡状态！</p><h3 id="设置或获取多线程的线程名称的方法"><a href="#设置或获取多线程的线程名称的方法" class="headerlink" title="设置或获取多线程的线程名称的方法"></a>设置或获取多线程的线程名称的方法</h3><p>由于在一个进程中可能有多个线程，而多线程的运行状态又是不确定的，所以在多线程操作中需<br>要有一个明确的标识符标识出当前线程对象的信息，这个信息往往通过线程的名称来描述。在<br>Thread类中提供了一些设置或者获取线程名称的方法：</p><ol><li>创建线程时设置线程的名称；<br>public Thread(Runnable target,String name)</li><li>设置线程名称的普通方法；<br>public final synchronized void setName(String name)</li><li>取得线程名称的普通方法；<br>public final String getName()</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程中止：&quot;&gt;&lt;a href=&quot;#线程中止：&quot; class=&quot;headerlink&quot; title=&quot;线程中止：&quot;&gt;&lt;/a&gt;线程中止：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;设置标记位&lt;/strong&gt;(受限与线程中业务逻辑有循环条件)&lt;br&gt;thread.se
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目搭建</title>
    <link href="https://zhuyiting.xyz/2018/12/16/Vue.js/Vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>https://zhuyiting.xyz/2018/12/16/Vue.js/Vue项目搭建/</id>
    <published>2018-12-16T11:39:42.000Z</published>
    <updated>2019-11-15T04:56:12.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue项目实战"><a href="#Vue项目实战" class="headerlink" title="Vue项目实战"></a>Vue项目实战</h2><p>做一个简单的Vue前端项目,练习与巩固知识点,做一个总结</p><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>node环境<br>github+git项目管理</p><h4 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h4><ol><li><p>在github上创建一个仓库,作为本次项目仓库<br>然后clone到本地</p></li><li><p>命令行工具初始化一个Vue项目<br>前提:先安装好vue脚手架(全局), 可以使用vue命令<br>进入项目根目录,然后执行<code>vue init webpack</code>初始化一个vue</p></li><li><p>尝试启动项目<br>运行<code>npm run dev</code>命令,访问成功,一个vue的demo创建完成</p></li></ol><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><strong>src项目源代码结构</strong><br>业务开发根目录<br><img src="/2018/12/16/Vue.js/Vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p><ul><li>main.js — 项目入口文件</li><li>App.vue — 项目原始根组件</li><li>router<ul><li>index.js — 项目路由</li></ul></li><li>components — 项目中的组件</li><li>assests — 项目中的图片资源文件</li></ul><p><strong>config配置文件夹</strong></p><ul><li>index.js — 基础配置文件</li><li>dev.env.js — 开发环境</li><li>prod.env.js — 上线环境</li></ul><p><strong>build项目打包的webpack的配置内容</strong><br>一般也不需要修改</p><h4 id="vue文件结构"><a href="#vue文件结构" class="headerlink" title=".vue文件结构"></a>.vue文件结构</h4><p>.vue是一种单文件组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue单组件文件 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件逻辑 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 组件样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#2c3e50</span>;</span></span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="引入fastclick第三方模块"><a href="#引入fastclick第三方模块" class="headerlink" title="引入fastclick第三方模块"></a>引入fastclick第三方模块</h4><p>引入fastclick包解决有些浏览器延迟300ms响应click事件的问题<br><code>npm install fastclick --save</code></p><h4 id="引入Element模板库"><a href="#引入Element模板库" class="headerlink" title="引入Element模板库"></a>引入Element模板库</h4><p><code>npm i element-ui -S</code> npm安装,这样可以和webpack更好的结合<br>然后在main.js中导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入element</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"><span class="comment">// 全局使用</span></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue项目实战&quot;&gt;&lt;a href=&quot;#Vue项目实战&quot; class=&quot;headerlink&quot; title=&quot;Vue项目实战&quot;&gt;&lt;/a&gt;Vue项目实战&lt;/h2&gt;&lt;p&gt;做一个简单的Vue前端项目,练习与巩固知识点,做一个总结&lt;/p&gt;
&lt;h4 id=&quot;前期准备&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://zhuyiting.xyz/categories/Vue-js/"/>
    
    
      <category term="前端框架" scheme="https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue.js" scheme="https://zhuyiting.xyz/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue的Ajax(axios)</title>
    <link href="https://zhuyiting.xyz/2018/11/14/Vue.js/Vue%E7%9A%84Ajax-axios/"/>
    <id>https://zhuyiting.xyz/2018/11/14/Vue.js/Vue的Ajax-axios/</id>
    <published>2018-11-14T03:15:38.000Z</published>
    <updated>2019-11-15T04:55:48.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的Ajax-axios"><a href="#Vue的Ajax-axios" class="headerlink" title="Vue的Ajax(axios)"></a>Vue的Ajax(axios)</h2><p>Vue推荐使用axios来完成ajax请求</p><p>Axios是一个基于Promise的HTTP库,可以在浏览器或者Node中使用</p><h3 id="简单的Axios实例"><a href="#简单的Axios实例" class="headerlink" title="简单的Axios实例"></a>简单的Axios实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  GET 请求远程图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">'get'</span>,</span><br><span class="line">  url:<span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  responseType:<span class="string">'stream'</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发送 GET 请求（默认的方法）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure><h4 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h4><p>axios.request(config)<br>axios.get(url[, config])<br>axios.delete(url[, config])<br>axios.head(url[, config])<br>axios.post(url[, data[, config]])<br>axios.put(url[, data[, config]])<br>axios.patch(url[, data[, config]])<br><strong>注意：</strong>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p><h4 id="请求结构"><a href="#请求结构" class="headerlink" title="请求结构"></a>请求结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  url: <span class="string">"/user"</span>,</span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  method: <span class="string">"get"</span>, <span class="comment">// 默认是 get</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  baseURL: <span class="string">"https://some-domain.com/api/"</span>,</span><br><span class="line"></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="comment">//修改完后再提交</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="comment">// 修改完后再响应</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  headers: &#123;<span class="string">"X-Requested-With"</span>: <span class="string">"XMLHttpRequest"</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params` 是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">"brackets"</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 "PUT", "POST", 和 "PATCH"</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属：FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属： Stream</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">"Fred"</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求花费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">"janedoe"</span>,</span><br><span class="line">    password: <span class="string">"s00pers3cret"</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 "arraybuffer", "blob", "document", "json", "text", "stream"</span></span><br><span class="line">  responseType: <span class="string">"json"</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">"XSRF-TOKEN"</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span></span><br><span class="line">  xsrfHeaderName: <span class="string">"X-XSRF-TOKEN"</span>, <span class="comment">// 默认的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &amp;gt;= <span class="number">200</span> &amp;amp;&amp;amp; status &amp;lt; <span class="number">300</span>; <span class="comment">// 默认的</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "proxy" 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: <span class="string">"mikeymike"</span>,</span><br><span class="line">      password: <span class="string">"rapunz3l"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `status`  HTTP 状态码</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.config);</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue的Ajax-axios&quot;&gt;&lt;a href=&quot;#Vue的Ajax-axios&quot; class=&quot;headerlink&quot; title=&quot;Vue的Ajax(axios)&quot;&gt;&lt;/a&gt;Vue的Ajax(axios)&lt;/h2&gt;&lt;p&gt;Vue推荐使用axios来完成ajax请
      
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://zhuyiting.xyz/categories/Vue-js/"/>
    
    
      <category term="前端框架" scheme="https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue.js" scheme="https://zhuyiting.xyz/tags/Vue-js/"/>
    
  </entry>
  
</feed>
