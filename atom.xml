<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuyiting.xyz/"/>
  <updated>2019-12-08T02:31:39.299Z</updated>
  <id>https://zhuyiting.xyz/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TED道歉的力量</title>
    <link href="https://zhuyiting.xyz/2019/12/08/TED/TED%E9%81%93%E6%AD%89%E7%9A%84%E5%8A%9B%E9%87%8F/"/>
    <id>https://zhuyiting.xyz/2019/12/08/TED/TED道歉的力量/</id>
    <published>2019-12-08T00:16:00.000Z</published>
    <updated>2019-12-08T02:31:39.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TED道歉的力量"><a href="#TED道歉的力量" class="headerlink" title="TED道歉的力量"></a>TED道歉的力量</h3><p><strong>For the past few years, we’ve been calling men out. It had to be done.</strong><br>过去的几年里,我们在呼吁人们,这是必须做的<br><strong>But lately, I’ve been thinking we need to do something even harder. We need, as my good friend Tony Porter says, to find a way to call men in.</strong><br>但后来,我们在想我们需要做一些甚至更难的事.我们需要,就像我的好朋友Tony Porter说的,找到一个方法去召集人们<br><strong>My father began to sexually abuse me when I was five years old. He would come into my room in the middle of the night. He appeared to be in a trance. The abuse continued until I was 10. When I tried to resist him, when I was finally able to say no, he began to beat me. He called me stupid. He said I was a liar.</strong><br>我爸爸开始对我性虐待, 在我五岁的时候.他会进我的房间在半夜. 他出现是在恍惚中的. 虐待一直持续直到我10岁. 当我试着抵抗他,当我最终可以说不,他开始打我,他说我蠢,他说我是一个骗子.<br><strong>The sexual abuse ended when I was 10, but actually, it never ended. It changed who I was. I was filled with anxiety and guilt and shame all the time, and I didn’t know why. I hated my body, I hated myself, I got sick a lot, I couldn’t think, I couldn’t remember things. I was drawn to dangerous men and women who I allowed – actually, I invited – to treat me badly, because that is what my father taught me love was.</strong><br>性虐待结束当我10岁, 但事实上, 它从未结束. 它改变了我. 我一直充斥着焦虑和内疚还有羞耻,而且我不知道为什么, 我讨厌我的身体, 我讨厌我自己, 我得了很多病, 我不能思考, 我不能记住事情. 我被那些我允许的危险的男人和女人牵着–事实上, 我被邀请–去坏的试我, 因为那就是我父亲教育我的爱是什么<br><strong>I waited my whole life for my father to apologize to me. He didn’t. He wouldn’t. And then, with the recent scandals of famous men, as one after another was exposed, I realized something: I have never heard a man who has committed rape or physical violence ever publicly apologize to his victim. I began to wonder, what would an authentic, deep apology be like?</strong><br>我整个人生在等待着我父亲对我道歉. 他没有. 他不会. 然后,随着最近男性的丑闻, 一个接着另一个的被揭露, 我意识到一些事情: 我从没听到那些犯了强奸罪或者身体的暴力的男人曾经公开的道歉对受害者. 我开始思考, 一个真正的,深深的道歉会是什么样?<br><strong>So, something strange began to happen. I began to write, and my father’s voice began to come through me. He began to tell me what he had done and why. He began to apologize. My father is dead almost 31 years, and yet, in this apology, the one I had to write for him, I discovered the power of an apology and how it actually might be the way to move forward in the crisis we now face with men and all the women they abuse.</strong><br>因此,开始发生了一些奇怪的事. 我开始写作, 然后我父亲的声音开始穿过我. 他开始告诉我他做了什么和为什么这么做.他开始道歉, 我的父亲在31岁左右死去, 可是, 在这个道歉中, 一点我必须为他写, 我发现一个道歉的力量以及它真的可能是一个方法让我们现在面对的和男人和所有他们虐待的女人在危机中前进<br><strong>Apology is a sacred commitment. It requires complete honesty. It demands deep self-interrogation and time. It cannot be rushed. I discovered an apology has four steps, and, if you would, I’d like to take you through them.</strong><br>道歉是一个神圣的承诺. 它需要完全的诚实. 它需要深深的自我反省和时间. 它不能变的匆忙. 我发现一个道歉有四步,而且,如果你要道歉, 我就会喜欢拿你通过他们<br><strong>The first is you have to say what, in detail, you did. Your accounting cannot be vague. “I’m sorry if I hurt you” or “I’m sorry if I sexually abused you” doesn’t cut it. You have to say what actually happened. “I came into the room in the middle of the night, and I pulled your underpants down.” “I belittled you because I was jealous of you and I wanted you to feel less.” The liberation is in the details. An apology is a remembering. It connects the past with the present. It says that what occurred actually did occur.</strong><br>第一步是你必须说在细节上你做了什么. 你的解释不能模糊. “我对你很抱歉如果我伤害了你”或者”我很抱歉我如果我性虐待了你” 不要说出这些. 你必须说真正发生了什么. “我进了房间在半夜, 并且我拉下了你的内裤.” “我贬低了你因为我嫉妒你而且我想要你感觉少点” 解放是在细节中的. 一个道歉是一个记忆. 它连接了过去和现在. 它说了的发生了什么事是真的发生了的<br><strong>The second step is you have to ask yourself why. Survivors are haunted by the why. Why? Why would my father want to sexually abuse his eldest daughter? Why would he take my head and smash it against a wall? In my father’s case, he was a child born long after the other children. He was an accident that became “the miracle.” He was adored and treated as the golden boy. But adoration, it turns out, is not love. Adoration is a projection of someone’s need for you to be perfect onto you. My father had to live up to this impossible ideal, and so he was never allowed to be himself. He was never allowed to express tenderness or vulnerability, curiosity, doubt. He was never allowed to cry. And so he was forced to push all those feelings underground, and they eventually metastasized. Those suppressed feelings later became Shadowman, and he was out of control, and he eventually unleashed his torrent on me.</strong><br>第二步是你必须问自己为什么, 幸存者为什么要被骚扰. 为什么? 为什么我父亲想要性侵他最年长的女儿? 为什么他拿着我的头还去把它撞在墙上? 在我父亲的情境中, 他是一个孩子出生的在其他孩子之后的. 他是一个意外变成了”奇迹”. 他被崇拜和对待作为金童. 但是崇拜, 它转变了, 不是爱. 崇拜是某个人需要的推测为了你变得完美. 我父亲必须活着到不可能的理想,并且 因此他从来不被允许做他自己. 他从来不被允许去表达倾向或者弱点,好奇,怀疑. 他从来不被允许去哭. 而且因此他被强迫去推所有的感觉到地下, 并且他们最后转移了. 这些被抑制的感觉最后变成了影子, 并且他不能控制, 并且他最终释放了他的激流在我身上<br><strong>The third step is you have to open your heart and feel what your victim felt as you were abusing her. You have to let your heart break. You have to feel the horror and betrayal and the long-term impacts of your abuse on your victim. You have to sit with the suffering you have caused.</strong><br>第三步是你必须打开你的心还要体会你的受害者感受到了什么就像你被她虐待. 你必须让你的心破碎. 你必须感受到恐怖和背叛以及长期的被你的虐待和你的受害者影响. 你必须坐着和你引起的遭遇<br><strong>And, of course, the fourth step is taking responsibility for what you have done and making amends.</strong><br>还有, 当然, 第四步是担负责任 为你做的和制造了什么事赔偿<br><strong>So, why would anyone want to go through such a grueling and humbling process? Why would you want to rip yourself open? Because it is the only thing that will set yourself free. It is the only thing that will set your victim free. You didn’t just destroy your victim. You destroyed yourself. There is no one who enacts violence on another person who doesn’t suffer from the effects themselves. It creates an incredibly dark and contaminating spirit, and it spreads throughout your entire life.</strong><br>因此,为什么有人想要经历这些折磨和耻辱呢? 为什么你想撕开自己呢? 因为那是唯一让你自己自由的事. 那是唯一让你的受害者自由的事. 你不只是破坏你的受害者,你还破坏了自己, 没有一个制定暴力对其他人不会遭受他们影响的. 它创造了一个难以置信的黑暗和精神的污染, 而且一直在你完整的生命中传递<br><strong>The apology I wrote – I learned something about a different lens we have to look through to understand the problem of men’s violence that I and one billion other women have survived. We often turn to punishment first. It’s our first instinct, but actually, although punishment sometimes is effective, on its own, it is not enough. My father punished me. I was shut down, and I was broken. I think punishment hardens us, but it doesn’t teach us. Humiliation is not revelation. We actually need to create a process that may involve punishment, whereby we open a doorway where men can actually become something and someone else.</strong><br>我写下的道歉, 我学到了一些事关于一个不同的视角我们必须看到去理解那些我和十亿其他女性遭遇的男人的暴力的问题. 我们首先经常会去惩罚. 那是我们第一本能. 但是事实上, 虽然惩罚有时候是有效的, 但是在我自己的问题上, 它还不够. 我的父亲惩罚我, 我被压制, 而且我被破坏. 我认为惩罚让我们坚硬, 但是它不会教我们.  羞耻没有揭露. 我们真的需要创造一个进程可能涉及惩罚, 凭借此我们打开一个门,在那男人可以真正的成为一些事或一些人<br><strong>For so many years, I hated my father. I wanted him dead. I wanted him in prison. But actually, that rage kept me connected to my father’s story. What I really wanted wasn’t just for my father to be stopped. I wanted him to change. I wanted him to apologize. That’s what we want. We don’t want men to be destroyed, we don’t want them to only be punished. We want them to see us, the victims that they have harmed, and we want them to repent and change. And I actually believe this is possible. And I really believe it’s our way forward. But we need men to join us. We need men now to be brave and be part of this transformation. I have spent most of my life calling men out, and I am here now, right now, to call you in.</strong><br>很多年来, 我讨厌我父亲, 我想他死, 我想要他进监狱. 但是事实上, 愤怒使我继续写我父亲的故事, 我真正想要的不只是我父亲被停止. 我想要的是他改变, 我想要他道歉, 那就是我想要的. 我们不想让男人被破坏, 我们不想他们只是被惩罚, 我们想要他们看到我们, 那些受害者那些被他们伤害的人, 而且我们想要他们忏悔和改变. 而且我真的相信这是可能的, 而且我真的相信那是我们前进的方法. 但是我们需要男人来加入我们. 我们需要男人现在勇敢的成为这个改革的一部分. 我花了我大部分的生命来呼吁男人,而且我现在在这, 现在, 呼吁你们进来<br><strong>Thank you</strong><br>谢谢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TED道歉的力量&quot;&gt;&lt;a href=&quot;#TED道歉的力量&quot; class=&quot;headerlink&quot; title=&quot;TED道歉的力量&quot;&gt;&lt;/a&gt;TED道歉的力量&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;For the past few years, we’ve been cal
      
    
    </summary>
    
    
      <category term="英语" scheme="https://zhuyiting.xyz/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="TED" scheme="https://zhuyiting.xyz/tags/TED/"/>
    
  </entry>
  
  <entry>
    <title>党的有关理论和习近平新时代中国特色社会主义思想</title>
    <link href="https://zhuyiting.xyz/2019/10/29/%E5%85%9A%E7%9A%84%E6%9C%89%E5%85%B3%E7%90%86%E8%AE%BA%E5%92%8C%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3/"/>
    <id>https://zhuyiting.xyz/2019/10/29/党的有关理论和习近平新时代中国特色社会主义思想/</id>
    <published>2019-10-29T13:17:00.000Z</published>
    <updated>2019-11-15T05:11:22.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="党的有关理论知识"><a href="#党的有关理论知识" class="headerlink" title="党的有关理论知识"></a>党的有关理论知识</h3><h4 id="端正入党动机"><a href="#端正入党动机" class="headerlink" title="端正入党动机"></a>端正入党动机</h4><h5 id="1-正确入党动机的内涵"><a href="#1-正确入党动机的内涵" class="headerlink" title="1. 正确入党动机的内涵"></a>1. 正确入党动机的内涵</h5><p>正确的入党动机,指争取入党的内在原因是忠诚地信仰共产主义,把最终实现共产主义社会制度作为自己的最高理想,决心为了壮丽的共产主义事业奋斗终生,全心全意的为人民服务,并随时准备为党和人民的利益牺牲一切.<br>入党,意味着要比群众多吃亏,争取入党就是要为党和人民的利益不怕吃亏.<br>入党,意味着比群众多挑重担,多做贡献.<br>入党,意味着比群众多做牺牲,争取入党就要有革命的自我牺牲精神.</p><h5 id="2-怎样端正入党动机"><a href="#2-怎样端正入党动机" class="headerlink" title="2. 怎样端正入党动机?"></a>2. 怎样端正入党动机?</h5><p>主要以下三个方面的内容:<br>第一,要有为共产主义和中国特色社会主义奋斗终身的坚定信念.<br>第二,要有全心全意为人民服务的思想.<br>第三,要有在生产,工作,学习和社会生活中起先锋模范作用的觉悟.</p><h4 id="党的基本理论知识"><a href="#党的基本理论知识" class="headerlink" title="党的基本理论知识"></a>党的基本理论知识</h4><h5 id="1-中国共产党性质"><a href="#1-中国共产党性质" class="headerlink" title="1. 中国共产党性质:"></a>1. 中国共产党性质:</h5><p>中国共产党是中国工人阶级的先锋队,同时是中国人民和中华民族的先锋队,是中国特色社会主义失业的领导核心,代表中国先进生产力的发展要求,代表中国先进文化的前进方向,代表中国最广大人民的根本利益.</p><h5 id="2-党的行动指南"><a href="#2-党的行动指南" class="headerlink" title="2. 党的行动指南:"></a>2. 党的行动指南:</h5><p>是以马克思列宁主义,毛泽东思想,邓小平理论和”三个代表”重要思想作为自己的行动指南</p><h5 id="3-党的最高理想和最终目标"><a href="#3-党的最高理想和最终目标" class="headerlink" title="3. 党的最高理想和最终目标:"></a>3. 党的最高理想和最终目标:</h5><p>实现共产主义</p><h5 id="4-党的基本路线"><a href="#4-党的基本路线" class="headerlink" title="4. 党的基本路线:"></a>4. 党的基本路线:</h5><p>领导和团结全国各族人民,以经济建设为中心,坚持四项基本原则,坚持改革开放,自力更生,艰苦创业,为把我国建设成为富强,民主,文明,和谐的社会主义现代化国家而奋斗.</p><h5 id="5-党的外交政策"><a href="#5-党的外交政策" class="headerlink" title="5. 党的外交政策:"></a>5. 党的外交政策:</h5><p>坚持独立自主的和平外交政策,维护我国的独立和主权,反对霸权主义和强权政治,维护世界和平,促进人类进步.</p><h5 id="6-党的四项基本原则"><a href="#6-党的四项基本原则" class="headerlink" title="6. 党的四项基本原则"></a>6. 党的四项基本原则</h5><p>坚持社会主义道路,坚持人民民主专政,坚持中国共产党的领导,坚持马克思列宁主义毛泽东思想</p><h5 id="7-党的建设必须坚决实现的四项基本要求"><a href="#7-党的建设必须坚决实现的四项基本要求" class="headerlink" title="7. 党的建设必须坚决实现的四项基本要求"></a>7. 党的建设必须坚决实现的四项基本要求</h5><p>(1)坚持党的基本路线,(2)坚持解放思想,实事求是,与时俱进,(3)坚持全心全意为人民服务,(4)坚持民主集中制</p><h5 id="8-党的工作路线"><a href="#8-党的工作路线" class="headerlink" title="8. 党的工作路线:"></a>8. 党的工作路线:</h5><p>一切为了群众,一切依靠群众,从群众中来,到群众中去,把党的正确主张变为群众的自觉行动</p><h5 id="9-党的最大优势"><a href="#9-党的最大优势" class="headerlink" title="9. 党的最大优势:"></a>9. 党的最大优势:</h5><p>密切联系群众</p><h5 id="10-党执政后的最大危险"><a href="#10-党执政后的最大危险" class="headerlink" title="10. 党执政后的最大危险:"></a>10. 党执政后的最大危险:</h5><p>脱离群众</p><h5 id="11-党员享有的八项权利"><a href="#11-党员享有的八项权利" class="headerlink" title="11. 党员享有的八项权利:"></a>11. 党员享有的八项权利:</h5><p>(1)参加党的有关会议,阅读党的有关文件,接收党的教育和培训<br>(2)在党的会议上和党报党刊上,参加关于党的政策问题的讨论<br>(3)对党的工作提出建议和倡议<br>(4)在党的会议上有根据的批评党的任何组织和任何党员,向党员负责的揭发,检举党的任何组织和任何党员违法乱纪的事实,要求处分违法乱纪的党员,要求罢免或撤换不称职的干部.<br>(5)行使表决权,选举权,有被选举权<br>(6)在党组织讨论决定对党员的党纪处分或作出鉴定时,本人有权参加和进行申辩,其他党员可以为他作证和辩护<br>(7)对党的决议和政策如有不同意见,在坚决执行的前提下,可以声明保留,并且可以把自己的意见向党的上级组织直至中央提出<br>(8)向党的上级组织直至中央给以负责的答复</p><h5 id="12-党员履行的八项义务"><a href="#12-党员履行的八项义务" class="headerlink" title="12. 党员履行的八项义务:"></a>12. 党员履行的八项义务:</h5><p>(1)认真学习马克思列宁主义,毛泽东思想,邓小平理论和”三个代表”重要思想,学习党的路线,方针,政策及决议,学习党的基本知识,学习科学,文化和业务知识,努力提高为人民服务的本领<br>(2)贯彻执行党的基本路线和方针,政策,带头参加改革开放和社会主义现代化建设,带动群众为经济发展和社会进步艰苦奋斗,在生产,工作,学习和社会生活中起先锋模范左右<br>(3)坚持党和人民的利益高于一切,个人利益服从党和人民的利益,吃苦在前,享受在后,克己奉公,多做贡献<br>(4)自觉遵守党的纪律,模范遵守国家的法律法规,严格保守党和国家的秘密,执行党的决定,服从组织分配,积极完成党的任务.<br>(5)维护党的团结和统一,对党忠诚老实,言行一致,坚决反对一切派别组织和小集团活动,反对阳奉阴违的两面派行为和一切阴谋诡计<br>(6)切实开展批评和自我批评,勇于揭露和纠正工作中的缺点,错误,坚决痛消极腐败现象做斗争<br>(7)密切联系群众,向群众宣传党的主张,即时同群众商量,即时向党反应群众的一件和要求,维护群众的正当利益<br>(8)发扬社会主义新风尚,提倡共产主义道德,为了保护国家和人民的利益,在一切困难和危险的时刻挺身而出,英勇斗阵,不怕牺牲.</p><h5 id="13-预备党员的权利"><a href="#13-预备党员的权利" class="headerlink" title="13. 预备党员的权利:"></a>13. 预备党员的权利:</h5><p>除了没有表决权,选举权和被选举权,其他和正式党员一样</p><h5 id="14-党员的党龄"><a href="#14-党员的党龄" class="headerlink" title="14. 党员的党龄:"></a>14. 党员的党龄:</h5><p>从预备期满转为正式党员之日算起.<br>党员如果没有正当理由连续六个月不参加党的组织生活,或不缴纳党费,或不做党所分配的工作,就认为是自行脱党</p><h5 id="15-党的民主集中制的基本原则是"><a href="#15-党的民主集中制的基本原则是" class="headerlink" title="15. 党的民主集中制的基本原则是:"></a>15. 党的民主集中制的基本原则是:</h5><p>党员个人服从党的组织,少数服从多数,下级组织服从上级组织,全党各个组织和全体党员服从党的全国代表大会和中央委员会.</p><h5 id="16-党的纪律处分有五种"><a href="#16-党的纪律处分有五种" class="headerlink" title="16. 党的纪律处分有五种:"></a>16. 党的纪律处分有五种:</h5><p>警告,严重警告,撤销党内职务,留党察看,开除党籍</p><h5 id="17-党的五个作风"><a href="#17-党的五个作风" class="headerlink" title="17. 党的五个作风:"></a>17. 党的五个作风:</h5><p>思想作风,工作作风,领导作风,学风,干部生活作风</p><h5 id="18-两个务必"><a href="#18-两个务必" class="headerlink" title="18. 两个务必:"></a>18. 两个务必:</h5><p>(1)务必继续地保持谦虚,谨慎,不骄,不躁的作风<br>(2)务必继续保持艰苦奋斗的作风</p><h5 id="19-四个人格形象"><a href="#19-四个人格形象" class="headerlink" title="19. 四个人格形象:"></a>19. 四个人格形象:</h5><p>诚实守信的人格形象,<br>公道正派的人格形象,<br>清正廉洁的人格形象,<br>敬业奉献的人格形象.</p><h5 id="20-四个高度认同"><a href="#20-四个高度认同" class="headerlink" title="20. 四个高度认同:"></a>20. 四个高度认同:</h5><p>对祖国的高度认同,<br>对中华民族的高度认同,<br>对中华文化的高度认同,<br>对中国社会主义的高度认同.</p><h5 id="21-四大纪律"><a href="#21-四大纪律" class="headerlink" title="21. 四大纪律:"></a>21. 四大纪律:</h5><p>政治纪律,<br>组织纪律,<br>经济工作纪律,<br>群众工作纪律.</p><h5 id="22-五种精神"><a href="#22-五种精神" class="headerlink" title="22. 五种精神"></a>22. 五种精神</h5><p>解放思想,实事求是;<br>紧跟时代,勇于创新;<br>艰苦奋斗,务求实效;<br>知难而进,一往无前;<br>淡泊名利,无私奉献.</p><h5 id="23-八个坚持-八个反对"><a href="#23-八个坚持-八个反对" class="headerlink" title="23. 八个坚持,八个反对"></a>23. 八个坚持,八个反对</h5><p>(1)坚持解放思想,实事求是,反对因循守旧,不思进取;<br>(2)坚持理论联系实际,反对照抄照搬、本本主义;<br>(3)坚持密切联系群众，反对形式主义、官僚主义;<br>(4)坚持民主集中制，反对独断专行、软弱涣散;<br>(5)坚持党的纪律，反对自由主义;<br>(6)坚持艰苦奋斗，反对享乐主义;<br>(7)坚持清正廉洁，反对以权谋私;<br>(8)坚持任人唯贤，反对用人上的不正之风.</p><h5 id="24-八项要求"><a href="#24-八项要求" class="headerlink" title="24. 八项要求"></a>24. 八项要求</h5><p>(1)要同党中央保持高度一致，不阳奉阴违、自行其是;<br>(2)要遵守民主集中制，不独断专行、软弱放任;<br>(3)要依法行使权力，不滥用职权、玩忽职守;<br>(4)要廉洁奉公，不接受任何影响公正执行公务的利益;<br>(5)要管好配偶、子女和身边工作人员，不允许他们利用本人的影响谋取私利;<br>(6)要公道正派用人，不任人唯亲、营私舞弊;<br>(7)要艰苦奋斗，不奢侈浪费、贪图享受;<br>(8)要务实为民，不弄虚作假、与民争利.</p><h5 id="25-科学发展观的具体内容包括"><a href="#25-科学发展观的具体内容包括" class="headerlink" title="25. 科学发展观的具体内容包括:"></a>25. 科学发展观的具体内容包括:</h5><p>第一要义是发展,<br>核心是以人为本,<br>基本要求是全面协调可持续,<br>根本方法是统筹兼顾.</p><h4 id="发展党员的程序和手续"><a href="#发展党员的程序和手续" class="headerlink" title="发展党员的程序和手续"></a>发展党员的程序和手续</h4><p>（1）要求入党的人自愿向党组织提出入党申请；<br>（2）党组织接到申请入党人的申请书后，应及时研究能否列为入党积极分子；<br>（3）申请入党人被列为入党积极分子后，党组织即应落实对其培养教育和考察的措施；<br>（4）入党积极分之经一年以上的培养教育和考察后，党组织要研究能否确定为发展对象；<br>（5）入党积极分子被确定为发展对象后，党组织要对其进行政治审查；<br>（6）党组织在进行政治审查的同时，要征求党内外群众对发展对象的意见；<br>（7）党组织在接受发展对象入党前，要对其进行入党前期短期集中培训；<br>（8）做完上述工作后，支部委员会要将发展对象的入党材料报上级党组织预审；<br>（9）经上级党组织预审同意后，支部委员会应通知发展对象确定两名正式党员作入党介绍人；<br>（10）入党介绍人或支部领导成员指导发展对象填写《入党志愿书》；<br>（11）支部委员会对《入党志愿书》进行审查，认为合格后，即可召开支部大会讨论，作出决议，并报上级党组织审批；<br>（12）上级党组织在批准申请人入党前要派人同他谈话，作进一步的了解；<br>（13）上级党组织召开委员会，在听取谈话人的汇报和组织部门的意见后，集体讨论审批<br>（14）被批准入党的预备党员接受党组织一年预备期的教育和考察；<br>（15）预备党员在预备期内要面向党旗进行入党宣誓；<br>（16）预备党员预备期满，主动向党组织提出转为正式党员的申请，党组织要及时讨论其能否转为正式党员。</p><h3 id="习近平新时代中国特色社会主义思想"><a href="#习近平新时代中国特色社会主义思想" class="headerlink" title="习近平新时代中国特色社会主义思想"></a>习近平新时代中国特色社会主义思想</h3><h4 id="八个明确"><a href="#八个明确" class="headerlink" title="八个明确"></a>八个明确</h4><p>第一，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国；</p><p>第二，明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕；</p><p>第三，明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信；</p><p>第四，明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化；</p><p>第五，明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家；</p><p>第六，明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队；</p><p>第七，明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体；</p><p>第八，明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。</p><h4 id="十四个坚持"><a href="#十四个坚持" class="headerlink" title="十四个坚持"></a>十四个坚持</h4><p>第一条，坚持党对一切工作的领导；</p><p>第二条，坚持以人民为中心；</p><p>第三条，坚持全面深化改革；</p><p>第四条，坚持新发展理念；</p><p>第五条，坚持人民当家作主；</p><p>第六条，坚持全面依法治国；</p><p>第七条，坚持社会主义核心价值体系；</p><p>第八条，坚持在发展中保障和改善民生；</p><p>第九条，坚持人与自然和谐共生；</p><p>第十条，坚持总体国家安全观；</p><p>第十一条，坚持党对人民军队的绝对领导；</p><p>第十二条，坚持“一国两制”和推进祖国统一；</p><p>第十三条，坚持推动构建人类命运共同体；</p><p>第十四条，坚持全面从严治党。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;党的有关理论知识&quot;&gt;&lt;a href=&quot;#党的有关理论知识&quot; class=&quot;headerlink&quot; title=&quot;党的有关理论知识&quot;&gt;&lt;/a&gt;党的有关理论知识&lt;/h3&gt;&lt;h4 id=&quot;端正入党动机&quot;&gt;&lt;a href=&quot;#端正入党动机&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>论市场化改革</title>
    <link href="https://zhuyiting.xyz/2019/10/24/%E8%AE%BA%E5%B8%82%E5%9C%BA%E5%8C%96%E6%94%B9%E9%9D%A9/"/>
    <id>https://zhuyiting.xyz/2019/10/24/论市场化改革/</id>
    <published>2019-10-24T12:42:13.000Z</published>
    <updated>2019-10-29T02:32:58.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇"><a href="#当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇" class="headerlink" title="当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?"></a>当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?</h4><p>最近，<u>全球掀起了一阵降息潮，全球的经济环境普遍不太理想</u>，全球正在经历一轮新的经济周期调整。以10年为周期的金融危机再一次来临。中美的贸易摩擦对于中国金融市场的影响冲击也是巨大的，<u>人民币一度破7，持续的贬值导致国内资金外逃</u>，也导致了人民币国际化的步伐放缓。<br><font color="red">1.<em>[为什么经济不理想的时候要加息?加息为什么可以调整经济]</em><br>因为经济不理想(经济衰退)是市场投资不足(市场中流动的钱少了,都存银行了),政府为了刺激市场,减少银行利息,这样本来钱存在银行的一部分人就会因为收益少了,把钱投向市场中(股票或者消费),都会促进市场健康发展,使经济复苏<br>2.<em>[为什么人民币破7会导致国内资金外逃,人民币破7由什么导致,为什么人民币破7会阻碍人民币国际化?]</em><br>因为人民币破7是1美元兑换7块多人民币,而国际上以美元为主,本来6块多可以买到的东西,现在要多花钱才能买到,这样中国人不愿意买国外的东西(进口不利,因为变贵了).但是相反,中国更愿意卖东西了(出口有利).然后来自国外的资金,会因为人民币不值钱了(能换到的美元变少了)而减少对国内的投资(资本外逃).人民币的贬值是由于美元强势造成的(美国降息,资本都进入市场,经济强势)<br></font></p><p>2019年来，中国的经济形式总体仍延续着2018年的情况，我国经济增速下滑已是事实。由政府主导的央企在2000年后改革缓慢，各大原材料行业都亏损很大，产业的利润下滑非常严重，产能过剩，中国的供需关系面临着很大的结构性失衡，总体上低端产品产能过剩，高端产品产能不足。其次，我国低附加值、高功耗、高污染的产业比重很大；区域人口分布不合理，城镇化率低，导致发展不平衡；随着人口、土地、环境等这些红利慢慢的消失，<u>人工成本的上涨，土地价格的升高，环境的恶化，导致中低端产业较多</u>；我国经济的增长过多的依靠”<u>三驾马车</u>“，我国城乡收入差距大，行业收入差距大，居民贫富差距大。这些问题就会束缚经济的发展。<br><font color="red">1.<em>[为什么会导致中低端产业较多]</em><br>因为红利的消失会导致企业成本的增加,产品价格上涨,高端产品竞争力变弱(比如国产车和进口车一个价格, 选择国产车的人大大减少)<br>2.<em>[三驾马车是什么]</em><br>三驾马车是投资,消费,进口; 三驾马车是用来计算GDP的三部分,是经济发展的结果,不是根本动力. 根本动力是靠企业靠市场自我的健康发展.<br></font></p><p>当前的市场化改革，正式由习近平提出的供给侧结构性改革，<u>供给侧结构性改革，就是从提高供给质量出发，用改革的办法推进结构调整，矫正要素配置扭曲，扩大有效供给，提高供给结构对需求变化的适应性和灵活性，提高全要素生产率</u>，更好满足广大人民群众的需要，促进经济社会持续健康发展。<br><font color="red">1.<em>[解释一下供给侧结构性改革]</em><br>供给侧结构性改革就是强调供给方(也就是企业),能够制造出物美价廉的商品,怎么改呢呢? 通过改革,减少税收,降低土地价格,给予政策福利支持等<br></font></p><p>强调供给侧改革，从生产、供给入手，调整供应结构，才能使经济健康稳固发展。提升居民消费以及当前的供给侧改革并不能完全改变经济下滑趋势，<u>还必须打通供给以及需求，这一层中间地带</u>，一是政府对企业的税收以及居民的社保缴费高，让企业无法生产，市场需求低。二是垄断性国企占有太多的社会资源而效率又太低，靠价格垄断生存，抬高了整个市场的生产成本，比如油价，房价。<br><font color="red">1.<em>[为什么中间地带很重要]</em><br>中间地带是商品产出到消费者买入之间的地带,是企业或者消费者,在商品之外承担的费用,比如企业的税,居民的五险一金. 企业会把这些费用加到商品的价格上或者自己承担损失, 居民手上钱少, 消费降低, 都不利于经济健康发展<br></font></p><p>供给侧结构性改革自2015年提出以后，其主要任务也在不断变化。最初的“<u>三去一降一补</u>”，通过关、停、并、转等方式去掉多余产能，稳定房价去房地产库存，去杠杆减少政府债务，降低企业各项成本，补充生态建设、完善产业链。<br><font color="red">1.<em>[三去一降一补]</em><br>去产能,去库存,去债务,降成本,补生态产业链<br></font></p><p>当前不仅需要优化供给，提高内需，还要解决供给与需求的中间地带，做好减税降费，优化市场生态。供给侧结构性改革是利好于我国经济发展的，在贸易战加剧，逆全球化回溯的国际背景下，我国的供给侧结构性改革要结合一带一路，深化与沿线国家的合作，强化和欧洲，拉美地区国家的科技合作，扩大开放，将中国制造带出国。</p><p>我国要吸取日本经济发展的教训，20世纪后期，日本大力发展建设，逐渐陷入了失控的建设狂奔，建设业创造了庞大的就业机会，并非来自于真正的经济增长，<u>而是人为制造出的就业机会。这大大削弱并延缓了日本高技术产业的发展</u>，但这种失控的建设无法停止，因为一旦停止公共建设，就会出现大量失业。更严重的是，公共建设积累的巨大负债让日本难堪重负。<u>日本的房价泡沫也重创了日本实体工业的发展，泡沫的破灭导致了大量企业倒闭，失业率狂升</u>。当下的日本，也还没有完全走出当年的阴影。日本经济衰退的20年，主要原因就是日本政府对经济把控出现了失误，制定了违背经济规律的政策。<br><font color="red">1.<em>[为什么这会阻碍日本高科技产业发展?]</em><br>因为大量的人口资金投入到了基础建设业,相应的高科技产业就会没钱没人<br>2.<em>[房价的泡沫破裂为什么影响这么大?]</em><br>房价泡沫破灭, 高价买地的开发商,会破产,很多大企业也会因为投资房地产而大出血,这会让市场严重下跌,这样所有人手上的资产都贬值了,同时企业大量倒闭,失业率也会大大提高,已经买房的人失业后也还要承担巨额贷款.整个国家的经济都会受损,日本房价泡沫当时特别高,政府为了防止泡沫更高影响更恶劣,采取了主动刺破的措施.单也还是经济大衰退<br></font><br>我国可以从日本的经济发展的教训中收益到：房地产不能长久作为支柱产业，必须防止货币超发和过度升值，在宏观调控上，政府不能过于频繁也不能过紧过松，政策引导着眼长远，统筹兼顾。<br>面对经济寒冬，我们个人也需要重视，不要觉得离我们很遥远，面对危机，我们要留好资金，节约开销，努力工作，提升个人能力。<br>我国的市场化改革也会带来巨大的机遇，站在风口上，猪都会飞。乱世出英雄，变革带来的巨大机遇可能产生意想不到的风云人物，不过代价也是巨大的，在改革中，抓住机会很重要，不过我们需要做好充足的准备，机会总是留给有准备的人。能力上的准备，思想上的准备，以及恰到好处的机会。<br>在危机来临初期持有货币，<u>在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了</u>，但这其中随便哪一步出错，都会损失惨重，即使每一个环节都准确无误，也可能因为突如其来的不可抗力，导致整个投资计划的泡汤。比如限购限售，比如失业，比如投资企业破产。<u>在危机时期，不要轻易触碰杠杆加大交易规模</u>，其次要勤于学习，要对未来的风险做准备。<br><font color="red">1.<em>[为什么在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了?]</em><br>通俗点说就是在商品最便宜的时候买进。接下来商品会因为市场规律或者政府调控回升。但是政府为了控制物价（控制通货膨胀），会加息，钱流进银行，商品需求变小。在政府调控的时候，可以看成物价比较理想（高）的时候。这时候卖出。获利就很客观（差价最大的时候）<br>2.<em>[为什么不要触碰杠杆]</em><br>触碰杠杆可以理解为贷款,因为在经济危机时期,银行出于安全考虑不可能把大量的钱借给你, 所以只能贷到很少的钱,而钱越少,承受意外的能力越低,而且贷款需要抵押,(房子或者股票,在危机时期看不到底,随时会被银行卖掉,因为银行不可能等你房子不值钱了再卖,那就失去了抵押的意义),而银行低价卖出也会导致市场供大于求,进一步下跌. 而你通过贷款买入的资产也可能会进一步下跌.很容易破产<br></font><br>在宏观经济下滑的趋势下，要合理分配资产，综合来看2019年上半年的投资者大多以<u>黄金、比特币为代表的避险资产</u>，这些产品或者说是资产的价格也一直在上高，在国际范围中，各大央行实行降息政策，促进经济发展的前提下，黄金和比特币的抗通胀能力就展现出来了。<u>但千万不能在不了解的情况下，进行投资。</u><br><font color="red">1.<em>[为什么黄金,比特币是避险资产?]</em><br>因为他们都有共同属性,价值不受政府调控影响(因为总量固定,且没法造假).这样不管经济怎么样,黄金比特币本来能换多少米还是能换多少米.举例:比如一块黄金本来换一代米,一百块也能换一袋米,但是经济变化,一百块只能买半袋米了,但是一快黄金还是能买一袋米.<br>2.<em>[为什么不了解不能投资呢]</em><br>正式因为他们总量固定 ,他们会被资本炒作,比如大量买入造成供不应求,价格高了以后再高价卖出, 不了解就很可能成了韭菜,承担了这部分人造差价<br></font><br>改革初期，商品紧缺，供不应求，是暴利的时代，后来，电子商务兴起以及产能过剩，商家开启价格战，于是进入了薄利时期，而当前，我国正在转变，产品开始个性化、定制化、高端化，提高增值空间，从而进入厚利时代。<br>2019年下半年，<u>各大二线城市的抢人大战也已经偃旗息鼓，但一线新一线仍然对人才有着很高的需求。这意味着，宏观上的城市化进程将会放缓，大城市的自我迭代会深度展开</u>。其次我国股市长期以来以房地产与科技相关的驱动，目前的房价以稳为主，<u>投资的机会在科技类企业。</u><br><font color="red">1.<em>[为什么二线城市不抢人了?]</em><br>因为人才需要高薪,需要好的企业,而好的企业需要政策扶持,它才愿意来,二线城市没有这样的实力,相反,一线城市企业多,对于人才的需求也大,大城市的建设需要人才.<br>2.<em>[为什么说投资机会在科技类企业]</em><br>因为国家需要发展科技类企业来促进产业升级,政策的支持以及资金的流入,就会让科技类企业更健康的发展<br></font><br>在我国市场化改革的背景下，勤于学习，不多弥补知识盲区，扩充个人知识领域，才能知道更多有用的信息，见多识广的人，更能规避风险，才有更大的机会抓住机遇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇&quot;&gt;&lt;a href=&quot;#当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇&quot; class=&quot;headerlink&quot; title=&quot;当前的市场化
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>TED不念过往,不惧将来</title>
    <link href="https://zhuyiting.xyz/2019/10/24/TED/TED%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80,%E4%B8%8D%E6%83%A7%E5%B0%86%E6%9D%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/24/TED/TED不念过往,不惧将来/</id>
    <published>2019-10-24T02:16:00.000Z</published>
    <updated>2019-12-08T00:57:48.160Z</updated>
    
    <content type="html"><![CDATA[<p><u>“These are the times” said Thomas Paine,”that try men’s souls.”</u><br>“这些时间考验着人们的灵魂”Thomas Paine说.<br><u>And they’re trying ours now.</u><br>现在它们在考验我们.<br><u>This is a fateful moment in the history of the West.</u><br>这是一个西方历史的命运时刻.<br><u>We’ve seen divisive elections and divided societies.</u><br>我们看到了分裂的选举和分裂的社会.<br><u>We’ve seen a growth of extremism in politics and religion,</u><br>我们看到了一群极端分子在政治上和宗教上,<br><u>all of it fueled by anxiety,uncertainty and fear,</u><br>所有的这些都是被焦虑,不确定和害怕所推动,<br><u>of a world that’s changing almost faster than we can bear,</u><br>因为世界几乎在以比我们能够承受的更快的速度在改变,<br><u>and the sure knowledge that it’s going to change faster still.</u><br>并且都知道它未来还会改变的这么快<br><u>I have a friend in Washington.</u><br>我有一个朋友在Washington<br><u>I asked him,what was it like being in America during the recent presidential election?</u><br>我问他,在最近的总统选举期间待在美国像是什么?<br><u>He said to me,”Well,it was like the man sitting on the deck of the Titanic with a glass of whiskey in his hand and he’s saying,’I know I asked for ice–,but this is ridiculous.’”</u><br>他告诉我,”哇,它就像一个人坐在泰坦尼克的甲板上,手里拿着威士忌说’我知道我要了冰,但这太疯狂了’”<br><u>So is there something we can do,each of us,to be able to face the future without fear?</u><br>所以有没有一些事我们每个人都可以做的,可以让我们能够对未来不感到恐惧?<br><u>I think there is.</u><br>我觉得是有的.<br><u>And one way into it is to see that perhaps the most simple way into a culture and into an age is to ask: What do people worship? </u><br>有一个方法 也许是最简单的方法 进入一个文化进入一个时代去问:人们崇拜什么?<br><u>People have worshipped so many different things–the sun,the stars,the storm.</u><br>人们过去崇拜很多不同的是–太阳,星型,风暴.<br><u>Some people worship many gods, some one,some none.</u><br>有些人崇拜很多神,有些人崇拜一个,有些人没有<br><u>In the 19th and 20th centuries,people worshipped the nation,the Aryan race,the communist state.</u><br>在19到20世纪,人们崇拜国家,崇拜Aryan种族,崇拜共产主义.<br><u>What do we worship?</u><br>那我们崇拜什么呢?<br><u>I think future anthropologists will take a look at the books we read on self-help,self-realization,self-esteem.</u><br>我觉得未来的人类学家会看看到我们读过的书,关于自我帮助,自我认识,自我尊重,<br><u>They’ll look at the way we talk about morality as being true to oneself, the way we talk about politics as a matter of individual rights,</u><br>他们会看我们谈论道德的行为当成对自己的正确,我们谈论政治的行为当成个人权利的问题.<br><u>and they’ll look at this wonderful new religious ritual we have created.</u><br>并且他们会看看这些很棒的我们创造的宗教利益</p><p><u>You know the one?</u><br>你知道那是什么嘛?<br><u>Called the “selfie”.</u><br>我们成为”自拍”.<br><u>And I think they’ll conclude that what we worship in our time is the self,the me,the I.</u><br>并且我觉得他们会得出结论 那就是我们在那时候崇拜的就是自我,是我<br><u>And this is great.</u><br>这是很棒的<br><u>It’s liberating.</u><br>这是自由的<br><u>It’s empowering.</u><br>这是有权利的.<br><u>It’s wonderful.</u><br>这是极好的.<br><u>But don’t forget that biologically,</u><br>但是不要在生物上忘了<br><u>we’re social animals.</u><br>我们是社交动物<br><u>We’ve spent most of our evolutionary history in small groups.</u><br>我们进化历史中的很多时间都花在小小的群体中<br><u>We need those face-to-face interactions,where we learn the choreography of altruism and where we create those spiritual goods like friendship and trust and loyalty and love that redeem our solitude.</u><br>我们需要面对面的交流,来学习利他主义并且创造精神上的就像友谊,信任,忠诚和爱的东西以此救赎我们的孤独.<br><u>When we have too much of the “I” and too little of the “we”,</u><br>当我们过于关注我的, 很少关注我们时,<br><u>we can find ourselves vulnerable,fearful and alone.</u><br>我们会发现有多点的,会恐惧的并且孤独的自己.<br><u>It was no accident that Sherry Turkle of MIT called the book she wrote on the impact of social media “Alone together”.</u><br>MIT的Sherry Turkle把他写的关于社交媒体的影响命名为”一起孤单”不是一个意外.<br><u>So I think the simplest way of safeguarding the future “you” is to strengthen the future “us” in three dimensions:</u><br>所以我认为,最简单的保障未来的”你”的方法就是从三个方面来加深未来的”我们”<br><u>the us of relationship,the us of identity and the us of responsibility.</u><br>我们的关系,我们的身份和我们的责任<br><u>So let me first take the us of relationship.</u><br>所以,首先让我谈谈我们的关系.<br><u>And here, forgive me if I get personal.</u><br>在这里,原谅我如果我谈自己的事.<br><u>Once upon a time,a very long time age,I was a 20-year-old undergraduate studying philosophy.</u><br>从前,很长一段时间之前,我是20岁的大学生在学习哲学.<br><u>I was into Nietzsche and Schopenhauer and Sartre and Camus.</u><br>我沉迷于Nietzsche,Schopenhauer,Sartre和Camus<br><u>I was full of ontological uncertainty and existential angst.</u><br>我充满了本体论的不确定性和存在的焦虑<br><u>It was terrific.</u><br>那是极好的.<br><u>I was self-obsessed and thoroughly unpleasant to know,</u><br>我是自恋的并且感到非常厌恶,<br><u>until one day I saw, across the courtyard, a girl who was everything that I wasn’t.</u><br>直到有一天我看到,穿过这院子,一个女孩一切都和我不一样.<br><u>She radiated sunshine.</u><br>她散发着阳光.<br><u>She emanated joy.</u><br>她散发着快乐.<br><u>I found out her name was Elaine.</u><br>我找到她的名字是Elaine.<br><u>We met,We talked,We married.</u><br>我们见面,我们聊天,我们结婚.<br><u>And 47 years,three children and eight grandchildren later,</u><br>47年 有了3个小孩,8个孙子 以后<br><u>I can safely say it was the best decision I ever took in my life,</u><br>我可以说,那是我生命中做的最好的决定.<br><u>because it’s the people not like us that make us grow.</u><br>因为和我们不一样的人会让我们成长.<br><u>And that is why I thik we have to do just that.</u><br>这就是为什么我认为我们必须这样做.<br><u>The trouble with Google filters,Facebook friends and reading the news by narrowcasting rather than broadcasting means that we’re surrounded almost entirely by people like us whose views,whose opinions,whose prejudices,even, are just like ours.</u><br>谷歌过滤,脸书朋友圈以及阅读新闻通过很窄的渠道而不是广播这些麻烦意味着我们几乎完全被那些观点,想法,甚至成见和我们的一样的人包围着.<br><u>And Cass Sunstein of Harvard has shown that if we surround ourselves with people with the same views as us,we get more extreme.</u><br>哈弗的Cass Sunstein展示了如果我们被那些观点和我们一样的自己人包围,我们会变得极端<br><u>I think we need to renew those face-to-face encounters with the people not like us.</u><br>我认为我们需要重新和那些跟我们不一样的人面对面的接触.<br><u>I think we need to do that in order to realize that we can disagree strongly and yet still stay friends.</u><br>我认为我们需要这样做,为了我们能意识到强烈地争执也仍然可以当朋友.<br><u>It’s in those face-to-face encounters that we discover that the people not like us are just people like us.</u><br>在面对面的接触中我们发现那些和我们不同的人就是和我们一样的人<br><u>And actually, every time we hold out the hand of friendship to somebody not like us,whose class or creed or color are different from ours,</u><br>事实上,每一次,我们向那些和我们有不一样种族或者不一样信条或者不一样的肤色的人伸出友谊的手,<br><u>we heal one of the fractures of our wounded world.</u><br>我们治愈了我们破裂世界的一刀伤痕.<br><u>That is the us of relationship.</u><br>这就是我们的关系.<br><u>Second is the us of identity.</u><br>第二点是我们的身份.<br><u>Let me give you a thought experiment.</u><br>让我给你做个思维实验.<br><u>Have you been to Washington?</u><br>你去过Washington嘛?<br><u>Have tou seen the memorials?</u><br>你看过纪念碑嘛?<br><u>Absolutely fascinating.</u><br>绝对让人神魂颠倒.<br><u>There’s the Lincoln Memorial:Gettysburg Address on one side,Second Inaugural on the other.</u><br>在林肯纪念碑,一边是Gettysburg演说,另一边是Inaugural.<br><u>You go to the Jefferson Memorial,screeds of text.</u><br>你去Jefferson纪念碑,有一段话.<br><u>Martin Luther King Memorial,more than a dozen quotes from his speeches.</u><br>马丁路德金纪念碑,超过12条他演讲的引用.<br><u>I didn’t realize,in America you read memorials.</u><br>我不认为,你在美国会读这些纪念碑.<br><u>Now go to the equivalent in London in Parliament Square and you will see that the monument to David Lloyd George contains three words:David Lloyd George.</u><br>现在 一样去了伦敦的国会广场并且你会看到David Lloyd George的纪念碑上包含了三个单词:David Lloyd George.<br><u>Nelson Mandela gets two.</u><br>Nelson Mandela有两个<br><u>Churchill gets just one:Chuichill.</u><br>Churchill只有一个:Chuichill<br><u>Why the difference?</u><br>为什么会有这样的差异呢<br><u>I’ll tell you why the difference.</u><br>我来告诉你们为什么会有这样的差异.<br><u>Because America was from the outset a nation of wave after wave of immigrants,</u><br>因为美国是一个从一波又一波的移民开始的国家<br><u>so it had to create an identity which it did by telling a story which you learned at school, you read on memorials and you heard repeated in presidential inaugural addresses.</u><br>因此,它必须创造一个形象,那个形象可以通过你学校学到的故事,你在纪念碑上读到东西和你反复在总统开幕演讲中听到的故事来讲的.<br><u>Britain until recently wasn’t a nation of immigrants,</u><br>不列颠直到最近也不是一个移民国家,<br><u>so it could take identity for granted.</u><br>所以它可以认为形象是理所当然的.<br><u>The trouble is now that two tings have happened which shouldn’t have happened together.</u><br>麻烦的是现在两件不应该同时发生的事发生了.<br><u>The first thing is in the West we’ve stopped telling this story of who we are and why,even in America</u><br>第一件事是在西方,我们停止讲述我是谁还有为什么的故事了,甚至是美国<br><u>And at the same time,immigration is higher than it’s ever been before.</u><br>同时,移民人口变得比以前更高了.<br><u>So when you tell a story and your identity is strong,you can welcome the stranger,</u><br>因此,当你们讲述一个故事并且你们形象很强的时候,你们能欢迎那些陌生人<br><u>but when you stop telling the story,your identity gets weak and you fell threatened by the stranger.</u><br>但是,当你们停止讲述故事,你们的形象变弱了,并且你们感到了陌生人的威胁<br><u>And that’s bad.</u><br>那就糟了<br><u>I tell you,Jews have been scattered and dispersed and exiled for 2000 years.</u><br>我告诉你们,犹太人已经被分开,被分散并且被流亡了2000多年.<br><u>We never lost our identity.</u><br>我们从来没有失去我们的形象.<br><u>Why?Because at least once a year,on the festival of Passover,</u><br>为什么? 因为么每年至少一次,在Passover节<br><u>we told our story and we taught it to our children and we ate the unleavened bread of affliction and tasted the bitter herbs of slavery.</u><br>我们谈论我们的故事并且我们教它给我们的孩子,并且我们吃过还没发酵的苦的面包并且吃过奴隶制的苦.<br><u>So we never lost our identity.</u><br>所以我们从来没有丢失我们的形象.<br><u>I think collectively we’ve got to get back to telling our story,who we are,where we came from,what ideals by which we live.</u><br>我认为共同的,我们必须回到的我们的故事上来说,我们是谁,我们来自哪里,我们生活的理想是什么<br><u>And if that happens,we will become strong enough to welcome the stranger and say,</u><br>如果发生这样的事,我们会变得强壮的足够欢迎陌生人并且说<br><u>“Come and share our lives,share our stories,share our aspirations and dreams.”</u><br>“过来并且分享我们的生活,分享我们的故事,分享我们的愿望和梦想”.<br><u>That is the us of identity.</u><br>这就是我们的形象.<br><u>And finally,the us of responsibility.</u><br>最后,是我们的责任.<br><u>Do you know something?</u><br>你知道嘛?<br><u>My favorite phrase in all of politics,very American phrase,is:”We the people.”</u><br>我最喜欢的一句话在所有的政治言论中,一句非常美国的话,就是”我们人”<br><u>Why “we the people?”</u><br>为什么是”我们人”?<br><u>Because it says that we all share collective responsibility for our collective future.</u><br>因为它表达了我们分享所有集体的责任为了我们集体的未来.<br><u>And that’s how things really are and should be.</u><br>并且那就是应该有的样子<br><u>Have you noticed how magical thinking has taken over our politics?</u><br>你有没有注意到多少神奇的思想占据着我们的政治?<br><u>So we say, all you’ve got to do is elect this strong leader and he or she will solve all our problems for us.</u><br>因此我们说,我们都要去选一个强力的领导并且他会为我们解决我们的问题.<br><u>Believe me, that is magical thinking.</u><br>相信我,那是幻想.<br><u>And then we get the extremes:the far right,the far left,the extreme religious and extreme anti-religious,</u><br>当我们变得极端以后:极右,极左,极端宗教注意或者极端反宗教,<br><u>the far right dreaming of a golden age that never was,</u><br>极端的右派梦想着一个从未有过的黄金时代,<br><u>the far left dreaming of a utopia that never will be,</u><br>极端的左派梦想着一个从未出现过的乌托邦,<br><u>and the religious and anti-religious equally convinced that all it takes id God or the absence of God to save us from ourselves.</u><br>宗教和反宗教同意相信上帝或者没有上帝来拯救我们.<br><u>That,too,is magical thinking,</u><br>这是非常神奇的想法.<br><u>because the only people who will save us from ourselves is we the people,all of us together.</u><br>因为可以拯救我们只有我们自己,所有的我们一起.<br><u>And when we do that,and when we move from the politics of me to the politics of all of us together,</u><br>并且当我们去做,当我们从我的政治中到所有的我们的政治中<br><u>we rediscover those beautiful,counterintuitive truths:</u><br>我们重新发现了那些美丽的,与直觉相反的事实:<br><u>that a nation is strong when it cares for the weak,</u><br>当一个国家关注弱者的时候它是强大的,<br><u>that it becomes rich when it cares for the poor,</u><br>当一个国家关心穷人的时候它是富裕的,<br><u>it becomes invulnerable when it cares about the vulnerable.</u><br>当一个国家开始关心那些有弱点的人的时候,它是无懈可击的.<br><u>That is what makes great nations.</u><br>这就是伟大的国家的形成.<br><u>So here is my simple suggestion.</u><br>因此,这有一个我的简单简易<br><u>It might just change your life,</u><br>它也许可以改变你的生活,<br><u>and it might just help to begin to change the world.</u><br>它也许可以帮助开始改变这个世界<br><u>Do a search and replace operation one the text of your mind,</u><br>做一个搜索和替换操作,一是你心中的文字,<br><u>and wherever you encounter the word “self”, substitute the word “other”.</u><br>并且无论在哪你遇到了单词”自己”,替换成单词”其他人”<br><u>So instead of self-help,other-help;</u><br>替代”自我帮助”为”他人帮助”<br><u>instead of self-esteem,other-esteem.</u><br>替代”自我尊重”为”他人尊重”<br><u>And if you do that,you will begin to fell the power of what for me is one of the most moving sentences in all of religious literature.</u><br>如果你这么做,你会开始感受到力量,这力量对我来说就是所有宗教文学中最动人的句子之一<br><u>“Though I walk through the valley of the shadow of death,I will fear no evil,for you are with me.”</u><br>虽然我在死亡的阴影的深渊里走,但是我不会害怕邪恶,因为你和我在一起<br><u>We can face any future without fear so long as we know we will not face it alone.</u><br>我们能够不害怕面对任何我们知道的我们不能独自面对的未来<br><u>So for the sake of the future “you”,together let us strengthen the future “us”.</u><br>为了未来的”你”,让我们一起加固未来的”我们”</p><p><u>Thank you.</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;“These are the times” said Thomas Paine,”that try men’s souls.”&lt;/u&gt;&lt;br&gt;“这些时间考验着人们的灵魂”Thomas Paine说.&lt;br&gt;&lt;u&gt;And they’re trying ours now.
      
    
    </summary>
    
    
      <category term="英语" scheme="https://zhuyiting.xyz/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="TED" scheme="https://zhuyiting.xyz/tags/TED/"/>
    
  </entry>
  
  <entry>
    <title>延期年金现值的计算</title>
    <link href="https://zhuyiting.xyz/2019/10/18/%E5%BB%B6%E6%9C%9F%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://zhuyiting.xyz/2019/10/18/延期年金现值的计算/</id>
    <published>2019-10-18T01:56:00.000Z</published>
    <updated>2019-10-29T02:32:30.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延期年金"><a href="#延期年金" class="headerlink" title="延期年金"></a>延期年金</h2><p>==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.<br>==延期年金现值计算==假定最初又m期没有收付款项,后面n期每年有等额的系列收付款项,则此延期年金的现值即为后n期年金先折现至n期期初(m期期末),再折现至第一期期初的现值.</p><p>==年金==是指定期定额的收付款项</p><p>==现值==成本或收益的价值以今天的现金来计量时,称为现值</p><p>==终值==是指现在某一时点上的一定量现金折合到未来的价值</p><ol><li>延期年金的==终值==大小和延期数m无关<br>所以延期m期之后的n期年金终值为<br>$ F=A\frac{(1+i)^n-1}{i} $</li><li>普通年金的==现值==计算<br>$ P=A\frac{1-\frac{1}{(1+i)^n}}{i}$</li><li>==延期年金==的现值计算<br>延期年金的现值与延期数m相关,m越长,现值越低.<ul><li>方法一:先当成n期普通年金,求出现值P1,在将P作为第m期终值,再折现到第一期的现值P2<br>$P1=A\frac{1-\frac{1}{(1+i)^n}}{i}$<br>$P2=P1\frac{1-\frac{1}{(1+i)^m}}{i} $</li><li>方法二:先计算m+n期现值,再减去m期年金现值<br>$P=A(\frac{1-\frac{1}{(1+i)^m(1+i)^n}}{i}-\frac{1-\frac{1}{(1+i)^m}}{i}) $</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;延期年金&quot;&gt;&lt;a href=&quot;#延期年金&quot; class=&quot;headerlink&quot; title=&quot;延期年金&quot;&gt;&lt;/a&gt;延期年金&lt;/h2&gt;&lt;p&gt;==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.&lt;br&gt;==延期年
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://zhuyiting.xyz/2019/07/30/JVM指令手册/</id>
    <published>2019-07-30T07:18:00.000Z</published>
    <updated>2019-12-25T03:49:17.766Z</updated>
    
    <content type="html"><![CDATA[<p>栈和局部变量操作<br>将常量压入栈的指令<br>aconst_null 将 null 对象引用压入栈<br>iconst_m1 将 int 类型常量-1 压入栈<br>iconst_0 将 int 类型常量 0 压入栈<br>iconst_1 将 int 类型常量 1 压入栈<br>iconst_2 将 int 类型常量 2 压入栈<br>iconst_3 将 int 类型常量 3 压入栈<br>iconst_4 将 int 类型常量 4 压入栈<br>iconst_5 将 int 类型常量 5 压入栈<br>lconst_0 将 long 类型常量 0 压入栈<br>lconst_1 将 long 类型常量 1 压入栈<br>fconst_0 将 float 类型常量 0 压入栈<br>fconst_1 将 float 类型常量 1 压入栈<br>dconst_0 将 double 类型常量 0 压入栈<br>dconst_1 将 double 类型常量 1 压入栈<br>bipush 将一个 8 位带符号整数压入栈<br>sipush 将 16 位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中 long 类型或者 double 类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载 int 类型值<br>lload 从局部变量中装载 long 类型值<br>fload 从局部变量中装载 float 类型值<br>dload 从局部变量中装载 double 类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量 0 中装载 int 类型值<br>iload_1 从局部变量 1 中装载 int 类型值<br>iload_2 从局部变量 2 中装载 int 类型值<br>iload_3 从局部变量 3 中装载 int 类型值<br>lload_0 从局部变量 0 中装载 long 类型值<br>lload_1 从局部变量 1 中装载 long 类型值<br>lload_2 从局部变量 2 中装载 long 类型值<br>lload_3 从局部变量 3 中装载 long 类型值<br>fload_0 从局部变量 0 中装载 float 类型值<br>fload_1 从局部变量 1 中装载 float 类型值<br>fload_2 从局部变量 2 中装载 float 类型值<br>fload_3 从局部变量 3 中装载 float 类型值<br>dload_0 从局部变量 0 中装载 double 类型值<br>dload_1 从局部变量 1 中装载 double 类型值<br>dload_2 从局部变量 2 中装载 double 类型值<br>dload_3 从局部变量 3 中装载 double 类型值<br>aload_0 从局部变量 0 中装载引用类型值<br>aload_1 从局部变量 1 中装载引用类型值<br>aload_2 从局部变量 2 中装载引用类型值<br>aload_3 从局部变量 3 中装载引用类型值<br>iaload 从数组中装载 int 类型值<br>laload 从数组中装载 long 类型值<br>faload 从数组中装载 float 类型值<br>daload 从数组中装载 double 类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载 byte 类型或 boolean 类型值<br>caload 从数组中装载 char 类型值<br>saload 从数组中装载 short 类型值<br>将栈中的值存入局部变量的指令<br>istore 将 int 类型值存入局部变量<br>lstore 将 long 类型值存入局部变量<br>fstore 将 float 类型值存入局部变量<br>dstore 将 double 类型值存入局部变量<br>astore 将将引用类型或 returnAddress 类型值存入局部变量<br>istore_0 将 int 类型值存入局部变量 0<br>istore_1 将 int 类型值存入局部变量 1<br>istore_2 将 int 类型值存入局部变量 2<br>istore_3 将 int 类型值存入局部变量 3<br>lstore_0 将 long 类型值存入局部变量 0<br>lstore_1 将 long 类型值存入局部变量 1<br>lstore_2 将 long 类型值存入局部变量 2<br>lstore_3 将 long 类型值存入局部变量 3<br>fstore_0 将 float 类型值存入局部变量 0<br>fstore_1 将 float 类型值存入局部变量 1<br>fstore_2 将 float 类型值存入局部变量 2<br>fstore_3 将 float 类型值存入局部变量 3<br>dstore_0 将 double 类型值存入局部变量 0<br>dstore_1 将 double 类型值存入局部变量 1<br>dstore_2 将 double 类型值存入局部变量 2<br>dstore_3 将 double 类型值存入局部变量 3<br>astore_0 将引用类型或 returnAddress 类型值存入局部变量 0<br>astore_1 将引用类型或 returnAddress 类型值存入局部变量 1<br>astore_2 将引用类型或 returnAddress 类型值存入局部变量 2<br>astore_3 将引用类型或 returnAddress 类型值存入局部变量 3<br>iastore 将 int 类型值存入数组中<br>lastore 将 long 类型值存入数组中<br>fastore 将 float 类型值存入数组中<br>dastore 将 double 类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将 byte 类型或者 boolean 类型值存入数组中<br>castore 将 char 类型值存入数组中<br>sastore 将 short 类型值存入数组中<br>wide 指令<br>wide 使用附加字节扩展局部变量索引<br>通用(无类型）栈操作<br>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容<br>类型转换<br>i2l 把 int 类型的数据转化为 long 类型<br>i2f 把 int 类型的数据转化为 float 类型<br>i2d 把 int 类型的数据转化为 double 类型<br>l2i 把 long 类型的数据转化为 int 类型<br>l2f 把 long 类型的数据转化为 float 类型<br>l2d 把 long 类型的数据转化为 double 类型<br>f2i 把 float 类型的数据转化为 int 类型<br>f2l 把 float 类型的数据转化为 long 类型<br>f2d 把 float 类型的数据转化为 double 类型<br>d2i 把 double 类型的数据转化为 int 类型<br>d2l 把 double 类型的数据转化为 long 类型<br>d2f 把 double 类型的数据转化为 float 类型<br>i2b 把 int 类型的数据转化为 byte 类型<br>i2c 把 int 类型的数据转化为 char 类型<br>i2s 把 int 类型的数据转化为 short 类型<br>整数运算<br>iadd 执行 int 类型的加法<br>ladd 执行 long 类型的加法<br>isub 执行 int 类型的减法<br>lsub 执行 long 类型的减法<br>imul 执行 int 类型的乘法<br>lmul 执行 long 类型的乘法<br>idiv 执行 int 类型的除法<br>ldiv 执行 long 类型的除法<br>irem 计算 int 类型除法的余数<br>lrem 计算 long 类型除法的余数<br>ineg 对一个 int 类型值进行取反操作<br>lneg 对一个 long 类型值进行取反操作<br>iinc 把一个常量值加到一个 int 类型的局部变量上<br>逻辑运算<br>移位操作<br>ishl 执行 int 类型的向左移位操作<br>lshl 执行 long 类型的向左移位操作<br>ishr 执行 int 类型的向右移位操作<br>lshr 执行 long 类型的向右移位操作<br>iushr 执行 int 类型的向右逻辑移位操作<br>lushr 执行 long 类型的向右逻辑移位操作<br>按位布尔运算<br>iand 对 int 类型值进行“逻辑与”操作<br>land 对 long 类型值进行“逻辑与”操作<br>ior 对 int 类型值进行“逻辑或”操作<br>lor 对 long 类型值进行“逻辑或”操作<br>ixor 对 int 类型值进行“逻辑异或”操作<br>lxor 对 long 类型值进行“逻辑异或”操作<br>浮点运算<br>fadd 执行 float 类型的加法<br>dadd 执行 double 类型的加法<br>fsub 执行 float 类型的减法<br>dsub 执行 double 类型的减法<br>fmul 执行 float 类型的乘法<br>dmul 执行 double 类型的乘法<br>fdiv 执行 float 类型的除法<br>ddiv 执行 double 类型的除法<br>frem 计算 float 类型除法的余数<br>drem 计算 double 类型除法的余数<br>fneg 将一个 float 类型的数值取反<br>dneg 将一个 double 类型的数值取反<br>对象和数组<br>对象操作指令<br>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型<br>数组操作指令<br>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组<br>控制流<br>条件分支指令<br>ifeq 如果等于 0，则跳转<br>ifne 如果不等于 0，则跳转<br>iflt 如果小于 0，则跳转<br>ifge 如果大于等于 0，则跳转<br>ifgt 如果大于 0，则跳转<br>ifle 如果小于等于 0，则跳转<br>if_icmpcq 如果两个 int 值相等，则跳转<br>if_icmpne 如果两个 int 类型值不相等，则跳转<br>if_icmplt 如果一个 int 类型值小于另外一个 int 类型值，则跳转<br>if_icmpge 如果一个 int 类型值大于或者等于另外一个 int 类型值，则跳转<br>if_icmpgt 如果一个 int 类型值大于另外一个 int 类型值，则跳转<br>if_icmple 如果一个 int 类型值小于或者等于另外一个 int 类型值，则跳转<br>ifnull 如果等于 null，则跳转<br>ifnonnull 如果不等于 null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转<br>比较指令<br>lcmp 比较 long 类型值<br>fcmpl 比较 float 类型值（当遇到 NaN 时，返回-1）<br>fcmpg 比较 float 类型值（当遇到 NaN 时，返回 1）<br>dcmpl 比较 double 类型值（当遇到 NaN 时，返回-1）<br>dcmpg 比较 double 类型值（当遇到 NaN 时，返回 1）<br>无条件转移指令<br>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）<br>表跳转指令<br>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<br>异常<br>athrow 抛出异常或错误<br>finally 子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回<br>方法调用指令<br>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法<br>方法返回指令<br>ireturn 从方法中返回 int 类型的数据<br>lreturn 从方法中返回 long 类型的数据<br>freturn 从方法中返回 float 类型的数据<br>dreturn 从方法中返回 double 类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为 void<br>线程同步<br>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><hr><p>JVM 指令助记符<br>变量到操作数栈：iload,iload<em>,lload,lload</em>,fload,fload<em>,dload,dload</em>,aload,aload*<br>操作数栈到变量：istore,istore<em>,lstore,lstore</em>,fstore,fstore<em>,dstore,dstor</em>,astore,astore*<br>常数到操作数栈：bipush,sipush,ldc,ldc<em>w,ldc2_w,aconst_null,iconst_ml,iconst</em>,lconst<em>,fconst</em>,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally 关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈和局部变量操作&lt;br&gt;将常量压入栈的指令&lt;br&gt;aconst_null 将 null 对象引用压入栈&lt;br&gt;iconst_m1 将 int 类型常量-1 压入栈&lt;br&gt;iconst_0 将 int 类型常量 0 压入栈&lt;br&gt;iconst_1 将 int 类型常量 1 压
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解SpringAOP</title>
    <link href="https://zhuyiting.xyz/2019/07/21/JavaWeb%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/"/>
    <id>https://zhuyiting.xyz/2019/07/21/JavaWeb框架/深入理解SpringAOP/</id>
    <published>2019-07-21T13:30:45.000Z</published>
    <updated>2019-12-26T09:12:34.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解-SpringAOP"><a href="#深入理解-SpringAOP" class="headerlink" title="深入理解 SpringAOP"></a>深入理解 SpringAOP</h2><p>AOP 是指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式</p><p>SpringAOP 的底层其实就是动态代理</p><h3 id="Spring-是如何使用动态代理的"><a href="#Spring-是如何使用动态代理的" class="headerlink" title="Spring 是如何使用动态代理的"></a>Spring 是如何使用动态代理的</h3><ol><li>将业务组件和切面组件添加到容器中,</li><li>创建对象的时候, 根据切入点表达式拦截的类, 加入通知,生成代理对象.</li><li>如果目标对象有实现接口就用 JDK 代理, 反之就用 CGLIB 代理.</li></ol><h3 id="SpringAOP-注解驱动原理"><a href="#SpringAOP-注解驱动原理" class="headerlink" title="SpringAOP 注解驱动原理"></a>SpringAOP 注解驱动原理</h3><p>IoC容器启动中,创建了哪些和AOP有关的组件? 这些组件什么时候工作? 工作内容是什么?</p><h4 id="1-实现入口-EnableAspectJAutoProxy"><a href="#1-实现入口-EnableAspectJAutoProxy" class="headerlink" title="1. 实现入口@EnableAspectJAutoProxy"></a>1. 实现入口@EnableAspectJAutoProxy</h4><p>主要工作:</p><ul><li>@Import(AspectJAutoProxyRegistrar.class)给容器导入 <code>AspectJAutoProxyRegistrar</code> 组件(切面自动代理注册器)</li><li>利用 AspectJAutoProxyRegistrar 给容器中注册一个切面相关的 bean<code>AnnotationAwareAspectJAutoProxyCreator</code>(支持注解的 AspectJ 自动代理创建器)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *代码跟进演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//出发点</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">//跟进</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AspectJAutoProxyRegistrar.class&#125;)</span><br><span class="line"><span class="comment">//点进AspectJAutoProxyRegistrar</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"><span class="comment">//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary方法</span></span><br><span class="line"><span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary</span></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line"><span class="comment">//点进AnnotationAwareAspectJAutoProxyCreator</span></span><br></pre></td></tr></table></figure><h4 id="2-AnnotationAwareAspectJAutoProxyCreator-创建过程"><a href="#2-AnnotationAwareAspectJAutoProxyCreator-创建过程" class="headerlink" title="2. AnnotationAwareAspectJAutoProxyCreator 创建过程"></a>2. AnnotationAwareAspectJAutoProxyCreator 创建过程</h4><p><img src="/2019/07/21/JavaWeb%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/AnnotationAwareAspectJAutoProxyCreator%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="AnnotationAwareAspectJAutoProxyCreator继承关系"></p><p>主要关注的是它继承了BeanFactoryAware和BeanPostProcessor接口,</p><p>所以它的创建是在BeanFactory进行初始化,注册BeanPostProcessor阶段(也就是BeanFactoryPostProcessor注册完成之后)</p><p>registerBeanPostProcessors(beanFactory);注册 BeanPostProcessor 来处理拦截 bean 的创建(在bean创建前后执行)；</p><ol><li>先获取 IOC 容器已经定义的需要创建对象的所有 BeanPostProcessor</li><li>注册 BeanPostProcessor,实际上就是创建 BeanPostProcessor 对象，保存在容器中；<br>创建 internalAutoProxyCreator 的 BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】<ol><li>创建 Bean 的实例</li><li>populateBean；给 bean 的各种属性赋值</li><li>initializeBean</li><li>invokeAwareMethods()：处理 Aware 接口的方法回调</li><li>applyBeanPostProcessorsBeforeInitialization();应用后置处理器的 postProcessBeforeInitialization();</li><li>invokeInitMethods()；执行自定义的初始化方法</li><li>applyBeanPostProcessorsAfterInitialization()；执行后置处理器的 postProcessAfterInitialization();</li><li>BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–》aspectJAdvisorsBuilder</li></ol></li><li>把 BeanPostProcessor 注册到 BeanFactory 中；<br>beanFactory.addBeanPostProcessor(postProcessor);</li></ol><h4 id="3-起作用阶段"><a href="#3-起作用阶段" class="headerlink" title="3. 起作用阶段"></a>3. 起作用阶段</h4><p>BeanPostProcessor是在bean实例化前后起作用的, 所以它的执行是在beanFactroy对bean实例化的阶段进行</p><p>finishBeanFactoryInitialization(beanFactory);实例化所有单例 bean</p><ol><li>遍历所有Bean,依次创建对象,使用getBean(beanName);方法</li><li>创建bean<ol><li>先看看容器中是否存在bean,如果存在直接使用,没有再创建</li><li>创建bean;<ol><li>resolveBeforeInstantiation解析,如果能返回一个代理对象则直接用,不能继续</li><li>createBean<ol><li>拿到所有BeanPostProcessor并执行postProcessBeforeInstantiation</li><li>doCreateBean真正的创建bean</li><li>创建完,执行</li></ol></li></ol></li></ol></li></ol><h4 id="4-AnnotationAwareAspectJAutoProxyCreator的作用"><a href="#4-AnnotationAwareAspectJAutoProxyCreator的作用" class="headerlink" title="4. AnnotationAwareAspectJAutoProxyCreator的作用"></a>4. AnnotationAwareAspectJAutoProxyCreator的作用</h4><h5 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h5><p>每一个bean创建之前,调用postProcessBeforeInstantiation</p><p>前提: 容器加载了@AspectJ注解的类,并加载了信息,再匹配切入点表达式与哪些类、方法匹配</p><ol><li>判断当前的bean是否在advisedBeans中(里面保存了所有需要增强的bean)</li><li>判断当前bean是否Advice、Pointcut、Advisor、AopInfrastructureBean、被@Aspect注解的类型 或者是设置了跳过自动代理</li><li>是否配置了跳过通知</li></ol><h5 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h5><p>前提：bean实例化完成</p><ol><li>获取bean的所有通知器</li><li>找到当前bean所匹配的通知器</li><li>对通知器进行优先级排序</li><li>将通知器存入adviseBeans</li><li>如果当前的bean需要注入切面,创建bean的代理对象(jdk代理或者cglib代理)</li><li>向容器返回增强后的代理对象</li></ol><h4 id="代理对象如何工作"><a href="#代理对象如何工作" class="headerlink" title="代理对象如何工作"></a>代理对象如何工作</h4><p>容器中保存了基础组件的代理对象</p><ol><li>拦截器拦截目标方法的执行</li><li>根据ProxyFactory对象获取将要执行的目标方法的增强器链</li><li>以任务栏的形式执行通知和目标方法</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>@EnableAspectJAutoProxy</code> 开启AOP功能<br>会在容器启动阶段注册一个组件 <code>AnnotationAwareAspectJAutoProxyCreator</code></li><li>容器开始创建</li><li>容器注册后置处理器;<br><code>AnnotationAwareAspectJAutoProxyCreator</code> 继承了后置处理器接口. 被创建并注册进容器</li><li>容器开始创建bean;<ol><li>创建业务逻辑bean;和切面bean</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>拦截组件创建,如果有已代理对象,直接返回</li><li>组件创建</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>执行postProcessBeforeInstantiation,给需要增强bean创建代理对象<br>获取目标对象以及advisor(增强器,切面的通知方法) 创建代理</li></ol></li><li>执行目标方法<ol><li>CglibAopProxy.intercept();拦截</li><li>执行通知任务链和目标方法</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入理解-SpringAOP&quot;&gt;&lt;a href=&quot;#深入理解-SpringAOP&quot; class=&quot;headerlink&quot; title=&quot;深入理解 SpringAOP&quot;&gt;&lt;/a&gt;深入理解 SpringAOP&lt;/h2&gt;&lt;p&gt;AOP 是指在程序运行期间动态的将某段代码切
      
    
    </summary>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://zhuyiting.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringIoC详解</title>
    <link href="https://zhuyiting.xyz/2019/07/10/JavaWeb%E6%A1%86%E6%9E%B6/SpringIoC%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhuyiting.xyz/2019/07/10/JavaWeb框架/SpringIoC详解/</id>
    <published>2019-07-10T08:30:45.000Z</published>
    <updated>2019-12-26T09:12:31.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringIoC详解"><a href="#SpringIoC详解" class="headerlink" title="SpringIoC详解"></a>SpringIoC详解</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>对于SpringIoC来说,最重要的就是容器了,容器管理这所有的Bean,控制这Bean的依赖注入</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>早期基础容器, 可以理解成一个HashMap,key是BeanName,value是Bean实例.</p><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>应用上下午,高级容器,相比BeanFactory功能全面很多</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>Bean对象在Spring中是以BeanDefinition来描述的</p><p>Bean的解析主要就是对配置文件或者配置类的解析</p><h3 id="SpringIoC注解驱动初始化过程"><a href="#SpringIoC注解驱动初始化过程" class="headerlink" title="SpringIoC注解驱动初始化过程"></a>SpringIoC注解驱动初始化过程</h3><p>SpringIoC的初始化过程也是ApplicationContext容器的初始化过程</p><p>入口:<code>AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);</code></p><ol><li><p>调用AnnotationConfigApplicationContext构造函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先执行父类构造方法,再执行本类无参构造方法</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 2. 注册带注解的类</span></span><br><span class="line">    <span class="keyword">this</span>.register(annotatedClasses);</span><br><span class="line">    <span class="comment">// 3. 更新容器</span></span><br><span class="line">    <span class="keyword">this</span>.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this(); 默认先调用父类无参构造函数,构建初始对象<strong>DefaultListableBeanFactory</strong>,最基础的BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.customClassLoader = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">this</span>.refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">     <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>再调用当前类this();创建读取器和扫描器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//BeanDefinition解析器; 用来解析带注解的bean</span></span><br><span class="line">     <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">//ClassPath下的BeanDefinition的扫描器(用来扫描类)</span></span><br><span class="line">     <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建注解模式下的BeanDefinition解析器AnnotatedBeanDefinitionReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// BeanName产生器</span></span><br><span class="line">     <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">     <span class="comment">// 作用域元数据解析器</span></span><br><span class="line">     <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">     Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">     <span class="keyword">this</span>.registry = registry;</span><br><span class="line">     <span class="comment">// @Conditionl条件表达式鉴别器</span></span><br><span class="line">     <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, (ResourceLoader)<span class="keyword">null</span>);</span><br><span class="line">     AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">     DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">     <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">             beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">             beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet(<span class="number">4</span>);</span><br><span class="line">     RootBeanDefinition def;</span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册主配置类的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理@Autowired注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理@Required注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理JSR规范注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册处理jpa的后置处理器</span></span><br><span class="line">     <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             def.setBeanClass(ClassUtils.forName(<span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>, AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassNotFoundException var6) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot load optional framework class: org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>, var6);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册处理事件监听方法的处理器</span></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册事件监听工厂</span></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//完成spring自身的后置处理器注册</span></span><br><span class="line">     <span class="comment">//到这一步, BeanDefinitionMap中已经保存了一些spring自带的后置处理器的定义信息了</span></span><br><span class="line">     <span class="keyword">return</span> beanDefs;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建ClassPath下的BeanDefinition的扫描器ClassPathBeanDefinitionScanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters, Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.beanDefinitionDefaults = <span class="keyword">new</span> BeanDefinitionDefaults();</span><br><span class="line">     <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">     <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">     <span class="keyword">this</span>.includeAnnotationConfig = <span class="keyword">true</span>;</span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">     <span class="comment">//设置加载BeanDefinition的注册器</span></span><br><span class="line">     <span class="keyword">this</span>.registry = registry;</span><br><span class="line">     <span class="comment">//是否使用默认的过滤规则</span></span><br><span class="line">     <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">         <span class="keyword">this</span>.registerDefaultFilters();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//设置环境</span></span><br><span class="line">     <span class="keyword">this</span>.setEnvironment(environment);</span><br><span class="line">     <span class="comment">//设置资源加载器</span></span><br><span class="line">     <span class="keyword">this</span>.setResourceLoader(resourceLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进this.registerDefaultFilters();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 向includeFilters中添加所有@Component注解的类(其他的一些Bean注解也都有@Component)</span></span><br><span class="line">     <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">     ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl), <span class="keyword">false</span>));</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="function">AnnotationTypeFil        <span class="title">ter</span><span class="params">(ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)</span>, <span class="keyword">false</span>))</span>;</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>注册Bean配置类register(annotatedClasses)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, String name, Class... qualifiers)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将Bean配置信息转换成AnnotatedGenericBeanDefinition  注解通用BeanDefinition</span></span><br><span class="line">     AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">     <span class="comment">// 判断@Conditionl条件是否有跳过注册的</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">         <span class="comment">// 解析@Scope作用域, 没有则默认Singleton</span></span><br><span class="line">         ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">         <span class="comment">// 将作用域信息添加到BeanDefinition</span></span><br><span class="line">         abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">         <span class="comment">// 设置beanName</span></span><br><span class="line">         String beanName = name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry);</span><br><span class="line">         AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">         <span class="comment">// 解析@Qualifier</span></span><br><span class="line">         <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Class[] var7 = qualifiers;</span><br><span class="line">             <span class="keyword">int</span> var8 = qualifiers.length;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> var9 = <span class="number">0</span>; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">                 Class&lt;? extends Annotation&gt; qualifier = var7[var9];</span><br><span class="line">                 <span class="comment">// 如果有@Primary注解,向BeanDefinition中写入首选bean</span></span><br><span class="line">                 <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">                     abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">                 <span class="comment">// 如果有@Lazy注解, 设置懒加载</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">                     abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 封装一个BeanName和BeanDefinition之间的映射关系</span></span><br><span class="line">         BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">         <span class="comment">// 创建代理对象</span></span><br><span class="line">         definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">         <span class="comment">// 按BeanName将BeanDefinition注册到容器中</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>refresh();  IoC容器启动的核心</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">         <span class="comment">// 1. 刷新上下文之前的准备工作</span></span><br><span class="line">         <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">         <span class="comment">// 2. 获取初始化BeanFactory</span></span><br><span class="line">         ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">         <span class="comment">// 3. 对BeanFactory进行属性填充</span></span><br><span class="line">         <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 4. 模板方法，注册自己添加的BeanPostFactoryProcessor</span></span><br><span class="line">             <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">             <span class="comment">// 5. 执行BeanFactory后置处理器</span></span><br><span class="line">             <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">             <span class="comment">// 6. 注册Bean后置注册器</span></span><br><span class="line">             <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">             <span class="comment">// 7. 初始化国际化资源处理器</span></span><br><span class="line">             <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">             <span class="comment">// 8. 初始化应用事件多播器</span></span><br><span class="line">             <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">             <span class="comment">// 9. 模板方法，调用某些特殊的bean的初始化，springboot中在这个地方启动tomcat</span></span><br><span class="line">             <span class="keyword">this</span>.onRefresh();</span><br><span class="line">             <span class="comment">// 10. 注册监听器到多播器上</span></span><br><span class="line">             <span class="keyword">this</span>.registerListeners();</span><br><span class="line">             <span class="comment">// 11. 实例化所有非懒加载的单例Bean</span></span><br><span class="line">             <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">             <span class="comment">// 12. 初始化容器生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">             <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                 <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">             <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">             <span class="keyword">throw</span> var9;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对代码进行进一步跟进,看看每一步中都做了什么</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1. prepareRefresh()</span></span><br><span class="line"><span class="comment">    1. this.startupDate = System.currentTimeMillis();设置启动时间</span></span><br><span class="line"><span class="comment">    2. initPropertySources();自定义属性设置</span></span><br><span class="line"><span class="comment">    3. getEnvironment().validateRequiredProperties();检验属性的合法性</span></span><br><span class="line"><span class="comment">    4. earlyApplicationEvents = new LinkedHashSet();创建早期应用事件集合</span></span><br><span class="line"><span class="comment"> 2. beanFactory = this.obtainFreshBeanFactory();</span></span><br><span class="line"><span class="comment">    1. this.beanFactory.setSerializationId(this.getId());设置BeanFactoryID</span></span><br><span class="line"><span class="comment"> 3. prepareBeanFactory(beanFactory);</span></span><br><span class="line"><span class="comment">    1. addBeanPostProcessor(new ApplicationContextAwareProcessor(this));添加一个ApplicationContextAwareProcessor</span></span><br><span class="line"><span class="comment">    2. ignoreDependencyInterface(XXX.class); 设置忽略注入的接口实现类</span></span><br><span class="line"><span class="comment">    3. registerResolvableDependency(XXX.class,beanFactory); 注册可解析的注入的组件</span></span><br><span class="line"><span class="comment">    4. 添加编译时的AOP组件</span></span><br><span class="line"><span class="comment">    5. 注册环境组件,系统属性组件,系统环境组件</span></span><br><span class="line"><span class="comment"> 4. postProcessBeanFactory(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 子类重写这个方法,在BeanFactory准备完成创建之前做最后的步骤</span></span><br><span class="line"><span class="comment"> 5. invokeBeanFactoryPostProcessors(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 执行BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       1. 获取所有BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       2. 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       3. 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       4. 最后执行其他的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    2. 执行BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       1. 获取所有BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       2. 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       3. 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       4. 最后执行其他的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> 6. registerBeanPostProcessors(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 获取所有的BeanPostProcessor</span></span><br><span class="line"><span class="comment">    2. 先BeanPostProcessor</span></span><br><span class="line"><span class="comment">    3. 注册MergedBeanDefinitionPostProcessor</span></span><br><span class="line"><span class="comment">    4. 最后创建一个ApplicationListenerDetector;检查是ApplicationListener的bean</span></span><br><span class="line"><span class="comment"> 7. initMessageSource();</span></span><br><span class="line"><span class="comment">    1. 获取BeanFactory</span></span><br><span class="line"><span class="comment">    2. 判断容器中是否有MessageSource的组件</span></span><br><span class="line"><span class="comment">    3. 如果有则取用, 没有则创建DelegatingMessageSource</span></span><br><span class="line"><span class="comment">    4. 将国际化组件祖册到容器</span></span><br><span class="line"><span class="comment"> 8. initApplicationEventMulticaster();</span></span><br><span class="line"><span class="comment">    1. 获取BeanFactory</span></span><br><span class="line"><span class="comment">    2. 判断容器是否有ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">    3. 如果有取用, 没有则创建SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">    4. 将ApplicationEventMulticaster组件添加到BeanFactory</span></span><br><span class="line"><span class="comment"> 9. onRefresh();</span></span><br><span class="line"><span class="comment">    1.  留给子类,子类重写这个方法, 在容器刷新时可以自定义一些逻辑</span></span><br><span class="line"><span class="comment"> 10. registerListeners();</span></span><br><span class="line"><span class="comment">     1.  获取容器中的ApplicationListener</span></span><br><span class="line"><span class="comment">     2.  将所有ApplicationListener添加到ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">     3.  派发早期事件earlyApplicationEvents</span></span><br><span class="line"><span class="comment"> 11. finishBeanFactoryInitialization(beanFactory);</span></span><br><span class="line"><span class="comment">     1.  preInstantiateSingletons;初始化剩下的所有单实例Bean</span></span><br><span class="line"><span class="comment">         1.  获取容器中的单例beanName</span></span><br><span class="line"><span class="comment">         2.  如果beanName对应的bean不是抽象不是懒加载不是多实例的</span></span><br><span class="line"><span class="comment">         3.  getBean(beanName);</span></span><br><span class="line"><span class="comment">         4.  doGetBean(beanName);</span></span><br><span class="line"><span class="comment">         5.  标记要创建bean了,保证线程安全</span></span><br><span class="line"><span class="comment">         6.  getMergedLocalBeanDefinition(beanName);获得BeanDefinition</span></span><br><span class="line"><span class="comment">         7.  getDependsOn();获取依赖</span></span><br><span class="line"><span class="comment">         8.  递归getBean;创建所依赖Bean</span></span><br><span class="line"><span class="comment">         9.  将获取的依赖bean注册到denpendsOn集合</span></span><br><span class="line"><span class="comment">         10. createBean(beanName, ex1, args);创建bean</span></span><br><span class="line"><span class="comment">         11. doCreateBean(beanName, mbdToUse, args);</span></span><br><span class="line"><span class="comment">             1.  createBeanInstance(beanName, mbd, args);</span></span><br><span class="line"><span class="comment">             2.  调用前置处理器</span></span><br><span class="line"><span class="comment">             3.  属性赋值</span></span><br><span class="line"><span class="comment">             4.  执行初始化</span></span><br><span class="line"><span class="comment">             5.  执行后置处理器</span></span><br><span class="line"><span class="comment">             6.  注册bean销毁方法</span></span><br><span class="line"><span class="comment">             7.  添加到单例bean集合</span></span><br><span class="line"><span class="comment"> 12. finishRefresh();</span></span><br><span class="line"><span class="comment">     1.  初始化生命周期有关后置处理器</span></span><br><span class="line"><span class="comment">     2.  执行容器刷新完成事件</span></span><br><span class="line"><span class="comment">     3.  将ApplicationContext注册到视图中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><blockquote><ol><li>Spring容器在启动时,会先加载有关Bean定义信息的配置文件或者配置类(xml注册bean/注解注册bean)</li><li>BeanDefinitionReader将配置文件或者配置类解析成BeanDefinition,并存入容器中BeanDefinitionRegistry</li><li>Spring容器扫描BeanDefinitionRegistry中的所有BeanDefinition,使用BeanFactoryPostProcessor对它们进行加工, 主要是依赖处理和属性赋值</li><li>实例化Bean时,封装Bean然后完成对Bean的属性设置工作</li><li>利用Bean后置处理器,对完成的Bean进行加工</li></ol></blockquote><h5 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h5><ol><li><p>Resource<br>xml、properties资源文件的抽象</p></li><li><p>ResourceLoader<br>资源的加载, 解析xml、properties返回Resource</p></li><li><p>BeanDefinition<br>保存了从配置文件中读取到的bean的各种信息,一个bean对应一个BeanDefinition<br>有beanClass、scope、lazyInit等属性</p></li><li><p>BeanDefinitionReader<br>定义读取组件，从Resource资源中读取出BeanDefinition</p></li><li><p>BeanDefinitionRegistry<br>BeanFactory的实现类需要实现这个接口，所以所有BeanFactory都有注册BeanDefinition的功能<br>其内部维护了一个Map，可以将BeanDefinition和beanName的对应关系添加进去</p></li><li><p>Enviroment<br>环境，保存了程序运行的环境参数（JDK版本，jre等等）</p></li><li><p>BeanFactoryPostProcessor接口<br>BeanFactory后置处理器, 扩展切口, 允许它的实现类在容器初始化前后进行相应操作<br>典型的有PropertyPlaceholderConfigurer,占位符配置处理器</p></li><li><p>Aware接口<br>对于实现了XXXXAware的bean,spring会注入相应的XXXX, 通过重写setXXXX的方法</p></li><li><p>BeanPostProcessor接口<br>允许实现它的bean,在实例化前后做相应操作,在最前最后位置</p></li><li><p>InitializingBean接口<br>允许实现它的bean,在实例化前后做相应操作, 在处理器before之后和after之前</p></li><li><p>DisposableBean接口<br>允许实现它的bean,在摧毁前后做相应操作</p></li><li><p>FactoryBean接口<br>允许实现它的bean,在beanFactory.getBean()获取该bean时, 会调用这个bean中重写的方法getObject,而不是直接返回该bean<br>工厂模式的体现</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringIoC详解&quot;&gt;&lt;a href=&quot;#SpringIoC详解&quot; class=&quot;headerlink&quot; title=&quot;SpringIoC详解&quot;&gt;&lt;/a&gt;SpringIoC详解&lt;/h2&gt;&lt;h3 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://zhuyiting.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://zhuyiting.xyz/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2019/07/02/设计模式/代理模式/</id>
    <published>2019-07-02T11:35:45.000Z</published>
    <updated>2019-12-26T08:41:46.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p>Proxy-代理模式是指为其他对象提供一种代理,来控制对这个对象的访问</p><p>即对A对象进行代理后, 本来A对象的功能交给代理B来做; 代理就是原实例前后添加一层处理.</p><h3 id="为什么使用代理模式"><a href="#为什么使用代理模式" class="headerlink" title="为什么使用代理模式"></a>为什么使用代理模式</h3><ul><li>授权机制: 不同级别的用户对于同一对象的访问权限是不同的, 要用代理实现对不同用户的访问权限的控制</li><li>某个客户端不能直接操作一个对象, 但又要和那个对象互动, 也要通过代理实现间接互动</li><li>代理类为委托类预处理消息,过滤消息,把消息传递给委托类, 以及事后对返回结果的处理等.</li></ul><h3 id="3种代理模式"><a href="#3种代理模式" class="headerlink" title="3种代理模式"></a>3种代理模式</h3><h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h4><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:创建服务类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:实现服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步:创建代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(<span class="keyword">final</span> UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService=userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备登录"</span>);</span><br><span class="line">        userService.login();</span><br><span class="line">        System.out.println(<span class="string">"登录完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步:测试运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy userServiceProxy=<span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理可以做到符合开闭原则的对目标对象进行功能扩展, 但是工作量大, 要给每个对象创建代理类, 而且不易管理, 接口发生改变, 代理类也要改变</p><h4 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2. JDK动态代理"></a>2. JDK动态代理</h4><p>动态代理中, 不需要手动创建代理类了, 只要编写一个动态处理器就OK了</p><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:编写动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] agrs)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">        Object result=method.invoke(Object,args);</span><br><span class="line">        System.out.println(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:编写测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService userServiceProxy=(UserService)Proxy.newProxyInstnce(UserService.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;UserService.class&#125;,<span class="keyword">new</span> DynamicProxyHandler(userService));</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-CGLIB代理"><a href="#3-CGLIB代理" class="headerlink" title="3. CGLIB代理"></a>3. CGLIB代理</h4><p>JDK实现动态代理需要实现类通过接口定义业务的方法, 对于没有接口的类就不能实现代理.这就需要CGLIB了</p><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:创建CGLIB代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object</span></span></span><br><span class="line"><span class="function"><span class="params">    target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(This.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args,MeyhodProxy methodProxy)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">        Object result=method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:创建测试类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        CglibProxy cglibProxy=<span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserService userServiceProxy=(UserService)cglibProxy.getInstance(userService1;)</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLIB代理比JDK代理的性能更高,但是CGLIB比JDK创建代理的耗时要更高,所以单例对象CGLIB更合适, 反之JDK更合适.</p><p><img src="/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="CGLIB动态代理执行流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式-Proxy&quot;&gt;&lt;a href=&quot;#代理模式-Proxy&quot; class=&quot;headerlink&quot; title=&quot;代理模式(Proxy)&quot;&gt;&lt;/a&gt;代理模式(Proxy)&lt;/h2&gt;&lt;p&gt;Proxy-代理模式是指为其他对象提供一种代理,来控制对这个对象的访问&lt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://zhuyiting.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://zhuyiting.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ入门</title>
    <link href="https://zhuyiting.xyz/2019/06/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://zhuyiting.xyz/2019/06/30/消息中间件/ActiveMQ入门/</id>
    <published>2019-06-30T14:10:45.000Z</published>
    <updated>2019-12-23T01:40:26.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ入门"><a href="#ActiveMQ入门" class="headerlink" title="ActiveMQ入门"></a>ActiveMQ入门</h2><p>ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现<br>尽管JMS已经出台很久, 但在J2EE中仍然扮演者重要角色</p><h3 id="ActiveMQ特性"><a href="#ActiveMQ特性" class="headerlink" title="ActiveMQ特性"></a>ActiveMQ特性</h3><ol><li>支持多种编程语言</li><li>支持多种传输协议</li><li>支持多种持久化方式(文件系统/数据库)</li></ol><h3 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h3><ol><li>从官网下载ActiveMQ</li><li>利用Xftp将文件传到服务器</li><li>解压到<code>/var</code>目录下</li><li>修改文件名为<code>activemq</code></li></ol><h3 id="ActiveMQ启动"><a href="#ActiveMQ启动" class="headerlink" title="ActiveMQ启动"></a>ActiveMQ启动</h3><p>在activemq文件下使用命令<code>./bin/activemq start</code> 后台启动ActiveMQ</p><p>但最好是将ActiveMQ作为一个服务来启动,这样可以使activemq在系统启动时自动启动</p><h4 id="创建ActiveMQ服务"><a href="#创建ActiveMQ服务" class="headerlink" title="创建ActiveMQ服务"></a>创建ActiveMQ服务</h4><ol><li><p>使用vim创建一个服务文件<br><code>vi /usr/lib/systemd/system/activemq.service</code></p></li><li><p>输入内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ActiveMQ service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/var/activemq/bin/activemq start</span><br><span class="line">ExecStop=/var/activemq/bin/activemq stop</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=9</span><br><span class="line">StandardOutput=syslog</span><br><span class="line">StandardError=syslog</span><br><span class="line">SyslogIdentifier=activemq</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>修改<code>/var/activemq/bin/env</code>文件<br> 将JAVA_HOME的注释删除,然后填入系统jdk的安装路径</p></li><li><p>启动ActiveMQ服务<br> 使用<code>systemctl start activemq</code>来启动服务</p></li><li><p>查看服务状态<br> 使用命令<code>systemctl status activemq</code></p></li><li><p>设置开机自动启动<br> <code>ln -s /usr/lib/systemd/system/activemq.service/etc/systemd/system/multi-user.target.wants/activemq.service</code><br> <code>systemctl enable activemq</code></p></li><li><p>在防火墙添加ActiveMQ的Web管理端口和通讯端口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Web管理端口默认为8161,通讯端口默认为61616</span><br><span class="line">ufw allow 8161</span><br><span class="line">ufw allow 61616</span><br><span class="line"># 部分服务器需要在对应的服务提供商管理页面修改出入站规则</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问<code>http://服务IP:8161/admin</code>进入管理平台<br>账户默认:admin<br>密码默认:admin</p></li></ol><h4 id="Web管理平台配置"><a href="#Web管理平台配置" class="headerlink" title="Web管理平台配置"></a>Web管理平台配置</h4><p>ActiveMQ的Web管理平台是基于jetty运行,因此在/var/activemq/conf目录可以查看jetty的配置文件</p><p>在<code>/var/activemq/conf/jetty.xml</code>文件中,可以进行修改端口,密码等内容</p><h3 id="使用ActiveMQ"><a href="#使用ActiveMQ" class="headerlink" title="使用ActiveMQ"></a>使用ActiveMQ</h3><p>在Java中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Spring中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-broker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>geronimo-jms_1.1_spec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.apache.geronimo.specs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ActiveMQ支持的协议"><a href="#ActiveMQ支持的协议" class="headerlink" title="ActiveMQ支持的协议"></a>ActiveMQ支持的协议</h3><p>ActiveMQ支持多种协议传输和传输方式,允许客户端使用多种协议连接.</p><p>ActiveMQ支持的协议: AUTO、OpenWire、AMQP、Stomp、MQTT等<br>在${ACTIVE_HOME}/conf/activemq.xml中, 通过配置<code>&lt;transportConnectors&gt;</code>就可以使用多种传输方式</p><p>ActiveMQ支持的基础传输方式有: VM、TCP、SSL、UDP、Peer、Multicast、HTTP(S)等\</p><p>由于TCP的稳定性, 它也是ActiveMQ中最常用的一种协议. 在默认的设置中, TCP连接的端口为61616</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ入门&quot;&gt;&lt;a href=&quot;#ActiveMQ入门&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ入门&quot;&gt;&lt;/a&gt;ActiveMQ入门&lt;/h2&gt;&lt;p&gt;ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="ActiveMQ" scheme="https://zhuyiting.xyz/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>分布式消息中间件</title>
    <link href="https://zhuyiting.xyz/2019/06/27/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://zhuyiting.xyz/2019/06/27/消息中间件/分布式消息中间件/</id>
    <published>2019-06-27T13:36:45.000Z</published>
    <updated>2019-12-22T11:48:47.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h2><p><strong>生产者</strong>(客户端)–发送消息–&gt;<strong>消息中间件</strong>–分发消息–&gt;<strong>消费者</strong>(服务器)</p><h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><ol><li>利用高效可靠的消息传递机制进行平台无关的数据交互;<br> 把用户消息暂存到消息中间件, 消息中间件在把消息分发到对应分布式模块</li><li>基于数据通信来集成分布式系统<br> 分布式系统之间完全通过数据来连接,后台系统之间不需要接口调用</li><li>通过提供消息传递和消息队列模型, 它可以在分布式环境下扩展进程间的通信<br> 跨系统跨进程通信</li></ol><h4 id="消息中间件的应用场景"><a href="#消息中间件的应用场景" class="headerlink" title="消息中间件的应用场景"></a>消息中间件的应用场景</h4><p>跨系统数据传递、高并发流量削峰填谷、数据异步处理…等等</p><h4 id="常用的消息中间件"><a href="#常用的消息中间件" class="headerlink" title="常用的消息中间件"></a>常用的消息中间件</h4><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ</p><h3 id="消息中间件的核心设计"><a href="#消息中间件的核心设计" class="headerlink" title="消息中间件的核心设计"></a>消息中间件的核心设计</h3><h4 id="消息中间件的本质"><a href="#消息中间件的本质" class="headerlink" title="消息中间件的本质"></a>消息中间件的本质</h4><p>一种具备<strong>接收请求、保存数据、发送数据</strong>等功能的网络应用；和一般网络应用的区别是它主要负责数据的接收和传递，所以性能一般高于普通程序</p><h4 id="消息中间件的5大核心组成"><a href="#消息中间件的5大核心组成" class="headerlink" title="消息中间件的5大核心组成"></a>消息中间件的5大核心组成</h4><h5 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h5><p>计算机之间通信共同遵循的一组约定<br>协议三要素:</p><ol><li>语法</li><li>语义</li><li>时序</li></ol><p><strong>消息中间件常用的协议:</strong> OpenWire、AMQP、MQTT、Kafka、OpenMessage(国内发起)</p><h5 id="2-持久化机制"><a href="#2-持久化机制" class="headerlink" title="2. 持久化机制"></a>2. 持久化机制</h5><p>简单来说就是将数据存入磁盘,而不是在内存中,不会因为服务器宕机而丢失数据,能够让数据永久保存就叫持久化</p><p>常用持久化方式就是文件系统</p><h5 id="3-消息分发机制"><a href="#3-消息分发机制" class="headerlink" title="3. 消息分发机制"></a>3. 消息分发机制</h5><p>为什么要有消息分发策略</p><ol><li>消息要被特定的系统接收到, 其他的系统不需要接收</li><li>试错机制:后台出错,需要重新发送消息</li></ol><p>要解决的问题:</p><ol><li>消息传递是推还是拉</li><li>是主动分发还是轮询分发</li><li>有无重发功能</li></ol><h5 id="4-高可用设计"><a href="#4-高可用设计" class="headerlink" title="4. 高可用设计"></a>4. 高可用设计</h5><p>指服务可用性,保持能够使用的状态, 避免服务中断.消息中间件可以使用集群部署, 来达到高可用</p><p>分布式消息中间件实现方式:</p><ol><li>Master-Slave主从共享数据<br>服务器共用同一份数据</li><li>Master-Slave主从同步部署方式<br>主服务器同步数据到所有服务器</li><li>Broker-Cluster多主集群同步<br>所有服务器都可以进行同步数据</li><li>Broker-Cluster多主集群转发<br>只同步数据信息,不同步数据内容, 服务器将请求转发给存有消息内容的服务器</li><li>Master-Slave与Broker-Cluster结合<br>分区同步数据</li></ol><h5 id="5-高可靠设计"><a href="#5-高可靠设计" class="headerlink" title="5. 高可靠设计"></a>5. 高可靠设计</h5><p>消息传输可靠:通过协议保证系统数据解析的正确性<br>消息存储可靠:通过持久化保证存储消息的可靠性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式消息中间件&quot;&gt;&lt;a href=&quot;#分布式消息中间件&quot; class=&quot;headerlink&quot; title=&quot;分布式消息中间件&quot;&gt;&lt;/a&gt;分布式消息中间件&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;生产者&lt;/strong&gt;(客户端)–发送消息–&amp;gt;&lt;strong&gt;消息中
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="https://zhuyiting.xyz/2019/06/27/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8CPU100%25%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://zhuyiting.xyz/2019/06/27/Java系统调优/内存爆炸CPU100%问题分析/</id>
    <published>2019-06-27T13:36:45.000Z</published>
    <updated>2019-12-22T06:45:07.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存爆炸和CPU100-问题分析"><a href="#内存爆炸和CPU100-问题分析" class="headerlink" title="内存爆炸和CPU100%问题分析"></a>内存爆炸和CPU100%问题分析</h2><p>当线上的系统突然请求缓慢, CPU100%, 内存占用巨大, 当JVM出现问题时,应该如何排查问题呢</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>登录服务器, 使用<code>top</code>命令查看系统资源使用情况<br>一般出问题时java程序的占用是最高的</p></li><li><p>找到CPU或者内存占用高的java进程PID, 使用命令<code>top -Hp 进程ID</code>, <strong>查询该进程中线程的运行情况</strong></p></li><li><p>使用<code>printf &quot;%x\n&quot; 线程ID</code><strong>查看线程PID的16进制</strong>形式<br> 因为在java日志中记录的PID是16进制的形式</p></li><li><p><code>jstack 进程ID &gt; ./threadDump.log</code> <strong>打印JVM堆栈信息</strong>到文件threadDump.log中<br>在该堆栈信息文件中,找到第3步的线程, 查看具体信息</p></li><li><p>使用<code>jstat -gcutil 进程号 统计间隔时间 统计次数</code><strong>查看GC的变化情况</strong>, 当发现<code>FGC</code>的值一直增大时, 继续使用<code>jmap -heap 进程ID</code> 查看进程堆内存的情况, 特别是老年代的使用情况.<br>老年代内存占用达到阈值时就会触发Full GC</p></li><li><p><code>jmap -dump:format=b,file=filename 进程ID</code> ,导出Java进程下内存堆到文件中, 再把内存镜像dump文件传到本地, 利用工具进行分析<br>可以使用<code>jhat</code>、<code>VisualVM</code>等工具分析dump文件</p></li></ol><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h4 id="Full-GC次数过多"><a href="#Full-GC次数过多" class="headerlink" title="Full GC次数过多"></a>Full GC次数过多</h4><ol><li>jstat命令发现GC次数很多,并且不断增加</li><li>分析dump文件,查看具体对象的内存占用情况<br>如果内存占用情况不多, 说明代码中频繁使用了System.gc()</li></ol><h4 id="代码中消耗CPU的操作太多"><a href="#代码中消耗CPU的操作太多" class="headerlink" title="代码中消耗CPU的操作太多"></a>代码中消耗CPU的操作太多</h4><p>比如复杂的算法,递归的循环等,甚至是代码BUG</p><h4 id="锁的使用不正确-造成死锁"><a href="#锁的使用不正确-造成死锁" class="headerlink" title="锁的使用不正确, 造成死锁"></a>锁的使用不正确, 造成死锁</h4><p>分析JVM堆栈信息,看是否有死锁deadlock</p><h4 id="不定期的接口耗时现象"><a href="#不定期的接口耗时现象" class="headerlink" title="不定期的接口耗时现象"></a>不定期的接口耗时现象</h4><p>这主要是因为不定期的高并发带来的问题, 要通过压测工具不断加大访问力度, 发现某个接口某个位置响应缓慢, 再查看堆栈日志, 发现大量线程被阻塞在同一位置, 就能查到我们哪个业务代码出了问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存爆炸和CPU100-问题分析&quot;&gt;&lt;a href=&quot;#内存爆炸和CPU100-问题分析&quot; class=&quot;headerlink&quot; title=&quot;内存爆炸和CPU100%问题分析&quot;&gt;&lt;/a&gt;内存爆炸和CPU100%问题分析&lt;/h2&gt;&lt;p&gt;当线上的系统突然请求缓慢, 
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
      <category term="JDK" scheme="https://zhuyiting.xyz/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="https://zhuyiting.xyz/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <id>https://zhuyiting.xyz/2019/06/18/Java系统调优/JDK内置命令工具/</id>
    <published>2019-06-18T06:56:05.000Z</published>
    <updated>2019-12-19T11:09:06.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK内置命令工具"><a href="#JDK内置命令工具" class="headerlink" title="JDK内置命令工具"></a>JDK内置命令工具</h2><h3 id="javap命令"><a href="#javap命令" class="headerlink" title="javap命令"></a>javap命令</h3><p>java反编译工具, 主要用于根据Java字节码文件反汇编为Java源代码文件.</p><h3 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h3><p>显示当前所有java进程pid的命令</p><h3 id="jstat命令"><a href="#jstat命令" class="headerlink" title="jstat命令"></a>jstat命令</h3><p>监视Java虚拟机统计信息</p><h3 id="jcmd命令"><a href="#jcmd命令" class="headerlink" title="jcmd命令"></a>jcmd命令</h3><p>可以替代jps工具查看本地的jvm信息</p><h3 id="jinfo命令"><a href="#jinfo命令" class="headerlink" title="jinfo命令"></a>jinfo命令</h3><p>可以查看运行中的jvm的全部参数, 还可以设置部分参数</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>分析java堆的命令,可以将堆中的对象以html的形式展现出来,支持对象查询语言SQL</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>打印出java进程内存中对象的情况,或者将JVM中的堆,以二进制输出成文本</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于打印出给定的java进程ID或core file或远程调试服务的堆栈信息, 如果在64位机器, 需要指定选项<code>-J-d64</code></p><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h3><p>可视化的监视管理控制台</p><h3 id="JvisualVM"><a href="#JvisualVM" class="headerlink" title="JvisualVM"></a>JvisualVM</h3><p>可视化的JVM监控工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK内置命令工具&quot;&gt;&lt;a href=&quot;#JDK内置命令工具&quot; class=&quot;headerlink&quot; title=&quot;JDK内置命令工具&quot;&gt;&lt;/a&gt;JDK内置命令工具&lt;/h2&gt;&lt;h3 id=&quot;javap命令&quot;&gt;&lt;a href=&quot;#javap命令&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
      <category term="JDK" scheme="https://zhuyiting.xyz/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数以及调优</title>
    <link href="https://zhuyiting.xyz/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
    <id>https://zhuyiting.xyz/2019/06/18/Java系统调优/JVM参数以及调优/</id>
    <published>2019-06-18T06:56:05.000Z</published>
    <updated>2019-12-20T06:17:18.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM参数以及调优"><a href="#JVM参数以及调优" class="headerlink" title="JVM参数以及调优"></a>JVM参数以及调优</h2><h3 id="JVM调优基本概念"><a href="#JVM调优基本概念" class="headerlink" title="JVM调优基本概念"></a>JVM调优基本概念</h3><ol><li>堆大小调整</li><li>垃圾收集器调整</li><li>JIT编译器</li></ol><p>大多数调优选项都与调整堆大小和根据情况选择最合适的垃圾收集器有关.</p><h4 id="调优的主要目标"><a href="#调优的主要目标" class="headerlink" title="调优的主要目标"></a>调优的主要目标</h4><p><strong>响应性:</strong> 应用程序或系统对请求的数据进行响应的速度, 对于响应性要求高的程序,重点是在短时间内做出回应, 不接受长暂停.</p><p><strong>吞吐量:</strong> 侧重于在特定时间段内最大化应用程序的工作量. 高暂停是可接受的.</p><p><strong>系统瓶颈核心还是在应用代码, 一般情况下无需过多调优, JVM本身在不断优化.</strong></p><h3 id="GC调优思路"><a href="#GC调优思路" class="headerlink" title="GC调优思路"></a>GC调优思路</h3><ol><li>分析场景</li><li>确定目标<br>内存占用、低延时、吞吐量</li><li>收集日志<br>通过参数配置收集GC日志; 通过JVM分析GC状态看GC状态</li><li>分析日志<br>使用工具辅助分析日志, 查看GC次数, GC时间</li><li>调整参数<br>切换垃圾收集器或者调整垃圾收集器参数</li></ol><h4 id="通用GC参数"><a href="#通用GC参数" class="headerlink" title="通用GC参数"></a>通用GC参数</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM参数以及调优&quot;&gt;&lt;a href=&quot;#JVM参数以及调优&quot; class=&quot;headerlink&quot; title=&quot;JVM参数以及调优&quot;&gt;&lt;/a&gt;JVM参数以及调优&lt;/h2&gt;&lt;h3 id=&quot;JVM调优基本概念&quot;&gt;&lt;a href=&quot;#JVM调优基本概念&quot; class
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="https://zhuyiting.xyz/2019/06/10/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://zhuyiting.xyz/2019/06/10/Java系统调优/JVM垃圾回收机制/</id>
    <published>2019-06-10T09:23:11.000Z</published>
    <updated>2019-12-19T08:46:04.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><h3 id="自动垃圾收集"><a href="#自动垃圾收集" class="headerlink" title="自动垃圾收集"></a>自动垃圾收集</h3><p>自动垃圾收集是<strong>查看堆内存</strong>,<strong>识别正在使用哪些对象</strong>以及<strong>哪些对象未被删除</strong>以及<strong>删除未使用对象</strong>的过程</p><p>正在使用的对象是指,程序的某些部分仍然维护指向该对象的指针<br>未使用的对象是指,程序的任何部分都不再引用的对象,因此需要回收未引用对象的内存</p><p>自动垃圾收集机制也是java非常重要的一大特性</p><h3 id="如何确定内存需要被回收"><a href="#如何确定内存需要被回收" class="headerlink" title="如何确定内存需要被回收"></a>如何确定内存需要被回收</h3><p>第一步,称为<strong>标记</strong>.这是垃圾收集器识别哪些内存正在使用而哪些不在使用的</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>就是将对象及其引用关系看做一个图,选定<strong>活动的对象</strong>作为GC Roots;<br>然后跟踪引用链,如果一个对象和GC Roots之间没有连通性,也就是不存在引用,那么可以认为是可回收对象.</p><h5 id="可以用作GC-Root的对象"><a href="#可以用作GC-Root的对象" class="headerlink" title="可以用作GC Root的对象"></a>可以用作GC Root的对象</h5><ol><li>虚拟机栈中正在引用的对象</li><li>本地方法栈中正在引用的对象</li><li>静态属性引用的对象</li><li>方法区常量引用的对象</li></ol><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ol><li>强引用:最常见的普通对象引用,只要还有强引用指向一个对象,就不会回收(new出来的对象)</li><li>软引用:JVM认为内存不足,才会去试图回收软引用指向的对象.(缓存场景)</li><li>弱引用:虽然是引用,但随时可能被回收掉</li><li>虚引用:不能通过它访问对象. 通常是在GC时做一些操作</li></ol><h5 id="可达性级别"><a href="#可达性级别" class="headerlink" title="可达性级别"></a>可达性级别</h5><ol><li>强可达:一个对象可以有一个或多个线程可以通过各种引用访问</li><li>软可达:只能通过软引用才能访问</li><li>弱引用:只能通过弱引用访问</li><li>幻象可达:不存在其他引用,并且finalize过了,只有虚引用指向它</li><li>不可达:意味着可以被GC了</li></ol><h3 id="怎么清楚垃圾"><a href="#怎么清楚垃圾" class="headerlink" title="怎么清楚垃圾"></a>怎么清楚垃圾</h3><p>第二步, 定义如何清除垃圾</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除-mark-sweep-算法"><a href="#标记-清除-mark-sweep-算法" class="headerlink" title="标记-清除(mark-sweep)算法"></a>标记-清除(mark-sweep)算法</h5><p>首先标识出所有要回收的对象,然后清除,标记-清除算法效率优先,有内存碎片化问题,不适合特别大的堆;分代收集算法基本基于标记-清除算法的思路改进.</p><h5 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h5><p>划分两块同等大小的区域,收集时将活着的对象复制到另一块区域. 拷贝过程中将对象顺序放置,就可以避免内存碎片化. 复制+预留内存, 有一定的资源浪费.</p><h5 id="标记-整理-mark-compact"><a href="#标记-整理-mark-compact" class="headerlink" title="标记-整理(mark-compact)"></a>标记-整理(mark-compact)</h5><p>类似于标记-清除,但是为了避免内存碎片化,会在清理过程中将对象移动,已确保对象占用连续的内存空间.</p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前商业虚拟机常用的算法,根据对象存活周期的不同,将内存划分为几块,一般是把堆划分为新生代和老年代,这样就可以根据各个年代的特点采用最适合的收集算发.<br>在新生代中,每次垃圾收集都有大量对象死去,少量存活,就用复制算法,只需要付出少量存活对象的复制成本就可以完成收集,<br>而老年代中因为对象存活率高,没有额外的空间对它进行分配担保,必须使用标记-清除或者标记-整理算法来回收,不需要大量的移动对象.</p><p>新对象会被分配到新生代(Eden),如果超过<code>-XX:+PretenureSizeThreshold</code>:设置的大对象直接进入老年代的阈值, 直接存放到老年代</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h4><h5 id="Serial-GC-XX-UseSerialGC"><a href="#Serial-GC-XX-UseSerialGC" class="headerlink" title="-Serial GC -XX:UseSerialGC"></a>-Serial GC -XX:UseSerialGC</h5><p>单个线程来执行所有垃圾收集工作,适合单处理器机器,Glient模式下JVM的默认选项</p><h5 id="Serial-Old-XX-UseSeriaOldlGC"><a href="#Serial-Old-XX-UseSeriaOldlGC" class="headerlink" title="-Serial Old -XX:UseSeriaOldlGC"></a>-Serial Old -XX:UseSeriaOldlGC</h5><p>Serial的老年代版本,可以在老年代使用, 它采用了标记-整理(Mark-Compact)算法,区别于新生代的复制算法</p><h4 id="并行收集器Parallel"><a href="#并行收集器Parallel" class="headerlink" title="并行收集器Parallel"></a>并行收集器Parallel</h4><h5 id="Parallel-GC-XX-UseParallelGC"><a href="#Parallel-GC-XX-UseParallelGC" class="headerlink" title="-Parallel GC -XX:+UseParallelGC"></a>-Parallel GC -XX:+UseParallelGC</h5><h5 id="Parallel-Old-GC-XX-UseParallelGC"><a href="#Parallel-Old-GC-XX-UseParallelGC" class="headerlink" title="-Parallel Old GC -XX:+UseParallelGC"></a>-Parallel Old GC -XX:+UseParallelGC</h5><p>server模式JVM的默认GC选择,整体算法和Serial类似,区别是新生代和老年代GC都是并行进行;<br>可以设置GC时间或吞吐量等,可以自动进行适应性调整Eden,Survivor大小和MaxTenuringThreshold的值.</p><p>也称为吞吐量优先的GC: 吞吐量=用户代码运行时间/(用户代码运行时间+GC时间)</p><p>-XX:ParallelGCThreads: 设置用于垃圾回收的线程数. 通常和CPU数相等<br>-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间. 值是大于0的整数.<br>-XX:GCTimeRatio: 设置吞吐量大小,它的值是一个0-100之间的整数.<br>-XX:+UseAdaptiveSizePolicy: 打开自适应GC策略. 以达到在堆大小,吞吐量和停顿时间之间的平衡点</p><h5 id="ParNew-GC-XX-UseParNewGC"><a href="#ParNew-GC-XX-UseParNewGC" class="headerlink" title="-ParNew GC -XX:+UseParNewGC"></a>-ParNew GC -XX:+UseParNewGC</h5><p>新生代GC的实现, 它实际是Serial GC的多线程版本. 可以控制线程数量, 参数: -XX:ParallelGCThreads<br>最常见的场景是配合老年代的CMS GC工作. 参数: -XX:+UseConcMarkSweepGC</p><h4 id="并发收集器CMS-Concurrent-Mark-Sweep"><a href="#并发收集器CMS-Concurrent-Mark-Sweep" class="headerlink" title="并发收集器CMS(Concurrent Mark Sweep)"></a>并发收集器CMS(Concurrent Mark Sweep)</h4><h5 id="CMS-GC-XX-UseConcMarkSweepGC"><a href="#CMS-GC-XX-UseConcMarkSweepGC" class="headerlink" title="-CMS GC -XX:+UseConcMarkSweepGC"></a>-CMS GC -XX:+UseConcMarkSweepGC</h5><p>专用老年代,基于标记-清除算法,设计目标是尽量减少停顿时间.<br>但会占用更多的CPU资源,并和用户线程争抢</p><h5 id="G1-XX-UseG1GC"><a href="#G1-XX-UseG1GC" class="headerlink" title="-G1 -XX:+UseG1GC"></a>-G1 -XX:+UseG1GC</h5><p>针对大堆内存设计的收集器,兼顾吞吐量和停顿时间, JDK9后为默认选项, 目标是替代GMC;<br>G1将堆分为多个固定大小, 堆之间是复制算法, 但整体上可以理解为标记-整理算法,可以有效避免内存碎片化.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM垃圾回收机制&quot;&gt;&lt;a href=&quot;#JVM垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾回收机制&quot;&gt;&lt;/a&gt;JVM垃圾回收机制&lt;/h2&gt;&lt;h3 id=&quot;自动垃圾收集&quot;&gt;&lt;a href=&quot;#自动垃圾收集&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="https://zhuyiting.xyz/2019/06/03/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://zhuyiting.xyz/2019/06/03/Java系统调优/类加载机制/</id>
    <published>2019-06-03T02:53:51.000Z</published>
    <updated>2019-12-19T08:19:01.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h2><p><strong>1. 加载</strong>:读取二进制内容<br><strong>2. 验证</strong>:验证class文件格式规范、语义分析、引用验证、字节码验证<br><strong>3. 准备</strong>:分配内存、设置类static修饰的变量初始值<br><strong>4. 解析</strong>:类、接口、字段、类方法等解析<br><strong>5. 初始化</strong>:为静态变量赋值；执行静态代码块<br><strong>6. 使用</strong>:创建实例对象<br><strong>7. 卸载</strong>:从JVM方法区中卸载</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器负责装入类,搜索各个位置的类资源.<br>一个Java程序运行,至少有三个类加载器实例,负责不同类的加载</p><ol><li><strong>Bootstrap Loader 核心类库加载器</strong>,由C语言实现,加载JDK核心类库</li><li><strong>Extension Class Loader 拓展类库加载器</strong>,加载JDK拓展包</li><li><strong>application class loader 用户应用程序加载器</strong>,加载classpath路径下的包</li></ol><h3 id="类不会重复加载"><a href="#类不会重复加载" class="headerlink" title="类不会重复加载"></a>类不会重复加载</h3><p>类的唯一性:同一个类加载器,类名一样,代表同一个类.</p><h4 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h4><p>某一个类加载器想要去加载一个类,并不会立刻去加载,而是委托给父亲,如果父亲上面还有父亲,则继续向上委托,最终到达核心类库加载器,如果核心类库无法记载,再向下一个个委托.<br><strong>即,有父类交给父类加载,没父类了开始加载,无法加载向下委托,全都不能加载则失败</strong></p><p>通过双亲委派机制</p><ol><li>建立类的层级关系可以避免类的重复加载,当父亲已经加载该类时,就没必要再加载一次了.</li><li>优先加载核心类库, 这样防止用户恶意的同名类,因为永远是核心的类先被加载.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类生命周期&quot;&gt;&lt;a href=&quot;#类生命周期&quot; class=&quot;headerlink&quot; title=&quot;类生命周期&quot;&gt;&lt;/a&gt;类生命周期&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 加载&lt;/strong&gt;:读取二进制内容&lt;br&gt;&lt;strong&gt;2. 验证&lt;/strong&gt;:验
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty网络编程框架</title>
    <link href="https://zhuyiting.xyz/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/"/>
    <id>https://zhuyiting.xyz/2019/05/07/网络编程/Netty网络编程框架/</id>
    <published>2019-05-07T12:59:55.000Z</published>
    <updated>2019-11-25T05:34:33.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty网络编程框架"><a href="#Netty网络编程框架" class="headerlink" title="Netty网络编程框架"></a>Netty网络编程框架</h2><p>Netty是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，它极大的简化了TCP和UDP客户端和服务器开发等网络编程</p><p>Netty支持BIO、NIO，支持各种协议</p><h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>Reactor模型也叫Dispatcher模式,服务器接收多路请求,并同步反派给请求对应的线程</p><h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty线程模型基于主从Reactor线程模型,有多个Reactor</p><h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul><li><strong>Bootstrap引导</strong>: 一个Netty应用通常由一个Bootstrap开始,主要作用是配置整个Netty程序,串联各个组件,Netty中Bootstrap类是客户端程序的启动引导类,ServerBootstrap是服务端启动引导类</li><li><strong>Future ChannelFuture</strong>: 可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</li><li><strong>Channel</strong>: 网络通信通道,发送接收数据</li><li><strong>Selector</strong>: 实现I/O多路复用,一个Selector线程可以监听多个线程的Channel事件</li><li><strong>NioEventLoop</strong>: 类似线程池,维护了一个线程和任务队列,支持异步提交执行,线程启动时,会调用run()方法,执行IO任务和非IO任务</li><li><strong>NioEventLoopGroup</strong>: 用于管理eventLoop的生命周期,可以理解为大线程池,内部维护了一组小线程池</li><li><strong>ChannelHandler</strong>: 处理IO事件或者拦截IO操作,并转发到ChannelPipeline(业务处理链)中<br>Handler可以被共享,但是要注意防止共享变量,比如解码器是不能被共享的<br>耗时的业务不要放在Handler,要单独交给指定的线程池中</li><li><strong>ChannelHandlerContext</strong>: 保存Channel相关的上下文信息,每一个ChannelHandlerContext关联一个ChannelHandler</li><li><strong>ChannelPipline</strong>: 责任链,业务处理链,保存了ChannelHandler的List,用于处理或拦截Channel的入站事件或者出站操作.</li></ul><p><img src="/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/netty%E6%B5%81%E7%A8%8B.jpg" alt="netty流程"></p><p><a href="https://luan.ma/post/netty-flow/" target="_blank" rel="noopener">netty服务端处理用户请求流程图解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netty网络编程框架&quot;&gt;&lt;a href=&quot;#Netty网络编程框架&quot; class=&quot;headerlink&quot; title=&quot;Netty网络编程框架&quot;&gt;&lt;/a&gt;Netty网络编程框架&lt;/h2&gt;&lt;p&gt;Netty是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Netty" scheme="https://zhuyiting.xyz/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>NIO网络编程</title>
    <link href="https://zhuyiting.xyz/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2019/04/30/网络编程/NIO网络编程/</id>
    <published>2019-04-30T14:19:55.000Z</published>
    <updated>2019-11-23T06:37:07.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO网络编程"><a href="#NIO网络编程" class="headerlink" title="NIO网络编程"></a>NIO网络编程</h2><p>非阻塞IO</p><p>NIO是Java提供的替代BIO的相关API</p><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p>Buffr 缓冲区<br>Channel 通道<br>Selector 选择器</p><h4 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h4><p>Java提供Buffer API, 可以让我们更轻松的使用内存块</p><p>使用Buffer对象,对数据进行写入和读取</p><ol><li>将数据写入缓冲区</li><li>调用buffer.flip(),转换为读取模式</li><li>缓冲区读取数据</li><li>调用buffer.clear()或buffer.compact() 清楚缓冲区</li></ol><p>Buffer的三个属性<br>capacity容量: 缓冲区内存块大小<br>position位置: 写入或读取时的位置<br>limit限制: 限制每次读取或者写入的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建一个byte字节缓冲区，容量是4</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认写入模式，查看三个重要的指标</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"初始化：capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line">        <span class="comment">// 写入2字节的数据</span></span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 再看数据</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对)</span></span><br><span class="line">        System.out.println(<span class="string">"#######开始读取"</span>);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="keyword">byte</span> a = byteBuffer.get();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">byte</span> b = byteBuffer.get();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(String.format(<span class="string">"读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据</span></span><br><span class="line">        <span class="comment">// clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式</span></span><br><span class="line">        byteBuffer.compact(); <span class="comment">// buffer : 1 , 3</span></span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">4</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">5</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"最终的情况，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rewind() 重置position为0</span></span><br><span class="line">        <span class="comment">// mark() 标记position的位置</span></span><br><span class="line">        <span class="comment">// reset() 重置position为上次mark()标记的位置</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer可以直接获取直接内存<br>ByteBuffer directByteBuffer=ByteBuffer.allocateDirect(n);<br>内部有一个回收对象, 可以进行垃圾回收, 否则JVM的垃圾回收无法管理堆外内存</p><p>否则使用JVM堆内存,写入时用堆内存会复制一份数据到堆外内存</p><h4 id="Channel通道"><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h4><p>通道从ByteBuffer中读取数据或者写入数据</p><h5 id="Channel四种实现类型"><a href="#Channel四种实现类型" class="headerlink" title="Channel四种实现类型"></a>Channel四种实现类型</h5><p><strong>1. FileChannel</strong>: 用于文件的数据读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FileChannel通道</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>，<span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure><p><strong>2. DatagramChannel</strong>: 用于UDP的数据读写。<br><strong>3. SocketChannel</strong>: 用于TCP的数据读写。<br><strong>4. ServerSocketChannel</strong>: 监听TCP链接请求，每个请求会创建会一个SocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h4><p>可以检查一个或多个NIO通道,实现单个线程管理多个通道,从而管理多个网络连接</p><p>比如:当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务,不会阻塞</p><p>一个通道继承了SelectableChannel,那么他就可以被Selector复用</p><p><strong>一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</strong><br>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上，在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。</p><p>使用Channel.register（Selector sel，int ops）方法, 将通道注册到选择器上,这里的操作指的是当前通道已经准备就绪,能够进行的操作类型<br>int ops包括</p><ol><li>可读 : SelectionKey.OP_READ</li><li>可写 : SelectionKey.OP_WRITE</li><li>连接 : SelectionKey.OP_CONNECT</li><li>接收 : SelectionKey.OP_ACCEPT</li></ol><p><code>selector.select();</code> 查找准备就绪的通道</p><h5 id="Selector使用流程"><a href="#Selector使用流程" class="headerlink" title="Selector使用流程"></a>Selector使用流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建通道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//设置非租塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定连接</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(SystemConfig.SOCKET_SERVER_PORT));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将通道注册到选择器,并指定为可接收</span></span><br><span class="line">serverSocketChannel.register(selector，SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用轮询的方式，查询获取“准备就绪”的注册过的操作</span></span><br><span class="line"><span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前选择器中所有注册的选择键（“已经准备就绪的操作”）</span></span><br><span class="line">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (selectedKeys.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取“准备就绪”的事件</span></span><br><span class="line">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class="line">        <span class="comment">// 判断key是具体的什么事件</span></span><br><span class="line">        <span class="keyword">if</span> (selectedKey.isAcceptable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若接受的事件是“接收就绪” 操作,就获取客户端连接</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">// 切换为非阻塞模式</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将该通道注册到selector选择器上,并指定为可读</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (selectedKey.isReadable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取该选择器上的“读就绪”状态的通道</span></span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = socketChannel.read(byteBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, length));</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除选择键</span></span><br><span class="line">        selectedKeys.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">serverSocketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:要注册到选择器, 通道必须是非租塞的</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>基于Java NIO, 在此基础, 抽象出来两个组件–Reactor和Handler</p><ol><li>Reactor: 负责响应IO事件,当检测到新的时间, 发送给相应的Handler</li><li>Handler: 执行处理</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO网络编程&quot;&gt;&lt;a href=&quot;#NIO网络编程&quot; class=&quot;headerlink&quot; title=&quot;NIO网络编程&quot;&gt;&lt;/a&gt;NIO网络编程&lt;/h2&gt;&lt;p&gt;非阻塞IO&lt;/p&gt;
&lt;p&gt;NIO是Java提供的替代BIO的相关API&lt;/p&gt;
&lt;h3 id=&quot;NI
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BIO网络编程</title>
    <link href="https://zhuyiting.xyz/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/BIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2019/04/30/网络编程/BIO网络编程/</id>
    <published>2019-04-30T11:29:55.000Z</published>
    <updated>2019-11-22T05:58:00.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BIO网络编程"><a href="#BIO网络编程" class="headerlink" title="BIO网络编程"></a>BIO网络编程</h2><p>同步阻塞网络编程</p><h3 id="阻塞IO的含义"><a href="#阻塞IO的含义" class="headerlink" title="阻塞IO的含义"></a>阻塞IO的含义</h3><p>阻塞IO: 资源不可用时,IO请求一直阻塞,直到有数据或者阻塞超时<br>非阻塞IO: 资源不可用时,IO请求离开返回,返回数据标识资源不可用<br>阻塞非阻塞描述请求,即如何获取数据</p><p>同步IO: 应用阻塞在发送或者接受数据的状态,直到数据成功传输或者返回失败<br>异步IO: 应用发送或接受数据后立刻返回,实际处理是异步执行<br>同步异步描述响应,即如何拿数据</p><p>Java中的<br>ServerSocket类的accept方法和InputStream类的read方法,都是阻塞API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="comment">// 初始化服务端Socket</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">System.out.println(<span class="string">"服务器启动成功"</span>);</span><br><span class="line"><span class="keyword">while</span> (!serverSocket.isClosed()) &#123;</span><br><span class="line">    Socket request = serverSocket.accept();<span class="comment">// 阻塞</span></span><br><span class="line">    System.out.println(<span class="string">"收到新连接 : "</span> + request.toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据、打印</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"utf-8"</span>));</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 没有数据，阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (msg.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"收到数据,来自："</span>+ request.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">serverSocket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">String msg = scanner.nextLine();</span><br><span class="line">out.write(msg.getBytes(charset)); <span class="comment">// 阻塞，写完成</span></span><br><span class="line">scanner.close();</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BIO网络编程&quot;&gt;&lt;a href=&quot;#BIO网络编程&quot; class=&quot;headerlink&quot; title=&quot;BIO网络编程&quot;&gt;&lt;/a&gt;BIO网络编程&lt;/h2&gt;&lt;p&gt;同步阻塞网络编程&lt;/p&gt;
&lt;h3 id=&quot;阻塞IO的含义&quot;&gt;&lt;a href=&quot;#阻塞IO的含义&quot; c
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://zhuyiting.xyz/2019/04/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhuyiting.xyz/2019/04/27/网络编程/网络协议/</id>
    <published>2019-04-27T05:25:11.000Z</published>
    <updated>2019-11-23T09:26:07.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI网络七层模型"><a href="#OSI网络七层模型" class="headerlink" title="OSI网络七层模型"></a>OSI网络七层模型</h3><p><strong>物理层</strong>: 使原始的数据比特流能在物理介质上传输<br><strong>数据链路层</strong>: 封装成帧、透明传输、差错检测。<br><strong>网络层</strong>: 路由选择、流量控制（IP协议）</p><p><strong>传输层</strong>： 提供可靠的端口到端口的数据传输服务（TCP/UDP协议）</p><p><strong>会话层</strong>: 建立、管理、终止进程之间的会话和数据交换<br><strong>表示层</strong>: 数据格式转换，加密解密，压缩解压等<br><strong>应用层</strong>: 为用户的应用进程提供网络服务</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP提供面向连接、可靠、有序、字节流传输服务。<br>应用程序在使用TCP之前，必须先建立TCP连接。</p><h5 id="TCO三次握手"><a href="#TCO三次握手" class="headerlink" title="TCO三次握手"></a>TCO三次握手</h5><p>在正式发送数据之前，做的检验机制<br>通过以后就成功建立了TCP连接，然后开始传输数据</p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><p>在断开连接之前，做的确认机制</p><p>TCP三次握手和四次挥手，都是为了让连接的可靠性更高</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP提供无连接、不可靠、数据报尽力传输服务。</p><p>比如语言视频聊天， 日志上报等， 会用到</p><h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><p>一个http请求包含四个部分</p><ol><li>请求行: 请求类型,资源路径,以及http版本</li><li>请求头部: 用来说明服务器要使用的附加信息</li><li>空行: 请求头和数据主体之间必须有换行,作为分隔标记</li><li>主体: 即请求数据</li></ol><p>一个http响应数据包含</p><ol><li>状态行: HTTP版本、状态码、状态消息</li><li>响应报头部: 用来说明服务器要使用的附加信息</li><li>空行: 头部和数据之间的换行</li><li>响应正文: 即响应数据</li></ol><h4 id="HTTP协议响应状态码"><a href="#HTTP协议响应状态码" class="headerlink" title="HTTP协议响应状态码"></a>HTTP协议响应状态码</h4><ul><li>1XX: 临时响应<br>握手成功,TCP建立</li><li>2XX: 成功<br>表示已成功处理了请求</li><li>3XX: 重定向<br>表示要完成请求,需要进一步操作</li><li>4XX: 请求错误<br>请求可能出错</li><li>5XX: 服务器错误<br>服务器内部出错</li></ul><h4 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h4><p>WebSocket是基于TCP的一种新的网络协议<br>它实现了服务器和客户端全双工通信</p><p>支持多客服端,多语言,多服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OSI网络七层模型&quot;&gt;&lt;a href=&quot;#OSI网络七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI网络七层模型&quot;&gt;&lt;/a&gt;OSI网络七层模型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;: 使原始的数据比特流能在物理介质上传输&lt;b
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络协议" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
