<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuyiting.xyz/"/>
  <updated>2019-10-21T05:17:23.090Z</updated>
  <id>https://zhuyiting.xyz/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019双十一攻略</title>
    <link href="https://zhuyiting.xyz/2019/10/21/2019%E5%8F%8C%E5%8D%81%E4%B8%80%E6%94%BB%E7%95%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/21/2019双十一攻略/</id>
    <published>2019-10-21T01:49:00.000Z</published>
    <updated>2019-10-21T05:17:23.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h3><ol><li>每日任务领喵币</li><li>团队PK拉人助力</li></ol><h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><ol><li>每日任务领喵币</li><li>双十一7点领彩蛋</li><li>双十一7点钻石铂金会员领金手指</li></ol><h3 id="优酷"><a href="#优酷" class="headerlink" title="优酷"></a>优酷</h3><ol><li>每日进入APP获红包</li><li>每日视频观看3分钟获红包</li></ol><h3 id="UC"><a href="#UC" class="headerlink" title="UC"></a>UC</h3><ol><li>每日签到领红包</li><li>每日开启红包雨</li><li>做任务瓜分现金</li><li>每日可抽10次幸运好礼</li></ol><h3 id="高德"><a href="#高德" class="headerlink" title="高德"></a>高德</h3><ol><li>完成每日体验获红包</li></ol><h3 id="饿了吗"><a href="#饿了吗" class="headerlink" title="饿了吗"></a>饿了吗</h3><ol><li>每日心愿城打卡得红包</li><li>下单外卖获红包</li><li>每日三次掷骰子有机会获红包</li></ol><h3 id="口碑"><a href="#口碑" class="headerlink" title="口碑"></a>口碑</h3><ol><li>每日登陆领红包</li><li>掷骰子获得更多奖励</li><li>每天玩游戏5次可获得一个红包</li></ol><h3 id="飞猪"><a href="#飞猪" class="headerlink" title="飞猪"></a>飞猪</h3><ol><li>每日签到获红包</li><li>完成每日任务,打卡成功获红包</li></ol><h3 id="淘宝特价版"><a href="#淘宝特价版" class="headerlink" title="淘宝特价版"></a>淘宝特价版</h3><ol><li>登陆签到得红包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;淘宝&quot;&gt;&lt;a href=&quot;#淘宝&quot; class=&quot;headerlink&quot; title=&quot;淘宝&quot;&gt;&lt;/a&gt;淘宝&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;每日任务领喵币&lt;/li&gt;
&lt;li&gt;团队PK拉人助力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;支付宝&quot;&gt;&lt;a href=&quot;#支付宝&quot;
      
    
    </summary>
    
    
      <category term="生活方式" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>延期年金现值的计算</title>
    <link href="https://zhuyiting.xyz/2019/10/18/%E5%BB%B6%E6%9C%9F%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://zhuyiting.xyz/2019/10/18/延期年金现值的计算/</id>
    <published>2019-10-18T01:56:00.000Z</published>
    <updated>2019-10-21T03:58:39.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延期年金"><a href="#延期年金" class="headerlink" title="延期年金"></a>延期年金</h2><p>==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.<br>==延期年金现值计算==假定最初又m期没有收付款项,后面n期每年有等额的系列收付款项,则此延期年金的现值即为后n期年金先折现至n期期初(m期期末),再折现至第一期期初的现值.</p><p>==年金==是指定期定额的收付款项</p><p>==现值==成本或收益的价值以今天的现金来计量时,称为现值</p><p>==终值==是指现在某一时点上的一定量现金折合到未来的价值</p><ol><li>延期年金的==终值==大小和延期数m无关<br>所以延期m期之后的n期年金终值为<br>$ F=A\frac{(1+i)^n-1}{i} $</li><li>普通年金的==现值==计算<br>$ P=A\frac{1-\frac{1}{(1+i)^n}}{i}$</li><li>==延期年金==的现值计算<br>延期年金的现值与延期数m相关,m越长,现值越低.<ul><li>方法一:先当成n期普通年金,求出现值P1,在将P作为第m期终值,再折现到第一期的现值P2<br>$P1=A\frac{1-\frac{1}{(1+i)^n}}{i}$<br>$P2=P1\frac{1-\frac{1}{(1+i)^m}}{i} $</li><li>方法二:先计算m+n期现值,再减去m期年金现值<br>$P=A(\frac{1-\frac{1}{(1+i)^m(1+i)^n}}{i}-\frac{1-\frac{1}{(1+i)^m}}{i}) $</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;延期年金&quot;&gt;&lt;a href=&quot;#延期年金&quot; class=&quot;headerlink&quot; title=&quot;延期年金&quot;&gt;&lt;/a&gt;延期年金&lt;/h2&gt;&lt;p&gt;==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.&lt;br&gt;==延期年
      
    
    </summary>
    
    
      <category term="生活方式" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://zhuyiting.xyz/2019/07/30/JVM指令手册/</id>
    <published>2019-07-30T07:18:00.000Z</published>
    <updated>2019-10-20T00:56:02.507Z</updated>
    
    <content type="html"><![CDATA[<p>栈和局部变量操作<br>将常量压入栈的指令<br>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值<br>将栈中的值存入局部变量的指令<br>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中<br>wide指令<br>wide 使用附加字节扩展局部变量索引<br>通用(无类型）栈操作<br>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容<br>类型转换<br>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型<br>整数运算<br>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上<br>逻辑运算<br>移位操作<br>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作<br>按位布尔运算<br>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作<br>浮点运算<br>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反<br>对象和数组<br>对象操作指令<br>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型<br>数组操作指令<br>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组<br>控制流<br>条件分支指令<br>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转<br>比较指令<br>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）<br>无条件转移指令<br>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）<br>表跳转指令<br>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<br>异常<br>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回<br>方法调用指令<br>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法<br>方法返回指令<br>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void<br>线程同步<br>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><hr><p>JVM指令助记符<br>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈和局部变量操作&lt;br&gt;将常量压入栈的指令&lt;br&gt;aconst_null 将null对象引用压入栈&lt;br&gt;iconst_m1 将int类型常量-1压入栈&lt;br&gt;iconst_0 将int类型常量0压入栈&lt;br&gt;iconst_1 将int类型常量1压入栈&lt;br&gt;iconst_
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>EL与JSTL表达式</title>
    <link href="https://zhuyiting.xyz/2018/01/30/EL%E4%B8%8EJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2018/01/30/EL与JSTL表达式/</id>
    <published>2018-01-30T06:15:00.000Z</published>
    <updated>2019-10-20T14:59:58.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式:"></a>EL表达式:</h4><p>EL表达式的功能:(让JSP编写更为简单)</p><ol><li>EL是Expression Language的简称，即表达式语言；</li><li>EL在JSP中使用，服务器会对其进行解析翻译，生成相应的Java代码；</li><li>EL的作用是用来在JSP页面输出动态内容，可以替代JSP中的表达式元素&lt;%=%&gt;</li></ol><p><strong>EL表达式的一般格式:</strong><br> <code>${EL表达式}</code><br>    例如:<code>${param.username}</code><br>    等同于:<code>&lt;%=request.getParameter(&quot;username&quot;)%&gt;</code></p><h4 id="EL表达式的内置对象"><a href="#EL表达式的内置对象" class="headerlink" title="EL表达式的内置对象:"></a>EL表达式的内置对象:</h4><p>其中</p><ul><li>2个内置对象为了方便输出请求参数： param/paramValues；<ul><li>内置对象param：用来输出请求参数的值，格式为${param.请求参数名字}</li><li>内置对象paramValues：用来获取一对多的参数值，返回一个数组。</li></ul></li><li>4个内置对象为了方便输出各个范围的属性： pageScope/ requestScope /sessionScope /applicationScope<ul><li>获取四个范围的属性数据</li><li>检索顺序：当不指定范围时，例如，${user.pwd}，将自动从pageScope开始查找，直到applicationScope，如果没查到，则什么也不显示</li></ul></li><li>2个与请求头有关的内置对象：header/headerValues<ul><li>内置对象header：用来输出输出某一个请求头的值，格式为${header.请求头名字}</li><li>内置对象headerValues：如果某个请求头的值有多个，则使用headerValues返回一个数组。</li></ul></li><li>2个其他内置对象：cookie/initParam<ul><li>内置对象cookie：用来获取cookie的值</li><li>内置对象initParam：用来输出上下文参数;</li></ul></li><li>1个特殊的内置对象pageContext<ul><li>内置对象pageContext：EL中的pageContext对象可以调用PageContext类中所有符合规范的getXxx方法</li></ul></li></ul><h4 id="使用-EL-取出内置对象的数据。"><a href="#使用-EL-取出内置对象的数据。" class="headerlink" title="使用 EL 取出内置对象的数据。"></a>使用 EL 取出内置对象的数据。</h4><ol><li>普通对象和对象属性。<br> 服务器端：<pre><code>`request.setAttribute(&quot;student&quot;, student);`</code></pre> 在浏览器上打印出服务器端绑定的数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; student &#125;  <span class="comment">&lt;!-- 相当于执行了 student.toString(); --&gt;</span></span><br><span class="line">$&#123; student.name &#125;  <span class="comment">&lt;!-- 相当于执行了 student.getName(); --&gt;</span></span><br><span class="line">$&#123; student.teacher.name &#125;  <span class="comment">&lt;!-- 相当于执行了 student.getTeacher().getName(); --&gt;</span></span><br></pre></td></tr></table></figure></li><li>数组中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] nameArray = <span class="keyword">new</span> String[]&#123;<span class="string">"Tom"</span>, <span class="string">"Lucy"</span>, <span class="string">"Lilei"</span>&#125;;</span><br><span class="line">request.setAttribute(“nameArray”,nameArray);</span><br><span class="line">Student[] students = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">students[<span class="number">0</span>] = stu1;</span><br><span class="line">students[<span class="number">1</span>] = stu2;</span><br><span class="line">students[<span class="number">2</span>] = stu3;</span><br><span class="line">request.setAttribute(“students”,students);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的数组数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123; nameArray[0] &#125;   <span class="comment">&lt;!-- Tom --&gt;</span></span><br><span class="line">$&#123; nameArray[1] &#125;   <span class="comment">&lt;!-- Lucy --&gt;</span></span><br><span class="line">$&#123; nameArray[2] &#125;   <span class="comment">&lt;!-- Lilei --&gt;</span></span><br><span class="line">$&#123; students[0].id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; students[1].name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">$&#123; students[2].teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure></li><li>List中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList=<span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">studentList.add(stu1);</span><br><span class="line">studentList.add(stu2);</span><br><span class="line">studentList.add(stu3);</span><br><span class="line">request.setAttribute(“studentList”,studentList);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的List数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; studentList[0].id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; studentList[1].name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">$&#123; studentList[2].teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure></li><li>Map中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Student&gt; studentMap = <span class="keyword">new</span> HashMap&lt;String, Student&gt;();</span><br><span class="line">studentMap.put(<span class="string">"Tom"</span>, stu1);</span><br><span class="line">studentMap.put(<span class="string">"Lucy"</span>, stu2);</span><br><span class="line">studentMap.put(<span class="string">"Lilei"</span>, stu3);</span><br><span class="line">request.setAttribute(“studentMap”,studentMap);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的Map数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; studentMap.Tom.id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; studentMap.Lucy.name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">   $&#123; studentMap.Lilei.teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符:"></a>EL运算符:</h4>EL中提供了多种运算符，可以对变量或常量进行运算，输出运算结果；<br>EL中的运算符包括：</li><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>其他运算符</li></ol><h4 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL:"></a>JSTL:</h4><p>JSTL是一套定义好的标签库，可以直接使用；<br>JSTL的全称是Jsp  Standard Tag Library，即JSP标准标签库；<br>JSTL包含很多标签，根据其作用可以分为：属性相关的标签、条件分支相关的标签、迭代标签、其他标签；<br>标签库包括标签处理器类及描述文件tld文件，JSTL也一样：</p><ul><li>使用JSTL首先需要下载相关的jar文件并保存到工程的lib目录下；在JSP中使用taglib指令引入需要使用的标签库；</li><li>forEach、set、if等是JSTL中常用的标签；</li><li>JSTL标签库的使用是为类弥补html表的不足，规范自定义标签的使用而诞生的。在告别modle1模式开发应用程序后，人们开始注重软件的分层设计，不希望在jsp页面中出现java逻辑代码，同时也由于自定义标签的开发难度较大和不利于技术标准化产生了自定义标签库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;EL表达式&quot;&gt;&lt;a href=&quot;#EL表达式&quot; class=&quot;headerlink&quot; title=&quot;EL表达式:&quot;&gt;&lt;/a&gt;EL表达式:&lt;/h4&gt;&lt;p&gt;EL表达式的功能:(让JSP编写更为简单)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EL是Expression Languag
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式</title>
    <link href="https://zhuyiting.xyz/2018/01/19/MVC%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2018/01/19/MVC模式/</id>
    <published>2018-01-19T06:15:00.000Z</published>
    <updated>2019-10-20T14:04:47.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MVC模式基本概念"><a href="#MVC模式基本概念" class="headerlink" title="MVC模式基本概念"></a>MVC模式基本概念</h4><p>MVC（Model-View-Controller）是一种软件架构设计模式，最初应用在桌面应用程序；</p><p>MVC模式将软件的代码按照模型（M）、视图（V）、控制器（C）三部分组织</p><p>MVC模式构建应用的优势:</p><ul><li>耦合性低：视图层和业务层分离，耦合性降低，可以独立修改；</li><li>重用性高：可以用不同的视图访问模型部分，实现在不同终端上访问应用；</li><li>可维护性高：视图与业务分离，降低了维护成本；</li></ul><h4 id="MVC模式中的三个角色"><a href="#MVC模式中的三个角色" class="headerlink" title="MVC模式中的三个角色:"></a>MVC模式中的三个角色:</h4><p>在控制器和视图之间共享数据:</p><ol><li>在控制器和视图之间，常常需要共享数据；例如从数据查出来的商品列表信息，需要从控制器发送到视图；</li><li>Servlet和JSP之间共享数据一般使用请求、会话、上下文范围的属性进行；</li><li>HttpServletRequest/HttpSession/ServletContext接口中都定义了存取、查询、删除属性的方法【前面已经学习过】；</li><li>使用原则：尽量用范围小的属性，即，请求范围内共享即可就用请求，以此类推；否则会造成资源浪费，降低安全性；</li></ol><h4 id="redirect-forward-include几种跳转方式的功能与差异"><a href="#redirect-forward-include几种跳转方式的功能与差异" class="headerlink" title="redirect\forward\include几种跳转方式的功能与差异:"></a>redirect\forward\include几种跳转方式的功能与差异:</h4><p>MVC模式中，控制器和视图之间需要进行跳转，Servlet规范中，有三种跳转方式：</p><ol><li>redirect：调用响应接口的sendRedirect方法，响应重定向，相当于重新请求新的资源，当前请求对象不会到目标资源；</li><li>forward: 调用请求转发器接口的forward方法，请求转发，将当前的请求、响应对象转发到目标资源；(最常用)</li><li>include：调用请求转发器接口的include方法，动态包含，将目标资源的请求、响应对象包含到当前资源；</li></ol><h4 id="forword带来的重复提交问题"><a href="#forword带来的重复提交问题" class="headerlink" title="forword带来的重复提交问题;"></a>forword带来的重复提交问题;</h4><ul><li><p>使用forward转发请求后，再次刷新当前页面，会进行重复提交；</p><ul><li>例如：使用LoginServlet进行登录，成功后跳转到loginsuccess.jsp页面：</li></ul></li><li><p>刷新当前页面，再次进行了登录</p></li><li><p>为了能够解决重复提交问题，关键在于：能够标志一次提交，从而识别出该提交已经处理；</p><ol><li>步骤一：在JSP中记录一个随机数，称为令牌（token），存储在session中<br><code>&lt;%session.setAttribute(&quot;token&quot;,System.nanoTime())+&quot;&quot;%&gt;</code></li><li>步骤二：将token值作为表单的一个隐藏域<br><code>&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;)%&gt;&quot; &gt;</code></li><li>步骤三：在LoginServlet中获取token值，并进行判断 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出存储在请求参数中的token</span></span><br><span class="line">String requestToken = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="comment">//取出存储在session中的token</span></span><br><span class="line">String sessionToken = (String)request.getSession().getAttribute(<span class="string">"token"</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li>步骤四：将token值从会话中删除 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getSession().removeAttribute(<span class="string">"token"</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MVC模式基本概念&quot;&gt;&lt;a href=&quot;#MVC模式基本概念&quot; class=&quot;headerlink&quot; title=&quot;MVC模式基本概念&quot;&gt;&lt;/a&gt;MVC模式基本概念&lt;/h4&gt;&lt;p&gt;MVC（Model-View-Controller）是一种软件架构设计模式，最初应用
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>系统开发和运行知识</title>
    <link href="https://zhuyiting.xyz/2018/01/13/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhuyiting.xyz/2018/01/13/系统开发和运行知识/</id>
    <published>2018-01-13T14:40:00.000Z</published>
    <updated>2019-10-19T00:10:01.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件工程、软件过程改进和软件开发项目管理知识"><a href="#1-软件工程、软件过程改进和软件开发项目管理知识" class="headerlink" title="1. 软件工程、软件过程改进和软件开发项目管理知识"></a>1. 软件工程、软件过程改进和软件开发项目管理知识</h3><ul><li>软件工程知识</li><li>软件开发生命周期各阶段的目标和任务</li><li>软件开发项目管理基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具</li><li>主要的软件开发方法（生命周期法、原型法、面向对象法、CASE）</li><li>软件开发工具与环境知识</li><li>软件过程改进知识</li><li>软件质量管理知识</li><li>软件开发过程评估、软件能力成熟评估基础知识<h3 id="2-系统分析基础知识"><a href="#2-系统分析基础知识" class="headerlink" title="2. 系统分析基础知识"></a>2. 系统分析基础知识</h3></li><li>系统分析的目的和任务</li><li>结构化分析方法（数据流图（DFD）、数据字典（DD）、实体关系图（ERD）、描述加工处理的结构化语言）</li><li>统一建模语言（UML）</li><li>系统规格说明书<h3 id="3-系统设计知识"><a href="#3-系统设计知识" class="headerlink" title="3. 系统设计知识"></a>3. 系统设计知识</h3></li><li>系统设计的目的和任务</li><li>结构化设计方法和工具（系统流程图、HIPO图、控制流程图）</li><li>系统总体结构设计（总体布局、设计原则、模块结构设计、数据存储设计、系统配置方案）</li><li>系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计）</li><li>系统设计说明书<h3 id="4-系统实施知识"><a href="#4-系统实施知识" class="headerlink" title="4. 系统实施知识"></a>4. 系统实施知识</h3></li><li>系统实施的主要任务</li><li>结构化程序设计、面向对象程序设计、可视化程序设计</li><li>程序设计风格</li><li>程序设计语言的选择</li><li>系统测试的目的、类型，系统测试方法（黑盒测试、白盒测试、灰盒测试）</li><li>测试设计和管理（错误曲线、错误排除、收敛、注入故障、测试用例设计、系统测试报告）</li><li>系统转换基础知识<h3 id="5-系统运行和维护知识"><a href="#5-系统运行和维护知识" class="headerlink" title="5. 系统运行和维护知识"></a>5. 系统运行和维护知识</h3></li><li>系统运行管理基础知识</li><li>系统维护基础知识</li><li>系统评价基础知识<h3 id="6-面向对象开发方法"><a href="#6-面向对象开发方法" class="headerlink" title="6. 面向对象开发方法"></a>6. 面向对象开发方法</h3></li><li>面向对象开发概念（类、对象、属性、封装性、继承性、多态性、对象之间的引用）</li><li>面向对象开发方法的优越性以及有效领域</li><li>面向对象设计方法（体系结构、类的设计、用户接口设计）</li><li>面向对象实现方法（选择程序设计语言、类的实现、方法的实现、用户接口的实现、准备测试数据）</li><li>面向对象程序设计语言（如C++、Java、Visual、Bsasic、Visual C++）的基本机制</li><li>面向对象数据库、分布式对象的概念</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;a href=&quot;#1-软件工程、软件过程改进和软件开发项目管理知识&quot; class=&quot;headerlink&quot; title=&quot;1. 软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;/a&gt;1. 软件工程、软件过程改
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统知识</title>
    <link href="https://zhuyiting.xyz/2017/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhuyiting.xyz/2017/12/30/计算机系统知识/</id>
    <published>2017-12-30T14:36:00.000Z</published>
    <updated>2019-10-19T00:09:45.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-硬件知识"><a href="#1-硬件知识" class="headerlink" title="1. 硬件知识"></a>1. 硬件知识</h3><h4 id="1-1-计算机系统的组成、体系结构分类及特性"><a href="#1-1-计算机系统的组成、体系结构分类及特性" class="headerlink" title="1.1 计算机系统的组成、体系结构分类及特性"></a>1.1 计算机系统的组成、体系结构分类及特性</h4><ul><li>CPU和存储器的组成、性能和基本工作原理</li><li>常用I/O设备、通信设备的性能，以及基本工作原理</li><li>I/O接口的功能、类型和特性</li><li>I/O控制方式（中断系统、DMA、I/O处理机方式）</li><li>CISC/RISC，流水线操作，多处理机，并行处理<h4 id="1-2-存储系统"><a href="#1-2-存储系统" class="headerlink" title="1.2 存储系统"></a>1.2 存储系统</h4></li><li>主存-Cache存储系统的工作原理</li><li>虚拟存储器基本工作原理，多级存储体系的性能价格</li><li>RAID类型和特性<h4 id="1-3-安全性、可靠性与系统性能评测基础知识"><a href="#1-3-安全性、可靠性与系统性能评测基础知识" class="headerlink" title="1.3 安全性、可靠性与系统性能评测基础知识"></a>1.3 安全性、可靠性与系统性能评测基础知识</h4></li><li>诊断与容错</li><li>系统可靠性分析评价</li><li>计算机系统性能评测方式<h3 id="2-软件知识"><a href="#2-软件知识" class="headerlink" title="2. 软件知识"></a>2. 软件知识</h3><h4 id="2-1-操作系统知识"><a href="#2-1-操作系统知识" class="headerlink" title="2.1 操作系统知识"></a>2.1 操作系统知识</h4></li><li>操作系统的内核（中断控制）、进程、线程概念</li><li>处理机管理（状态转换、共享与互斥、分时轮转、抢占、死锁）</li><li>存储管理（主存保护、动态连接分配、分段、分页、虚存）</li><li>设备管理（I/O控制、假脱机）</li><li>文件管理（文件目录、文件组织、存取方法、存取控制、恢复处理）</li><li>作业管理（作业调度、作业控制语言（JCL）、多道程序设计）</li><li>汉字处理，多媒体处理，人机界面</li><li>网络操作系统和嵌入式操作系统基础知识</li><li>操作系统的配置<h4 id="2-2-程序设计语言和语言处理程序的知识"><a href="#2-2-程序设计语言和语言处理程序的知识" class="headerlink" title="2.2 程序设计语言和语言处理程序的知识"></a>2.2 程序设计语言和语言处理程序的知识</h4></li><li>汇编、编译、解释系统的基础知识和基本工作原理</li><li>程序设计语言的基本成分：数据、运算、控制和传输，过程（函数）调用</li><li>各类程序设计语言主要特点和适用情况<h3 id="3-计算机网络知识"><a href="#3-计算机网络知识" class="headerlink" title="3. 计算机网络知识"></a>3. 计算机网络知识</h3></li><li>网络体系结构（网络拓扑、OSI/RM、基本的网络协议）</li><li>传输介质、传输技术、传输方法、传输控制</li><li>常用网络设备和各类通信设备</li><li>Client/Server结构、Browser/Server结构</li><li>LAN拓扑，存取控制，LAN的组网，LAN间连接，LAN-WAN连接</li><li>因特网基础知识以及应用</li><li>网络软件</li><li>网络管理</li><li>网络性能分析<h3 id="4-数据库知识"><a href="#4-数据库知识" class="headerlink" title="4. 数据库知识"></a>4. 数据库知识</h3></li><li>数据库管理系统的功能和特征</li><li>数据库模型（概念模式、外模式、内模式）</li><li>数据模型，ER图，第一范式、第二范式、第三范式</li><li>数据操作（集合运算和关系运算）</li><li>数据库语言（SQL）</li><li>数据库的控制功能（并发控制、恢复、安全性、完整性）</li><li>数据仓库和分布式数据库基础知识<h3 id="5-多媒体知识"><a href="#5-多媒体知识" class="headerlink" title="5. 多媒体知识"></a>5. 多媒体知识</h3></li><li>多媒体系统基础知识，多媒体设备的性能特性，常用多媒体文件格式</li><li>简单图形的绘制，图像文件的处理方法</li><li>音频和视频信息的应用</li><li>多媒体应用开发过程<h3 id="6-系统性能知识"><a href="#6-系统性能知识" class="headerlink" title="6. 系统性能知识"></a>6. 系统性能知识</h3></li><li>性能指标（响应时间、吞吐量、周转时间）和性能设计</li><li>性能测试和性能评估</li><li>可靠性指标及计算、可靠性设计</li><li>可靠性测试和可靠性评估<h3 id="7-计算机应用基础知识"><a href="#7-计算机应用基础知识" class="headerlink" title="7. 计算机应用基础知识"></a>7. 计算机应用基础知识</h3></li><li>信息管理、数据处理、辅助设计、自动控制、科学计算、人工智能等基础知识</li><li>远程通信服务基础知识</li><li>常用应用系统</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-硬件知识&quot;&gt;&lt;a href=&quot;#1-硬件知识&quot; class=&quot;headerlink&quot; title=&quot;1. 硬件知识&quot;&gt;&lt;/a&gt;1. 硬件知识&lt;/h3&gt;&lt;h4 id=&quot;1-1-计算机系统的组成、体系结构分类及特性&quot;&gt;&lt;a href=&quot;#1-1-计算机系统的组成、
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JSP扩展</title>
    <link href="https://zhuyiting.xyz/2017/12/29/JSP%E6%89%A9%E5%B1%95/"/>
    <id>https://zhuyiting.xyz/2017/12/29/JSP扩展/</id>
    <published>2017-12-29T02:25:00.000Z</published>
    <updated>2019-10-20T14:04:30.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象:"></a>JSP内置对象:</h4><ul><li>内置对象指的是服务器已经创建好的对象，可以直接使用；</li><li>9个内置对象:<ul><li>request</li><li>response</li><li>out<ul><li>out的类型是JspWriter</li><li>out可以用来输出内容到客户端，但是程序员一般不会使用，因为直接使用&lt;%=%&gt;即可以实现输出；</li></ul></li><li>page<ul><li>page即当前类对象</li><li>page也很少使用，与this相同</li></ul></li><li>pageContext<ul><li>其他多数内置对象都是通过它获得  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">        application = pageContext.getServletContext();</span><br><span class="line">        config = pageContext.getServletConfig();</span><br><span class="line">        session = pageContext.getSession();</span><br><span class="line">        out = pageContext.getOut();</span><br><span class="line">    + pageContext对象是JSP中一个非常重要的对象，是`javax.servlet.jsp.PageContext`类型的对象，指的是页面的上下文，封装了其他的内置对象，同时代表的是四大作用域【页面、请求、会话、上下文】中的页面作用域，也可以在页面上下文范围添加属性，`PageContext`中与属性相关方法如下：</span><br><span class="line"></span><br><span class="line">        |方法声明|方法描述|</span><br><span class="line">        |:---:|:---:|</span><br><span class="line">        |<span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(java.lang.String name, java.lang.Object o)</span> |将任意类型对象设置为属性，指定一个名字；|</span></span><br><span class="line"><span class="function">        |java.lang.Object <span class="title">getAttribute</span><span class="params">(java.lang.String name)</span>|通过属性的名字，获取属性的值；|</span></span><br><span class="line"><span class="function">        |<span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(java.lang.String name)</span>|通过属性的名字，删除属性；|</span></span><br><span class="line"><span class="function">    + session</span></span><br><span class="line"><span class="function">+ session是JSP中的另一个内置对象，是`HttpSession`类型的对象，可以在JSP中调用HttpSession接口中的任何方法；默认存在</span></span><br><span class="line"><span class="function">+ application</span></span><br><span class="line"><span class="function">+ application是JSP中的另一个内置对象，是`ServletContext`类型的对 象，可以在JSP中调用`ServlletContext`接口中的任何方法；</span></span><br><span class="line"><span class="function">+ exception</span></span><br><span class="line"><span class="function">+ 内置对象exception比较特殊，默认情况下不存在；只有当JSP中使用指令指定该页面作为错误页面使用时才会翻译生成该内置对象。</span></span><br><span class="line"><span class="function">+ config</span></span><br><span class="line"><span class="function">+ 在JSP中可以直接使用config对象调用ServletConfig接口中任意方法，例如，可以在web.xml中对JSP配置初始化参数，与前面学习的Servlet初始化参数相同的含义：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#### 指令与动作:</span></span><br><span class="line"><span class="function">+ JSP可以通过指令元素而影响容器翻译生成Java类的整体结构；</span></span><br><span class="line"><span class="function">+ 指令的语法为：`&lt;%@ directive </span>&#123;attr=“value”&#125;* %&gt;`；</span><br><span class="line">+ 其中，directive为指令名，attr指该指令对应的属性名，一个指令可能有多个属性；</span><br><span class="line">JSP中常用的指令有三个：page、include、taglib，前两个常用</span><br><span class="line">+ **page指令**作用于整个JSP页面，可以将指令放在JSP页面任何一个位置;</span><br><span class="line">  + <span class="keyword">import</span>属性:用来引入JSP文件需要使用的类；</span><br><span class="line">+ 可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用<span class="keyword">import</span>；</span><br><span class="line">+ 值得注意的是，<span class="keyword">import</span>是page指令中唯一一个可以在一个JSP文件中多次出现的属性，其他属性在一个JSP文件中只能出现一次；</span><br><span class="line">  + pageEncoding属性:用来设置JSP文件的页面编码格式；</span><br><span class="line">+ page指令的session属性：用来设置JSP页面是否生成session对象。该属性默认值为<span class="keyword">true</span>，可以设置成<span class="keyword">false</span>。</span><br><span class="line">+ session属性值设置为<span class="keyword">false</span>后，该JSP翻译生成的类中将没有内置对象session，该JSP不参与会话。</span><br><span class="line">  + errorPage属性:设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面；</span><br><span class="line">+ 访问该页面将发生数学异常，而且并没有对异常进行处理，那么将跳转到错误页面error.jsp</span><br><span class="line">  + isErrorPage属性默认值是<span class="keyword">false</span>，可以设置为<span class="keyword">true</span>。在JSP的错误页面中，将isErrorPage设置为<span class="keyword">true</span>，则该页面翻译生成的Java类中，将生成exception内置对象。在error.jsp中加入代码：`&lt;%<span class="meta">@page</span> isErrorPage=<span class="string">"true"</span>%&gt;`</span><br><span class="line">+ 上述代码将error.jsp页面设置为错误页面，所以，在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象</span><br><span class="line">    + 注意：即使一个页面没有设置isErrorPage=“<span class="keyword">true</span>”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。</span><br><span class="line"></span><br><span class="line">+ **include指令**是JSP中另外一个常用指令，用来静态包含其他页面；</span><br><span class="line">  + 在翻译期间，把包含的页面也翻译到当前页面的Java文件中，也就是Java源文件即实现“二合一”；</span><br><span class="line">  + `&lt;%<span class="meta">@include</span> file=<span class="string">"copyright.jsp"</span>%&gt;`</span><br><span class="line"></span><br><span class="line">+ **include动作标签**:</span><br><span class="line">  + JSP规范中定义了一系列的标准动作。Web容器按照规范进行了实现，可以解析并执行标准动作；</span><br><span class="line">  + 标准动作使用标准的XML语法。</span><br><span class="line">    ```jsp</span><br><span class="line">    &lt;jsp:action_name attribute1=<span class="string">"value1"</span> attribute2=<span class="string">"value2"</span>&gt;</span><br><span class="line">    &lt;/jsp:action_name&gt;</span><br><span class="line">    ```</span><br><span class="line">  + 其中action_name表示标准动作的名字，attribute1和attribute2是标准动作的若干个属性；</span><br><span class="line">  + include标准动作:`&lt;jsp:include&gt;`是动态包含，即在运行期访问被包含的页面，并将响应结果同包含页面的响应结果合并，生成最终响应。类似在Servlet中调用`RequestDispatcher`的`include`方法进行包含。</span><br><span class="line"></span><br><span class="line">+ **include标准动作和include指令的差异**;</span><br><span class="line">  + include标准动作与include指令都是实现包含其他页面的功能;</span><br><span class="line">  + include标准动作的属性是page，实现动态包含，发生在请求阶段；</span><br><span class="line">  + include指令的属性是file，实现静态包含，发生在翻译阶段。</span><br><span class="line"></span><br><span class="line">+ include其他动作</span><br><span class="line">  + forward动作：在JSP页面中进行请求转发，如下代码所示：</span><br></pre></td></tr></table></figure>  &lt;jsp:forward page=“loginsuccess.jsp”&gt;<br>  </jsp:forward>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ param动作：往往作为子动作使用，为forward和include动作传递参数，如下代码所示：</span><br></pre></td></tr></table></figure>  &lt;jsp:forward page=”copyright.jsp”&gt;<br>  &lt;jsp:param name=”author” value=”etc”/&gt;<pre><code>&lt;/jsp:forward&gt;</code></pre>  &lt;jsp:include page=”copyright.jsp”&gt;     <pre><code>&lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt;</code></pre>  </jsp:include><br>  ```</li></ul></li><li>上述代码使用param为forward和include动作传递参数，参数将被作为请求参数传递。</li><li>使用标准动作时，一定注意正确结束标准动作，如<code>&lt;jsp:include&gt;</code>是标准动作的开始，一定要对应结束标记，如<code>&lt;/jsp:include&gt;</code>。</li></ul></li></ul><h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>JavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类，这些类遵循一定的编码规范：</p><ol><li>必须是public类 ；</li><li>必须有一个无参的public的构造方法； </li><li>返回属性的方法为getXxxx()格式 ；</li><li>设置属性的方法为setXxx(形式参数)格式；</li></ol><p>JSP中还提供了3个与JavaBean有关的动作；</p><ol><li>useBean动作：<code>&lt;jsp:useBean  id=“” class=“” scope=“”&gt;</code><ul><li>useBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性；</li><li>Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope内的一个属性，属性名为id；</li><li>其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。</li></ul></li><li>setProperty 动作：<code>&lt;jsp:setProperty name=“” property=“” param|value=“”/&gt;</code><ul><li>setProperty标准动作可以用来对JavaBean对象的属性赋值，替代调用setXxxx方法；</li><li>setProperty的name属性表示JavaBean对象的id值，property表示需要调用的setXxx方法中的Xxx部分，将首字母变小写。比如需要调用setCustname方法，则property即为Custname首字母变小写，即custname；</li><li>如果setXxx方法的参数是某一个请求参数的值，则使用param属性指定请求参数名字即可；</li><li>如果setXxx方法的参数是一个常量，则使用value属性指定即可。</li><li>同时，setProperty标准动作可以对一些常见数据类型直接转换，如字符串与Integer的转换就可以自动进行；</li></ul></li><li>getProperty动作：&lt;jsp:getProperty  name=”” property=””/&gt;<ul><li>getProperty标准动作用来调用JavaBean对象的getXxx方法，将其返回值在当前位置输出。</li><li>name是JavaBean对象的id值，property的值是getXxx方法中的Xxx部分，首字母变小写。假设需要调用getAddress方法显示其返回值，那么property的值就是Address的首字母变小写，即address。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JSP内置对象&quot;&gt;&lt;a href=&quot;#JSP内置对象&quot; class=&quot;headerlink&quot; title=&quot;JSP内置对象:&quot;&gt;&lt;/a&gt;JSP内置对象:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内置对象指的是服务器已经创建好的对象，可以直接使用；&lt;/li&gt;
&lt;li&gt;9个内置对象
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学基础</title>
    <link href="https://zhuyiting.xyz/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2017/12/27/计算机科学基础/</id>
    <published>2017-12-27T14:17:00.000Z</published>
    <updated>2019-10-20T00:44:59.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数制及其转换"><a href="#1-数制及其转换" class="headerlink" title="1. 数制及其转换"></a>1. 数制及其转换</h4><p>• 二进制、十进制和十六进制等常用制数制及其相互转换</p><h4 id="2-数据的表示"><a href="#2-数据的表示" class="headerlink" title="2. 数据的表示"></a>2. 数据的表示</h4><p>• 数的表示（原码、反码、补码、移码表示，整数和实数的机内表示，精度和溢出）<br>• 非数值表示（字符和汉字表示、声音表示、图像表示）<br>• 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码）</p><h4 id="3-算术运算和逻辑运算"><a href="#3-算术运算和逻辑运算" class="headerlink" title="3. 算术运算和逻辑运算"></a>3. 算术运算和逻辑运算</h4><p>• 计算机中的二进制数运算方法<br>• 逻辑代数的基本运算和逻辑表达式的化简</p><h4 id="4-数学基础知识"><a href="#4-数学基础知识" class="headerlink" title="4.  数学基础知识"></a>4.  数学基础知识</h4><p>• 命题逻辑、谓词逻辑、形式逻辑的基础知识<br>• 常用数值计算（误差、矩阵和行列式、近似求解方程、插值、数值积分）<br>• 排列组合、概率论应用、应用统计（数据的统计分析）<br>• 运算基本方法（预测与决策、线性规划、网络图、模拟）</p><h4 id="5-常用数据结构"><a href="#5-常用数据结构" class="headerlink" title="5. 常用数据结构"></a>5. 常用数据结构</h4><p>• 数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、线索树、堆）、图等的定义、存储和操作<br>• Hash（存储地址计算，冲突处理）</p><h4 id="6-常用算法"><a href="#6-常用算法" class="headerlink" title="6. 常用算法"></a>6. 常用算法</h4><p>• 排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法<br>• 算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-数制及其转换&quot;&gt;&lt;a href=&quot;#1-数制及其转换&quot; class=&quot;headerlink&quot; title=&quot;1. 数制及其转换&quot;&gt;&lt;/a&gt;1. 数制及其转换&lt;/h4&gt;&lt;p&gt;• 二进制、十进制和十六进制等常用制数制及其相互转换&lt;/p&gt;
&lt;h4 id=&quot;2-数据的
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Servlet上下文</title>
    <link href="https://zhuyiting.xyz/2017/12/25/JSP%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://zhuyiting.xyz/2017/12/25/JSP上下文/</id>
    <published>2017-12-25T10:47:00.000Z</published>
    <updated>2019-10-20T14:04:04.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文:"></a>什么是上下文:</h4><p>上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个上下文对象.</p><ul><li>当服务器启动的时候，就会为每一个应用创建一个上下文对象；</li><li>当服务器关闭的时候，上下文对象就销毁；</li></ul><h4 id="Servlet中的ServletContext接口"><a href="#Servlet中的ServletContext接口" class="headerlink" title="Servlet中的ServletContext接口:"></a>Servlet中的ServletContext接口:</h4><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">java.io.InputStream getResourceAsStream(java.lang.String path)</td><td align="center">将path所代表的资源以输入流返回，可以进一步进行读操作；可以用来读取服务器端的文件；</td></tr><tr><td align="center">RequestDispatcher getRequestDispatcher(java.lang.String path)</td><td align="center">返回RequestDispatcher 对象，路径是相对于上下文路径的；</td></tr></tbody></table><h4 id="上下文获取方法"><a href="#上下文获取方法" class="headerlink" title="上下文获取方法:"></a>上下文获取方法:</h4><p>Servlet规范中的多个接口中都定义了<code>getServletContext</code>方法获得上下文对象</p><h4 id="上下文参数"><a href="#上下文参数" class="headerlink" title="上下文参数:"></a>上下文参数:</h4><ul><li>在web.xml中可以配置上下文参数，使用<code>ServletContext</code>中的<code>getInitParameter</code>方法可以获取该参数；【之前学习过的Servlet初始化参数，只能在当前Servlet中使用】</li><li>上下文参数存储在上下文对象，所以应用下所有组件都可以使用；</li><li>获取上下文参数：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>version<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回ServletContext对象</span></span><br><span class="line">ServletContext ctxt=<span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//获取上下文参数</span></span><br><span class="line">String version=ctxt.getinitParameter(<span class="string">"version"</span>);</span><br><span class="line">System.out.println(<span class="string">"上下文参数version的值:"</span>+version);</span><br></pre></td></tr></table></figure></li></ul><h4 id="利用ServletContext在应用中共享数据"><a href="#利用ServletContext在应用中共享数据" class="headerlink" title="利用ServletContext在应用中共享数据:"></a>利用ServletContext在应用中共享数据:</h4><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">void setAttribute(java.lang.String name, java.lang.Object o)</td><td align="center">将任意类型对象设置为上下文属性，指定一个名字</td></tr><tr><td align="center">java.lang.Object getAttribute(java.lang.String name)</td><td align="center">通过属性的名字，获取属性的值；</td></tr><tr><td align="center">void removeAttribute(java.lang.String name)</td><td align="center">通过属性的名字，删除属性；</td></tr></tbody></table><h4 id="四大作用范围"><a href="#四大作用范围" class="headerlink" title="四大作用范围:"></a>四大作用范围:</h4><p>在Web应用中，有四大作用域范围</p><ul><li>页面范围<code>PageContext</code>：一个Servlet或JSP文件；</li><li>请求范围<code>ServletRequest</code>：一次请求中可以访问多个Servlet或JSP； 访问的Servlet或JSP能够包含其他资源；</li><li>会话范围<code>HttpSession</code>：一次会话中可以包含多个请求；</li><li>上下文范围<code>ServletContext</code>：上下文包含所有会话；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是上下文&quot;&gt;&lt;a href=&quot;#什么是上下文&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文:&quot;&gt;&lt;/a&gt;什么是上下文:&lt;/h4&gt;&lt;p&gt;上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>软件开发基础</title>
    <link href="https://zhuyiting.xyz/2017/12/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2017/12/25/软件开发基础/</id>
    <published>2017-12-25T07:18:00.000Z</published>
    <updated>2019-10-20T00:45:13.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算机工作的简单过程"><a href="#计算机工作的简单过程" class="headerlink" title="计算机工作的简单过程:"></a>计算机工作的简单过程:</h4><ol><li>将程序和数据通关输入设备送入存储器(可以理解为内存)</li><li>计算机从存储器中取出程序指令送到控制器(可以理解为CPU)</li><li>控制器更具指令的含义发出相应的命令(如加法,减法),将存储单元中存放的操作数据取出送往运算器进行运算,再把运算结果送回存储器指定的单元中<h4 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件:"></a>什么是软件:</h4> 软件=程序+文档</li></ol><h4 id="不同类型语言的编译与运行"><a href="#不同类型语言的编译与运行" class="headerlink" title="不同类型语言的编译与运行:"></a>不同类型语言的编译与运行:</h4><p>==编译型==语言是先把源程序的每一条语句都编译成机器语言,并保存成二进制文件,运行时计算机可以直接以机器语言来运行此程序,速度较快;<br>==解释型==语言在执行程序时才一条条的解释成机器语言给计算机来执行,所以运行速度会受到影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算机工作的简单过程&quot;&gt;&lt;a href=&quot;#计算机工作的简单过程&quot; class=&quot;headerlink&quot; title=&quot;计算机工作的简单过程:&quot;&gt;&lt;/a&gt;计算机工作的简单过程:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;将程序和数据通关输入设备送入存储器(可以理解为内存)&lt;/li
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>会话跟踪(前后端交互)</title>
    <link href="https://zhuyiting.xyz/2017/12/23/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA(%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92)/"/>
    <id>https://zhuyiting.xyz/2017/12/23/会话跟踪(前后端交互)/</id>
    <published>2017-12-23T06:01:00.000Z</published>
    <updated>2019-10-20T14:03:46.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="会话的概念和作用"><a href="#会话的概念和作用" class="headerlink" title="会话的概念和作用:"></a>会话的概念和作用:</h4><ul><li><strong>会话</strong>:    对于Web应用来说,会话就是浏览器与服务器之间的一次连续的通讯过程.</li><li>HTTP协议是无状态的，也就是说，一次请求结束后，HTTP协议就不再记录相关信息；</li><li>而实际应用中，却常常需要记住一些状态信息；</li><li>==会话跟踪==技术就是能够跟踪<strong>客户端和服务端的交互</strong>,保存和记忆相关信息,保存请求的状态信息.</li></ul><h4 id="常用的四种会话跟踪技术"><a href="#常用的四种会话跟踪技术" class="headerlink" title="常用的四种会话跟踪技术:"></a>常用的四种会话跟踪技术:</h4><ul><li><strong>URL方式</strong>：需要保存的信息直接追加到URL后，例如：<code>http://127.0.0.1:8080/chapter03/viewList?pageNo=12</code></li><li><strong>隐藏域方式</strong>：可以使用表单中的隐藏域保存相关信息， 例如：<br><code>&lt;input type=&quot;hidden&quot; name=“status&quot; value=“true&quot;&gt;</code></li><li><strong>Cookie方式</strong>：将状态信息保存到客户端，服务器能够获得相关信息进行分析，从而生成对客户端的响应；例如简化登录功能就可以使用Cookie实现；</li><li><strong>Session方式</strong>：将状态信息保存到服务器的会话对象中，通过唯一标记的ID值与客户端进行绑定使用；例如访问控制功能就可以使用Session实现；</li></ul><h4 id="Cookie的功能和特点"><a href="#Cookie的功能和特点" class="headerlink" title="Cookie的功能和特点:"></a>Cookie的功能和特点:</h4><ul><li>Cookie是一段保存在客户端的小文本；能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪到用户的状态；</li><li>Cookie包含一系列属性:如:<ul><li><strong>name</strong>：cookie的名字，每个cookie都有一个名字；<ul><li><strong>content</strong>：cookie的值，与名字一起作为键值对形式存在；</li><li><strong>domain</strong>：域，该cookie的域名，例如csdn.net，说明当前cookie来自csdn.net;</li><li><strong>path</strong>：路径，访问csdn.net下该路径时，当前cookie将被发送；</li><li><strong>created</strong>：cookie被创建的时间；</li><li><strong>Expired</strong>：cookie失效的时间；</li><li><strong>最大生命时间</strong>：失效时间和创建时间的时间差，就是cookie的最大生命时间，超过该时间，cookie将失效，不再被发送到相应的域地址；</li></ul></li></ul></li></ul><h4 id="创建cookie-设置cookie属性"><a href="#创建cookie-设置cookie属性" class="headerlink" title="创建cookie,设置cookie属性:"></a>创建cookie,设置cookie属性:</h4><p>Servlet规范中定了Cookie类，创建该类对象就可以创建Cookie，并可以调用其中方法为Cookie设置属性；</p><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">Cookie(java.lang.String name, java.lang.String value)</td><td align="center">创建Cookie对象，指定名字和对应的值；</td></tr><tr><td align="center">void setMaxAge(int expiry)</td><td align="center">设置最大生命时间（秒），如果不设置，当前浏览器关闭，cookie即失效；</td></tr><tr><td align="center">void setValue(java.lang.String newValue)</td><td align="center">设置Cookie的值；</td></tr><tr><td align="center">setDomain(java.lang.String domain)</td><td align="center">设置cookie的域名；</td></tr></tbody></table><p>cookie创建好后并不能存储到客户端,要将cookie保存到客户端,必须添加到响应对象中,响应接口中定义了Cookie的方法:<br>|方法声明|方法描述|<br>|:—:|:—:|<br>|void addCookie(Cookie cookie)|将Cookie对象保存到相应的响应对象中；|</p><p>当访问相同域名及路径时,没有超过有效时间的cookie将自动通关请求发送到网站;</p><p>Servlet在请求接口中定义了获取cookie的方法:<br>|方法声明|方法描述|<br>|:—:|:—:|<br>|Cookie[] getCookies()|获取请求中的所有Cookie对象，返回数组；|</p><h4 id="Session简介"><a href="#Session简介" class="headerlink" title="Session简介:"></a>Session简介:</h4><ul><li>Session是会话跟踪的另一种实现手段；</li><li>Session是存储在服务器上的对象，该对象由服务器创建并维护；</li><li>服务器为客户端与服务器的每一次会话过程都创建并维护一个Session对象；每个服务器对Session的创建和维护的底层实现有所区别；</li></ul><h5 id="session创建的时间"><a href="#session创建的时间" class="headerlink" title="session创建的时间:"></a>session创建的时间:</h5><p>一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用 <code>HttpServletRequest.getSession(true)</code>这样的语句时才被创建，注意如果JSP没有显示的使用 <code>&lt;% @page session=”false”%&gt;</code> 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句 <code>HttpSession session = HttpServletRequest.getSession(true);</code>这也是JSP中隐含的 session对象的来历。 </p><p>由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。</p><h5 id="session的生命周期"><a href="#session的生命周期" class="headerlink" title="session的生命周期:"></a>session的生命周期:</h5><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。 </p><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;会话的概念和作用&quot;&gt;&lt;a href=&quot;#会话的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;会话的概念和作用:&quot;&gt;&lt;/a&gt;会话的概念和作用:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会话&lt;/strong&gt;:    对于Web应用来说,会话就是
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>JSP</title>
    <link href="https://zhuyiting.xyz/2017/12/15/JSP/"/>
    <id>https://zhuyiting.xyz/2017/12/15/JSP/</id>
    <published>2017-12-15T06:37:00.000Z</published>
    <updated>2019-10-20T14:03:32.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h4><p>JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件。翻译和编译的过程遵守Servlet规范，因此说==JSP的本质也是Servlet==；</p><p>html和jsp的表头不一样，这个是JSP的头<code>&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;</code>在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。</p><p><u><strong>简单说，jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。</strong></u></p><h4 id="为什么要用JSP"><a href="#为什么要用JSP" class="headerlink" title="为什么要用JSP:"></a>为什么要用JSP:</h4><p>Servlet生成动态页面比较繁琐，使用JSP生成动态页面比较便捷，因为其中的静态内容可以使用HTML生成；</p><h4 id="JSP元素"><a href="#JSP元素" class="headerlink" title="JSP元素:"></a>JSP元素:</h4><ul><li><p>脚本元素可以用来包含任意Java代码,格式为：<code>&lt;%Java代码%&gt;</code></p><ul><li>服务器翻译脚本元素时，将把其中Java代码直接翻译到<code>jspService</code>方法中，如果语法错误，将在浏览器中提示错误；</li></ul></li><li><p>表达式元素用来向页面输出动态内容;格式为：<code>&lt;%=Java代码%&gt;</code></p><ul><li>服务器翻译表达式元素时，将把其中Java代码部分的返回值使用out.write语句输出</li></ul></li><li><p>模块元素指JSP中静态HTML或者XML内容</p></li><li><p>注释元素有三种情况：</p><ul><li>格式为<code>&lt;%--JSP注释--%&gt;</code>；JSP的注释只有在源代码中可见，翻译时已经忽略；</li><li>在JSP中，除了使用JSP注释外，还可以使用HTML注释，<code>&lt;!--HTML注释--&gt;</code>，HTML注释会被返回到客户端，但是不显示到页面中；</li><li>JSP中的Java代码部分，可以使用Java注释；Java注释会翻译到.java文件中，但是编译时忽略；</li></ul></li><li><p>声明元素:</p><ul><li>如果需要在JSP文件中定义类的成员变量或方法，可以使用声明元素，格式为<code>&lt;%! 声明语句%&gt;</code>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">private</span> String path=<span class="string">"WEB-INF"</span>; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPropertiesFile</span><span class="params">()</span></span>&#123;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li>声明元素被翻译到Java类中，而不是_jspService方法中；</li></ul></li></ul><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象:"></a>内置对象:</h4><p>内置对象指的是在JSP中<strong>可以直接使用的对象，不需要声明</strong>，直接使用固定的名字使用即可；例如<code>&lt;%=request.getRemoteAddr()%&gt;</code>中的<code>request</code>就是内置对象；</p><p>jsp中共有9种对象</p><ol><li><code>request</code>：用户端请求，此请求会包含来自GET/Post请求的参数；</li><li><code>response</code>：网页传回用户端的回应。</li><li><code>pageContext</code>：页面的属性是在这里管理</li><li><code>session</code>：与请求有关的回话期</li><li><code>application</code> ：Servlet正在执行的内容</li><li><code>out</code> ：用来传递回应的输出</li><li><code>config</code> ：servlet的构架部件</li><li><code>pagejsp</code>网页本身</li><li><code>exception</code> ：针对错误的网页。未捕捉的例外</li></ol><h4 id="Servlet和JSP的作用"><a href="#Servlet和JSP的作用" class="headerlink" title="Servlet和JSP的作用:"></a>Servlet和JSP的作用:</h4><p>实际应用中，Servlet是不会用来生成动态页面的，而是会用来接收来自JSP的请求，处理请求，然后调跳转到JSP页面把结果显示给客户端看；</p><h4 id="Servlet与JSP之间的跳转方式"><a href="#Servlet与JSP之间的跳转方式" class="headerlink" title="Servlet与JSP之间的跳转方式:"></a>Servlet与JSP之间的跳转方式:</h4><ol><li><p>跳转方式一:<strong>响应重定向</strong>,响应接口中提供了该方法    </p><ul><li><p><code>void sendRedirect(java.lang.String location)</code>:响应重定向到location，相当于客户端重新请求location所在的资源；    </p></li><li><p>第一个JSP页面发送请求<code>request</code>到<code>Servlet</code>,<code>Servlet</code>接收请求后,响应<code>response</code>重定向到目标JSP页面,但是请求并没有传递过来.(<strong>重定向相当于是产生一个新的请求</strong>)</p></li></ul></li><li><p>跳转方式二:<strong>请求转发</strong>,RequestDispatcher接口定义了请求转发的方法</p><ul><li><code>forward(ServletRequest request, ServletResponse response)</code>:将请求转发到服务器上的其他资源，包括其他的Servlet，JSP等；</li><li>要使用forward方法，需要先获得RequestDispatcher对象；请求接口(request)中提供了获得该对象的方法：<ul><li><code>RequestDispatcher getRequestDispatcher(java.lang.String path)</code>:使用path返回一个RequestDispatcher 对象</li></ul></li><li>请求转发把请求对象发送到了目标JSP页面,因此<strong>目标页面可以获得上一个页面的请求对象.</strong></li></ul></li></ol><h4 id="请求属性的使用"><a href="#请求属性的使用" class="headerlink" title="请求属性的使用:"></a>请求属性的使用:</h4><p>如果需要在Servlet，JSP之间跳转时，同时把一些自定义的、或者通过数据库查询的、或者调用其他资源获得的数据传递到下一个资源时，就可以把这些数据设置为请求的属性即可。</p><p>请求接口中定义了一系列与属性有关的方法。<br>|方法声明|方法描述|<br>|:——:|:—–:|<br>|void setAttribute(java.lang.String name, java.lang.Object o)|将任意类型对象设置为请求的属性，指定一个名字；|<br>|java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；|<br>|void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；|<br>可以将数据封装进请求对象中,在前后端传递<br>例如:后台Servlet中将数据保存进request(请求)中,跳转到前台JSP后,JSP可以用<code>&lt;%=request.getAttribute(&quot;name&quot;)%&gt;</code>来获取(直接输出)也可以<strong>保存为变量(前提是需要强转</strong>,因为获取的是Object类型)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是JSP&quot;&gt;&lt;a href=&quot;#什么是JSP&quot; class=&quot;headerlink&quot; title=&quot;什么是JSP&quot;&gt;&lt;/a&gt;什么是JSP&lt;/h4&gt;&lt;p&gt;JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://zhuyiting.xyz/2017/12/06/Servlet/"/>
    <id>https://zhuyiting.xyz/2017/12/06/Servlet/</id>
    <published>2017-12-06T09:12:00.000Z</published>
    <updated>2019-10-20T14:03:11.936Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h4><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><h4 id="Servlet的线程特性"><a href="#Servlet的线程特性" class="headerlink" title="Servlet的线程特性:"></a>Servlet的线程特性:</h4><p>Web应用服务器(Tomcat)将为每个客户端的连接启动一个线程来服务</p><p>第一次访问Servlet时，服务器将创建一个该Servlet类的对象，并调用doXXX方法生成响应；多个客户端访问同一个Servlet时，不再创建新的对象，而是共用同一个Servlet对象。可以说，Servlet是多线程单实例的。</p><h4 id="Servlet请求和响应接口"><a href="#Servlet请求和响应接口" class="headerlink" title="Servlet请求和响应接口:"></a>Servlet请求和响应接口:</h4><p>通过浏览器提交给服务端的所有数据,都称为<strong>请求数据</strong></p><p>通过服务器返回给客户端的所有数据,都称为<strong>响应数据</strong></p><p>ServletAPI中,定义了请求和响应接口,用来封装和操作请求和响应数据</p><ul><li>请求接口:<ul><li><code>javax.servlet.ServletRequest</code></li><li><code>javax.servlet.HttpServletRequest</code></li></ul></li><li>响应接口:<ul><li><code>javax.servlet.ServletResponse</code></li><li><code>javax.servlet.HttpServletResponse</code></li></ul></li></ul><p>Servlet类使用doXXX方法提供服务,这些方法继承于<code>HttpServlet</code><br>doXXX方法中都有两个参数,分别是请求和响应;<br>|方法|参数|作用|<br>|:–:|:–:|:–:|<br>|void doDelete|(HttpServletRequest request,HttpServletResponse response)|用来处理一个HTTP DELETE操作,这个操作允许客户端请求从服务器上删除URL|<br>|void doGet|(HttpServletRequest request,             HttpServletResponse response)|用来处理一个HTTP GET操作。这个操作允许客户端简单地从一个HTTP服务器“获得”资源|<br>|void doHead|(HttpServletRequest request,          HttpServletResponse response)|用来处理一个HTTP HEAD操作。默认的情况是，这个操作会按照一个无条件的GET方法来执行|<br>|void doOptions|(HttpServletRequest request,           HttpServletResponse response)|用来处理一个HTTP OPTION操作。这个操作自动地决定支持哪一种HTTP方法。例如，一个Servlet写了一个HttpServlet的子类并重载了doGet方法，doOption会返回下面的头：    Allow:GET,HEAD,TRACE,OPTIONS|<br>|void doPost|(HttpServletRequest request,             HttpServletResponse response)|用来处理一个HTTP POST操作。这个操作包含请求体的数据，Servlet应该按照他行事。|<br>|void doPut|(HttpServletRequest request,        HttpServletResponse response)|用来处理一个HTTP PUT操作。这个操作类似于通过FTP发送文件。|<br>|void doTrace|(HttpServletRequest request,            HttpServletResponse response)|用来处理一个HTTP TRACE操作。这个操作的默认执行结果是产生一个响应，这个响应包含一个反映trace请求中发送的所有头域的信息。|<br>|long getLastModified|(HttpServletRequest request)|返回这个请求实体的最后修改时间。|<br>|void service|(HttpServletRequest request,     HttpServletResponse response)|这是一个Servlet的HTTP-specific方案，它分配请求到这个类的支持这个请求的其他方法。当你开发Servlet时，在多数情况下你不必重载这个方法。|<br><strong><em>也就是说：服务器会创建请求对象和响应对象传递给doXXX方法，doXXX方法中可以直接使用请求和响应对象;</em></strong><br><strong>doXXX方法中可以使用方法参数request，response去调用请求和响应接口中的方法；</strong></p><h4 id="利用Servlet对客户端不同方式请求作出动态响应"><a href="#利用Servlet对客户端不同方式请求作出动态响应" class="headerlink" title="利用Servlet对客户端不同方式请求作出动态响应:"></a>利用Servlet对客户端不同方式请求作出动态响应:</h4><p>客户端访问服务器端Servlet的三种方式:</p><ol><li>直接从地址栏输入URL访问；是GET方式，调用doGet方法;</li><li>在网页中点击超级链接访问；是GET方式，调用doGet方法;</li><li>在网页中通过表单提交访问；取决form的method属性的值，默认是get，指定为post时，调用doPost方法;</li></ol><p>Servlet中获取请求参数的方法:</p><ol><li>可以在URL后使用name=value&amp;name=value的形式传递，例如： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">“TestPramServlet?page</span>=<span class="string">1&amp;author</span>=<span class="string">wangxh”</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 传递两个请求参数，名字分别为page和author，值分别为1和wangxh；--&gt;</span></span><br></pre></td></tr></table></figure></li><li>可以在使用表单提交，表单中的元素值将作为请求参数传递，元素的name是参数名字，value的值是参数的值</li></ol><p>当客户端请求服务器端的Servlet时，请求参数都会被发送到服务器，服务器会将请求参数封装到<strong>请求对象</strong>中；</p><h4 id="Servlet初始化参数"><a href="#Servlet初始化参数" class="headerlink" title="Servlet初始化参数:"></a>Servlet初始化参数:</h4><ol><li>如果某个Servlet需要使用一些可以配置的参数，可以在web.xml进行配置，称为初始化参数；</li><li>这些参数在服务器初始化Servlet实例时被初始化到配置信息中，可以在Servlet中获取并使用；</li><li>一个Servlet可以配置多个初始化参数，所有的初始化参数只能在当前Servlet类中使用；</li></ol><h4 id="Servlet加载启动选项"><a href="#Servlet加载启动选项" class="headerlink" title="Servlet加载启动选项:"></a>Servlet加载启动选项:</h4><ol><li>默认情况下，只有当第一次访问Servlet时，服务器才会初始化Servlet实例；</li><li>如果需要更早实例化Servlet，可以在web.xml中进行配置，使得在启动容器的时候就能初始化Servlet实例；</li></ol><h4 id="Servlet配置中通配符-的用法"><a href="#Servlet配置中通配符-的用法" class="headerlink" title="Servlet配置中通配符*的用法:"></a>Servlet配置中通配符*的用法:</h4><ul><li><em>.扩展名 ： 比如 *.do、</em>.action</li><li>以 / 开头，同时以 /* 结尾，比如  /*  、/admin/*</li></ul><h4 id="web-xml中首页及错误页面等其他配置信息"><a href="#web-xml中首页及错误页面等其他配置信息" class="headerlink" title="web.xml中首页及错误页面等其他配置信息"></a>web.xml中首页及错误页面等其他配置信息</h4><ul><li><strong>配置默认页面</strong>:当不指定具体访问路径时,默认访问默认页面<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>配置错误页面</strong>:当应用中出现响应错误或者异常时,可以跳转到错误页面;</li></ul><h4 id="Servlet中获取请求头属性的方法"><a href="#Servlet中获取请求头属性的方法" class="headerlink" title="Servlet中获取请求头属性的方法:"></a>Servlet中获取请求头属性的方法:</h4><p>客户端请求服务端的Servlet,会传递给服务器一系列的HTTP请求头属性,请求接口中定义了系列方法获取请求属性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Servlet&quot;&gt;&lt;a href=&quot;#什么是Servlet&quot; class=&quot;headerlink&quot; title=&quot;什么是Servlet&quot;&gt;&lt;/a&gt;什么是Servlet&lt;/h4&gt;&lt;p&gt;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://zhuyiting.xyz/2017/11/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2017/11/30/Java多线程/</id>
    <published>2017-11-30T00:43:00.000Z</published>
    <updated>2019-10-20T13:59:32.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><h4 id="程序-进程和多任务"><a href="#程序-进程和多任务" class="headerlink" title="程序.进程和多任务:"></a>程序.进程和多任务:</h4><ul><li><strong>程序（program）</strong> 是对数据描述与操作的代码的集合，是应用程序执行的脚本。</li><li><strong>进程（process）</strong> 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。</li><li><strong>多任务（multi task）</strong> 在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序</li><li>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</li></ul><h4 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程:"></a>如何创建多线程:</h4><ul><li>创建 java.lang.Thread 类的子类，重写该类的 run方 法</li><li>创建 java.lang.Runnable接 口的实现类，实现接口中的 run 方法(用的更多)</li></ul><h4 id="Runnable-接口与-Thread-类之间的区别"><a href="#Runnable-接口与-Thread-类之间的区别" class="headerlink" title="Runnable 接口与 Thread 类之间的区别:"></a>Runnable 接口与 Thread 类之间的区别:</h4><ul><li>Runnable 接口必须实现 run 方法，而 Thread 类中的run 方法是一个空方法，可以不重写</li><li>Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必须依靠 Thread 类 </li><li>Runnable 接口适合于资源的共享</li></ul><h4 id="多线程的四种状态"><a href="#多线程的四种状态" class="headerlink" title="多线程的四种状态:"></a>多线程的四种状态:</h4><ul><li>新建（New）</li><li>可执行（Runnable）</li><li>运行（Running)</li><li>阻塞（Blocking)</li><li>死亡（Dead)</li></ul><h4 id="状态之间的相互转化可执行-lt-—-gt-阻塞"><a href="#状态之间的相互转化可执行-lt-—-gt-阻塞" class="headerlink" title="状态之间的相互转化可执行&lt;—-&gt;阻塞"></a>状态之间的相互转化可执行&lt;—-&gt;阻塞</h4><ul><li>wait()方法:<ul><li>中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。</li></ul></li><li>notify()方法：<ul><li>唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待</li></ul></li><li>notifyall()方法：<ul><li>唤醒所有由于使用这个同步方法而处于等待的线程结束等待</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java多线程&quot;&gt;&lt;a href=&quot;#Java多线程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程&quot;&gt;&lt;/a&gt;Java多线程&lt;/h3&gt;&lt;h4 id=&quot;程序-进程和多任务&quot;&gt;&lt;a href=&quot;#程序-进程和多任务&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>SteamAPI</title>
    <link href="https://zhuyiting.xyz/2017/11/25/SteamAPI/"/>
    <id>https://zhuyiting.xyz/2017/11/25/SteamAPI/</id>
    <published>2017-11-25T03:30:00.000Z</published>
    <updated>2019-10-20T13:58:59.770Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>Stream位于包java.util.stream .* 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><h4 id="流-Stream-到底是什么呢"><a href="#流-Stream-到底是什么呢" class="headerlink" title="流(Stream)到底是什么呢?"></a>流(Stream)到底是什么呢?</h4><p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br><strong>集合讲的是数据，流讲的是计算！</strong></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>Stream 自己不会存储元素。 </li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h4 id="Stream的操作三步骤"><a href="#Stream的操作三步骤" class="headerlink" title="Stream的操作三步骤"></a>Stream的操作三步骤</h4><ol><li>创建Stream<br>一个数据源（如：集合、数组），获取一个流</li><li>中间操作<br>一个中间操作链，对数据源的数据进行处理</li><li>终止操作（终端操作）<br>一个终止操作，执行中间操作链，并产生结果</li></ol><h5 id="1-创建Stream"><a href="#1-创建Stream" class="headerlink" title="1. 创建Stream"></a>1. 创建Stream</h5><ol><li><p>可以通过<code>Collection</code>系列集合提供的<code>stream()</code>或<code>parallelStream()</code>方法<br><code>default Stream&lt; E&gt; stream()</code> : 返回一个顺序流<br><code>default Stream&lt; E&gt; parallelStream()</code> : 返回一个并行流</p></li><li><p>通过 <code>Arrays</code> 中的静态方法<code>stream()</code>获取数组流<br><code>static &lt;T&gt; Stream&lt;T&gt; stream( T[] array)</code>: 返回一个流<br>重载形式，能够处理对应基本类型的数组：<br><code>public static IntStream stream(int[] array)</code><br><code>public static LongStream stream(long[] array)</code><br><code>public static DoubleStream stream(double[] array)</code></p></li><li><p>通过Stream 类中的静态方法of()，通过显示值创建一个流。它可以接收任意数量的参数。<br><code>public static&lt; T&gt; Stream&lt; T&gt; of(T… values)</code> : 返回一个流</p></li><li><p>创建无限流<br>可以使用静态方法 <code>Stream.iterate()</code> 和<code>Stream.generate()</code>, 创建无限流。<br>迭代 <code>public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f)</code><br>生成 <code>public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s)</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Stream</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.可以通过Collection 系列集合提供的stream()或parallelStream()</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.通过 Arrays 中的静态方法stream()获取数组流</span></span><br><span class="line">    Employee[] emps=<span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">    Stream&lt;Employee&gt; stream2=Arrays.stream(emps);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.通过Stream 类中的静态方法of()</span></span><br><span class="line">    Stream&lt;String&gt; stream3=Stream.of(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.创建无限流</span></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    Stream&lt;Integer&gt; stream4=Stream.iterate(<span class="number">0</span>, (x) -&gt; x+<span class="number">2</span>);</span><br><span class="line">    stream4.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//生成</span></span><br><span class="line">    Stream.generate(() -&gt; Math.random()).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2.中间操作"></a>2.中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性处理，成为“惰性求值”。</p></li><li><p>筛选与切片<br><code>filter(Predicate p)</code>: 接收lambda,从流中排除某些元素<br><code>distinct()</code>: 筛选,通过流所生成元素的<code>hashCode()</code>和<code>equals</code>去除重复元素<br><code>limit(long maxSize)</code>: 截断流,使元素不超过给定数量<br><code>skip(long n)</code>: 跳过元素,返回一个扔掉了前n个元素的流,若流中元素不足n个,则返回一个空流,与<code>limit(n)</code>互补</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中间操作</span></span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; employees=Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">9999.99</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">58</span>,<span class="number">5555.55</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">26</span>,<span class="number">3333.33</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">36</span>,<span class="number">6666.66</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"田七"</span>,<span class="number">12</span>,<span class="number">8888.88</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">"田七"</span>,<span class="number">12</span>,<span class="number">8888.88</span>)</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 筛选与切片</span></span><br><span class="line"><span class="comment">*  filter--接收Lambda，从流中排除某些元素。</span></span><br><span class="line"><span class="comment">*  limit--截断流，使其元素不超过给定数量。</span></span><br><span class="line"><span class="comment">*  skip(n)--跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补</span></span><br><span class="line"><span class="comment">*  distinct--筛选，通过流所生成元素的 hashCode() 和 equals() 去掉重复元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部迭代：迭代操作由 Stream API 完成</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//中间操作：不会执行任何操作</span></span><br><span class="line">    Stream&lt;Employee&gt; stream=employees.stream().filter((e) -&gt; e.getAge()&gt;<span class="number">35</span> );</span><br><span class="line">    <span class="comment">//终止操作：一次性执行全部内容，即 惰性求值</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部迭代</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Iterator&lt;Employee&gt; it=employees.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;<span class="comment">//发现“短路”只输出了两次，说明只要找到 2 个 符合条件的就不再继续迭代</span></span><br><span class="line">    employees.stream().filter((e)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"短路！"</span>);</span><br><span class="line">        <span class="keyword">return</span> e.getSalary()&gt;<span class="number">5000</span>;</span><br><span class="line">    &#125;).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    employees.stream().filter((e)-&gt;e.getSalary()&gt;<span class="number">5000</span>).skip(<span class="number">2</span>)<span class="comment">//跳过前两个</span></span><br><span class="line">    .distinct()<span class="comment">//去重，注意：需要Employee重写hashCode 和 equals 方法</span></span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 映射</span></span><br><span class="line"><span class="comment">* map--接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。</span></span><br><span class="line"><span class="comment">* flatMap--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"ddd"</span>);</span><br><span class="line">    list.stream() .map((str)-&gt;str.toUpperCase())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">    employees.stream().map(Employee::getName)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>); Stream&lt;Character&gt; sm=list.stream()</span><br><span class="line">    .flatMap(TestStream::filterChatacter);</span><br><span class="line">    sm.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterChatacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character ch : str.toCharArray()) &#123;</span><br><span class="line">        list.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排序</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*排序</span></span><br><span class="line"><span class="comment">* sorted()-自然排序（按照对象类实现Comparable接口的compareTo()方法 排序）</span></span><br><span class="line"><span class="comment">* sorted(Comparator com)-定制排序（Comparator）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=Arrays.asList(<span class="string">"ccc"</span>,<span class="string">"bbb"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">    employees.stream().sorted((e1,e2)-&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">            <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-终止操作"><a href="#3-终止操作" class="headerlink" title="3. 终止操作"></a>3. 终止操作</h4><p>终止操作会从流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。</p><ol><li>查找与匹配 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 查找与匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//allMatch-检查是否匹配所有元素</span></span><br><span class="line">    <span class="keyword">boolean</span> b1=employees.stream().allMatch((e)-&gt;e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b1);<span class="comment">//false</span></span><br><span class="line">    <span class="keyword">boolean</span> b2=employees.stream().anyMatch((e)-&gt;e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b2);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//noneMatch-检查是否没有匹配所有元素 </span></span><br><span class="line">    booleanb3=employees.stream().noneMatch((e)-&gt;e.getStatus().equals(Status.BUSY));</span><br><span class="line">    System.out.println(b3);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//findFirst-返回第一个元素//Optional是Java8中避免空指针异常的容器类  </span></span><br><span class="line">    Optional&lt;Employee&gt; op=employees.stream().sorted((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).findFirst();</span><br><span class="line">    System.out.println(op.get());</span><br><span class="line">    <span class="comment">//findAny-返回当前流中的任意元素       </span></span><br><span class="line">    Optional&lt;Employee&gt; op2=employees.parallelStream().filter((e)-&gt;e.getStatus().equals(Status.FREE)).findAny();</span><br><span class="line">    System.out.println(op2.get());</span><br><span class="line">    <span class="comment">//count-返回流中元素的总个数</span></span><br><span class="line">    Long count=employees.stream().count();</span><br><span class="line">    System.out.println(count);<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//max-返回流中最大值</span></span><br><span class="line">    Optional&lt;Employee&gt; op3=employees.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">    System.out.println(op3.get());</span><br><span class="line">    <span class="comment">//min返回流中最小值</span></span><br><span class="line">    Optional&lt;Double&gt;op4=employees.stream().map(Employee::getSalary).min(Double::compare);</span><br><span class="line">        System.out.println(op4.get());<span class="comment">//3333.33</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>归约  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*归约</span></span><br><span class="line"><span class="comment">* reduce(T identity,BinaryOperator b) / reduce(BinaryOperator b)-可以将流中元素反复结合起来，得到一个值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    Integer sum=list.stream()</span><br><span class="line">    reduce(T identity,BinaryOperator b).reduce(<span class="number">0</span>, (x,y)-&gt;x+y);</span><br><span class="line">    <span class="comment">//0为起始值</span></span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">    Optional&lt;Double&gt; op=employees.stream().map(Employee::getSalary).reduce(Double::sum);</span><br><span class="line">    System.out.println(op.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>收集  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 收集</span></span><br><span class="line"><span class="comment">* collect-将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list=employees.stream().map(Employee::getName).collect(Collectors.toList());</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    Set&lt;String&gt; set=employees.stream().map(Employee::getName).collect(Collectors.toSet());</span><br><span class="line">    set.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    <span class="comment">//总和</span></span><br><span class="line">    Long count=employees.stream().collect(Collectors.counting());</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    <span class="comment">//平均值</span></span><br><span class="line">    Double avg=employees.stream().collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line">    System.out.println(avg);</span><br><span class="line">    <span class="comment">//总和</span></span><br><span class="line">    Double sum=employees.stream().collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    Optional&lt;Employee&gt; max=employees.stream().collect(Collectors.maxBy((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line">    System.out.println(max.get());</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    Optional&lt;Double&gt; min=employees.stream().map(Employee::getSalary).collect(Collectors.minBy(Double::compare));</span><br><span class="line">    System.out.println(min.get());</span><br><span class="line">    System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    Map&lt;Status,List&lt;Employee&gt;&gt; map=employees.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="comment">//分区</span></span><br><span class="line">    Map&lt;Boolean,List&lt;Employee&gt;&gt; map3=employees.stream().collect(Collectors.partitioningBy((e)-&gt;e.getSalary()&gt;<span class="number">8000</span>));</span><br><span class="line">    System.out.println(map3);</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Stream-API&quot;&gt;&lt;a href=&quot;#Stream-API&quot; class=&quot;headerlink&quot; title=&quot;Stream API&quot;&gt;&lt;/a&gt;Stream API&lt;/h3&gt;&lt;p&gt;Stream位于包java.util.stream .* 是Java8 中处
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="https://zhuyiting.xyz/2017/11/18/Lambda/"/>
    <id>https://zhuyiting.xyz/2017/11/18/Lambda/</id>
    <published>2017-11-18T05:40:00.000Z</published>
    <updated>2019-10-20T13:58:44.954Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口:"></a>函数式接口:</h4><p>我们把只拥有一个方法的接口称为函数式接口.</p><p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个 Object 已经提供的方法，比如 toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过 @FunctionalInterface 注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p><p>函数式接口的实现引入了一个全新的结构化函数类型.我们也称为是”箭头”类型.</p><h5 id="Java8中加入新的包：java-util-function"><a href="#Java8中加入新的包：java-util-function" class="headerlink" title="Java8中加入新的包：java.util.function"></a>Java8中加入新的包：java.util.function</h5><p>它包含了常用的函数式接口:</p><ol><li><code>Predicate&lt;T&gt;</code>: 接收<code>T</code>并返回<code>boolean</code></li><li><code>Consumer&lt;T&gt;</code>: 接收<code>T</code>,不返回值</li><li><code>Function&lt;T, R&gt;</code>: 接收<code>T</code>,返回<code>R</code></li><li><code>Supplier&lt;T&gt;</code>: 提供<code>T</code>,不接收值</li><li><code>Unaryoperator&lt;T&gt;</code>: 接收<code>T</code>,返回<code>T</code></li><li><code>Binary0perator&lt;T&gt;</code>: 接收两个<code>T</code>,返回<code>T</code></li></ol><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式:"></a>Lambda表达式:</h4><p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的语法过于冗余.</p><ul><li><p>下面是一些表达式:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;x+y</span><br><span class="line">()-&gt;<span class="number">42</span></span><br><span class="line">(String s)-&gt;System.out.println(s);</span><br></pre></td></tr></table></figure></li><li><p>lambda 表达式的语法由参数列表、箭头符号 <code>-&gt;</code> 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p><ul><li>表达式:表达式会被执行然后返回执行结果.</li><li>语句块:语句块中的语句会被依次执行,就像方法中的语句一样<ul><li><code>return</code>语句会把控制权交给匿名方法的调用者</li><li><code>break</code>和<code>continue</code>只能在循环中使用</li><li>如果函数体有返回值,那么函数体内部的每一条路径都必须返回值</li></ul></li></ul></li><li><p>目标类型:</p><ul><li>编译器负责推导<strong>lambda</strong>表达式类型,它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导,这个<strong>被期待的类型</strong>被称为==目标类型==.<strong>lambda</strong>表达式只能出现在目标类型为函数式接口的上下文中.</li><li>当然<strong>lambda</strong>对于<strong>目标类型</strong>也是有要求的,编译器会检查lambda表达式的类型和目标类型的方法签名是否一致,当且仅当下面所有条件均满足时,lambda表达式才可以被赋给目标类型<code>T</code>:<ul><li><code>T</code>是一个函数式接口</li><li><code>lambda</code>表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li><li><code>lambda</code>表达式的返回值和<code>T</code>的方法返回值相兼容</li><li><code>lambda</code>表达式内锁抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li></ul></li></ul></li></ul><h4 id="Java内置函数式接口"><a href="#Java内置函数式接口" class="headerlink" title="Java内置函数式接口"></a>Java内置函数式接口</h4><p>为了免去用户每次使用Lamdba表达式时,都自行创建函数式接口,java中提供了四大核心内置函数式接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Consumer&lt;T&gt; :消费型接口</span></span><br><span class="line"><span class="comment">    *          void accept(T t);</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Supplier&lt;T&gt; :供给型接口</span></span><br><span class="line"><span class="comment">    *          T get();</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Function&lt;T,R&gt; :函数型接口</span></span><br><span class="line"><span class="comment">    *          R apply(T t);</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Predicate&lt;T&gt; :断言型接口</span></span><br><span class="line"><span class="comment">    *          boolean test(T t);</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Consumer&lt;T&gt; 消费型接口：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money,Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        happy(<span class="number">1000</span>,(m) -&gt;System.out.println(<span class="string">"消费："</span>+m+<span class="string">"元"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Supplier&lt;T&gt; 供给型接口:</span></span><br><span class="line">    <span class="comment">//需求：产生指定个数的整数，并放入集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num,Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Integer n=sup.get();</span><br><span class="line">            list.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numList=getNumList(<span class="number">10</span>, ()-&gt;(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (Integer num : numList) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Function&lt;T,R&gt; 函数型接口:</span></span><br><span class="line">    <span class="comment">//需求：处理字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str,Function&lt;String,String&gt; fun)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String newStr=strHandler(<span class="string">"\t\t\t 哈哈哈  "</span>, (str)-&gt;str.trim());</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line">        String subStr=strHandler(<span class="string">"abcdef"</span>, (str)-&gt;str.substring(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">        System.out.println(subStr);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Predicate&lt;T&gt; 断言型接口：</span></span><br><span class="line">    <span class="comment">//需求：将满足条件的字符串，放入集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list,Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; strList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( String str : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.test(str))&#123;</span><br><span class="line">                strList.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=Arrays.asList(<span class="string">"Hello"</span>,<span class="string">"jj"</span>,<span class="string">"Lambda"</span>,<span class="string">"www"</span>,<span class="string">"ok"</span>);</span><br><span class="line">        List&lt;String&gt; strList=filterStr(list, (s)-&gt;s.length()&gt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String string : strList) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;函数式接口&quot;&gt;&lt;a href=&quot;#函数式接口&quot; class=&quot;headerlink&quot; title=&quot;函数式接口:&quot;&gt;&lt;/a&gt;函数式接口:&lt;/h4&gt;&lt;p&gt;我们把只拥有一个方法的接口称为函数式接口.&lt;/p&gt;
&lt;p&gt;我们并不需要额外的工作来声明一个接口是函数式接口：编译
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Java输入输出</title>
    <link href="https://zhuyiting.xyz/2017/11/14/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://zhuyiting.xyz/2017/11/14/Java输入输出/</id>
    <published>2017-11-14T02:01:00.000Z</published>
    <updated>2019-10-20T13:58:33.914Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第1节-文件"><a href="#第1节-文件" class="headerlink" title="第1节:文件"></a>第1节:文件</h4><ol><li><strong>File类型</strong></li></ol><ul><li><code>java.io.File</code>类的对象可以表示文件和目录，在程序中一个File类对象可以代表一个文件或目录</li><li>当创建一个File对象后，就可以利用它来对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等等</li><li>需要注意的是，File对象并不能直接对文件内容进行读/写操作，只能查看文件的属性</li></ul><h4 id="第2节-输出输出流"><a href="#第2节-输出输出流" class="headerlink" title="第2节:输出输出流"></a>第2节:输出输出流</h4><ol><li><strong>输入输出流的概念与作用</strong></li></ol><ul><li>流的特点:<ul><li>流是一串连续不断的数据的集合,只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的</li></ul></li><li>输入流：从外存读取数据到内存，输出流：将数据从内存写到外存中</li></ul><ol start="2"><li><strong>Java中输入输出流的类型</strong></li></ol><ul><li>对于输入和输出流，由于传输格式的不同，又分为字节流和字符流：</li></ul><ol start="3"><li><strong>Java的输入输出流的继承树</strong></li></ol><ul><li>Java I/O主要包括:<ul><li><strong>流式部分</strong>:IO的主体部分；</li><li><strong>非流式部分</strong>:主要包含一些辅助流式部分的类，如：File类、<code>RandomAccessFile</code>类和<code>FileDescriptor</code>等类；</li><li><strong>其他类</strong>:文件读取部分的与安全相关的类，如：<code>SerializablePermissio</code>n类，以及与本地操作系统相关的文件系统的类，如：<code>FileSystem</code>类和<code>Win32FileSystem</code>类和<code>WinNTFileSystem</code>类。</li></ul></li></ul><ol start="4"><li><strong>字节输出流</strong></li></ol><ul><li>OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的</li></ul><ol start="5"><li><strong>OutputStream</strong></li></ol><ul><li>OutputStream是一个抽象类，提供了Java向流中以字节为单位写入数据的公开接口，大部分字节输出流都继承自OutputStream类</li></ul><ol start="6"><li><strong>DataOutput</strong></li></ol><ul><li>DataOutput接口规定一组操作，用于直接向流中写入基本类型的数据和字符串：<ul><li>DataInput对基本数据类型的写入分别提供了不同的方法，方法名满足<code>writeXXX()</code>的规律,如<code>writeInt()</code>表示向流中写入一个int型数据，写入字符串的方法为<code>writeUTF()</code></li></ul></li></ul><ol start="7"><li><strong>常见字节输出流工具的作用与使用</strong></li></ol><ul><li>FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象。</li><li>创建一个文件流对象有以下方法:<ul><li>方式1：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(“d:/abc.txt”);</span><br><span class="line">FileOutputStream out=<span class="keyword">new</span> FileOutputStream (f);</span><br></pre></td></tr></table></figure></li><li>方式2：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream out=<span class="keyword">new</span> FileOutputStream(“d:/abc.txt”);</span><br></pre></td></tr></table></figure></li><li>方式3：构造函数将 FileDescriptor()对象作为其参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileDescriptor() fd=<span class="keyword">new</span> FileDescriptor();</span><br><span class="line">FileOutputStream f2=<span class="keyword">new</span> FileOutputStream(fd);</span><br></pre></td></tr></table></figure></li><li>方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream f=<span class="keyword">new</span> FileOutputStream(“d:/abc.txt”,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="8"><li><strong>字节输入流</strong></li></ol><ul><li>InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法.</li></ul><ol start="9"><li><strong>InputStream</strong></li></ol><ul><li>InputStream也是一个抽象类，提供了Java中从流中以字节为单位读取数据的公开接口，大部分字节输入流都继承自InputStream类</li></ul><ol start="10"><li><strong>DataInput</strong></li></ol><ul><li>DataInput接口规定一组操作，用于以一种与机器无关（当前操作系统等）的方式，直接在流中读取基本类型的数据和字符串：</li><li>DataInput对基本数据类型的读取分别提供了不同的方法，方法名满足readXXX()的规律,如readInt()表示从流中读取一个int型数据读取字符串的方法为readUTF()</li></ul><ol start="11"><li><strong>常见的字节输入流工具的作用与使用</strong></li></ol><ul><li>FileInputStream类是InputStream类的子类，用来处理以文件作为数据输入源的数据流。<ul><li>使用方法:<ul><li>方式1：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   File fin=<span class="keyword">new</span> File(“d:/abc.txt”);</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(fin);</span><br></pre></td></tr></table></figure></li><li>方式2：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(“d: /abc.txt”;</span><br></pre></td></tr></table></figure></li><li>方式3：构造函数将 FileDescriptor()对象作为其参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileDescriptor() fd=<span class="keyword">new</span> FileDescriptor();</span><br><span class="line">FileInputStream f2=<span class="keyword">new</span> FileInputStream(fd);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>程序对应的基本输入为键盘输入，基本输出为显示器输出。Java中，System类的in和out两个成员代表了基本输入输出的抽象</li></ul><p><strong>System.in</strong>:基本输入，对应InputStream<br><strong>System.out</strong>:基本输出，对应PrintStream    </p><ul><li><strong>RandomAccessFile</strong><ul><li>RandomAccessFile类可以在文件中==任何位置==查找或写入数据</li><li>RandomAccessFile==同时实现了DataInput和DataOutput接口==</li><li>磁盘文件都是可以随机访问的， 但是从网络而来的数据流却不是</li></ul></li></ul><ol start="12"><li><strong>ByteArrayOutpuStream/ByteArrayInputStream</strong></li></ol><ul><li>一对输入输出工具为我们提供了在内存中利用byte[]进行缓冲流操作的工具</li><li>ByteArrayOutputStream提供工具将内存中以串行序列存在的流式数据以一个字节为单位进行切分，形成一个byte[]数组</li><li>而ByteArrayInputStream则正好相反，提供工具将内存中的byte[]数组中的数据进行串行序列化拼接，形成一个可供操作的流式数据</li><li>从功能上看，ByteArrayOutpuStream可以将任意数据组合转换为byte[]，而ByteArrayInputStream可以将这个数组还原，从而以流的形式读取任意数据组合</li></ul><ol start="13"><li><strong>字符输出流</strong></li></ol><ul><li>考虑到Java是跨平台的语言，要经常操作Unicode编码的文件，使用基于字符为读、写基本单元的字符流操作文件是有必要的,以字符为单位进行数据输出的工具继承自Writer</li></ul><ol start="14"><li><strong>字符输出流的统一数据写入方法</strong></li></ol><ul><li>Writer和OutputStream类似也提供了统一的往流中写入数据的方法，和OutputStream不同的是，写入数据的单位由字节变成了字符</li></ul><ol start="15"><li><strong>字符输出流工具的作用与使用</strong></li></ol><ul><li>FileWriter类称为文件写入流，以字符流的形式对文件进行写操作</li><li>FileWriter将逐个向文件写入字符，效率比较低下，因此一般将该类对象包装到缓冲流中进行操作</li><li>还可以使用PrintWriter对流进行包装，提供更方便的字符输出格式控制</li></ul><ol start="16"><li><strong>字符输入流</strong></li></ol><ul><li>以字符为单位进行数据读取的工具继承自Reader，Reader会将读取到的数据按照标准的规则转换为Java字符串对象</li></ul><ol start="17"><li><strong>字符输入流的统一数据读取方法</strong></li></ol><ul><li>字符输入流Reader也提供的统一读取数据的方法（和InputStream不同，实际开发时更多的调用不同Reader提供的特殊读取方法，如BufferedReader的readLine()，能够简化操作）</li></ul><ol start="18"><li><strong>常见的字符输入流工具的作用与使用</strong></li></ol><ul><li>FileReader类称为文件读取流，允许以字符流的形式对文件进行读操作</li><li>与FileWriter相似，该类将从文件中逐个地读取字符，效率比较低下，因此一般也将该类对象包装到缓冲流中进行操作</li></ul><ol start="19"><li><strong>字节流与字符流的适配器</strong></li></ol><ul><li>在某些时候虽然我们操作的是字符串，但是不得不面对数据来源是InputStream（字节输入流）的情况，在这种情况下，Java提供了将InputStream和Reader之间进行转换的工具，事实上，字节输出流和字符输出流之间也存在这种工具，称为：字节流与字符流的适配器：<ul><li>InputStreamReader：<ul><li>字节流通向字符流的桥梁，它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集</li><li>每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节</li></ul></li><li>OutputStreamWriter： <ul><li>字符流通向字节流的桥梁，使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集</li><li>每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲</li></ul></li></ul></li></ul><h4 id="第3节-对象序列化"><a href="#第3节-对象序列化" class="headerlink" title="第3节:对象序列化"></a>第3节:对象序列化</h4><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能</p><ol><li>对象序列化的作用</li></ol><ul><li>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量</li><li>除了在持久化对象时会用到对象序列化之外，在网络中传递对象时，也会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制</li></ul><ol start="2"><li>序列化接口</li></ol><ul><li>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以被序列化</li><li><code>java.io.Serializable</code>是一个标识接口，即意味着它仅仅是为了说明类的可序列化属性，接口没有包含任何需要子类实现的抽象方法</li></ul><ol start="3"><li>对象序列化和反序列化</li></ol><ul><li>将对象的状态信息保存到流中的操作，称为序列化，可以使用Java提供的工具<code>ObjectOutputStream. writeObject(Serializable obj)</code>来完成</li><li>从流中读取对心状态信息的操作称为反序列化，可以使用Java提供的工具<code>ObjectInputStream.readObject()</code>来完成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第1节-文件&quot;&gt;&lt;a href=&quot;#第1节-文件&quot; class=&quot;headerlink&quot; title=&quot;第1节:文件&quot;&gt;&lt;/a&gt;第1节:文件&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;File类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Java核心API</title>
    <link href="https://zhuyiting.xyz/2017/11/10/Java%E6%A0%B8%E5%BF%83API/"/>
    <id>https://zhuyiting.xyz/2017/11/10/Java核心API/</id>
    <published>2017-11-10T02:09:00.000Z</published>
    <updated>2019-10-20T13:56:26.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li><p>Object类是Java语言中所有类的根,所有的类都直接或间接的继承了Object类;</p></li><li><p><strong>数组</strong>也继承了Object类;</p></li><li><p>Object类中定义了<code>equals(Object obj)</code>方法,用来比较两个对象的虚拟地址,如果虚拟地址相同则返回true,否则返回false;</p><ul><li>Object类中的<code>equals()</code>方法的作用,与<code>==</code>相同,都是比较两个对象的虚地址</li><li>很多类覆盖了<code>equals</code>方法,用来比较两个对象的属性值,如果属性值相同,则认为两个对象相等,例如[String类就覆盖了equals方法,用来比较两个字符串的字符序列值]</li></ul></li><li><p>Object类中定义了<code>hashCode</code>方法<code>public int hashCode()</code>，用来返回对象的哈希码；</p><ul><li><code>hashCode</code>方法主要为了配合基于哈希的集合类一起工作，例如HashSet、HashMap等；</li><li>默认情况下(即没有重新hashCode方法时)，当两个引用的虚地址相同时，hashCode返回相同的值，否则返回不同的值；</li><li>事实上，基于哈希的集合在使用hashCode的时候，基本都是和equals一起使用；先用hashCode初步比较,再用equals比较</li><li><strong>注意</strong>:使用的时候一起使用,重写的时候也要一起重写</li></ul></li><li><p>Object类中定义了<code>toString</code>方法</p><ul><li>字符串类型是编程时最常用的类型，Object类中定义了toString方法<code>public String toString()</code>，可以把任意类型对象转换成字符串返回；</li><li>默认情况（没有重写Object类中的toString方法）下，返回字符串的格式为：对象类型@对象调用hashCode方法的返回值；</li><li>返回Object类中默认格式的字符串几乎没有实用意义，因此很多时候，都会重写一些实体类的toString方法，返回需要的字符串格式；</li></ul></li><li><p>Object类中定义了克隆方法<code>clone</code></p><ul><li><code>Clone</code>方法能够“复制”一个对象，生成一个新的引用，分配新的内存空间；</li><li>一个类必须实现Cloneable接口，才能被克隆，否则抛出异常；</li><li>克隆是生成了一个新的对象，然而，对象的属性如果有引用类型，实际上还是公用；</li><li>深克隆时，属性不仅值相同，同时又都存储在完全不同的内存中</li></ul></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习</p><ol><li>子串截取方法:<ol><li><code>String substring(int beginIndex)</code></li><li><code>String substring(int beginIndex,int endIndex)</code></li></ol></li><li>检索相关方法:<ol><li><code>int indexOf(int ch)</code></li><li><code>int indexOf(int ch,int fromIndex)</code></li><li><code>int indexOf(String str)</code></li><li><code>int indexOf(String str,int fromIndex)</code></li><li><code>int lastIndexOf(int ch)</code></li><li><code>int lastIndexOf(int ch,int fromIndex)</code></li><li><code>int lastIndexOf(String str)</code></li><li><code>int lastIndexOf(String str,int fromIndex)</code></li><li><code>char charAt(int index)</code></li></ol></li><li>类型转换相关的方法:<ol><li><code>static String valueOf(boolen b)</code></li><li><code>static String valueOf(char c)</code></li><li><code>static String valueOf(char[] data)</code></li><li><code>static String valueOf(char[] data,int offset,int count)</code></li><li><code>static String valueOf(double d)</code></li><li><code>static String valueOf(float f)</code></li><li><code>static String valueOf(int i)</code></li><li><code>static String valueOf(long l)</code></li><li><code>static String valueOf(Object obj)</code></li></ol></li><li>其他方法:<ol><li><code>int compareTo(String anotherString)</code></li><li><code>boolean endsWith(String suffix)</code></li><li><code>byte[] getBytes()</code></li><li><code>byte[] getBytes(Charset charset)</code></li><li><code>int length()</code></li><li><code>boolean startsWith(String prefix)</code></li><li><code>boolean startsWith(String prefix,int toffset)</code></li><li><code>String trim()</code></li></ol></li></ol><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式就是用来描述字符串逻辑规则的工具</p><ul><li>正则表达式本身也是个字符串，不过这些字符串是使用系列“元字符”组成；</li><li>所谓“元字符”就是预先定义的，有特殊意义的字符；例如\d用来匹配一个数字； \w用来匹配字母或数字或下划线或汉字等；</li><li>很多语言多对正则表达式提供了支持，例如JavaScript、Java等；</li><li>不同语言中使用正则表达式时，正则表达式的具体编写规则会有些小的差别，但是大体相同；</li></ul><h4 id="正大表达式在Java中的使用"><a href="#正大表达式在Java中的使用" class="headerlink" title="正大表达式在Java中的使用"></a>正大表达式在Java中的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String regex=<span class="string">"^((13[0-9])|(15[0-3,5-9])|(18[0,2,3,5-9])|(17[0-8])|(147))\\d&#123;8&#125;$"</span>;</span><br><span class="line"><span class="comment">//检验的手机号码</span></span><br><span class="line">String string=<span class="string">"15123569087"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//将正则表达式编译成Pattern对象</span></span><br><span class="line">Pattern pattern=Pattern.compile(regex);</span><br><span class="line"><span class="comment">//使用Pattern对象为每个手机号码产生一个匹配器</span></span><br><span class="line">Matcher matcher=pattern.matcher( string);</span><br><span class="line"><span class="keyword">boolean</span> flag=matcher.matches();</span><br><span class="line">System.out.println(flag==<span class="keyword">true</span>?<span class="string">"手机号正确"</span>:<span class="string">"手机号错误"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="comment">//将正则表法式编译成Pattern对象</span></span><br><span class="line">Pattern pattern2=Pattern.compile(regex);</span><br><span class="line"><span class="keyword">boolean</span> flag2=pattern2.matches(regex, string);</span><br><span class="line">System.out.println(flag2==<span class="keyword">true</span>?<span class="string">"手机号正确"</span>:<span class="string">"手机号错误"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="keyword">boolean</span> flag3=string.matches(regex);</span><br><span class="line">System.out.println(flag3==<span class="keyword">true</span>?<span class="string">"手机号正确"</span>:<span class="string">"手机号错误"</span>);</span><br></pre></td></tr></table></figure><h3 id="对象的自然比较"><a href="#对象的自然比较" class="headerlink" title="对象的自然比较"></a>对象的自然比较</h3><h5 id="内部比较器"><a href="#内部比较器" class="headerlink" title="内部比较器:"></a>内部比较器:</h5><ul><li>一个类如果想【支持排序】，那么就必须实现接口<code>Comparable&lt;T&gt;</code>，该接口被称为对象的内部比较器；</li><li>该接口中只有一个方法；<code>int compareTo(T o)</code></li></ul><h5 id="外部比较器"><a href="#外部比较器" class="headerlink" title="外部比较器:"></a>外部比较器:</h5><ul><li>一个类实现Comparable这个内部比较器后，该类支持排序，然而只能有一种排序逻辑，比较受限制；</li><li>可以使用外部比较器Comparator，灵活为类定义多种比较器，此时类本身不需要实现Comparable接口；</li><li>Comparator接口中有两个方法<code>int compareTo(T o1,T o2)</code>和<code>boolean equals(Object obj)</code></li></ul><h5 id="对象数组的排序"><a href="#对象数组的排序" class="headerlink" title="对象数组的排序:"></a>对象数组的排序:</h5><ul><li><code>java.util.Arrays</code>类是一个针对数组进行操作的工具类，其中提供了对对象数组进行排序的方法；</li><li>两个常用的对象数组排序方法如下：<br><code>static void sort(Object[] a)</code><br><code>static &lt;T&gt;void sort(T[] a,ComparaTor&lt;? super T?&gt; c)</code></li></ul><h3 id="数学API"><a href="#数学API" class="headerlink" title="数学API"></a>数学API</h3><p>Math类提供的数学运算方法:</p><ul><li>Math类位于java.lang包中，是一个final类，不能被继承；</li><li>Math类中所有方法都是static方法，可以直接使用类名Math调用；</li><li>Math中定义了大量与数学运算有关的方法，包括求绝对值、三角函数、平方根等；</li><li>Math类是final类，不能被继承，所有方法都是static方法，可以直接用类名调用；</li><li>Math中的round方法是四舍五入，ceil是返回大于参数且最接近参数的整数，floor是返回小于参数且最接近参数的整数；</li><li>Math中的random方法返回[0.0,1.0)范围的值；</li><li>Math类中还定义了很多数学计算方法；</li><li>Java中的大整数API:<ul><li>Java中整数最大范围是long型，64位，如果需要使用超过long范围的大整数，可以使用BigInteger类；</li><li>BigInteger位于java.math包中，定义了一系列的数学运算方法，调用这些方法可以进行计算，不能使用运算符计算；</li><li>java.math包中还有一个类叫BigDecimal，虽然和整数无关，我们也在此一起学习；</li><li>BigDecimal是用来针对浮点型进行精确运算的；</li><li>BigInteger用来对超过long范围整数进行运算；</li><li>BigDecimal用来对double、float类型进行精确计算；</li></ul></li></ul><h3 id="Java中的随机API"><a href="#Java中的随机API" class="headerlink" title="Java中的随机API"></a>Java中的随机API</h3><ul><li>Math类中的random方法可以产生随机数，然而，该方法只能生成[0.0,1.0)范围的double值；很多时候，可能需要生成不同类型不同范围的随机值；</li><li>java.util包中的Random类可以用来生成不同类型的随机值，功能更为强大；</li><li>Random类有两个构造方法，无参的构造方法创建对象后，每次都生成不同的随机数；有参的构造方法创建对象后，如果种子参数值一样，那么每次生成的随机数也相同；</li><li>Random类功能强大，能生成int,float,double,boolean各种类型的随机数；</li><li><code>random.nextInt</code>生成不定范围的int随机数，而带参数的nextInt生成的随机数有范围；</li></ul><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><ul><li>UUID指的是通用唯一识别码，常用于分布式系统；</li><li>有多种生成UUID的策略，包括基于时间、基于名字、随机等；</li><li>Java API中定义了java.util.UUID类，对UUID的生成提供了支持；</li></ul><h3 id="DateAPI"><a href="#DateAPI" class="headerlink" title="DateAPI"></a>DateAPI</h3><ul><li>java.util.Date类表示时间，不过由于对国际化支持有限，所以JDK1.1之后推荐使用java.util.Calendar类；</li><li>JDK1.1版本开始，增加Calendar类，建议使用Calendar类代替Date类；</li><li>Calendar是抽象类，不能直接使用new创建对象；<ul><li>Calendar类中定义了获得实例的方法<code>getInstance()</code>,得到的实际是子类<strong>GregorianCalendar</strong>的对象!!</li></ul></li><li>获得日历对象后，可以为该对象的年、月、日、时、分、秒等进行赋值：</li><li>实际编程中，往往需要对时间用不同的格式进行展示;<ul><li><strong>SimpleDateFormat</strong>中定义了对时间进行格式化的方法；该类继承了抽象父类DateFormat，某些方法在父类中定义，查阅API文档时注意；</li><li>可以自定义一个模式字符串来构建SimpleDateFormat对象：</li><li>通常使用format方法进行格式化；</li></ul></li></ul><h3 id="JDK8中的新API"><a href="#JDK8中的新API" class="headerlink" title="JDK8中的新API"></a>JDK8中的新API</h3><ul><li>JDK8中定义了<code>java.time.LocalDate</code>，用来表示日期，默认格式是yyyy-MM-dd；该类不包含时间信息；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object类是Java语言中所有类的根,所有的类都直接或间接的继承了Object类;&lt;/
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="https://zhuyiting.xyz/2017/11/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://zhuyiting.xyz/2017/11/03/Java异常处理/</id>
    <published>2017-11-03T10:14:00.000Z</published>
    <updated>2019-10-20T13:55:41.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="异常处理和错误的区别"><a href="#异常处理和错误的区别" class="headerlink" title="异常处理和错误的区别:"></a>异常处理和错误的区别:</h4><p><strong>异常:</strong> 异常指的是程序运行时发生的不正常的时间;异常能够被程序处理,保证程序继续运行下去;例如除数为0,文件没有找到,输入的数字格式不对;<br><strong>错误:</strong> 错误程序没法处理,例如内存泄漏,发生错误后,一般虚拟机会选择终止程序运行,程序员需要修改代码才能解决相关错误;</p><h4 id="运行时异常与非运行时异常"><a href="#运行时异常与非运行时异常" class="headerlink" title="运行时异常与非运行时异常:"></a>运行时异常与非运行时异常:</h4><p>Exception有很多子类,这些子类又可以分为两大类;即<strong>运行时异常</strong>和<strong>非运行时异常</strong><br><strong>运行时异常:</strong> 也称为非检测异常,这些异常在编译期不检测,程序中可以选择处理,也可以不处理,如果不处理运行时会中断,但编译没问题.<br><strong>非运行时异常:</strong> 也称为检测异常,是必须进行处理的异常,如果不处理,将发生编译期错误.</p><h4 id="异常处理的标准流程"><a href="#异常处理的标准流程" class="headerlink" title="异常处理的标准流程:"></a>异常处理的标准流程:</h4><ol><li><strong>抛出异常</strong><br>运行时异常JVM自行抛出,非运行时异常使用<code>throw</code>抛出</li><li><strong>捕获异常</strong><br><code>catch</code>语句捕获异常</li><li>如<strong>捕获成功</strong>,异常被处理,程序继续运行<br><code>catch</code>的异常类型与抛出的异常类型匹配时</li><li>如<strong>捕获失败</strong>,异常未被处理,程序中断运行<br><code>catch</code>的异常类型与抛出的异常类型不匹配</li></ol><h4 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h4><ul><li><strong>Exception</strong>: 异常层次结构的父类</li><li><strong>ArithmeticException</strong>:算术错误情况,如以0作除数</li><li><strong>ArrayIndexOutOfBoundsException</strong>: 数组下标越界</li><li><strong>NullPointerException</strong>: 尝试访问null对象成员</li><li><strong>ClassNotFoundException</strong>: 不能加载所需的类</li><li><strong>ClassCastException</strong>:对象强制类型转换出错</li><li><strong>NumberFormatException</strong>: 数字格式转换异常,如把”abc”转成数字了</li></ul><h4 id="Try-catch代码块"><a href="#Try-catch代码块" class="headerlink" title="Try-catch代码块:"></a>Try-catch代码块:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 代码段 1</span></span><br><span class="line">  <span class="comment">// 产生异常的代码段 2</span></span><br><span class="line">  <span class="comment">// 代码段 3</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">1</span> e) &#123;</span><br><span class="line">  <span class="comment">// 对异常进行处理的代码段4</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (异常类型<span class="number">2</span> e) &#123;</span><br><span class="line">  <span class="comment">// 对异常进行处理的代码段5</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 无论是否发生异常,代码总能执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Throw-Throws关键字"><a href="#Throw-Throws关键字" class="headerlink" title="Throw,Throws关键字"></a>Throw,Throws关键字</h4><ul><li><strong>throw</strong>: 抛出异常(一般用于代码块和方法中)</li><li><strong>throws</strong>: 声明异常(一般用于方法中)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(age&lt;=<span class="number">0</span>||age&gt;<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(); <span class="comment">//处理方法 try-catch</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常:"></a>自定义异常:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class AgeException extends <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言:"></a>断言:</h4><p>assert 5&lt;3==false “断言信息”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;异常处理和错误的区别&quot;&gt;&lt;a href=&quot;#异常处理和错误的区别&quot; class=&quot;headerlink&quot; title=&quot;异常处理和错误的区别:&quot;&gt;&lt;/a&gt;异常处理和错误的区别:&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;异常:&lt;/strong&gt; 异常指的是程序运行时发生的不正
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaSE" scheme="https://zhuyiting.xyz/tags/JavaSE/"/>
    
  </entry>
  
</feed>
