<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuyiting.xyz/"/>
  <updated>2019-10-29T02:25:33.893Z</updated>
  <id>https://zhuyiting.xyz/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中equals的注意事项</title>
    <link href="https://zhuyiting.xyz/2019/10/29/Java%E4%B8%ADequals%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://zhuyiting.xyz/2019/10/29/Java中equals的注意事项/</id>
    <published>2019-10-29T02:25:33.000Z</published>
    <updated>2019-10-29T02:25:33.893Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>论市场化改革</title>
    <link href="https://zhuyiting.xyz/2019/10/24/%E8%AE%BA%E5%B8%82%E5%9C%BA%E5%8C%96%E6%94%B9%E9%9D%A9/"/>
    <id>https://zhuyiting.xyz/2019/10/24/论市场化改革/</id>
    <published>2019-10-24T12:42:13.000Z</published>
    <updated>2019-10-29T02:32:58.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇"><a href="#当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇" class="headerlink" title="当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?"></a>当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?</h4><p>最近，<u>全球掀起了一阵降息潮，全球的经济环境普遍不太理想</u>，全球正在经历一轮新的经济周期调整。以10年为周期的金融危机再一次来临。中美的贸易摩擦对于中国金融市场的影响冲击也是巨大的，<u>人民币一度破7，持续的贬值导致国内资金外逃</u>，也导致了人民币国际化的步伐放缓。<br><font color="red">1.<em>[为什么经济不理想的时候要加息?加息为什么可以调整经济]</em><br>因为经济不理想(经济衰退)是市场投资不足(市场中流动的钱少了,都存银行了),政府为了刺激市场,减少银行利息,这样本来钱存在银行的一部分人就会因为收益少了,把钱投向市场中(股票或者消费),都会促进市场健康发展,使经济复苏<br>2.<em>[为什么人民币破7会导致国内资金外逃,人民币破7由什么导致,为什么人民币破7会阻碍人民币国际化?]</em><br>因为人民币破7是1美元兑换7块多人民币,而国际上以美元为主,本来6块多可以买到的东西,现在要多花钱才能买到,这样中国人不愿意买国外的东西(进口不利,因为变贵了).但是相反,中国更愿意卖东西了(出口有利).然后来自国外的资金,会因为人民币不值钱了(能换到的美元变少了)而减少对国内的投资(资本外逃).人民币的贬值是由于美元强势造成的(美国降息,资本都进入市场,经济强势)<br></font></p><p>2019年来，中国的经济形式总体仍延续着2018年的情况，我国经济增速下滑已是事实。由政府主导的央企在2000年后改革缓慢，各大原材料行业都亏损很大，产业的利润下滑非常严重，产能过剩，中国的供需关系面临着很大的结构性失衡，总体上低端产品产能过剩，高端产品产能不足。其次，我国低附加值、高功耗、高污染的产业比重很大；区域人口分布不合理，城镇化率低，导致发展不平衡；随着人口、土地、环境等这些红利慢慢的消失，<u>人工成本的上涨，土地价格的升高，环境的恶化，导致中低端产业较多</u>；我国经济的增长过多的依靠”<u>三驾马车</u>“，我国城乡收入差距大，行业收入差距大，居民贫富差距大。这些问题就会束缚经济的发展。<br><font color="red">1.<em>[为什么会导致中低端产业较多]</em><br>因为红利的消失会导致企业成本的增加,产品价格上涨,高端产品竞争力变弱(比如国产车和进口车一个价格, 选择国产车的人大大减少)<br>2.<em>[三驾马车是什么]</em><br>三驾马车是投资,消费,进口; 三驾马车是用来计算GDP的三部分,是经济发展的结果,不是根本动力. 根本动力是靠企业靠市场自我的健康发展.<br></font></p><p>当前的市场化改革，正式由习近平提出的供给侧结构性改革，<u>供给侧结构性改革，就是从提高供给质量出发，用改革的办法推进结构调整，矫正要素配置扭曲，扩大有效供给，提高供给结构对需求变化的适应性和灵活性，提高全要素生产率</u>，更好满足广大人民群众的需要，促进经济社会持续健康发展。<br><font color="red">1.<em>[解释一下供给侧结构性改革]</em><br>供给侧结构性改革就是强调供给方(也就是企业),能够制造出物美价廉的商品,怎么改呢呢? 通过改革,减少税收,降低土地价格,给予政策福利支持等<br></font></p><p>强调供给侧改革，从生产、供给入手，调整供应结构，才能使经济健康稳固发展。提升居民消费以及当前的供给侧改革并不能完全改变经济下滑趋势，<u>还必须打通供给以及需求，这一层中间地带</u>，一是政府对企业的税收以及居民的社保缴费高，让企业无法生产，市场需求低。二是垄断性国企占有太多的社会资源而效率又太低，靠价格垄断生存，抬高了整个市场的生产成本，比如油价，房价。<br><font color="red">1.<em>[为什么中间地带很重要]</em><br>中间地带是商品产出到消费者买入之间的地带,是企业或者消费者,在商品之外承担的费用,比如企业的税,居民的五险一金. 企业会把这些费用加到商品的价格上或者自己承担损失, 居民手上钱少, 消费降低, 都不利于经济健康发展<br></font></p><p>供给侧结构性改革自2015年提出以后，其主要任务也在不断变化。最初的“<u>三去一降一补</u>”，通过关、停、并、转等方式去掉多余产能，稳定房价去房地产库存，去杠杆减少政府债务，降低企业各项成本，补充生态建设、完善产业链。<br><font color="red">1.<em>[三去一降一补]</em><br>去产能,去库存,去债务,降成本,补生态产业链<br></font></p><p>当前不仅需要优化供给，提高内需，还要解决供给与需求的中间地带，做好减税降费，优化市场生态。供给侧结构性改革是利好于我国经济发展的，在贸易战加剧，逆全球化回溯的国际背景下，我国的供给侧结构性改革要结合一带一路，深化与沿线国家的合作，强化和欧洲，拉美地区国家的科技合作，扩大开放，将中国制造带出国。</p><p>我国要吸取日本经济发展的教训，20世纪后期，日本大力发展建设，逐渐陷入了失控的建设狂奔，建设业创造了庞大的就业机会，并非来自于真正的经济增长，<u>而是人为制造出的就业机会。这大大削弱并延缓了日本高技术产业的发展</u>，但这种失控的建设无法停止，因为一旦停止公共建设，就会出现大量失业。更严重的是，公共建设积累的巨大负债让日本难堪重负。<u>日本的房价泡沫也重创了日本实体工业的发展，泡沫的破灭导致了大量企业倒闭，失业率狂升</u>。当下的日本，也还没有完全走出当年的阴影。日本经济衰退的20年，主要原因就是日本政府对经济把控出现了失误，制定了违背经济规律的政策。<br><font color="red">1.<em>[为什么这会阻碍日本高科技产业发展?]</em><br>因为大量的人口资金投入到了基础建设业,相应的高科技产业就会没钱没人<br>2.<em>[房价的泡沫破裂为什么影响这么大?]</em><br>房价泡沫破灭, 高价买地的开发商,会破产,很多大企业也会因为投资房地产而大出血,这会让市场严重下跌,这样所有人手上的资产都贬值了,同时企业大量倒闭,失业率也会大大提高,已经买房的人失业后也还要承担巨额贷款.整个国家的经济都会受损,日本房价泡沫当时特别高,政府为了防止泡沫更高影响更恶劣,采取了主动刺破的措施.单也还是经济大衰退<br></font><br>我国可以从日本的经济发展的教训中收益到：房地产不能长久作为支柱产业，必须防止货币超发和过度升值，在宏观调控上，政府不能过于频繁也不能过紧过松，政策引导着眼长远，统筹兼顾。<br>面对经济寒冬，我们个人也需要重视，不要觉得离我们很遥远，面对危机，我们要留好资金，节约开销，努力工作，提升个人能力。<br>我国的市场化改革也会带来巨大的机遇，站在风口上，猪都会飞。乱世出英雄，变革带来的巨大机遇可能产生意想不到的风云人物，不过代价也是巨大的，在改革中，抓住机会很重要，不过我们需要做好充足的准备，机会总是留给有准备的人。能力上的准备，思想上的准备，以及恰到好处的机会。<br>在危机来临初期持有货币，<u>在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了</u>，但这其中随便哪一步出错，都会损失惨重，即使每一个环节都准确无误，也可能因为突如其来的不可抗力，导致整个投资计划的泡汤。比如限购限售，比如失业，比如投资企业破产。<u>在危机时期，不要轻易触碰杠杆加大交易规模</u>，其次要勤于学习，要对未来的风险做准备。<br><font color="red">1.<em>[为什么在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了?]</em><br>通俗点说就是在商品最便宜的时候买进。接下来商品会因为市场规律或者政府调控回升。但是政府为了控制物价（控制通货膨胀），会加息，钱流进银行，商品需求变小。在政府调控的时候，可以看成物价比较理想（高）的时候。这时候卖出。获利就很客观（差价最大的时候）<br>2.<em>[为什么不要触碰杠杆]</em><br>触碰杠杆可以理解为贷款,因为在经济危机时期,银行出于安全考虑不可能把大量的钱借给你, 所以只能贷到很少的钱,而钱越少,承受意外的能力越低,而且贷款需要抵押,(房子或者股票,在危机时期看不到底,随时会被银行卖掉,因为银行不可能等你房子不值钱了再卖,那就失去了抵押的意义),而银行低价卖出也会导致市场供大于求,进一步下跌. 而你通过贷款买入的资产也可能会进一步下跌.很容易破产<br></font><br>在宏观经济下滑的趋势下，要合理分配资产，综合来看2019年上半年的投资者大多以<u>黄金、比特币为代表的避险资产</u>，这些产品或者说是资产的价格也一直在上高，在国际范围中，各大央行实行降息政策，促进经济发展的前提下，黄金和比特币的抗通胀能力就展现出来了。<u>但千万不能在不了解的情况下，进行投资。</u><br><font color="red">1.<em>[为什么黄金,比特币是避险资产?]</em><br>因为他们都有共同属性,价值不受政府调控影响(因为总量固定,且没法造假).这样不管经济怎么样,黄金比特币本来能换多少米还是能换多少米.举例:比如一块黄金本来换一代米,一百块也能换一袋米,但是经济变化,一百块只能买半袋米了,但是一快黄金还是能买一袋米.<br>2.<em>[为什么不了解不能投资呢]</em><br>正式因为他们总量固定 ,他们会被资本炒作,比如大量买入造成供不应求,价格高了以后再高价卖出, 不了解就很可能成了韭菜,承担了这部分人造差价<br></font><br>改革初期，商品紧缺，供不应求，是暴利的时代，后来，电子商务兴起以及产能过剩，商家开启价格战，于是进入了薄利时期，而当前，我国正在转变，产品开始个性化、定制化、高端化，提高增值空间，从而进入厚利时代。<br>2019年下半年，<u>各大二线城市的抢人大战也已经偃旗息鼓，但一线新一线仍然对人才有着很高的需求。这意味着，宏观上的城市化进程将会放缓，大城市的自我迭代会深度展开</u>。其次我国股市长期以来以房地产与科技相关的驱动，目前的房价以稳为主，<u>投资的机会在科技类企业。</u><br><font color="red">1.<em>[为什么二线城市不抢人了?]</em><br>因为人才需要高薪,需要好的企业,而好的企业需要政策扶持,它才愿意来,二线城市没有这样的实力,相反,一线城市企业多,对于人才的需求也大,大城市的建设需要人才.<br>2.<em>[为什么说投资机会在科技类企业]</em><br>因为国家需要发展科技类企业来促进产业升级,政策的支持以及资金的流入,就会让科技类企业更健康的发展<br></font><br>在我国市场化改革的背景下，勤于学习，不多弥补知识盲区，扩充个人知识领域，才能知道更多有用的信息，见多识广的人，更能规避风险，才有更大的机会抓住机遇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇&quot;&gt;&lt;a href=&quot;#当前的市场化改革是否有助于挽救我国经济下滑趋势-应该怎么样抓住市场化改革带来的巨大机遇&quot; class=&quot;headerlink&quot; title=&quot;当前的市场化
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>TED不念过往,不惧将来</title>
    <link href="https://zhuyiting.xyz/2019/10/24/TED%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80,%E4%B8%8D%E6%83%A7%E5%B0%86%E6%9D%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/24/TED不念过往,不惧将来/</id>
    <published>2019-10-24T02:16:00.000Z</published>
    <updated>2019-10-24T14:19:31.012Z</updated>
    
    <content type="html"><![CDATA[<p><u>“These are the times” said Thomas Paine,”that try men’s souls.”</u><br>“这些时间考验着人们的灵魂”Thomas Paine说.<br><u>And they’re trying ours now.</u><br>现在它们在考验我们.<br><u>This is a fateful moment in the history of the West.</u><br>这是一个西方历史的命运时刻.<br><u>We’ve seen divisive elections and divided societies.</u><br>我们看到了分裂的选举和分裂的社会.<br><u>We’ve seen a growth of extremism in politics and religion,</u><br>我们看到了一群极端分子在政治上和宗教上,<br><u>all of it fueled by anxiety,uncertainty and fear,</u><br>所有的这些都是被焦虑,不确定和害怕所推动,<br><u>of a world that’s changing almost faster than we can bear,</u><br>因为世界几乎在以比我们能够承受的更快的速度在改变,<br><u>and the sure knowledge that it’s going to change faster still.</u><br>并且都知道它未来还会改变的这么快<br><u>I have a friend in Washington.</u><br>我有一个朋友在Washington<br><u>I asked him,what was it like being in America during the recent presidential election?</u><br>我问他,在最近的总统选举期间待在美国像是什么?<br><u>He said to me,”Well,it was like the man sitting on the deck of the Titanic with a glass of whiskey in his hand and he’s saying,’I know I asked for ice–,but this is ridiculous.’”</u><br>他告诉我,”哇,它就像一个人坐在泰坦尼克的甲板上,手里拿着威士忌说’我知道我要了冰,但这太疯狂了’”<br><u>So is there something we can do,each of us,to be able to face the future without fear?</u><br>所以有没有一些事我们每个人都可以做的,可以让我们能够对未来不感到恐惧?<br><u>I think there is.</u><br>我觉得是有的.<br><u>And one way into it is to see that perhaps the most simple way into a culture and into an age is to ask: What do people worship? </u><br>有一个方法 也许是最简单的方法 进入一个文化进入一个时代去问:人们崇拜什么?<br><u>People have worshipped so many different things–the sun,the stars,the storm.</u><br>人们过去崇拜很多不同的是–太阳,星型,风暴.<br><u>Some people worship many gods, some one,some none.</u><br>有些人崇拜很多神,有些人崇拜一个,有些人没有<br><u>In the 19th and 20th centuries,people worshipped the nation,the Aryan race,the communist state.</u><br>在19到20世纪,人们崇拜国家,崇拜Aryan种族,崇拜共产主义.<br><u>What do we worship?</u><br>那我们崇拜什么呢?<br><u>I think future anthropologists will take a look at the books we read on self-help,self-realization,self-esteem.</u><br>我觉得未来的人类学家会看看到我们读过的书,关于自我帮助,自我认识,自我尊重,<br><u>They’ll look at the way we talk about morality as being true to oneself, the way we talk about politics as a matter of individual rights,</u><br>他们会看我们谈论道德的行为当成对自己的正确,我们谈论政治的行为当成个人权利的问题.<br><u>and they’ll look at this wonderful new religious ritual we have created.</u><br>并且他们会看看这些很棒的我们创造的宗教利益</p><p><u>You know the one?</u><br>你知道那是什么嘛?<br><u>Called the “selfie”.</u><br>我们成为”自拍”.<br><u>And I think they’ll conclude that what we worship in our time is the self,the me,the I.</u><br>并且我觉得他们会得出结论 那就是我们在那时候崇拜的就是自我,是我<br><u>And this is great.</u><br>这是很棒的<br><u>It’s liberating.</u><br>这是自由的<br><u>It’s empowering.</u><br>这是有权利的.<br><u>It’s wonderful.</u><br>这是极好的.<br><u>But don’t forget that biologically,</u><br>但是不要在生物上忘了<br><u>we’re social animals.</u><br>我们是社交动物<br><u>We’ve spent most of our evolutionary history in small groups.</u><br>我们进化历史中的很多时间都花在小小的群体中<br><u>We need those face-to-face interactions,where we learn the choreography of altruism and where we create those spiritual goods like friendship and trust and loyalty and love that redeem our solitude.</u><br>我们需要面对面的交流,来学习利他主义并且创造精神上的就像友谊,信任,忠诚和爱的东西以此救赎我们的孤独.<br><u>When we have too much of the “I” and too little of the “we”,</u><br>当我们过于关注我的, 很少关注我们时,<br><u>we can find ourselves vulnerable,fearful and alone.</u><br>我们会发现有多点的,会恐惧的并且孤独的自己.<br><u>It was no accident that Sherry Turkle of MIT called the book she wrote on the impact of social media “Alone together”.</u><br>MIT的Sherry Turkle把他写的关于社交媒体的影响命名为”一起孤单”不是一个意外.<br><u>So I think the simplest way of safeguarding the future “you” is to strengthen the future “us” in three dimensions:</u><br>所以我认为,最简单的保障未来的”你”的方法就是从三个方面来加深未来的”我们”<br><u>the us of relationship,the us of identity and the us of responsibility.</u><br>我们的关系,我们的身份和我们的责任<br><u>So let me first take the us of relationship.</u><br>所以,首先让我谈谈我们的关系.<br><u>And here, forgive me if I get personal.</u><br>在这里,原谅我如果我谈自己的事.<br><u>Once upon a time,a very long time age,I was a 20-year-old undergraduate studying philosophy.</u><br>从前,很长一段时间之前,我是20岁的大学生在学习哲学.<br><u>I was into Nietzsche and Schopenhauer and Sartre and Camus.</u><br>我沉迷于Nietzsche,Schopenhauer,Sartre和Camus<br><u>I was full of ontological uncertainty and existential angst.</u><br>我充满了本体论的不确定性和存在的焦虑<br><u>It was terrific.</u><br>那是极好的.<br><u>I was self-obsessed and thoroughly unpleasant to know,</u><br>我是自恋的并且感到非常厌恶,<br><u>until one day I saw, across the courtyard, a girl who was everything that I wasn’t.</u><br>直到有一天我看到,穿过这院子,一个女孩一切都和我不一样.<br><u>She radiated sunshine.</u><br>她散发着阳光.<br><u>She emanated joy.</u><br>她散发着快乐.<br><u>I found out her name was Elaine.</u><br>我找到她的名字是Elaine.<br><u>We met,We talked,We married.</u><br>我们见面,我们聊天,我们结婚.<br><u>And 47 years,three children and eight grandchildren later,</u><br>47年 有了3个小孩,8个孙子 以后<br><u>I can safely say it was the best decision I ever took in my life,</u><br>我可以说,那是我生命中做的最好的决定.<br><u>because it’s the people not like us that make us grow.</u><br>因为和我们不一样的人会让我们成长.<br><u>And that is why I thik we have to do just that.</u><br>这就是为什么我认为我们必须这样做.<br><u>The trouble with Google filters,Facebook friends and reading the news by narrowcasting rather than broadcasting means that we’re surrounded almost entirely by people like us whose views,whose opinions,whose prejudices,even, are just like ours.</u><br>谷歌过滤,脸书朋友圈以及阅读新闻通过很窄的渠道而不是广播这些麻烦意味着我们几乎完全被那些观点,想法,甚至成见和我们的一样的人包围着.<br><u>And Cass Sunstein of Harvard has shown that if we surround ourselves with people with the same views as us,we get more extreme.</u><br>哈弗的Cass Sunstein展示了如果我们被那些观点和我们一样的自己人包围,我们会变得极端<br><u>I think we need to renew those face-to-face encounters with the people not like us.</u><br>我认为我们需要重新和那些跟我们不一样的人面对面的接触.<br><u>I think we need to do that in order to realize that we can disagree strongly and yet still stay friends.</u><br>我认为我们需要这样做,为了我们能意识到强烈地争执也仍然可以当朋友.<br><u>It’s in those face-to-face encounters that we discover that the people not like us are just people like us.</u><br>在面对面的接触中我们发现那些和我们不同的人就是和我们一样的人<br><u>And actually, every time we hold out the hand of friendship to somebody not like us,whose class or creed or color are different from ours,</u><br>事实上,每一次,我们向那些和我们有不一样种族或者不一样信条或者不一样的肤色的人伸出友谊的手,<br><u>we heal one of the fractures of our wounded world.</u><br>我们治愈了我们破裂世界的一刀伤痕.<br><u>That is the us of relationship.</u><br>这就是我们的关系.<br><u>Second is the us of identity.</u><br>第二点是我们的身份.<br><u>Let me give you a thought experiment.</u><br>让我给你做个思维实验.<br><u>Have you been to Washington?</u><br>你去过Washington嘛?<br><u>Have tou seen the memorials?</u><br>你看过纪念碑嘛?<br><u>Absolutely fascinating.</u><br>绝对让人神魂颠倒.<br><u>There’s the Lincoln Memorial:Gettysburg Address on one side,Second Inaugural on the other.</u><br>在林肯纪念碑,一边是Gettysburg演说,另一边是Inaugural.<br><u>You go to the Jefferson Memorial,screeds of text.</u><br>你去Jefferson纪念碑,有一段话.<br><u>Martin Luther King Memorial,more than a dozen quotes from his speeches.</u><br>马丁路德金纪念碑,超过12条他演讲的引用.<br><u>I didn’t realize,in America you read memorials.</u><br>我不认为,你在美国会读这些纪念碑.<br><u>Now go to the equivalent in London in Parliament Square and you will see that the monument to David Lloyd George contains three words:David Lloyd George.</u><br>现在 一样去了伦敦的国会广场并且你会看到David Lloyd George的纪念碑上包含了三个单词:David Lloyd George.<br><u>Nelson Mandela gets two.</u><br>Nelson Mandela有两个<br><u>Churchill gets just one:Chuichill.</u><br>Churchill只有一个:Chuichill<br><u>Why the difference?</u><br>为什么会有这样的差异呢<br><u>I’ll tell you why the difference.</u><br>我来告诉你们为什么会有这样的差异.<br><u>Because America was from the outset a nation of wave after wave of immigrants,</u><br>因为美国是一个从一波又一波的移民开始的国家<br><u>so it had to create an identity which it did by telling a story which you learned at school, you read on memorials and you heard repeated in presidential inaugural addresses.</u><br>因此,它必须创造一个形象,那个形象可以通过你学校学到的故事,你在纪念碑上读到东西和你反复在总统开幕演讲中听到的故事来讲的.<br><u>Britain until recently wasn’t a nation of immigrants,</u><br>不列颠直到最近也不是一个移民国家,<br><u>so it could take identity for granted.</u><br>所以它可以认为形象是理所当然的.<br><u>The trouble is now that two tings have happened which shouldn’t have happened together.</u><br>麻烦的是现在两件不应该同时发生的事发生了.<br><u>The first thing is in the West we’ve stopped telling this story of who we are and why,even in America</u><br>第一件事是在西方,我们停止讲述我是谁还有为什么的故事了,甚至是美国<br><u>And at the same time,immigration is higher than it’s ever been before.</u><br>同时,移民人口变得比以前更高了.<br><u>So when you tell a story and your identity is strong,you can welcome the stranger,</u><br>因此,当你们讲述一个故事并且你们形象很强的时候,你们能欢迎那些陌生人<br><u>but when you stop telling the story,your identity gets weak and you fell threatened by the stranger.</u><br>但是,当你们停止讲述故事,你们的形象变弱了,并且你们感到了陌生人的威胁<br><u>And that’s bad.</u><br>那就糟了<br><u>I tell you,Jews have been scattered and dispersed and exiled for 2000 years.</u><br>我告诉你们,犹太人已经被分开,被分散并且被流亡了2000多年.<br><u>We never lost our identity.</u><br>我们从来没有失去我们的形象.<br><u>Why?Because at least once a year,on the festival of Passover,</u><br>为什么? 因为么每年至少一次,在Passover节<br><u>we told our story and we taught it to our children and we ate the unleavened bread of affliction and tasted the bitter herbs of slavery.</u><br>我们谈论我们的故事并且我们教它给我们的孩子,并且我们吃过还没发酵的苦的面包并且吃过奴隶制的苦.<br><u>So we never lost our identity.</u><br>所以我们从来没有丢失我们的形象.<br><u>I think collectively we’ve got to get back to telling our story,who we are,where we came from,what ideals by which we live.</u><br>我认为共同的,我们必须回到的我们的故事上来说,我们是谁,我们来自哪里,我们生活的理想是什么<br><u>And if that happens,we will become strong enough to welcome the stranger and say,</u><br>如果发生这样的事,我们会变得强壮的足够欢迎陌生人并且说<br><u>“Come and share our lives,share our stories,share our aspirations and dreams.”</u><br>“过来并且分享我们的生活,分享我们的故事,分享我们的愿望和梦想”.<br><u>That is the us of identity.</u><br>这就是我们的形象.<br><u>And finally,the us of responsibility.</u><br>最后,是我们的责任.<br><u>Do you know something?</u><br>你知道嘛?<br><u>My favorite phrase in all of politics,very American phrase,is:”We the people.”</u><br>我最喜欢的一句话在所有的政治言论中,一句非常美国的话,就是”我们人”<br><u>Why “we the people?”</u><br>为什么是”我们人”?<br><u>Because it says that we all share collective responsibility for our collective future.</u><br>因为它表达了我们分享所有集体的责任为了我们集体的未来.<br><u>And that’s how things really are and should be.</u><br>并且那就是应该有的样子<br><u>Have you noticed how magical thinking has taken over our politics?</u><br>你有没有注意到多少神奇的思想占据着我们的政治?<br><u>So we say, all you’ve got to do is elect this strong leader and he or she will solve all our problems for us.</u><br>因此我们说,我们都要去选一个强力的领导并且他会为我们解决我们的问题.<br><u>Believe me, that is magical thinking.</u><br>相信我,那是幻想.<br><u>And then we get the extremes:the far right,the far left,the extreme religious and extreme anti-religious,</u><br>当我们变得极端以后:极右,极左,极端宗教注意或者极端反宗教,<br><u>the far right dreaming of a golden age that never was,</u><br>极端的右派梦想着一个从未有过的黄金时代,<br><u>the far left dreaming of a utopia that never will be,</u><br>极端的左派梦想着一个从未出现过的乌托邦,<br><u>and the religious and anti-religious equally convinced that all it takes id God or the absence of God to save us from ourselves.</u><br>宗教和反宗教同意相信上帝或者没有上帝来拯救我们.<br><u>That,too,is magical thinking,</u><br>这是非常神奇的想法.<br><u>because the only people who will save us from ourselves is we the people,all of us together.</u><br>因为可以拯救我们只有我们自己,所有的我们一起.<br><u>And when we do that,and when we move from the politics of me to the politics of all of us together,</u><br>并且当我们去做,当我们从我的政治中到所有的我们的政治中<br><u>we rediscover those beautiful,counterintuitive truths:</u><br>我们重新发现了那些美丽的,与直觉相反的事实:<br><u>that a nation is strong when it cares for the weak,</u><br>当一个国家关注弱者的时候它是强大的,<br><u>that it becomes rich when it cares for the poor,</u><br>当一个国家关心穷人的时候它是富裕的,<br><u>it becomes invulnerable when it cares about the vulnerable.</u><br>当一个国家开始关心那些有弱点的人的时候,它是无懈可击的.<br><u>That is what makes great nations.</u><br>这就是伟大的国家的形成.<br><u>So here is my simple suggestion.</u><br>因此,这有一个我的简单简易<br><u>It might just change your life,</u><br>它也许可以改变你的生活,<br><u>and it might just help to begin to change the world.</u><br>它也许可以帮助开始改变这个世界<br><u>Do a search and replace operation one the text of your mind,</u><br>做一个搜索和替换操作,一是你心中的文字,<br><u>and wherever you encounter the word “self”, substitute the word “other”.</u><br>并且无论在哪你遇到了单词”自己”,替换成单词”其他人”<br><u>So instead of self-help,other-help;</u><br>替代”自我帮助”为”他人帮助”<br><u>instead of self-esteem,other-esteem.</u><br>替代”自我尊重”为”他人尊重”<br><u>And if you do that,you will begin to fell the power of what for me is one of the most moving sentences in all of religious literature.</u><br>如果你这么做,你会开始感受到力量,这力量对我来说就是所有宗教文学中最动人的句子之一<br><u>“Though I walk through the valley of the shadow of death,I will fear no evil,for you are with me.”</u><br>虽然我在死亡的阴影的深渊里走,但是我不会害怕邪恶,因为你和我在一起<br><u>We can face any future without fear so long as we know we will not face it alone.</u><br>我们能够不害怕面对任何我们知道的我们不能独自面对的未来<br><u>So for the sake of the future “you”,together let us strengthen the future “us”.</u><br>为了未来的”你”,让我们一起加固未来的”我们”</p><p><u>Thank you.</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;“These are the times” said Thomas Paine,”that try men’s souls.”&lt;/u&gt;&lt;br&gt;“这些时间考验着人们的灵魂”Thomas Paine说.&lt;br&gt;&lt;u&gt;And they’re trying ours now.
      
    
    </summary>
    
    
      <category term="英语" scheme="https://zhuyiting.xyz/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="TED" scheme="https://zhuyiting.xyz/tags/TED/"/>
    
  </entry>
  
  <entry>
    <title>嘉善立春</title>
    <link href="https://zhuyiting.xyz/2019/10/21/%E5%98%89%E5%96%84%E7%AB%8B%E6%98%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/21/嘉善立春/</id>
    <published>2019-10-21T09:06:16.000Z</published>
    <updated>2019-10-22T02:40:41.045Z</updated>
    
    <content type="html"><![CDATA[<p>节气之首是立春,<br>万物复苏很精神.<br>嘉善地方虽然小,<br>东西样样都不少.<br>初春温度还很低,<br>地嘉人善却不冷.<br>早晨起来还有露,<br>上学骑在阳光路.<br>几年发展太迅速,<br>日子过的真惬意.<br>不管我们去哪里,<br>嘉善永远是窝里.<br>车站路上哼小曲,<br>儿童公园有飞机.<br>白水塘里游大鱼,<br>大云还有巧克力.<br>西塘景区人密集,<br>灯火夜景很美丽.<br>现在还有新西塘,<br>小桥流水和人家.<br>看看嘉善的变化,<br>讲讲嘉善的闲话.<br>今年也要努努力,<br>明年定会更顺利.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;节气之首是立春,&lt;br&gt;万物复苏很精神.&lt;br&gt;嘉善地方虽然小,&lt;br&gt;东西样样都不少.&lt;br&gt;初春温度还很低,&lt;br&gt;地嘉人善却不冷.&lt;br&gt;早晨起来还有露,&lt;br&gt;上学骑在阳光路.&lt;br&gt;几年发展太迅速,&lt;br&gt;日子过的真惬意.&lt;br&gt;不管我们去哪里,&lt;br&gt;嘉善永远是
      
    
    </summary>
    
    
      <category term="生活方式" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="备忘录" scheme="https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>2019双十一攻略</title>
    <link href="https://zhuyiting.xyz/2019/10/21/2019%E5%8F%8C%E5%8D%81%E4%B8%80%E6%94%BB%E7%95%A5/"/>
    <id>https://zhuyiting.xyz/2019/10/21/2019双十一攻略/</id>
    <published>2019-10-21T01:49:00.000Z</published>
    <updated>2019-10-29T02:32:17.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h3><ol><li>每日任务领喵币</li><li>团队PK拉人助力</li></ol><h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><ol><li>每日任务领喵币</li><li>双十一7点领彩蛋</li><li>双十一7点钻石铂金会员领金手指</li></ol><h3 id="优酷"><a href="#优酷" class="headerlink" title="优酷"></a>优酷</h3><ol><li>每日进入APP获红包</li><li>每日视频观看3分钟获红包</li></ol><h3 id="UC"><a href="#UC" class="headerlink" title="UC"></a>UC</h3><ol><li>每日签到领红包</li><li>每日开启红包雨</li><li>每日可抽10次幸运好礼</li></ol><h3 id="高德"><a href="#高德" class="headerlink" title="高德"></a>高德</h3><ol><li>完成每日体验获红包</li></ol><h3 id="饿了吗"><a href="#饿了吗" class="headerlink" title="饿了吗"></a>饿了吗</h3><ol><li>每日心愿城打卡得红包</li><li>下单外卖获红包</li><li>每日三次掷骰子有机会获红包</li></ol><h3 id="口碑"><a href="#口碑" class="headerlink" title="口碑"></a>口碑</h3><ol><li>每日登陆领红包</li><li>掷骰子获得更多奖励</li><li>每天玩游戏5次可获得一个红包</li></ol><h3 id="飞猪"><a href="#飞猪" class="headerlink" title="飞猪"></a>飞猪</h3><ol><li>每日签到获红包</li><li>完成每日任务,打卡成功获红包</li></ol><h3 id="淘宝特价版"><a href="#淘宝特价版" class="headerlink" title="淘宝特价版"></a>淘宝特价版</h3><ol><li>登陆签到得红包</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;淘宝&quot;&gt;&lt;a href=&quot;#淘宝&quot; class=&quot;headerlink&quot; title=&quot;淘宝&quot;&gt;&lt;/a&gt;淘宝&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;每日任务领喵币&lt;/li&gt;
&lt;li&gt;团队PK拉人助力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;支付宝&quot;&gt;&lt;a href=&quot;#支付宝&quot;
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>延期年金现值的计算</title>
    <link href="https://zhuyiting.xyz/2019/10/20/%E8%8B%B1%E8%AF%AD%E7%BB%83%E4%B9%A001/"/>
    <id>https://zhuyiting.xyz/2019/10/20/英语练习01/</id>
    <published>2019-10-20T02:56:00.000Z</published>
    <updated>2019-10-29T02:35:43.326Z</updated>
    
    <content type="html"><![CDATA[<p>Oceanography has been defined as “The application of all sciences to the study of the sea”.<br><font color="red">{Oceanography:海洋学}<br>海洋学已经被定义为”所有科学的应用来进行海洋的学习”.<br></font></p><p>Before the nineteenth century ,scientists with an interest in the sea were few and far between.<br><font color="red">在19世纪之前,对海洋有兴趣的科学家们是很少并且距离很远的.<br></font></p><p>Certainly Newton considered some theoretical aspects of it in his writings ,but he was reluctant to go to sea to further his work.<br><font color="red">{consider:认为,Certainly:当然啦,theoretical:理论上的,aspect:方面,reluctant:不情愿的}<br>当然啦,牛顿在他写下的内容中考虑到一些理论上的方面,但是他是不情愿的去海洋去更进一步他的工作<br></font></p><p>For most people the sea was remote, and with the exception of early intercontinental travelers or others who earned a living from the sea ,there was little reason to ask many questions about it ,let alone to ask what lay beneath the surface.<br><font color="red">{remote:遥远的,intercontinental:洲际的,let alone:更不必说}<br>因为对于很多人海洋是遥远的,除了早期的洲际航行中的从海洋中获得生活的人,有很少的理由来问这些问题,更不必说去问在表面之下的是什么了.<br></font></p><p>The first time that the question ”what is at the bottom of the oceans? ”had to be answered with any commercial consequence was when the laying of a telegraph cable from Europe to America was proposed.<br><font color="red">{commercial:商业的}<br>第一次”海洋的底部是什么?”这个问题必须被回答伴随着商业结果是在电话线缆要躺在欧洲到美国被提出的时候<br></font></p><p>The engineers had to know the depth profile of the route to estimate the length of cable that had to be manufactured.<br><font color="red">{estimate:估计}<br>工程师必须知道路径的深度轮廓来估算必须被人造的线缆的长度<br></font></p><p>It was to Maury of the US Navy that the Atlantic Telegraph Company turned, in 1853, for information on this matter.<br><font color="red"><br>在1853年,大西洋电报公司转向了美国海军的莫里,为了在这件事情上的信息<br></font></p><p>In the 1840s, Maury had been responsible for encouraging voyages during which soundings were taken to investigate the depths of the North Atlantic and Pacific Oceans.<br><font color="red">{investigate:调查}<br>在1840年代,莫里是负责的为了鼓励航海在这个声音被用来调查大西洋和太平痒的深度的时期<br></font></p><p>Later, some of his findings aroused much popular interest in his book The Physical Geography of the Sea.<br><font color="red">{arouse:引起}<br>之后,他的发现的在他的《The Physical Geography of the Sea》书里的一些事引起了很大的兴趣<br></font></p><p>The cable was laid, but not until 1866 was the connection made permanent and reliable.<br><font color="red"><br></font></p><p>At the early attempts, the cable failed and when it was taken out for repairs it was found to be covered in living growths, a fact which defied contemporary scientific opinion that there was no life in the deeper parts of the sea.<br><font color="red"><br></font></p><p>Within a few years oceanography was under way.<br><font color="red"><br></font></p><p>In 1872 Thomson led a scientific expedition, which lasted four years and brought home thousands of samples from the sea.<br><font color="red"><br></font></p><p>Their classification and analysis occupied scientists for years and led to a five-volume report, the last volume being published in 1895.<br><font color="red"><br></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Oceanography has been defined as “The application of all sciences to the study of the sea”.&lt;br&gt;&lt;font color=&quot;red&quot;&gt;{Oceanography:海洋学}&lt;br&gt;海洋
      
    
    </summary>
    
    
      <category term="英语" scheme="https://zhuyiting.xyz/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="练习" scheme="https://zhuyiting.xyz/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>延期年金现值的计算</title>
    <link href="https://zhuyiting.xyz/2019/10/18/%E5%BB%B6%E6%9C%9F%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://zhuyiting.xyz/2019/10/18/延期年金现值的计算/</id>
    <published>2019-10-18T01:56:00.000Z</published>
    <updated>2019-10-29T02:32:30.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="延期年金"><a href="#延期年金" class="headerlink" title="延期年金"></a>延期年金</h2><p>==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.<br>==延期年金现值计算==假定最初又m期没有收付款项,后面n期每年有等额的系列收付款项,则此延期年金的现值即为后n期年金先折现至n期期初(m期期末),再折现至第一期期初的现值.</p><p>==年金==是指定期定额的收付款项</p><p>==现值==成本或收益的价值以今天的现金来计量时,称为现值</p><p>==终值==是指现在某一时点上的一定量现金折合到未来的价值</p><ol><li>延期年金的==终值==大小和延期数m无关<br>所以延期m期之后的n期年金终值为<br>$ F=A\frac{(1+i)^n-1}{i} $</li><li>普通年金的==现值==计算<br>$ P=A\frac{1-\frac{1}{(1+i)^n}}{i}$</li><li>==延期年金==的现值计算<br>延期年金的现值与延期数m相关,m越长,现值越低.<ul><li>方法一:先当成n期普通年金,求出现值P1,在将P作为第m期终值,再折现到第一期的现值P2<br>$P1=A\frac{1-\frac{1}{(1+i)^n}}{i}$<br>$P2=P1\frac{1-\frac{1}{(1+i)^m}}{i} $</li><li>方法二:先计算m+n期现值,再减去m期年金现值<br>$P=A(\frac{1-\frac{1}{(1+i)^m(1+i)^n}}{i}-\frac{1-\frac{1}{(1+i)^m}}{i}) $</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;延期年金&quot;&gt;&lt;a href=&quot;#延期年金&quot; class=&quot;headerlink&quot; title=&quot;延期年金&quot;&gt;&lt;/a&gt;延期年金&lt;/h2&gt;&lt;p&gt;==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.&lt;br&gt;==延期年
      
    
    </summary>
    
    
      <category term="生活" scheme="https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活技巧" scheme="https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JVM指令手册</title>
    <link href="https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://zhuyiting.xyz/2019/07/30/JVM指令手册/</id>
    <published>2019-07-30T07:18:00.000Z</published>
    <updated>2019-10-20T00:56:02.507Z</updated>
    
    <content type="html"><![CDATA[<p>栈和局部变量操作<br>将常量压入栈的指令<br>aconst_null 将null对象引用压入栈<br>iconst_m1 将int类型常量-1压入栈<br>iconst_0 将int类型常量0压入栈<br>iconst_1 将int类型常量1压入栈<br>iconst_2 将int类型常量2压入栈<br>iconst_3 将int类型常量3压入栈<br>iconst_4 将int类型常量4压入栈<br>iconst_5 将int类型常量5压入栈<br>lconst_0 将long类型常量0压入栈<br>lconst_1 将long类型常量1压入栈<br>fconst_0 将float类型常量0压入栈<br>fconst_1 将float类型常量1压入栈<br>dconst_0 将double类型常量0压入栈<br>dconst_1 将double类型常量1压入栈<br>bipush 将一个8位带符号整数压入栈<br>sipush 将16位带符号整数压入栈<br>ldc 把常量池中的项压入栈<br>ldc_w 把常量池中的项压入栈（使用宽索引）<br>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）<br>从栈中的局部变量中装载值的指令<br>iload 从局部变量中装载int类型值<br>lload 从局部变量中装载long类型值<br>fload 从局部变量中装载float类型值<br>dload 从局部变量中装载double类型值<br>aload 从局部变量中装载引用类型值（refernce）<br>iload_0 从局部变量0中装载int类型值<br>iload_1 从局部变量1中装载int类型值<br>iload_2 从局部变量2中装载int类型值<br>iload_3 从局部变量3中装载int类型值<br>lload_0 从局部变量0中装载long类型值<br>lload_1 从局部变量1中装载long类型值<br>lload_2 从局部变量2中装载long类型值<br>lload_3 从局部变量3中装载long类型值<br>fload_0 从局部变量0中装载float类型值<br>fload_1 从局部变量1中装载float类型值<br>fload_2 从局部变量2中装载float类型值<br>fload_3 从局部变量3中装载float类型值<br>dload_0 从局部变量0中装载double类型值<br>dload_1 从局部变量1中装载double类型值<br>dload_2 从局部变量2中装载double类型值<br>dload_3 从局部变量3中装载double类型值<br>aload_0 从局部变量0中装载引用类型值<br>aload_1 从局部变量1中装载引用类型值<br>aload_2 从局部变量2中装载引用类型值<br>aload_3 从局部变量3中装载引用类型值<br>iaload 从数组中装载int类型值<br>laload 从数组中装载long类型值<br>faload 从数组中装载float类型值<br>daload 从数组中装载double类型值<br>aaload 从数组中装载引用类型值<br>baload 从数组中装载byte类型或boolean类型值<br>caload 从数组中装载char类型值<br>saload 从数组中装载short类型值<br>将栈中的值存入局部变量的指令<br>istore 将int类型值存入局部变量<br>lstore 将long类型值存入局部变量<br>fstore 将float类型值存入局部变量<br>dstore 将double类型值存入局部变量<br>astore 将将引用类型或returnAddress类型值存入局部变量<br>istore_0 将int类型值存入局部变量0<br>istore_1 将int类型值存入局部变量1<br>istore_2 将int类型值存入局部变量2<br>istore_3 将int类型值存入局部变量3<br>lstore_0 将long类型值存入局部变量0<br>lstore_1 将long类型值存入局部变量1<br>lstore_2 将long类型值存入局部变量2<br>lstore_3 将long类型值存入局部变量3<br>fstore_0 将float类型值存入局部变量0<br>fstore_1 将float类型值存入局部变量1<br>fstore_2 将float类型值存入局部变量2<br>fstore_3 将float类型值存入局部变量3<br>dstore_0 将double类型值存入局部变量0<br>dstore_1 将double类型值存入局部变量1<br>dstore_2 将double类型值存入局部变量2<br>dstore_3 将double类型值存入局部变量3<br>astore_0 将引用类型或returnAddress类型值存入局部变量0<br>astore_1 将引用类型或returnAddress类型值存入局部变量1<br>astore_2 将引用类型或returnAddress类型值存入局部变量2<br>astore_3 将引用类型或returnAddress类型值存入局部变量3<br>iastore 将int类型值存入数组中<br>lastore 将long类型值存入数组中<br>fastore 将float类型值存入数组中<br>dastore 将double类型值存入数组中<br>aastore 将引用类型值存入数组中<br>bastore 将byte类型或者boolean类型值存入数组中<br>castore 将char类型值存入数组中<br>sastore 将short类型值存入数组中<br>wide指令<br>wide 使用附加字节扩展局部变量索引<br>通用(无类型）栈操作<br>nop 不做任何操作<br>pop 弹出栈顶端一个字长的内容<br>pop2 弹出栈顶端两个字长的内容<br>dup 复制栈顶部一个字长内容<br>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈<br>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2 复制栈顶部两个字长内容<br>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈<br>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈<br>swap 交换栈顶部两个字长内容<br>类型转换<br>i2l 把int类型的数据转化为long类型<br>i2f 把int类型的数据转化为float类型<br>i2d 把int类型的数据转化为double类型<br>l2i 把long类型的数据转化为int类型<br>l2f 把long类型的数据转化为float类型<br>l2d 把long类型的数据转化为double类型<br>f2i 把float类型的数据转化为int类型<br>f2l 把float类型的数据转化为long类型<br>f2d 把float类型的数据转化为double类型<br>d2i 把double类型的数据转化为int类型<br>d2l 把double类型的数据转化为long类型<br>d2f 把double类型的数据转化为float类型<br>i2b 把int类型的数据转化为byte类型<br>i2c 把int类型的数据转化为char类型<br>i2s 把int类型的数据转化为short类型<br>整数运算<br>iadd 执行int类型的加法<br>ladd 执行long类型的加法<br>isub 执行int类型的减法<br>lsub 执行long类型的减法<br>imul 执行int类型的乘法<br>lmul 执行long类型的乘法<br>idiv 执行int类型的除法<br>ldiv 执行long类型的除法<br>irem 计算int类型除法的余数<br>lrem 计算long类型除法的余数<br>ineg 对一个int类型值进行取反操作<br>lneg 对一个long类型值进行取反操作<br>iinc 把一个常量值加到一个int类型的局部变量上<br>逻辑运算<br>移位操作<br>ishl 执行int类型的向左移位操作<br>lshl 执行long类型的向左移位操作<br>ishr 执行int类型的向右移位操作<br>lshr 执行long类型的向右移位操作<br>iushr 执行int类型的向右逻辑移位操作<br>lushr 执行long类型的向右逻辑移位操作<br>按位布尔运算<br>iand 对int类型值进行“逻辑与”操作<br>land 对long类型值进行“逻辑与”操作<br>ior 对int类型值进行“逻辑或”操作<br>lor 对long类型值进行“逻辑或”操作<br>ixor 对int类型值进行“逻辑异或”操作<br>lxor 对long类型值进行“逻辑异或”操作<br>浮点运算<br>fadd 执行float类型的加法<br>dadd 执行double类型的加法<br>fsub 执行float类型的减法<br>dsub 执行double类型的减法<br>fmul 执行float类型的乘法<br>dmul 执行double类型的乘法<br>fdiv 执行float类型的除法<br>ddiv 执行double类型的除法<br>frem 计算float类型除法的余数<br>drem 计算double类型除法的余数<br>fneg 将一个float类型的数值取反<br>dneg 将一个double类型的数值取反<br>对象和数组<br>对象操作指令<br>new 创建一个新对象<br>checkcast 确定对象为所给定的类型<br>getfield 从对象中获取字段<br>putfield 设置对象中字段的值<br>getstatic 从类中获取静态字段<br>putstatic 设置类中静态字段的值<br>instanceof 判断对象是否为给定的类型<br>数组操作指令<br>newarray 分配数据成员类型为基本上数据类型的新数组<br>anewarray 分配数据成员类型为引用类型的新数组<br>arraylength 获取数组长度<br>multianewarray 分配新的多维数组<br>控制流<br>条件分支指令<br>ifeq 如果等于0，则跳转<br>ifne 如果不等于0，则跳转<br>iflt 如果小于0，则跳转<br>ifge 如果大于等于0，则跳转<br>ifgt 如果大于0，则跳转<br>ifle 如果小于等于0，则跳转<br>if_icmpcq 如果两个int值相等，则跳转<br>if_icmpne 如果两个int类型值不相等，则跳转<br>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转<br>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转<br>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转<br>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转<br>ifnull 如果等于null，则跳转<br>ifnonnull 如果不等于null，则跳转<br>if_acmpeq 如果两个对象引用相等，则跳转<br>if_acmpnc 如果两个对象引用不相等，则跳转<br>比较指令<br>lcmp 比较long类型值<br>fcmpl 比较float类型值（当遇到NaN时，返回-1）<br>fcmpg 比较float类型值（当遇到NaN时，返回1）<br>dcmpl 比较double类型值（当遇到NaN时，返回-1）<br>dcmpg 比较double类型值（当遇到NaN时，返回1）<br>无条件转移指令<br>goto 无条件跳转<br>goto_w 无条件跳转（宽索引）<br>表跳转指令<br>tableswitch 通过索引访问跳转表，并跳转<br>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作<br>异常<br>athrow 抛出异常或错误<br>finally子句<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>rct 从子例程返回<br>方法调用与返回<br>方法调用指令<br>invokcvirtual 运行时按照对象的类来调用实例方法<br>invokespecial 根据编译时类型来调用实例方法<br>invokestatic 调用类（静态）方法<br>invokcinterface 调用接口方法<br>方法返回指令<br>ireturn 从方法中返回int类型的数据<br>lreturn 从方法中返回long类型的数据<br>freturn 从方法中返回float类型的数据<br>dreturn 从方法中返回double类型的数据<br>areturn 从方法中返回引用类型的数据<br>return 从方法中返回，返回值为void<br>线程同步<br>montiorenter 进入并获取对象监视器<br>monitorexit 释放并退出对象监视器</p><hr><p>JVM指令助记符<br>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_<br>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_<br>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_<br>加：iadd,ladd,fadd,dadd<br>减：isub,lsub,fsub,dsub<br>乘：imul,lmul,fmul,dmul<br>除：idiv,ldiv,fdiv,ddiv<br>余数：irem,lrem,frem,drem<br>取负：ineg,lneg,fneg,dneg<br>移位：ishl,lshr,iushr,lshl,lshr,lushr<br>按位或：ior,lor<br>按位与：iand,land<br>按位异或：ixor,lxor<br>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)<br>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)<br>创建类实便：new<br>创建新数组：newarray,anewarray,multianwarray<br>访问类的域和类实例域：getfield,putfield,getstatic,putstatic<br>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload<br>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore<br>获取数组长度：arraylength<br>检相类实例或数组属性：instanceof,checkcast<br>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap<br>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,<br>if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl<br>fcmpg,dcmpl,dcmpg<br>复合条件转移：tableswitch,lookupswitch<br>无条件转移：goto,goto_w,jsr,jsr_w,ret<br>调度对象的实便方法：invokevirtual<br>调用由接口实现的方法：invokeinterface<br>调用需要特殊处理的实例方法：invokespecial<br>调用命名类中的静态方法：invokestatic<br>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return<br>异常：athrow<br>finally关键字的实现使用：jsr,jsr_w,ret</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;栈和局部变量操作&lt;br&gt;将常量压入栈的指令&lt;br&gt;aconst_null 将null对象引用压入栈&lt;br&gt;iconst_m1 将int类型常量-1压入栈&lt;br&gt;iconst_0 将int类型常量0压入栈&lt;br&gt;iconst_1 将int类型常量1压入栈&lt;br&gt;iconst_
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>maven项目构建工具</title>
    <link href="https://zhuyiting.xyz/2018/04/10/maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>https://zhuyiting.xyz/2018/04/10/maven项目构建工具/</id>
    <published>2018-04-10T00:33:00.000Z</published>
    <updated>2019-10-25T08:40:26.807Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Maven是什么"><a href="#1-Maven是什么" class="headerlink" title="1. Maven是什么?"></a>1. Maven是什么?</h4><p>Maven是一个用于构建项目包依赖的工具<br>它可以帮助统一维护项目中的jar包, 它把所有包都放在了仓库中,项目如果需要用到包,只需要引入jar包和对应的版本号就行了<br>这样只需要在本地配置好一个仓库,所有的项目都可以引入,不需要再把包复制到每个项目当中了.</p><h4 id="2-Maven的安装和配置"><a href="#2-Maven的安装和配置" class="headerlink" title="2.Maven的安装和配置"></a>2.Maven的安装和配置</h4><ol><li>从官网下载最新版本的maven,下载完后,解压到本地</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Maven是什么&quot;&gt;&lt;a href=&quot;#1-Maven是什么&quot; class=&quot;headerlink&quot; title=&quot;1. Maven是什么?&quot;&gt;&lt;/a&gt;1. Maven是什么?&lt;/h4&gt;&lt;p&gt;Maven是一个用于构建项目包依赖的工具&lt;br&gt;它可以帮助统一维护项
      
    
    </summary>
    
    
      <category term="工具" scheme="https://zhuyiting.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="项目构建" scheme="https://zhuyiting.xyz/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>GitHub使用</title>
    <link href="https://zhuyiting.xyz/2018/04/03/GitHub%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhuyiting.xyz/2018/04/03/GitHub使用/</id>
    <published>2018-04-03T09:33:00.000Z</published>
    <updated>2019-10-24T12:42:40.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>GitHub可以用来托管代码,也可以用来进行版本控制,它相比与其他版本控制工具的优势在于,可以非常方便的进行分支操作</p><h4 id="1-注册账户"><a href="#1-注册账户" class="headerlink" title="1.注册账户"></a>1.注册账户</h4><h4 id="2-新建一个仓库-repository"><a href="#2-新建一个仓库-repository" class="headerlink" title="2.新建一个仓库(repository)"></a>2.新建一个仓库(repository)</h4><p><img src="/2018/04/03/GitHub%E4%BD%BF%E7%94%A8/newRepo.png" alt="新建仓库"></p><h4 id="3-配置GitHub公钥"><a href="#3-配置GitHub公钥" class="headerlink" title="3.配置GitHub公钥"></a>3.配置GitHub公钥</h4><p>在Git终端输入<code>ssh-keygen -t rsa -C &quot;email@email.com&quot;</code><br>在系统用户下的<code>/.ssh</code>目录,找到<code>id_rsa.pub</code>文件,其中存放的就是秘钥.</p><p>再进入github个人设置,选择SSH and GPG keys,将<code>id_rsa.pub</code>文件中的内容复制进去<br>如:<br><img src="/2018/04/03/GitHub%E4%BD%BF%E7%94%A8/setSSHKey.png" alt="设置秘钥"></p><h4 id="4-clone仓库"><a href="#4-clone仓库" class="headerlink" title="4. clone仓库"></a>4. clone仓库</h4><p>使用 <code>git clone &lt;项目链接&gt;</code><br>将github仓库克隆到本地</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GitHub&quot;&gt;&lt;a href=&quot;#GitHub&quot; class=&quot;headerlink&quot; title=&quot;GitHub&quot;&gt;&lt;/a&gt;GitHub&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="工具" scheme="https://zhuyiting.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本控制" scheme="https://zhuyiting.xyz/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="代码托管" scheme="https://zhuyiting.xyz/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Git简单教程</title>
    <link href="https://zhuyiting.xyz/2018/03/31/Git%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2018/03/31/Git简单教程/</id>
    <published>2018-03-31T00:33:00.000Z</published>
    <updated>2019-10-21T08:00:57.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git?"></a>什么是Git?</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><h3 id="Git在Windows的安装和配置"><a href="#Git在Windows的安装和配置" class="headerlink" title="Git在Windows的安装和配置"></a>Git在Windows的安装和配置</h3><p>安装包下载地址：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p><p>在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><p>配置个人的用户名称和电子邮件地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --g user.name &quot;yanchengjie&quot;</span><br><span class="line">git config --g user.email ycj996425271@live.com</span><br></pre></td></tr></table></figure><h4 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h4><p>要检查已有的配置信息，可以使用 git config –list 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="Git的工作流程"><a href="#Git的工作流程" class="headerlink" title="Git的工作流程"></a>Git的工作流程</h3><p>Git工作的一般流程为:</p><ol><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ol><h3 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h3><p><strong>工作区</strong>：就是你在电脑里能看到的目录。<br><strong>暂存区</strong>：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><h3 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h3><p>Git 使用 <code>git init</code> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <code>git init</code> 是使用 Git 的第一个命令。</p><h3 id="Git克隆仓库"><a href="#Git克隆仓库" class="headerlink" title="Git克隆仓库"></a>Git克隆仓库</h3><p>我们使用 git clone 从现有 Git 仓库中拷贝项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/XXXX/XXX</span><br></pre></td></tr></table></figure><h3 id="Git添加文件到缓存"><a href="#Git添加文件到缓存" class="headerlink" title="Git添加文件到缓存"></a>Git添加文件到缓存</h3><p>使用命令 <code>git add &lt;fileName&gt;</code></p><h3 id="Git移除缓存中的文件"><a href="#Git移除缓存中的文件" class="headerlink" title="Git移除缓存中的文件"></a>Git移除缓存中的文件</h3><p>使用命令 <code>git rm &lt;fileName&gt;</code></p><h3 id="Git将缓存区添加到仓库"><a href="#Git将缓存区添加到仓库" class="headerlink" title="Git将缓存区添加到仓库"></a>Git将缓存区添加到仓库</h3><p>使用命令<code>git commit -m &quot;备注信息&quot;</code></p><h3 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h3><p>列出分支命令:<code>git branch</code>(master为主分支)<br>创建分支命令:<code>git branch (branchName)</code><br>切换分支命令:<code>git checkout (branchNaem)</code><br>删除分支命令:<code>git branch -d (branchName)</code><br>合并分支命令:<code>git merge (branchName)</code></p><h3 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h3><p>使用命令 <code>git log</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Git&quot;&gt;&lt;a href=&quot;#什么是Git&quot; class=&quot;headerlink&quot; title=&quot;什么是Git?&quot;&gt;&lt;/a&gt;什么是Git?&lt;/h3&gt;&lt;p&gt;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="工具" scheme="https://zhuyiting.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="版本控制" scheme="https://zhuyiting.xyz/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://zhuyiting.xyz/2018/03/05/Ajax/"/>
    <id>https://zhuyiting.xyz/2018/03/05/Ajax/</id>
    <published>2018-03-05T08:25:00.000Z</published>
    <updated>2019-10-21T08:35:18.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h3 id="1-Ajax的作用"><a href="#1-Ajax的作用" class="headerlink" title="1.Ajax的作用"></a>1.Ajax的作用</h3><p>获取服务器的数据</p><h3 id="2-Ajax的效果"><a href="#2-Ajax的效果" class="headerlink" title="2.Ajax的效果"></a>2.Ajax的效果</h3><p>在不刷新整个页面的情况下,通过一个url地址获取服务器的数据,然后进行页面的局部刷新. 异布加载,</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h3><p>Ajax的全称: Asychronous JavaScript And XML,就是使用js代码获取服务器数据.      </p><h3 id="4-Ajax的使用"><a href="#4-Ajax的使用" class="headerlink" title="4.Ajax的使用"></a>4.Ajax的使用</h3><p>Ajax简单的来说,就是一个异布的JavaScript请求,用来获取后台服务端的数据,而并不是整个界面进行跳转.    </p><p> 在元素js中来实现AJax主要的类就是XMLHttpRequest,它的使用一般有四个步骤;</p><ol><li>创建XMLHttpRequest对象</li><li>准备发送网络请求</li><li>开始发送网络请求</li><li>指定回调函数</li></ol><p><strong>注意:</strong> </p><blockquote></blockquote><ol><li>需要注意兼容处理.低版本浏览器不支持XMLHttpRequest对象,需要创建ActiveXObject对象;</li><li>指定请求方式,请求地址以及指定是否异步刷新</li><li>执行发送,<strong>POST请求方式</strong>时,数据不写在地址中,放在请求数据体中.需要发送给服务器,同时设置请求头</li><li>异步的原理是通过请求浏览器进行网络数据的请求   </li></ol><h3 id="5-数据格式"><a href="#5-数据格式" class="headerlink" title="5. 数据格式"></a>5. 数据格式</h3><ol><li>Xml数据格式<br>Xml数据格式是将数据以标签的方式进行组装,必须以<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</code>开头,标签必须成对出现,xml是一个通用标准,任何人都知道如何解析它;</li></ol><p><strong>缺点:</strong>体积太大,传播慢,元数据太多,解析不方便,目前使用很少    </p><ol start="2"><li>JSON数据格式<br>Json数据格式类似于js中的对象方式,通过key-value的形式组装,是一个通用的标准,任何人都知道如何解析它;</li></ol><p><strong>优点:</strong>体积小,传输快,解析方便    </p><ol start="3"><li>解析Xml数据格式<br>获取Xml对象,在通过getElementsBtTagName获取标签内元素<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=xhr.responseXML;</span><br><span class="line"><span class="keyword">var</span> books=result.getElementsByTagName(<span class="string">"booklist"</span>)[<span class="number">0</span>].getElementsByTagName(<span class="string">"book"</span>);</span><br><span class="line"><span class="keyword">var</span> newHtml=<span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;books.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> itemBook=books[i];</span><br><span class="line"><span class="keyword">var</span> name=itemBook.getElementsByTagName(<span class="string">"name"</span>)[<span class="number">0</span>].textContent;</span><br><span class="line"><span class="keyword">var</span> author=itemBook.getElementsByTagName(<span class="string">"author"</span>)[<span class="number">0</span>].textContent;</span><br><span class="line"><span class="keyword">var</span> desc=itemBook.getElementsByTagName(<span class="string">"desc"</span>)[<span class="number">0</span>].textContent;</span><br><span class="line"><span class="keyword">var</span> tempHtml=<span class="string">"&lt;tr&gt;&lt;td&gt;"</span>+name+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+author+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+desc+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>;</span><br><span class="line">newHtml += tempHtml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml = newHtml;</span><br></pre></td></tr></table></figure></li><li>解析Json数据格式<br>获取Json对象,再通过对象直接获取对象的属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=xhr.responseTest;</span><br><span class="line"><span class="comment">//responseTest获取的是字符串,要转换成JSON对象</span></span><br><span class="line">result=<span class="built_in">JSON</span>.parse(result);</span><br><span class="line"><span class="keyword">var</span> newHtml=<span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> item=result[i];</span><br><span class="line"><span class="keyword">var</span> name=item.name;</span><br><span class="line"><span class="keyword">var</span> author=item.author;</span><br><span class="line"><span class="keyword">var</span> desc=item.desc;</span><br><span class="line"><span class="keyword">var</span> tempHtml=<span class="string">"&lt;tr&gt;&lt;td&gt;"</span>+name+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+author+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+desc+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>;</span><br><span class="line">newHtml += tempHtml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bookContariner"</span>).innerHtml = newHtml;</span><br></pre></td></tr></table></figure><h3 id="6-封装Ajax"><a href="#6-封装Ajax" class="headerlink" title="6.封装Ajax"></a>6.封装Ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span>(<span class="params">type,url,params,callback,async</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="string">"get"</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(params &amp;&amp; params!=<span class="string">""</span>)&#123;</span><br><span class="line">url += <span class="string">"?"</span> + params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(type,url,<span class="keyword">async</span>);</span><br><span class="line"><span class="keyword">if</span>(type == <span class="string">"get"</span>)&#123;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">"post"</span>)&#123;</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Contend-Type"</span>,<span class="string">"application/x-www-from-urlencoded"</span>);</span><br><span class="line">xhr.send(params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">async</span>)&#123;</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(dataType == <span class="string">"json"</span>)&#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">result = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataType == <span class="string">"xml"</span>)&#123;</span><br><span class="line">result = xhr.responseXML;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(callback)&#123;</span><br><span class="line">callback(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(dataType == <span class="string">"json"</span>)&#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">result = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataType == <span class="string">"xml"</span>)&#123;</span><br><span class="line">result = xhr.responseXML;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">result = xhr.responseText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(callback)&#123;</span><br><span class="line">callback(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-用jQuery实现Ajax"><a href="#7-用jQuery实现Ajax" class="headerlink" title="7 用jQuery实现Ajax"></a>7 用jQuery实现Ajax</h3>jQuery对Ajex操作进行了封装,在jQuery中最底层的方法是<code>$.ajax()</code>,第二层是<code>$.load()</code>、<code>$.get()</code> 、<code>$.post()</code>  第三层是<code>$.getJSON()</code>、<code>$.getScript()</code></li></ol><ul><li><code>$.ajax()</code>用法:<ul><li><strong>type</strong>：指定数据提交的方式</li><li><strong>url</strong>：提交数据的路径</li><li><strong>cache</strong>:是否存在缓存</li><li><strong>data</strong>：向后台发送的数据</li><li><strong>dataType</strong>：服务器端返回的数据类型，比如：xml，text，json, html，script</li><li><strong>success</strong>：响应成功后执行的函数</li><li><strong>error</strong>：响应失败后执行的函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subData=&#123;</span><br><span class="line">name:<span class="string">'张三'</span></span><br><span class="line">&#125; <span class="comment">//提交的数据</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url : <span class="string">"IndexController/getIndexImages.html"</span>,</span><br><span class="line">type : <span class="string">"POST"</span>,</span><br><span class="line"><span class="keyword">async</span> : <span class="literal">true</span>,<span class="comment">//表示进行异步获取</span></span><br><span class="line">data:subData,<span class="comment">//提交的数据</span></span><br><span class="line">dataType : <span class="string">'json'</span>,</span><br><span class="line">contentType : <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>, <span class="comment">//contentType很重要   </span></span><br><span class="line">success : <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = $.parseJSON(result); </span><br><span class="line"><span class="comment">//在这里对返回的数据进行处理</span></span><br><span class="line">&#125;</span><br><span class="line">error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//请求失败执行这个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AJAX&quot;&gt;&lt;a href=&quot;#AJAX&quot; class=&quot;headerlink&quot; title=&quot;AJAX&quot;&gt;&lt;/a&gt;AJAX&lt;/h1&gt;&lt;h3 id=&quot;1-Ajax的作用&quot;&gt;&lt;a href=&quot;#1-Ajax的作用&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="前端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaScrpit" scheme="https://zhuyiting.xyz/tags/JavaScrpit/"/>
    
  </entry>
  
  <entry>
    <title>EL与JSTL表达式</title>
    <link href="https://zhuyiting.xyz/2018/01/30/EL%E4%B8%8EJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2018/01/30/EL与JSTL表达式/</id>
    <published>2018-01-30T06:15:00.000Z</published>
    <updated>2019-10-20T14:59:58.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式:"></a>EL表达式:</h4><p>EL表达式的功能:(让JSP编写更为简单)</p><ol><li>EL是Expression Language的简称，即表达式语言；</li><li>EL在JSP中使用，服务器会对其进行解析翻译，生成相应的Java代码；</li><li>EL的作用是用来在JSP页面输出动态内容，可以替代JSP中的表达式元素&lt;%=%&gt;</li></ol><p><strong>EL表达式的一般格式:</strong><br> <code>${EL表达式}</code><br>    例如:<code>${param.username}</code><br>    等同于:<code>&lt;%=request.getParameter(&quot;username&quot;)%&gt;</code></p><h4 id="EL表达式的内置对象"><a href="#EL表达式的内置对象" class="headerlink" title="EL表达式的内置对象:"></a>EL表达式的内置对象:</h4><p>其中</p><ul><li>2个内置对象为了方便输出请求参数： param/paramValues；<ul><li>内置对象param：用来输出请求参数的值，格式为${param.请求参数名字}</li><li>内置对象paramValues：用来获取一对多的参数值，返回一个数组。</li></ul></li><li>4个内置对象为了方便输出各个范围的属性： pageScope/ requestScope /sessionScope /applicationScope<ul><li>获取四个范围的属性数据</li><li>检索顺序：当不指定范围时，例如，${user.pwd}，将自动从pageScope开始查找，直到applicationScope，如果没查到，则什么也不显示</li></ul></li><li>2个与请求头有关的内置对象：header/headerValues<ul><li>内置对象header：用来输出输出某一个请求头的值，格式为${header.请求头名字}</li><li>内置对象headerValues：如果某个请求头的值有多个，则使用headerValues返回一个数组。</li></ul></li><li>2个其他内置对象：cookie/initParam<ul><li>内置对象cookie：用来获取cookie的值</li><li>内置对象initParam：用来输出上下文参数;</li></ul></li><li>1个特殊的内置对象pageContext<ul><li>内置对象pageContext：EL中的pageContext对象可以调用PageContext类中所有符合规范的getXxx方法</li></ul></li></ul><h4 id="使用-EL-取出内置对象的数据。"><a href="#使用-EL-取出内置对象的数据。" class="headerlink" title="使用 EL 取出内置对象的数据。"></a>使用 EL 取出内置对象的数据。</h4><ol><li>普通对象和对象属性。<br> 服务器端：<pre><code>`request.setAttribute(&quot;student&quot;, student);`</code></pre> 在浏览器上打印出服务器端绑定的数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; student &#125;  <span class="comment">&lt;!-- 相当于执行了 student.toString(); --&gt;</span></span><br><span class="line">$&#123; student.name &#125;  <span class="comment">&lt;!-- 相当于执行了 student.getName(); --&gt;</span></span><br><span class="line">$&#123; student.teacher.name &#125;  <span class="comment">&lt;!-- 相当于执行了 student.getTeacher().getName(); --&gt;</span></span><br></pre></td></tr></table></figure></li><li>数组中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] nameArray = <span class="keyword">new</span> String[]&#123;<span class="string">"Tom"</span>, <span class="string">"Lucy"</span>, <span class="string">"Lilei"</span>&#125;;</span><br><span class="line">request.setAttribute(“nameArray”,nameArray);</span><br><span class="line">Student[] students = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">students[<span class="number">0</span>] = stu1;</span><br><span class="line">students[<span class="number">1</span>] = stu2;</span><br><span class="line">students[<span class="number">2</span>] = stu3;</span><br><span class="line">request.setAttribute(“students”,students);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的数组数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123; nameArray[0] &#125;   <span class="comment">&lt;!-- Tom --&gt;</span></span><br><span class="line">$&#123; nameArray[1] &#125;   <span class="comment">&lt;!-- Lucy --&gt;</span></span><br><span class="line">$&#123; nameArray[2] &#125;   <span class="comment">&lt;!-- Lilei --&gt;</span></span><br><span class="line">$&#123; students[0].id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; students[1].name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">$&#123; students[2].teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure></li><li>List中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList=<span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">studentList.add(stu1);</span><br><span class="line">studentList.add(stu2);</span><br><span class="line">studentList.add(stu3);</span><br><span class="line">request.setAttribute(“studentList”,studentList);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的List数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; studentList[0].id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; studentList[1].name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">$&#123; studentList[2].teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure></li><li>Map中的数据。<br> 服务器端： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Student&gt; studentMap = <span class="keyword">new</span> HashMap&lt;String, Student&gt;();</span><br><span class="line">studentMap.put(<span class="string">"Tom"</span>, stu1);</span><br><span class="line">studentMap.put(<span class="string">"Lucy"</span>, stu2);</span><br><span class="line">studentMap.put(<span class="string">"Lilei"</span>, stu3);</span><br><span class="line">request.setAttribute(“studentMap”,studentMap);</span><br></pre></td></tr></table></figure> 在浏览器上打印出服务器端绑定的Map数据： <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123; studentMap.Tom.id &#125;   <span class="comment">&lt;!-- 输出第一个学生的ID --&gt;</span></span><br><span class="line">$&#123; studentMap.Lucy.name &#125;   <span class="comment">&lt;!-- 输出第二个学生的name --&gt;</span></span><br><span class="line">   $&#123; studentMap.Lilei.teacher.name &#125;   <span class="comment">&lt;!-- 输出第三个学生的老师的name --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符:"></a>EL运算符:</h4>EL中提供了多种运算符，可以对变量或常量进行运算，输出运算结果；<br>EL中的运算符包括：</li><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>其他运算符</li></ol><h4 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL:"></a>JSTL:</h4><p>JSTL是一套定义好的标签库，可以直接使用；<br>JSTL的全称是Jsp  Standard Tag Library，即JSP标准标签库；<br>JSTL包含很多标签，根据其作用可以分为：属性相关的标签、条件分支相关的标签、迭代标签、其他标签；<br>标签库包括标签处理器类及描述文件tld文件，JSTL也一样：</p><ul><li>使用JSTL首先需要下载相关的jar文件并保存到工程的lib目录下；在JSP中使用taglib指令引入需要使用的标签库；</li><li>forEach、set、if等是JSTL中常用的标签；</li><li>JSTL标签库的使用是为类弥补html表的不足，规范自定义标签的使用而诞生的。在告别modle1模式开发应用程序后，人们开始注重软件的分层设计，不希望在jsp页面中出现java逻辑代码，同时也由于自定义标签的开发难度较大和不利于技术标准化产生了自定义标签库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;EL表达式&quot;&gt;&lt;a href=&quot;#EL表达式&quot; class=&quot;headerlink&quot; title=&quot;EL表达式:&quot;&gt;&lt;/a&gt;EL表达式:&lt;/h4&gt;&lt;p&gt;EL表达式的功能:(让JSP编写更为简单)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EL是Expression Languag
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式</title>
    <link href="https://zhuyiting.xyz/2018/01/19/MVC%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2018/01/19/MVC模式/</id>
    <published>2018-01-19T06:15:00.000Z</published>
    <updated>2019-10-20T14:04:47.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MVC模式基本概念"><a href="#MVC模式基本概念" class="headerlink" title="MVC模式基本概念"></a>MVC模式基本概念</h4><p>MVC（Model-View-Controller）是一种软件架构设计模式，最初应用在桌面应用程序；</p><p>MVC模式将软件的代码按照模型（M）、视图（V）、控制器（C）三部分组织</p><p>MVC模式构建应用的优势:</p><ul><li>耦合性低：视图层和业务层分离，耦合性降低，可以独立修改；</li><li>重用性高：可以用不同的视图访问模型部分，实现在不同终端上访问应用；</li><li>可维护性高：视图与业务分离，降低了维护成本；</li></ul><h4 id="MVC模式中的三个角色"><a href="#MVC模式中的三个角色" class="headerlink" title="MVC模式中的三个角色:"></a>MVC模式中的三个角色:</h4><p>在控制器和视图之间共享数据:</p><ol><li>在控制器和视图之间，常常需要共享数据；例如从数据查出来的商品列表信息，需要从控制器发送到视图；</li><li>Servlet和JSP之间共享数据一般使用请求、会话、上下文范围的属性进行；</li><li>HttpServletRequest/HttpSession/ServletContext接口中都定义了存取、查询、删除属性的方法【前面已经学习过】；</li><li>使用原则：尽量用范围小的属性，即，请求范围内共享即可就用请求，以此类推；否则会造成资源浪费，降低安全性；</li></ol><h4 id="redirect-forward-include几种跳转方式的功能与差异"><a href="#redirect-forward-include几种跳转方式的功能与差异" class="headerlink" title="redirect\forward\include几种跳转方式的功能与差异:"></a>redirect\forward\include几种跳转方式的功能与差异:</h4><p>MVC模式中，控制器和视图之间需要进行跳转，Servlet规范中，有三种跳转方式：</p><ol><li>redirect：调用响应接口的sendRedirect方法，响应重定向，相当于重新请求新的资源，当前请求对象不会到目标资源；</li><li>forward: 调用请求转发器接口的forward方法，请求转发，将当前的请求、响应对象转发到目标资源；(最常用)</li><li>include：调用请求转发器接口的include方法，动态包含，将目标资源的请求、响应对象包含到当前资源；</li></ol><h4 id="forword带来的重复提交问题"><a href="#forword带来的重复提交问题" class="headerlink" title="forword带来的重复提交问题;"></a>forword带来的重复提交问题;</h4><ul><li><p>使用forward转发请求后，再次刷新当前页面，会进行重复提交；</p><ul><li>例如：使用LoginServlet进行登录，成功后跳转到loginsuccess.jsp页面：</li></ul></li><li><p>刷新当前页面，再次进行了登录</p></li><li><p>为了能够解决重复提交问题，关键在于：能够标志一次提交，从而识别出该提交已经处理；</p><ol><li>步骤一：在JSP中记录一个随机数，称为令牌（token），存储在session中<br><code>&lt;%session.setAttribute(&quot;token&quot;,System.nanoTime())+&quot;&quot;%&gt;</code></li><li>步骤二：将token值作为表单的一个隐藏域<br><code>&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;)%&gt;&quot; &gt;</code></li><li>步骤三：在LoginServlet中获取token值，并进行判断 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出存储在请求参数中的token</span></span><br><span class="line">String requestToken = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="comment">//取出存储在session中的token</span></span><br><span class="line">String sessionToken = (String)request.getSession().getAttribute(<span class="string">"token"</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li>步骤四：将token值从会话中删除 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getSession().removeAttribute(<span class="string">"token"</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MVC模式基本概念&quot;&gt;&lt;a href=&quot;#MVC模式基本概念&quot; class=&quot;headerlink&quot; title=&quot;MVC模式基本概念&quot;&gt;&lt;/a&gt;MVC模式基本概念&lt;/h4&gt;&lt;p&gt;MVC（Model-View-Controller）是一种软件架构设计模式，最初应用
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>系统开发和运行知识</title>
    <link href="https://zhuyiting.xyz/2018/01/13/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhuyiting.xyz/2018/01/13/系统开发和运行知识/</id>
    <published>2018-01-13T14:40:00.000Z</published>
    <updated>2019-10-19T00:10:01.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件工程、软件过程改进和软件开发项目管理知识"><a href="#1-软件工程、软件过程改进和软件开发项目管理知识" class="headerlink" title="1. 软件工程、软件过程改进和软件开发项目管理知识"></a>1. 软件工程、软件过程改进和软件开发项目管理知识</h3><ul><li>软件工程知识</li><li>软件开发生命周期各阶段的目标和任务</li><li>软件开发项目管理基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具</li><li>主要的软件开发方法（生命周期法、原型法、面向对象法、CASE）</li><li>软件开发工具与环境知识</li><li>软件过程改进知识</li><li>软件质量管理知识</li><li>软件开发过程评估、软件能力成熟评估基础知识<h3 id="2-系统分析基础知识"><a href="#2-系统分析基础知识" class="headerlink" title="2. 系统分析基础知识"></a>2. 系统分析基础知识</h3></li><li>系统分析的目的和任务</li><li>结构化分析方法（数据流图（DFD）、数据字典（DD）、实体关系图（ERD）、描述加工处理的结构化语言）</li><li>统一建模语言（UML）</li><li>系统规格说明书<h3 id="3-系统设计知识"><a href="#3-系统设计知识" class="headerlink" title="3. 系统设计知识"></a>3. 系统设计知识</h3></li><li>系统设计的目的和任务</li><li>结构化设计方法和工具（系统流程图、HIPO图、控制流程图）</li><li>系统总体结构设计（总体布局、设计原则、模块结构设计、数据存储设计、系统配置方案）</li><li>系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计）</li><li>系统设计说明书<h3 id="4-系统实施知识"><a href="#4-系统实施知识" class="headerlink" title="4. 系统实施知识"></a>4. 系统实施知识</h3></li><li>系统实施的主要任务</li><li>结构化程序设计、面向对象程序设计、可视化程序设计</li><li>程序设计风格</li><li>程序设计语言的选择</li><li>系统测试的目的、类型，系统测试方法（黑盒测试、白盒测试、灰盒测试）</li><li>测试设计和管理（错误曲线、错误排除、收敛、注入故障、测试用例设计、系统测试报告）</li><li>系统转换基础知识<h3 id="5-系统运行和维护知识"><a href="#5-系统运行和维护知识" class="headerlink" title="5. 系统运行和维护知识"></a>5. 系统运行和维护知识</h3></li><li>系统运行管理基础知识</li><li>系统维护基础知识</li><li>系统评价基础知识<h3 id="6-面向对象开发方法"><a href="#6-面向对象开发方法" class="headerlink" title="6. 面向对象开发方法"></a>6. 面向对象开发方法</h3></li><li>面向对象开发概念（类、对象、属性、封装性、继承性、多态性、对象之间的引用）</li><li>面向对象开发方法的优越性以及有效领域</li><li>面向对象设计方法（体系结构、类的设计、用户接口设计）</li><li>面向对象实现方法（选择程序设计语言、类的实现、方法的实现、用户接口的实现、准备测试数据）</li><li>面向对象程序设计语言（如C++、Java、Visual、Bsasic、Visual C++）的基本机制</li><li>面向对象数据库、分布式对象的概念</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;a href=&quot;#1-软件工程、软件过程改进和软件开发项目管理知识&quot; class=&quot;headerlink&quot; title=&quot;1. 软件工程、软件过程改进和软件开发项目管理知识&quot;&gt;&lt;/a&gt;1. 软件工程、软件过程改
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统知识</title>
    <link href="https://zhuyiting.xyz/2017/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhuyiting.xyz/2017/12/30/计算机系统知识/</id>
    <published>2017-12-30T14:36:00.000Z</published>
    <updated>2019-10-19T00:09:45.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-硬件知识"><a href="#1-硬件知识" class="headerlink" title="1. 硬件知识"></a>1. 硬件知识</h3><h4 id="1-1-计算机系统的组成、体系结构分类及特性"><a href="#1-1-计算机系统的组成、体系结构分类及特性" class="headerlink" title="1.1 计算机系统的组成、体系结构分类及特性"></a>1.1 计算机系统的组成、体系结构分类及特性</h4><ul><li>CPU和存储器的组成、性能和基本工作原理</li><li>常用I/O设备、通信设备的性能，以及基本工作原理</li><li>I/O接口的功能、类型和特性</li><li>I/O控制方式（中断系统、DMA、I/O处理机方式）</li><li>CISC/RISC，流水线操作，多处理机，并行处理<h4 id="1-2-存储系统"><a href="#1-2-存储系统" class="headerlink" title="1.2 存储系统"></a>1.2 存储系统</h4></li><li>主存-Cache存储系统的工作原理</li><li>虚拟存储器基本工作原理，多级存储体系的性能价格</li><li>RAID类型和特性<h4 id="1-3-安全性、可靠性与系统性能评测基础知识"><a href="#1-3-安全性、可靠性与系统性能评测基础知识" class="headerlink" title="1.3 安全性、可靠性与系统性能评测基础知识"></a>1.3 安全性、可靠性与系统性能评测基础知识</h4></li><li>诊断与容错</li><li>系统可靠性分析评价</li><li>计算机系统性能评测方式<h3 id="2-软件知识"><a href="#2-软件知识" class="headerlink" title="2. 软件知识"></a>2. 软件知识</h3><h4 id="2-1-操作系统知识"><a href="#2-1-操作系统知识" class="headerlink" title="2.1 操作系统知识"></a>2.1 操作系统知识</h4></li><li>操作系统的内核（中断控制）、进程、线程概念</li><li>处理机管理（状态转换、共享与互斥、分时轮转、抢占、死锁）</li><li>存储管理（主存保护、动态连接分配、分段、分页、虚存）</li><li>设备管理（I/O控制、假脱机）</li><li>文件管理（文件目录、文件组织、存取方法、存取控制、恢复处理）</li><li>作业管理（作业调度、作业控制语言（JCL）、多道程序设计）</li><li>汉字处理，多媒体处理，人机界面</li><li>网络操作系统和嵌入式操作系统基础知识</li><li>操作系统的配置<h4 id="2-2-程序设计语言和语言处理程序的知识"><a href="#2-2-程序设计语言和语言处理程序的知识" class="headerlink" title="2.2 程序设计语言和语言处理程序的知识"></a>2.2 程序设计语言和语言处理程序的知识</h4></li><li>汇编、编译、解释系统的基础知识和基本工作原理</li><li>程序设计语言的基本成分：数据、运算、控制和传输，过程（函数）调用</li><li>各类程序设计语言主要特点和适用情况<h3 id="3-计算机网络知识"><a href="#3-计算机网络知识" class="headerlink" title="3. 计算机网络知识"></a>3. 计算机网络知识</h3></li><li>网络体系结构（网络拓扑、OSI/RM、基本的网络协议）</li><li>传输介质、传输技术、传输方法、传输控制</li><li>常用网络设备和各类通信设备</li><li>Client/Server结构、Browser/Server结构</li><li>LAN拓扑，存取控制，LAN的组网，LAN间连接，LAN-WAN连接</li><li>因特网基础知识以及应用</li><li>网络软件</li><li>网络管理</li><li>网络性能分析<h3 id="4-数据库知识"><a href="#4-数据库知识" class="headerlink" title="4. 数据库知识"></a>4. 数据库知识</h3></li><li>数据库管理系统的功能和特征</li><li>数据库模型（概念模式、外模式、内模式）</li><li>数据模型，ER图，第一范式、第二范式、第三范式</li><li>数据操作（集合运算和关系运算）</li><li>数据库语言（SQL）</li><li>数据库的控制功能（并发控制、恢复、安全性、完整性）</li><li>数据仓库和分布式数据库基础知识<h3 id="5-多媒体知识"><a href="#5-多媒体知识" class="headerlink" title="5. 多媒体知识"></a>5. 多媒体知识</h3></li><li>多媒体系统基础知识，多媒体设备的性能特性，常用多媒体文件格式</li><li>简单图形的绘制，图像文件的处理方法</li><li>音频和视频信息的应用</li><li>多媒体应用开发过程<h3 id="6-系统性能知识"><a href="#6-系统性能知识" class="headerlink" title="6. 系统性能知识"></a>6. 系统性能知识</h3></li><li>性能指标（响应时间、吞吐量、周转时间）和性能设计</li><li>性能测试和性能评估</li><li>可靠性指标及计算、可靠性设计</li><li>可靠性测试和可靠性评估<h3 id="7-计算机应用基础知识"><a href="#7-计算机应用基础知识" class="headerlink" title="7. 计算机应用基础知识"></a>7. 计算机应用基础知识</h3></li><li>信息管理、数据处理、辅助设计、自动控制、科学计算、人工智能等基础知识</li><li>远程通信服务基础知识</li><li>常用应用系统</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-硬件知识&quot;&gt;&lt;a href=&quot;#1-硬件知识&quot; class=&quot;headerlink&quot; title=&quot;1. 硬件知识&quot;&gt;&lt;/a&gt;1. 硬件知识&lt;/h3&gt;&lt;h4 id=&quot;1-1-计算机系统的组成、体系结构分类及特性&quot;&gt;&lt;a href=&quot;#1-1-计算机系统的组成、
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JSP扩展</title>
    <link href="https://zhuyiting.xyz/2017/12/29/JSP%E6%89%A9%E5%B1%95/"/>
    <id>https://zhuyiting.xyz/2017/12/29/JSP扩展/</id>
    <published>2017-12-29T02:25:00.000Z</published>
    <updated>2019-10-20T14:04:30.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象:"></a>JSP内置对象:</h4><ul><li>内置对象指的是服务器已经创建好的对象，可以直接使用；</li><li>9个内置对象:<ul><li>request</li><li>response</li><li>out<ul><li>out的类型是JspWriter</li><li>out可以用来输出内容到客户端，但是程序员一般不会使用，因为直接使用&lt;%=%&gt;即可以实现输出；</li></ul></li><li>page<ul><li>page即当前类对象</li><li>page也很少使用，与this相同</li></ul></li><li>pageContext<ul><li>其他多数内置对象都是通过它获得  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">        application = pageContext.getServletContext();</span><br><span class="line">        config = pageContext.getServletConfig();</span><br><span class="line">        session = pageContext.getSession();</span><br><span class="line">        out = pageContext.getOut();</span><br><span class="line">    + pageContext对象是JSP中一个非常重要的对象，是`javax.servlet.jsp.PageContext`类型的对象，指的是页面的上下文，封装了其他的内置对象，同时代表的是四大作用域【页面、请求、会话、上下文】中的页面作用域，也可以在页面上下文范围添加属性，`PageContext`中与属性相关方法如下：</span><br><span class="line"></span><br><span class="line">        |方法声明|方法描述|</span><br><span class="line">        |:---:|:---:|</span><br><span class="line">        |<span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(java.lang.String name, java.lang.Object o)</span> |将任意类型对象设置为属性，指定一个名字；|</span></span><br><span class="line"><span class="function">        |java.lang.Object <span class="title">getAttribute</span><span class="params">(java.lang.String name)</span>|通过属性的名字，获取属性的值；|</span></span><br><span class="line"><span class="function">        |<span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(java.lang.String name)</span>|通过属性的名字，删除属性；|</span></span><br><span class="line"><span class="function">    + session</span></span><br><span class="line"><span class="function">+ session是JSP中的另一个内置对象，是`HttpSession`类型的对象，可以在JSP中调用HttpSession接口中的任何方法；默认存在</span></span><br><span class="line"><span class="function">+ application</span></span><br><span class="line"><span class="function">+ application是JSP中的另一个内置对象，是`ServletContext`类型的对 象，可以在JSP中调用`ServlletContext`接口中的任何方法；</span></span><br><span class="line"><span class="function">+ exception</span></span><br><span class="line"><span class="function">+ 内置对象exception比较特殊，默认情况下不存在；只有当JSP中使用指令指定该页面作为错误页面使用时才会翻译生成该内置对象。</span></span><br><span class="line"><span class="function">+ config</span></span><br><span class="line"><span class="function">+ 在JSP中可以直接使用config对象调用ServletConfig接口中任意方法，例如，可以在web.xml中对JSP配置初始化参数，与前面学习的Servlet初始化参数相同的含义：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#### 指令与动作:</span></span><br><span class="line"><span class="function">+ JSP可以通过指令元素而影响容器翻译生成Java类的整体结构；</span></span><br><span class="line"><span class="function">+ 指令的语法为：`&lt;%@ directive </span>&#123;attr=“value”&#125;* %&gt;`；</span><br><span class="line">+ 其中，directive为指令名，attr指该指令对应的属性名，一个指令可能有多个属性；</span><br><span class="line">JSP中常用的指令有三个：page、include、taglib，前两个常用</span><br><span class="line">+ **page指令**作用于整个JSP页面，可以将指令放在JSP页面任何一个位置;</span><br><span class="line">  + <span class="keyword">import</span>属性:用来引入JSP文件需要使用的类；</span><br><span class="line">+ 可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用<span class="keyword">import</span>；</span><br><span class="line">+ 值得注意的是，<span class="keyword">import</span>是page指令中唯一一个可以在一个JSP文件中多次出现的属性，其他属性在一个JSP文件中只能出现一次；</span><br><span class="line">  + pageEncoding属性:用来设置JSP文件的页面编码格式；</span><br><span class="line">+ page指令的session属性：用来设置JSP页面是否生成session对象。该属性默认值为<span class="keyword">true</span>，可以设置成<span class="keyword">false</span>。</span><br><span class="line">+ session属性值设置为<span class="keyword">false</span>后，该JSP翻译生成的类中将没有内置对象session，该JSP不参与会话。</span><br><span class="line">  + errorPage属性:设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面；</span><br><span class="line">+ 访问该页面将发生数学异常，而且并没有对异常进行处理，那么将跳转到错误页面error.jsp</span><br><span class="line">  + isErrorPage属性默认值是<span class="keyword">false</span>，可以设置为<span class="keyword">true</span>。在JSP的错误页面中，将isErrorPage设置为<span class="keyword">true</span>，则该页面翻译生成的Java类中，将生成exception内置对象。在error.jsp中加入代码：`&lt;%<span class="meta">@page</span> isErrorPage=<span class="string">"true"</span>%&gt;`</span><br><span class="line">+ 上述代码将error.jsp页面设置为错误页面，所以，在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象</span><br><span class="line">    + 注意：即使一个页面没有设置isErrorPage=“<span class="keyword">true</span>”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。</span><br><span class="line"></span><br><span class="line">+ **include指令**是JSP中另外一个常用指令，用来静态包含其他页面；</span><br><span class="line">  + 在翻译期间，把包含的页面也翻译到当前页面的Java文件中，也就是Java源文件即实现“二合一”；</span><br><span class="line">  + `&lt;%<span class="meta">@include</span> file=<span class="string">"copyright.jsp"</span>%&gt;`</span><br><span class="line"></span><br><span class="line">+ **include动作标签**:</span><br><span class="line">  + JSP规范中定义了一系列的标准动作。Web容器按照规范进行了实现，可以解析并执行标准动作；</span><br><span class="line">  + 标准动作使用标准的XML语法。</span><br><span class="line">    ```jsp</span><br><span class="line">    &lt;jsp:action_name attribute1=<span class="string">"value1"</span> attribute2=<span class="string">"value2"</span>&gt;</span><br><span class="line">    &lt;/jsp:action_name&gt;</span><br><span class="line">    ```</span><br><span class="line">  + 其中action_name表示标准动作的名字，attribute1和attribute2是标准动作的若干个属性；</span><br><span class="line">  + include标准动作:`&lt;jsp:include&gt;`是动态包含，即在运行期访问被包含的页面，并将响应结果同包含页面的响应结果合并，生成最终响应。类似在Servlet中调用`RequestDispatcher`的`include`方法进行包含。</span><br><span class="line"></span><br><span class="line">+ **include标准动作和include指令的差异**;</span><br><span class="line">  + include标准动作与include指令都是实现包含其他页面的功能;</span><br><span class="line">  + include标准动作的属性是page，实现动态包含，发生在请求阶段；</span><br><span class="line">  + include指令的属性是file，实现静态包含，发生在翻译阶段。</span><br><span class="line"></span><br><span class="line">+ include其他动作</span><br><span class="line">  + forward动作：在JSP页面中进行请求转发，如下代码所示：</span><br></pre></td></tr></table></figure>  &lt;jsp:forward page=“loginsuccess.jsp”&gt;<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ param动作：往往作为子动作使用，为forward和include动作传递参数，如下代码所示：</span><br></pre></td></tr></table></figure>  &lt;jsp:forward page=”copyright.jsp”&gt;<br>  &lt;jsp:param name=”author” value=”etc”/&gt;<pre><code>&lt;/jsp:forward&gt;</code></pre>  &lt;jsp:include page=”copyright.jsp”&gt;     <pre><code>&lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt;</code></pre>  <br>  ```</li></ul></li><li>上述代码使用param为forward和include动作传递参数，参数将被作为请求参数传递。</li><li>使用标准动作时，一定注意正确结束标准动作，如<code>&lt;jsp:include&gt;</code>是标准动作的开始，一定要对应结束标记，如<code>&lt;/jsp:include&gt;</code>。</li></ul></li></ul><h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>JavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类，这些类遵循一定的编码规范：</p><ol><li>必须是public类 ；</li><li>必须有一个无参的public的构造方法； </li><li>返回属性的方法为getXxxx()格式 ；</li><li>设置属性的方法为setXxx(形式参数)格式；</li></ol><p>JSP中还提供了3个与JavaBean有关的动作；</p><ol><li>useBean动作：<code>&lt;jsp:useBean  id=“” class=“” scope=“”&gt;</code><ul><li>useBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性；</li><li>Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope内的一个属性，属性名为id；</li><li>其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。</li></ul></li><li>setProperty 动作：<code>&lt;jsp:setProperty name=“” property=“” param|value=“”/&gt;</code><ul><li>setProperty标准动作可以用来对JavaBean对象的属性赋值，替代调用setXxxx方法；</li><li>setProperty的name属性表示JavaBean对象的id值，property表示需要调用的setXxx方法中的Xxx部分，将首字母变小写。比如需要调用setCustname方法，则property即为Custname首字母变小写，即custname；</li><li>如果setXxx方法的参数是某一个请求参数的值，则使用param属性指定请求参数名字即可；</li><li>如果setXxx方法的参数是一个常量，则使用value属性指定即可。</li><li>同时，setProperty标准动作可以对一些常见数据类型直接转换，如字符串与Integer的转换就可以自动进行；</li></ul></li><li>getProperty动作：&lt;jsp:getProperty  name=”” property=””/&gt;<ul><li>getProperty标准动作用来调用JavaBean对象的getXxx方法，将其返回值在当前位置输出。</li><li>name是JavaBean对象的id值，property的值是getXxx方法中的Xxx部分，首字母变小写。假设需要调用getAddress方法显示其返回值，那么property的值就是Address的首字母变小写，即address。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JSP内置对象&quot;&gt;&lt;a href=&quot;#JSP内置对象&quot; class=&quot;headerlink&quot; title=&quot;JSP内置对象:&quot;&gt;&lt;/a&gt;JSP内置对象:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;内置对象指的是服务器已经创建好的对象，可以直接使用；&lt;/li&gt;
&lt;li&gt;9个内置对象
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学基础</title>
    <link href="https://zhuyiting.xyz/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2017/12/27/计算机科学基础/</id>
    <published>2017-12-27T14:17:00.000Z</published>
    <updated>2019-10-20T00:44:59.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数制及其转换"><a href="#1-数制及其转换" class="headerlink" title="1. 数制及其转换"></a>1. 数制及其转换</h4><p>• 二进制、十进制和十六进制等常用制数制及其相互转换</p><h4 id="2-数据的表示"><a href="#2-数据的表示" class="headerlink" title="2. 数据的表示"></a>2. 数据的表示</h4><p>• 数的表示（原码、反码、补码、移码表示，整数和实数的机内表示，精度和溢出）<br>• 非数值表示（字符和汉字表示、声音表示、图像表示）<br>• 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码）</p><h4 id="3-算术运算和逻辑运算"><a href="#3-算术运算和逻辑运算" class="headerlink" title="3. 算术运算和逻辑运算"></a>3. 算术运算和逻辑运算</h4><p>• 计算机中的二进制数运算方法<br>• 逻辑代数的基本运算和逻辑表达式的化简</p><h4 id="4-数学基础知识"><a href="#4-数学基础知识" class="headerlink" title="4.  数学基础知识"></a>4.  数学基础知识</h4><p>• 命题逻辑、谓词逻辑、形式逻辑的基础知识<br>• 常用数值计算（误差、矩阵和行列式、近似求解方程、插值、数值积分）<br>• 排列组合、概率论应用、应用统计（数据的统计分析）<br>• 运算基本方法（预测与决策、线性规划、网络图、模拟）</p><h4 id="5-常用数据结构"><a href="#5-常用数据结构" class="headerlink" title="5. 常用数据结构"></a>5. 常用数据结构</h4><p>• 数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、线索树、堆）、图等的定义、存储和操作<br>• Hash（存储地址计算，冲突处理）</p><h4 id="6-常用算法"><a href="#6-常用算法" class="headerlink" title="6. 常用算法"></a>6. 常用算法</h4><p>• 排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法<br>• 算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-数制及其转换&quot;&gt;&lt;a href=&quot;#1-数制及其转换&quot; class=&quot;headerlink&quot; title=&quot;1. 数制及其转换&quot;&gt;&lt;/a&gt;1. 数制及其转换&lt;/h4&gt;&lt;p&gt;• 二进制、十进制和十六进制等常用制数制及其相互转换&lt;/p&gt;
&lt;h4 id=&quot;2-数据的
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Servlet上下文</title>
    <link href="https://zhuyiting.xyz/2017/12/25/JSP%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://zhuyiting.xyz/2017/12/25/JSP上下文/</id>
    <published>2017-12-25T10:47:00.000Z</published>
    <updated>2019-10-20T14:04:04.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文:"></a>什么是上下文:</h4><p>上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个上下文对象.</p><ul><li>当服务器启动的时候，就会为每一个应用创建一个上下文对象；</li><li>当服务器关闭的时候，上下文对象就销毁；</li></ul><h4 id="Servlet中的ServletContext接口"><a href="#Servlet中的ServletContext接口" class="headerlink" title="Servlet中的ServletContext接口:"></a>Servlet中的ServletContext接口:</h4><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">java.io.InputStream getResourceAsStream(java.lang.String path)</td><td align="center">将path所代表的资源以输入流返回，可以进一步进行读操作；可以用来读取服务器端的文件；</td></tr><tr><td align="center">RequestDispatcher getRequestDispatcher(java.lang.String path)</td><td align="center">返回RequestDispatcher 对象，路径是相对于上下文路径的；</td></tr></tbody></table><h4 id="上下文获取方法"><a href="#上下文获取方法" class="headerlink" title="上下文获取方法:"></a>上下文获取方法:</h4><p>Servlet规范中的多个接口中都定义了<code>getServletContext</code>方法获得上下文对象</p><h4 id="上下文参数"><a href="#上下文参数" class="headerlink" title="上下文参数:"></a>上下文参数:</h4><ul><li>在web.xml中可以配置上下文参数，使用<code>ServletContext</code>中的<code>getInitParameter</code>方法可以获取该参数；【之前学习过的Servlet初始化参数，只能在当前Servlet中使用】</li><li>上下文参数存储在上下文对象，所以应用下所有组件都可以使用；</li><li>获取上下文参数：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>version<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回ServletContext对象</span></span><br><span class="line">ServletContext ctxt=<span class="keyword">this</span>.getServletContext();</span><br><span class="line"><span class="comment">//获取上下文参数</span></span><br><span class="line">String version=ctxt.getinitParameter(<span class="string">"version"</span>);</span><br><span class="line">System.out.println(<span class="string">"上下文参数version的值:"</span>+version);</span><br></pre></td></tr></table></figure></li></ul><h4 id="利用ServletContext在应用中共享数据"><a href="#利用ServletContext在应用中共享数据" class="headerlink" title="利用ServletContext在应用中共享数据:"></a>利用ServletContext在应用中共享数据:</h4><table><thead><tr><th align="center">方法声明</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">void setAttribute(java.lang.String name, java.lang.Object o)</td><td align="center">将任意类型对象设置为上下文属性，指定一个名字</td></tr><tr><td align="center">java.lang.Object getAttribute(java.lang.String name)</td><td align="center">通过属性的名字，获取属性的值；</td></tr><tr><td align="center">void removeAttribute(java.lang.String name)</td><td align="center">通过属性的名字，删除属性；</td></tr></tbody></table><h4 id="四大作用范围"><a href="#四大作用范围" class="headerlink" title="四大作用范围:"></a>四大作用范围:</h4><p>在Web应用中，有四大作用域范围</p><ul><li>页面范围<code>PageContext</code>：一个Servlet或JSP文件；</li><li>请求范围<code>ServletRequest</code>：一次请求中可以访问多个Servlet或JSP； 访问的Servlet或JSP能够包含其他资源；</li><li>会话范围<code>HttpSession</code>：一次会话中可以包含多个请求；</li><li>上下文范围<code>ServletContext</code>：上下文包含所有会话；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是上下文&quot;&gt;&lt;a href=&quot;#什么是上下文&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文:&quot;&gt;&lt;/a&gt;什么是上下文:&lt;/h4&gt;&lt;p&gt;上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个
      
    
    </summary>
    
    
      <category term="后端技术栈" scheme="https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="JavaEE" scheme="https://zhuyiting.xyz/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>软件开发基础</title>
    <link href="https://zhuyiting.xyz/2017/12/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhuyiting.xyz/2017/12/25/软件开发基础/</id>
    <published>2017-12-25T07:18:00.000Z</published>
    <updated>2019-10-20T00:45:13.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算机工作的简单过程"><a href="#计算机工作的简单过程" class="headerlink" title="计算机工作的简单过程:"></a>计算机工作的简单过程:</h4><ol><li>将程序和数据通关输入设备送入存储器(可以理解为内存)</li><li>计算机从存储器中取出程序指令送到控制器(可以理解为CPU)</li><li>控制器更具指令的含义发出相应的命令(如加法,减法),将存储单元中存放的操作数据取出送往运算器进行运算,再把运算结果送回存储器指定的单元中<h4 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件:"></a>什么是软件:</h4> 软件=程序+文档</li></ol><h4 id="不同类型语言的编译与运行"><a href="#不同类型语言的编译与运行" class="headerlink" title="不同类型语言的编译与运行:"></a>不同类型语言的编译与运行:</h4><p>==编译型==语言是先把源程序的每一条语句都编译成机器语言,并保存成二进制文件,运行时计算机可以直接以机器语言来运行此程序,速度较快;<br>==解释型==语言在执行程序时才一条条的解释成机器语言给计算机来执行,所以运行速度会受到影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;计算机工作的简单过程&quot;&gt;&lt;a href=&quot;#计算机工作的简单过程&quot; class=&quot;headerlink&quot; title=&quot;计算机工作的简单过程:&quot;&gt;&lt;/a&gt;计算机工作的简单过程:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;将程序和数据通关输入设备送入存储器(可以理解为内存)&lt;/li
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
