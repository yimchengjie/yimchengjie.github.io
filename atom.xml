<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yimchengjie.github.io/"/>
  <updated>2021-05-20T09:53:27.400Z</updated>
  <id>https://yimchengjie.github.io/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单测事例</title>
    <link href="https://yimchengjie.github.io/2021/05/20/%E5%8D%95%E6%B5%8B%E4%BA%8B%E4%BE%8B/"/>
    <id>https://yimchengjie.github.io/2021/05/20/单测事例/</id>
    <published>2021-05-20T09:53:27.399Z</published>
    <updated>2021-05-20T09:53:27.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>controller层mock service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BucketControllerTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BucketController bucketController;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CommonService commonService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uploadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BucketService bucketService = mock(BucketService.class);</span><br><span class="line">        <span class="comment">// A调用B，B调用C，测试方法A调用B，mock掉C的方法</span></span><br><span class="line">        ReflectionTestUtils.setField(commonService, <span class="string">"bucketService"</span>, bucketService);</span><br><span class="line">        doNothing().when(bucketService).putObject(any(), any(), any(), any(), any());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = bucketController.uploadFile(getMultipartFileTest());</span><br><span class="line">            assertNotNull(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.info(JSON.toJSONString(Arrays.asList(e.getStackTrace())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uploadPre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BucketService mock = mock(BucketService.class);</span><br><span class="line">        doNothing().when(mock).putObject(any(), any(), any(), any(), any());</span><br><span class="line">        ReflectionTestUtils.setField(bucketController, <span class="string">"bucketService"</span>, mock);</span><br><span class="line"></span><br><span class="line">        String s = bucketController.uploadPre(getMultipartFileTest());</span><br><span class="line">        assertNotNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MultipartFile <span class="title">getMultipartFileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String rootPath = Objects.requireNonNull(BucketController.class.getClassLoader().getResource(<span class="string">""</span>)).getPath();</span><br><span class="line">        String filePath = rootPath + <span class="string">"/sheet.xlsx"</span>;</span><br><span class="line">        BufferedInputStream inputStream = FileUtil.getInputStream(filePath);</span><br><span class="line">        MockMultipartFile mockMultipartFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mockMultipartFile = <span class="keyword">new</span> MockMultipartFile(<span class="string">"sheet.xlsx"</span>, inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.info(JSON.toJSONString(Arrays.asList(e.getStackTrace())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mockMultipartFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rpcImpl"><a href="#rpcImpl" class="headerlink" title="rpcImpl"></a>rpcImpl</h4><p>rpc的实现类mock掉依赖的service</p><h4 id="mock-static"><a href="#mock-static" class="headerlink" title="mock static"></a>mock static</h4><p>mock掉依赖三方rpc的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthCallBackRpcServiceImplTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthCallBackRpcService authCallBackRpcService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">authCallBackAsyncOfFaDaDa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mock static method</span></span><br><span class="line">        <span class="keyword">try</span> (MockedStatic&lt;RpcHttpUtil&gt; rpcHttpUtilMockedStatic = mockStatic(RpcHttpUtil.class)) &#123;</span><br><span class="line">            when(RpcHttpUtil.getBodyString(any())).thenReturn(TestDOGenerateUtil.getRpcHttpRequestStr());</span><br><span class="line">            when(RpcHttpUtil.getMap(any())).thenReturn(TestDOGenerateUtil.getAuthCallBackForFadadaMap());</span><br><span class="line">            RpcHttpResponse rpcHttpResponse = authCallBackRpcService.authCallBackAsyncOfFaDaDa(TestDOGenerateUtil.getRpcHttpRequest());</span><br><span class="line">            rpcHttpUtilMockedStatic.verify(() -&gt; RpcHttpUtil.getBodyString(any()));</span><br><span class="line">            rpcHttpUtilMockedStatic.verify(() -&gt; RpcHttpUtil.getMap(any()));</span><br><span class="line">            assertNotNull(rpcHttpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h4 id="Mock-httpClient"><a href="#Mock-httpClient" class="headerlink" title="Mock httpClient"></a>Mock httpClient</h4><p>mock http请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FadadaServiceImplTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> FadadaService fadadaService;</span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UploadTemplateClient uploadTemplateClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uploadTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        when(uploadTemplateClient.invoke(any(),any())).thenReturn(TestDOGenerateUtil.getFddReturnInApplyCert());</span><br><span class="line">        <span class="keyword">boolean</span> http = fadadaService.uploadTemplate(<span class="string">"1"</span>, <span class="string">"http"</span>);</span><br><span class="line">        assertTrue(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mock-Dao"><a href="#Mock-Dao" class="headerlink" title="Mock Dao"></a>Mock Dao</h4><p>mock Dao层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgentAgreementServiceImplTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AgentAgreementService agentAgreementService;</span><br><span class="line">    <span class="meta">@MockBean</span>(name = <span class="string">"baseMapper"</span>)</span><br><span class="line">    <span class="keyword">private</span> AgentAgreementMapper baseMapper;</span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> AgentAgreementMapper agentAgreementMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mockito.when(baseMapper.selectOne(Mockito.any())).thenReturn(TestDOGenerateUtil.getAgentAgreementDO());</span><br><span class="line">        <span class="keyword">boolean</span> b = agentAgreementService.create(TestDOGenerateUtil.getAgentCreateParam(), TestDOGenerateUtil.getAgentId(), TestDOGenerateUtil.getAgreementId());</span><br><span class="line">        Assertions.assertTrue(b);</span><br><span class="line"></span><br><span class="line">        Mockito.when(baseMapper.selectOne(Mockito.any())).thenReturn(<span class="keyword">null</span>);</span><br><span class="line">        Mockito.when(baseMapper.insert(Mockito.any())).thenReturn(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b1 = agentAgreementService.create(TestDOGenerateUtil.getAgentCreateParam(), TestDOGenerateUtil.getAgentId(), TestDOGenerateUtil.getAgreementId());</span><br><span class="line">        Assertions.assertTrue(b1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getByAgentIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mockito.when(agentAgreementMapper.selectList(Mockito.any())).thenReturn(Collections.singletonList(TestDOGenerateUtil.getAgentAgreementDO()));</span><br><span class="line">        List&lt;AgentAgreementDO&gt; agentAgreementDOS = agentAgreementService.getByAgentIds(Collections.singletonList(TestDOGenerateUtil.getAgentId()));</span><br><span class="line">        Assertions.assertTrue(CollUtil.isNotEmpty(agentAgreementDOS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mockito.when(baseMapper.update(Mockito.any(),Mockito.any(Wrapper.class))).thenReturn(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> update = agentAgreementService.update(TestDOGenerateUtil.getAgentEditParam());</span><br><span class="line">        Assertions.assertTrue(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">batchSaveAgentAgreement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Mockito.when(agentAgreementMapper.saveBatch(Mockito.any())).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        Boolean aBoolean = agentAgreementService.batchSaveAgentAgreement(Collections.singletonList(TestDOGenerateUtil.getAgentAgreementDO()));</span><br><span class="line">        Assertions.assertTrue(aBoolean);</span><br><span class="line"></span><br><span class="line">        Boolean bBoolean = agentAgreementService.batchSaveAgentAgreement(<span class="keyword">null</span>);</span><br><span class="line">        Assertions.assertFalse(bBoolean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mock-Rpc"><a href="#Mock-Rpc" class="headerlink" title="Mock Rpc"></a>Mock Rpc</h4><p>mock 依赖的rpc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonServiceImplTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CommonService commonService;</span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="comment">// mock Rpc Service</span></span><br><span class="line">    <span class="keyword">private</span> BucketService bucketService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String FILE_NAME = <span class="string">"sheet.xlsx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fmsUploadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doNothing().when(bucketService).putObject(any(), any(), any(), any(), any());</span><br><span class="line">        String s = commonService.fmsUploadFile(getInputStreamTest(), FILE_NAME);</span><br><span class="line">        Assertions.assertNotNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fmsUploadFileByURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doNothing().when(bucketService).putObject(any(), any(), any(), any(), any());</span><br><span class="line">        String s = commonService.fmsUploadFileByURI(getFilePathTest(), FILE_NAME);</span><br><span class="line">        Assertions.assertNotNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> InputStream <span class="title">getInputStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileUtil.getInputStream(getFilePathTest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFilePathTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String rootPath = Objects.requireNonNull(BucketController.class.getClassLoader().getResource(<span class="string">""</span>)).getPath();</span><br><span class="line">        <span class="keyword">return</span> rootPath + <span class="string">"/"</span> + FILE_NAME;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dao层单测"><a href="#Dao层单测" class="headerlink" title="Dao层单测"></a>Dao层单测</h3><p>使用h2内存数据库, 测试sql可行性(需要排除启动类加载的正常MysqlConfiguration), 如<code>@ComponentScan(value = &quot;com.jkys.hs.*&quot;,excludeFilters = {@ComponentScan.Filter(type= FilterType.REGEX,pattern = &quot;com\\.jkys\\.hs\\.config\\.app\\.DataSourceConfig&quot;)} )</code> 使用bean扫描中的excludeFilters属性排除不需要的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgentContractMapperTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AgentContractMapper agentContractMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AgentContractDO agentContractDO = TestDOGenerateUtil.getAgentContractDO();</span><br><span class="line">        agentContractDO.setId(<span class="keyword">null</span>);</span><br><span class="line">        List&lt;AgentContractDO&gt; agentContractDOS = Arrays.asList(agentContractDO);</span><br><span class="line">        Integer integer = agentContractMapper.insertList(agentContractDOS);</span><br><span class="line">        Assertions.assertEquals(<span class="number">1</span>, integer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selectByAgentAndStatusWithoutDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AgentContractDO&gt; agentContractDOS = agentContractMapper.selectByAgentAndStatusWithoutDeleted(TestDOGenerateUtil.getAgentId(), <span class="number">0</span>);</span><br><span class="line">        Assertions.assertNotNull(agentContractDOS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selectNotEndByAgent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AgentContractDO&gt; agentContractDOS = agentContractMapper.selectNotEndByAgent(TestDOGenerateUtil.getAgentId(), <span class="keyword">new</span> Date());</span><br><span class="line">        Assertions.assertNotNull(agentContractDOS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=org.h2.Driver</span><br><span class="line">spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;DATABASE_TO_UPPER=FALSE;MODE=MYSQL</span><br><span class="line">spring.datasource.username=sa</span><br><span class="line">spring.datasource.password=</span><br><span class="line"># 建表语句</span><br><span class="line">spring.datasource.schema=classpath:h2/schema.sql</span><br><span class="line"># 需要初始化的insert语句</span><br><span class="line">spring.datasource.data=classpath:h2/data.sql</span><br><span class="line">spring.datasource.continue-on-error=true</span><br><span class="line">spring.h2.console.enabled=true</span><br><span class="line">spring.h2.console.path=/h2</span><br><span class="line">spring.h2.console.settings.web-allow-others=true</span><br><span class="line">spring.h2.console.settings.trace=true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Gateway&quot;&gt;&lt;a href=&quot;#Gateway&quot; class=&quot;headerlink&quot; title=&quot;Gateway&quot;&gt;&lt;/a&gt;Gateway&lt;/h3&gt;&lt;h4 id=&quot;controller&quot;&gt;&lt;a href=&quot;#controller&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>zookeeper一致性</title>
    <link href="https://yimchengjie.github.io/2021/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/zookeeper%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://yimchengjie.github.io/2021/05/01/分布式开发技术/zookeeper一致性/</id>
    <published>2021-05-01T12:57:49.000Z</published>
    <updated>2021-05-12T06:38:01.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zookeeper一致性"><a href="#zookeeper一致性" class="headerlink" title="zookeeper一致性"></a>zookeeper一致性</h2><p>一个zookeeper集群需要保证数据一致性, 他的过程是又leader接受数据修改命令, 将命令发送给其他从服务器,然后自身执行命令.</p><h3 id="领导者选举算法"><a href="#领导者选举算法" class="headerlink" title="领导者选举算法"></a>领导者选举算法</h3><p>首先zookeeper需要有个leader,来保证数据一致性.</p><p>leader推荐: 哪一个zookeeper值得推荐</p><ol><li>数据越新能力越强,通过日志中的自增id来判断谁的数据更新</li><li>myid,由启动配置文件指定, 用户可以工具每个机器的性能个性化指定myid来决定leader,</li></ol><h3 id="二阶段提交-2PC"><a href="#二阶段提交-2PC" class="headerlink" title="二阶段提交(2PC)"></a>二阶段提交(2PC)</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zookeeper一致性&quot;&gt;&lt;a href=&quot;#zookeeper一致性&quot; class=&quot;headerlink&quot; title=&quot;zookeeper一致性&quot;&gt;&lt;/a&gt;zookeeper一致性&lt;/h2&gt;&lt;p&gt;一个zookeeper集群需要保证数据一致性, 他的过程是又
      
    
    </summary>
    
    
      <category term="分布式开发技术" scheme="https://yimchengjie.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式开发技术" scheme="https://yimchengjie.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Zookeeper" scheme="https://yimchengjie.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Java面试专题/springcloud</title>
    <link href="https://yimchengjie.github.io/2021/05/01/Java%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/springcloud/"/>
    <id>https://yimchengjie.github.io/2021/05/01/Java面试专题/springcloud/</id>
    <published>2021-05-01T05:18:23.170Z</published>
    <updated>2021-05-19T07:24:03.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要学习Spring-Cloud"><a href="#为什么需要学习Spring-Cloud" class="headerlink" title="为什么需要学习Spring Cloud"></a>为什么需要学习Spring Cloud</h1><p><b>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单<br>体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结<br>构的应用也会越来越复杂。这就会给应用带来如下的几个问题：</b></p><p>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会<br>给业务的快速迭代带来巨大挑战；<br>开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴<br>随着不断解决冲突的过程，这会严重的影响开发效率；<br>排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但<br>是，由于只有一套代码，需要重新编译、打包、上线，成本很高。<br>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年<br>来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring<br>Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p><h1 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h1><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙<br>地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、<br>消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格<br>做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司<br>开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格<br>进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易<br>懂、易部署和易维护的分布式系统开发工具包。</p><h1 id="设计目标与优缺点"><a href="#设计目标与优缺点" class="headerlink" title="设计目标与优缺点"></a>设计目标与优缺点</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><h4 id="协调各个微服务，简化分布式系统开发。"><a href="#协调各个微服务，简化分布式系统开发。" class="headerlink" title="协调各个微服务，简化分布式系统开发。"></a>协调各个微服务，简化分布式系统开发。</h4><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring<br>Cloud的呢？<br>优点：<br>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以<br>保证后续的更新、完善<br>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例<br>如、配置管理、服务发现、断路器、微服务网关等；<br>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案<br>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率<br>可以更精准的制定优化服务方案，提高系统的可维护性<br>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发<br>微服务可以是跨平台的，可以用任何一种语言开发<br>适于互联网时代，产品迭代周期更短<br>缺点：<br>微服务过多，治理成本高，不利于维护系统<br>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大<br>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框<br>架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对</p><p>于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。</p><h1 id="Spring-Cloud发展前景"><a href="#Spring-Cloud发展前景" class="headerlink" title="Spring Cloud发展前景"></a>Spring Cloud发展前景</h1><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有<br>实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring<br>Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，<br>随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来<br>越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解<br>决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规<br>范的诞生，有效推进服务端软件系统技术水平的进步。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><h1 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h1><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring<br>Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系<br>统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这<br>样的角色。</p><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配<br>置，可以支持客户端配置的刷新及加密、解密操作。</p><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等<br>核心组件。<br>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；<br>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；<br>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了<br>容错能力；<br>Feign：基于Ribbon和Hystrix的声明式服务调用组件；<br>Zuul：API网关组件，对请求提供路由及过滤功能。</p><h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><h4 id="用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节"><a href="#用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节" class="headerlink" title="用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节"></a>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节</h4><h4 id="点，可以用来动态刷新集群中的服务配置。"><a href="#点，可以用来动态刷新集群中的服务配置。" class="headerlink" title="点，可以用来动态刷新集群中的服务配置。"></a>点，可以用来动态刷新集群中的服务配置。</h4><h2 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h2><p>基于Hashicorp Consul的服务治理组件。</p><h2 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h2><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基<br>于日志（例如ELK）的跟踪。</p><h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><h4 id="轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主"><a href="#轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主" class="headerlink" title="轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主"></a>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主</h4><p>要实现为Apache Kafka及RabbitMQ。</p><h2 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h2><h4 id="用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性"><a href="#用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性" class="headerlink" title="用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性"></a>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性</h4><h4 id="和非功能性的特性。"><a href="#和非功能性的特性。" class="headerlink" title="和非功能性的特性。"></a>和非功能性的特性。</h4><h2 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h2><p>基于Apache Zookeeper的服务治理组件。</p><h2 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h2><h4 id="API网关组件，对请求提供路由及过滤功能。"><a href="#API网关组件，对请求提供路由及过滤功能。" class="headerlink" title="API网关组件，对请求提供路由及过滤功能。"></a>API网关组件，对请求提供路由及过滤功能。</h4><h2 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h2><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC<br>注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一<br>等公民。</p><h1 id="Spring-Cloud的版本关系"><a href="#Spring-Cloud的版本关系" class="headerlink" title="Spring Cloud的版本关系"></a>Spring Cloud的版本关系</h1><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节<br>奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其<br>中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版<br>本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，<br>这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺<br>序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布<br>内容积累到临界点或者一个重大BUG被解决后，会发布一个”service<br>releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的<br>Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p><h2 id="Spring-Cloud和SpringBoot版本对应关系"><a href="#Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="Spring Cloud和SpringBoot版本对应关系"></a>Spring Cloud和SpringBoot版本对应关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring</span><br><span class="line">Cloud</span><br><span class="line">Version</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SpringBo</span><br><span class="line">ot</span><br><span class="line">Version</span><br><span class="line">Hoxton 2.2.x</span><br><span class="line">Greenwic</span><br><span class="line">h 2.1.x</span><br><span class="line">Finchley 2.0.x</span><br><span class="line">Edgware 1.5.x</span><br><span class="line">Dalston 1.5.x</span><br></pre></td></tr></table></figure><h2 id="Spring-Cloud和各子项目版本对应关系"><a href="#Spring-Cloud和各子项目版本对应关系" class="headerlink" title="Spring Cloud和各子项目版本对应关系"></a>Spring Cloud和各子项目版本对应关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compon</span><br><span class="line">ent</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Edgware.</span><br><span class="line">SR</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Greenwic</span><br><span class="line">h.SR</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">bus</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.3.4.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud- 1.3.6.RELE2.1.2.RELE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloud-</span><br><span class="line">commons</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.3.6.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.4.7.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.3.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">netflix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.4.7.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">security</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.2.4.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.3.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">consul</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.3.6.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">sleuth</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.3.6.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.1.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">stream</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ditmars.S</span><br><span class="line">R</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fishtown.</span><br><span class="line">SR</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">zookeepe</span><br><span class="line">r</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.2.3.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.5.21.REL</span><br><span class="line">EASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.5.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">task</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.2.4.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">gateway</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.0.3.RELE</span><br><span class="line">ASE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.RELE</span><br><span class="line">ASE</span><br><span class="line">spring-</span><br><span class="line">cloud-</span><br><span class="line">openfeig</span><br><span class="line">n</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂无 2.1.2.RELEASE</span><br></pre></td></tr></table></figure><p>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版<br>本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止<br>维护。</p><h1 id="SpringBoot和SpringCloud的区别？"><a href="#SpringBoot和SpringCloud的区别？" class="headerlink" title="SpringBoot和SpringCloud的区别？"></a>SpringBoot和SpringCloud的区别？</h1><p>SpringBoot专注于快速方便的开发单个个体微服务。<br>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的<br>一个个单体微服务整合并管理起来，</p><h4 id="为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总"><a href="#为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总" class="headerlink" title="为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总"></a>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总</h4><h4 id="线、全局锁、决策竞选、分布式会话等等集成服务"><a href="#线、全局锁、决策竞选、分布式会话等等集成服务" class="headerlink" title="线、全局锁、决策竞选、分布式会话等等集成服务"></a>线、全局锁、决策竞选、分布式会话等等集成服务</h4><p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不<br>开SpringBoot ，属于依赖的关系<br>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局<br>的服务治理框架。</p><h1 id="使用-Spring-Boot-开发分布式微服务时，我们面临"><a href="#使用-Spring-Boot-开发分布式微服务时，我们面临" class="headerlink" title="使用 Spring Boot 开发分布式微服务时，我们面临"></a>使用 Spring Boot 开发分布式微服务时，我们面临</h1><h1 id="以下问题"><a href="#以下问题" class="headerlink" title="以下问题"></a>以下问题</h1><h4 id="（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问"><a href="#（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问" class="headerlink" title="（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问"></a>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问</h4><h4 id="题，安全问题。"><a href="#题，安全问题。" class="headerlink" title="题，安全问题。"></a>题，安全问题。</h4><h4 id="（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它"><a href="#（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它" class="headerlink" title="（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它"></a>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它</h4><h4 id="涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服"><a href="#涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服" class="headerlink" title="涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服"></a>涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服</h4><h4 id="务。"><a href="#务。" class="headerlink" title="务。"></a>务。</h4><h4 id="（3）冗余-分布式系统中的冗余问题。"><a href="#（3）冗余-分布式系统中的冗余问题。" class="headerlink" title="（3）冗余-分布式系统中的冗余问题。"></a>（3）冗余-分布式系统中的冗余问题。</h4><h4 id="（4）负载平衡-–负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算"><a href="#（4）负载平衡-–负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算" class="headerlink" title="（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算"></a>（4）负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算</h4><h4 id="机集群，网络链路，中央处理单元，或磁盘驱动器的分布。"><a href="#机集群，网络链路，中央处理单元，或磁盘驱动器的分布。" class="headerlink" title="机集群，网络链路，中央处理单元，或磁盘驱动器的分布。"></a>机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</h4><h4 id="（5）性能-问题-由于各种运营开销导致的性能问题。"><a href="#（5）性能-问题-由于各种运营开销导致的性能问题。" class="headerlink" title="（5）性能-问题 由于各种运营开销导致的性能问题。"></a>（5）性能-问题 由于各种运营开销导致的性能问题。</h4><p>（6）部署复杂性-Devops 技能的要求。</p><h1 id="服务注册和发现是什么意思？Spring-Cloud-如何实"><a href="#服务注册和发现是什么意思？Spring-Cloud-如何实" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud 如何实"></a>服务注册和发现是什么意思？Spring Cloud 如何实</h1><h1 id="现？"><a href="#现？" class="headerlink" title="现？"></a>现？</h1><h4 id="当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多"><a href="#当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多" class="headerlink" title="当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多"></a>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多</h4><h4 id="的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，"><a href="#的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，" class="headerlink" title="的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，"></a>的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，</h4><p>而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册<br>和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并<br>通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h1 id="Spring-Cloud-和dubbo区别"><a href="#Spring-Cloud-和dubbo区别" class="headerlink" title="Spring Cloud 和dubbo区别?"></a>Spring Cloud 和dubbo区别?</h1><p>（1）服务调用方式 dubbo是RPC springcloud Rest Api</p><p>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是<br>zookeeper<br>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，<br>springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分<br>发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线<br>实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</p><h1 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h1><h4 id="在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元"><a href="#在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元" class="headerlink" title="在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元"></a>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元</h4><h4 id="或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最"><a href="#或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最" class="headerlink" title="或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最"></a>或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最</h4><h4 id="大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负"><a href="#大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负" class="headerlink" title="大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负"></a>大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负</h4><h4 id="载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉"><a href="#载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉" class="headerlink" title="载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉"></a>载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉</h4><h4 id="及专用软件或硬件，例如多层交换机或域名系统服务器进程。"><a href="#及专用软件或硬件，例如多层交换机或域名系统服务器进程。" class="headerlink" title="及专用软件或硬件，例如多层交换机或域名系统服务器进程。"></a>及专用软件或硬件，例如多层交换机或域名系统服务器进程。</h4><h1 id="什么是-Hystrix？它如何实现容错？"><a href="#什么是-Hystrix？它如何实现容错？" class="headerlink" title="什么是 Hystrix？它如何实现容错？"></a>什么是 Hystrix？它如何实现容错？</h1><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，<br>当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹<br>性。<br>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协<br>作。<br>思考以下微服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img</span><br></pre></td></tr></table></figure><h4 id="假设如果上图中的微服务-9-失败了，那么使用传统方法我们将传播一个异常。"><a href="#假设如果上图中的微服务-9-失败了，那么使用传统方法我们将传播一个异常。" class="headerlink" title="假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。"></a>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。</h4><h4 id="但这仍然会导致整个系统崩溃。"><a href="#但这仍然会导致整个系统崩溃。" class="headerlink" title="但这仍然会导致整个系统崩溃。"></a>但这仍然会导致整个系统崩溃。</h4><h4 id="随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达-1000"><a href="#随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达-1000" class="headerlink" title="随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000."></a>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.</h4><p>这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功<br>能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开<br>的服务。<br>简化图如下所示</p><p>img<br>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在<br>这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服<br>务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p><h1 id="什么是-Hystrix-断路器？我们需要它吗？"><a href="#什么是-Hystrix-断路器？我们需要它吗？" class="headerlink" title="什么是 Hystrix 断路器？我们需要它吗？"></a>什么是 Hystrix 断路器？我们需要它吗？</h1><p>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使<br>用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法<br>返回一些默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img</span><br></pre></td></tr></table></figure><p>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员<br>工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是<br>给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可<br>能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-<br>nMSJX6ml-1582105816943)(<a href="https://user-gold-" target="_blank" rel="noopener">https://user-gold-</a><br>cdn.xitu.io/2019/12/30/16f55fbfd4e33ae7?<br>imageView2/0/w/1280/h/960/format/webp/ignore-error/1)]</p><h1 id="什么是-Netflix-Feign？它的优点是什么？"><a href="#什么是-Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是 Netflix Feign？它的优点是什么？"></a>什么是 Netflix Feign？它的优点是什么？</h1><p>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程<br>序。<br>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定<br>性。<br>在 employee-consumer 的例子中，我们使用了 employee-producer 使用<br>REST模板公开的 REST 服务。<br>但是我们必须编写大量代码才能执行以下步骤<br>（1）使用功能区进行负载平衡。<br>（2）获取服务实例，然后获取基本 URL。<br>（3）利用 REST 模板来使用服务。 前面的代码如下<br>1 @Controller<br>2 public class ConsumerControllerClient {<br>3 @Autowired<br>4 private LoadBalancerClient loadBalancer;<br>5 public void getEmployee() throws RestClientException, IOException {<br>6  ServiceInstance serviceInstance=loadBalancer.choose(“employee‐<br>producer”);<br>7  System.out.println(serviceInstance.getUri());<br>8  String baseUrl=serviceInstance.getUri().toString();<br>9  baseUrl=baseUrl+”/employee”;<br>10  RestTemplate restTemplate = new RestTemplate();<br>11  ResponseEntity<String> response=null;<br>12 try{<br>13 response=restTemplate.exchange(baseUrl,<br>14 HttpMethod.GET, getHeaders(),String.class);</String></p><p>15 }<br>16 catch (Exception ex)<br>17 {<br>18 System.out.println(ex);<br>19 }<br>20  System.out.println(response.getBody());<br>21 }<br>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到<br>如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依<br>赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p><h1 id="什么是-Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是-Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是 Spring Cloud Bus？我们需要它吗？"></a>什么是 Spring Cloud Bus？我们需要它吗？</h1><p>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而<br>Spring Cloud Config 从 GIT 读取这些属性。<br>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka<br>注册的财产。</p><p>img<br>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生<br>什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。<br>还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调<br>用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用</p><p>http：// localhost：8080 / refresh。同样对于 Employee Producer<br>http：//localhost：8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud<br>Bus 发挥作用的地方。</p><p>img<br>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例<br>中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模<br>块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连<br>接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理<br>的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何<br>单个实例的刷新。</p><h1 id="Spring-Cloud断路器的作用"><a href="#Spring-Cloud断路器的作用" class="headerlink" title="Spring Cloud断路器的作用"></a>Spring Cloud断路器的作用</h1><h4 id="当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待"><a href="#当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待" class="headerlink" title="当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待"></a>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待</h4><h4 id="被调用者的响应-当更多的服务请求到这些资源导致更多的请求等待，发生连锁"><a href="#被调用者的响应-当更多的服务请求到这些资源导致更多的请求等待，发生连锁" class="headerlink" title="被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁"></a>被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁</h4><h4 id="效应（雪崩效应）"><a href="#效应（雪崩效应）" class="headerlink" title="效应（雪崩效应）"></a>效应（雪崩效应）</h4><h4 id="断路器有完全打开状态-一段时间内-达到一定的次数无法调用-并且多次监测没有"><a href="#断路器有完全打开状态-一段时间内-达到一定的次数无法调用-并且多次监测没有" class="headerlink" title="断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有"></a>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有</h4><h4 id="恢复的迹象-断路器完全打开-那么下次请求就不会请求到该服务"><a href="#恢复的迹象-断路器完全打开-那么下次请求就不会请求到该服务" class="headerlink" title="恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务"></a>恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</h4><h4 id="半开-短时间内-有恢复迹象-断路器会将部分请求发给该服务，正常调用时-断路"><a href="#半开-短时间内-有恢复迹象-断路器会将部分请求发给该服务，正常调用时-断路" class="headerlink" title="半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路"></a>半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路</h4><h4 id="器关闭"><a href="#器关闭" class="headerlink" title="器关闭"></a>器关闭</h4><h4 id="关闭：当服务一直处于正常状态-能正常调用"><a href="#关闭：当服务一直处于正常状态-能正常调用" class="headerlink" title="关闭：当服务一直处于正常状态 能正常调用"></a>关闭：当服务一直处于正常状态 能正常调用</h4><h1 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h1><h4 id="在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更"><a href="#在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更" class="headerlink" title="在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更"></a>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更</h4><p>新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组<br>件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），<br>也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是<br>config server，二是config client。<br>使用：<br>（1）添加pom依赖<br>（2）配置文件添加相关配置<br>（3）启动类添加注解@EnableConfigServer</p><h1 id="什么是Spring-Cloud-Gateway"><a href="#什么是Spring-Cloud-Gateway" class="headerlink" title="什么是Spring Cloud Gateway?"></a>什么是Spring Cloud Gateway?</h1><p>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul<br>网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由<br>转发、权限校验、限流控制等作用。<br>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由<br>RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言<br>的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters<br>是各种过滤器，用来对请求做各种判断和修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要学习Spring-Cloud&quot;&gt;&lt;a href=&quot;#为什么需要学习Spring-Cloud&quot; class=&quot;headerlink&quot; title=&quot;为什么需要学习Spring Cloud&quot;&gt;&lt;/a&gt;为什么需要学习Spring Cloud&lt;/h1&gt;&lt;p&gt;&lt;b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>G1垃圾回收器特性</title>
    <link href="https://yimchengjie.github.io/2021/04/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%89%B9%E6%80%A7/"/>
    <id>https://yimchengjie.github.io/2021/04/15/Java虚拟机/G1垃圾回收器特性/</id>
    <published>2021-04-15T06:56:05.000Z</published>
    <updated>2021-05-20T09:53:27.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="G1垃圾回收器特性"><a href="#G1垃圾回收器特性" class="headerlink" title="G1垃圾回收器特性"></a>G1垃圾回收器特性</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;G1垃圾回收器特性&quot;&gt;&lt;a href=&quot;#G1垃圾回收器特性&quot; class=&quot;headerlink&quot; title=&quot;G1垃圾回收器特性&quot;&gt;&lt;/a&gt;G1垃圾回收器特性&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Java虚拟机" scheme="https://yimchengjie.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://yimchengjie.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://yimchengjie.github.io/tags/Java/"/>
    
      <category term="JDK" scheme="https://yimchengjie.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ事务机制</title>
    <link href="https://yimchengjie.github.io/2021/01/05/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
    <id>https://yimchengjie.github.io/2021/01/05/消息中间件/RocketMQ事务机制/</id>
    <published>2021-01-05T02:36:45.000Z</published>
    <updated>2021-05-20T09:53:27.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RocketMQ事务机制"><a href="#RocketMQ事务机制" class="headerlink" title="RocketMQ事务机制"></a>RocketMQ事务机制</h2><p>事务就是要保证一系列操作的一致性，同时成功或同时失败。<br>在单个JVM中，如果使用了Spring，我们只需要@Transactional注解就能开启事务了。<br>那么在一个分布式/微服务的系统下， 如何做事务机制呢？</p><h3 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h3><p>RocketMQ中有这样几个概念</p><ol><li>半消息/准备消息<br> 是指一个消息从生产者发送到消息队列，还没有被生产者进行消费二次确认前的消息。 发送者把事务消息标记为“暂时无法送达”。</li><li>消息状态检查<br> 当网络断开或者生产者重启可能会导致事务消息二次确认的丢失。当MQ发现消息长时间处于半消息状态时，会向消息创建者发送请求，检查消息的最终状态（提交还是回滚）</li></ol><p>事务消息的执行流程如下图<br><img src="/2021/01/05/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/RocketMQ%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><ol><li>生产者发送半消息到MQ服务器</li><li>半消息发送成功后执行本地事务</li><li>根据本地消息的成功与否，向MQ服务器发送提交或者回滚消息</li><li>如果在执行本地事务期间，未显示提交/回滚，MQ服务器将向同一组中的每个生产者发送检查消息来获取事务最新状态</li><li>基于本地事务状态的生产者回复提交或回滚状态</li><li>已提交的消息传递给使用者，回滚的消息将被MQ服务器抛弃。</li></ol><p>事务到这里就结束了</p><p>那么有同学可能就要问了， 如果消息提交， 但是消费者<strong>消费消息时失败</strong>了， 怎么办？</p><p>为什么消费者消费消息失败？ 可能时连接超时，可能是消费出错。<br>第一种， 我们只要消息重试就可以了。<br>如果是第二种，第一要重新排查代码问题， 第二是要报警和提醒，由人工介入或者T+1补偿。 <em>比如订单完成后，积分服务失败， 积分没有到账。</em></p><h3 id="如何使用RocketMQ事务消息"><a href="#如何使用RocketMQ事务消息" class="headerlink" title="如何使用RocketMQ事务消息"></a>如何使用RocketMQ事务消息</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RocketMQ事务机制&quot;&gt;&lt;a href=&quot;#RocketMQ事务机制&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ事务机制&quot;&gt;&lt;/a&gt;RocketMQ事务机制&lt;/h2&gt;&lt;p&gt;事务就是要保证一系列操作的一致性，同时成功或同时失败。&lt;br
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux的性能</title>
    <link href="https://yimchengjie.github.io/2020/12/23/Linux/Linux%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>https://yimchengjie.github.io/2020/12/23/Linux/Linux的性能/</id>
    <published>2020-12-23T05:48:00.000Z</published>
    <updated>2021-05-20T09:53:27.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的性能"><a href="#Linux的性能" class="headerlink" title="Linux的性能"></a>Linux的性能</h2><h3 id="一、什么是平均负载"><a href="#一、什么是平均负载" class="headerlink" title="一、什么是平均负载"></a>一、什么是平均负载</h3><p>当我们使用top或者uptime命令时，会观察到这样的值<br><img src="/2020/12/23/Linux/Linux%E7%9A%84%E6%80%A7%E8%83%BD/top%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD.png" alt="top命令查看平均负载"><br><img src="/2020/12/23/Linux/Linux%E7%9A%84%E6%80%A7%E8%83%BD/uptime%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD.png" alt="uptime命令查看平均负载"></p><p><strong>load average</strong>：就是指单位时间内，系统中处于可运行状态和不可中端状态的平均进场数<br>那什么是可运行状态和不可中端状态呢？<br><strong>可运行状态</strong>：是正在使用CPU或者正在等待CPU的进程，即使用<code>top</code>命令和<code>ps aux</code>命令下 S（STAT）处于<strong>R状态</strong>的进程<br><strong>不可中端状态的进程</strong>：处于内核态关键流程中的进程，且不可被打断，比如等待硬件设备IO响应。即使用<code>top</code>命令和<code>ps aux</code>命令下 S（STAT）处于<strong>D状态</strong>的进程<br><img src="/2020/12/23/Linux/Linux%E7%9A%84%E6%80%A7%E8%83%BD/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81STAT.png" alt="进程状态STAT"></p><p>load average(平均负载) 后面三个值就是表示最近1分钟、5分钟、15分钟的平均负载。</p><p><strong>那么这个平均负载多大最好呢？</strong><br>  每个CPU上都有一个活跃进程，平均负载数等于CPU核心数<br><strong>什么时候是过载状态，需要告警？</strong><br>  当平均负载高于CPU核心数70%的时候。</p><p>如何查看CPU核心数：<code>lscpu</code>命令下的CPU(s),或者使用 <code>grep &#39;model name&#39; /proc/cpuinfo | wc -l</code>命令。</p><h3 id="二、什么是上下文切换"><a href="#二、什么是上下文切换" class="headerlink" title="二、什么是上下文切换"></a>二、什么是上下文切换</h3><p>当多个进程争夺CPU的时候，运行的也还是只有一个CPU，其他进程并没有真正的运行，为什么还是会导致负载上升呢。 这就要说到上下文切换了。</p><p>我们都知道Linux是一个多任务操作系统，它支持远大于CPU数量的任务同时进行。 当然，这不是真正的同时运行， 而是在很短的时间内，将CPU轮流分配，形成宏观的同时运行。</p><p>在每个任务运行前，CPU需要知道任务要从哪里加载，从哪里开始运行，也就是说，系统在CPU执行任务之前，需要帮它设置好<strong>CPU寄存器和程序计数器</strong></p><p><strong>CPU寄存器</strong>：是CPU内置的容量很小的，但是速度极快的内存。<br><strong>程序计数器</strong>：则是用来存储CPU正在执行的指令位置。<br>它们都是CPU在运行任何任务之前，必须依赖的东西，所以也被叫做<strong>CPU上下文</strong></p><p>那么CPU上下文切换也就是把上一个任务的上下文保存起来，然后加载下一个任务的上下文，最后跳到将要执行的位置，运行新任务。</p><p>这些保存起来的上下文，会被存储在操作系统内核中，并在任务重新调度执行时再次被加载。</p><p>根据任务的不同，CPU的切换会有几个不同的场景： 进程上下文切换、线程上下文切换、中断上下文切换（即中断处理程序的调用）</p><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>进程在内核中运行时，可以访问所有资源，而在用户空间运行时称为用户态，无法访问全部的资源，当进程陷入内核空间时，被称为内核态。<br>从用户态到内核态，需要系统调用完成。 比如我们查看文件内容， 打开文件会调用<code>open()</code>,然后调用<code>read()</code>读取文件，再调用<code>write()</code>将内容写到标准输出，最后调用<code>close()</code>关闭文件</p><p>那么系统调用过程中有没有发生上下文切换？<br>CPU寄存器中原来用户态的指令位置，需要保存起来，然后为了执行内核代码，CPU寄存器需要更新为内核态指令的新位置，最后跳转到内核态运行内核任务。<br>而调用结束后，CPU寄存器需要恢复到原来保存的用户态，然后切换到用户空间，继续运行。<br>这样一次系统调用就会造成两次CPU上下文切换。</p><p>系统调用并不会切换进程，所以通常被称为特权模式切换，而不是上下文切换。但实际上，系统调用中的CPU上下文切换是不能避免的。</p><p>那么进程上下文切换和系统调用有什么区别呢。</p><p>进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以进程的上下文切换就会比系统调用时多了一步，在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈保存起来，然后加载下一个进程的内核态后，还需要刷新进程的虚拟内存和栈等资源</p><p>保存上下文和恢复上下文的过程并不是免费的，它需要内核在CPU上运行才可以。<br>每次上下文切换都需要几十纳秒～数微秒的CPU时间，这个时间如果在上下文切换次数较多的情况下，很容易导致CPU将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了进程的真正运行时间。</p><h5 id="什么时候会进行进程上下文切换"><a href="#什么时候会进行进程上下文切换" class="headerlink" title="什么时候会进行进程上下文切换"></a>什么时候会进行进程上下文切换</h5><p>究竟什么时候，才会切换进程上下文呢？</p><p>只有进程切换时才会切换进程上下文。Linux会为CPU维护一个就绪队列，将正在运行和正在等待CPU的进程按照优先级和等待CPU的时间排序，然后选择最需要CPU的进程，也就是优先级最高和等待CPU时间最长的进程来运行。</p><p>什么时候会触发进程调度？</p><ol><li>上一个进程的CPU时间片耗尽，就会被系统挂起，切换到其他的正在等待CPU的进程运行</li><li>进程所需的系统资源不足时，进程也会被挂起，并由系统调度其他进程来运行</li><li>当进程通过函数主动挂起时，自然也要重新调度</li><li>有优先级更高的进程运行时，当前进程也会被挂起</li><li>发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的任务</li></ol><h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>线程和进程最大的区别在于线程是调度的基本单位，而进程是资源拥有的基本单位。<br>内核中的任务调度，说白了调度对象是线程。</p><p>对于线程和进程</p><ul><li>当进程只有一个线程时，可以认为进程就是线程。</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量，这些公共资源在线程的上下文切换中时不需要修改的。</li><li>线程也有自己的私有数据，这些在线程上下文切换中是需要保存的。</li></ul><p>所以当线程切换在两个进程之间时， 切换过程就跟进程上下文切换一样。<br>如果两个线程在一个进程下，那么线程切换只需要切换线程的私有资源。</p><p>因此同进程内的线程上下文切换要比多进程之间切换消耗更少的资源，而这也是多线程代替多进程的一个优势。</p><h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存起来，这样在中断结束以后才可以从原来的状态恢复运行。</p><p>跟进程上下文切换不同的是，中断上下文并不涉及进程的用户态，所以中断过程打断了一个正处在用户态的进程时，也不需要保存和恢复这个进程的用户态资源。<br>中断上下文，只包含内核态中断服务程序执行所必须的状态，包括CPU寄存器，内核堆栈，硬件中断等。</p><p>对同一个CPU，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会于进程上下文切换同时发生。</p><h3 id="三、怎么查看上下文的切换情况"><a href="#三、怎么查看上下文的切换情况" class="headerlink" title="三、怎么查看上下文的切换情况"></a>三、怎么查看上下文的切换情况</h3><p>既然上下文切换对于系统性能影响很大，那么怎么查看上下文呢？</p><p>使用<code>vmstat</code>命令，这是一个常用的系统性能分析工具，主要是原来分析系统的内存使用情况，也能分析CPU上下文切换和中断的次数。</p><p><img src="/2020/12/23/Linux/Linux%E7%9A%84%E6%80%A7%E8%83%BD/vmstat%E5%91%BD%E4%BB%A4.png" alt="vmstat命令"></p><p>注意这几个值：</p><ul><li>cs(context switch): 每秒上下文切换的次数</li><li>in(interrupt): 每秒中断的次数</li><li>r(running ro runnable): 就绪队列的长度，也就是正在运行和等待CPU的进程数</li><li>b(Blocked): 处于不可中断睡眠状态的进程数</li></ul><p><code>vmstat</code>只给出了系统总体的上下文切换情况，想要查看某个进程的详细情况，就需要使用<code>pidstat -w</code></p><p><img src="/2020/12/23/Linux/Linux%E7%9A%84%E6%80%A7%E8%83%BD/pidstat%E6%9F%A5%E7%9C%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png" alt="pidstat查看上下文切换"></p><ul><li>cswch: 每秒自愿上下文切换，所谓自愿上下文切换，就是指进程无法获取所需自愿导致的上下文切换，是进程自主发起的</li><li>nvcswch: 每秒非自愿上下文切换，非自愿上下文切换，就是指进程由于时间片耗尽或者其他原因，被系统强制调度，进而发生的上下文切换，比如当大量进程争夺CPU资源时，就容易发生非自愿上下文切换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux的性能&quot;&gt;&lt;a href=&quot;#Linux的性能&quot; class=&quot;headerlink&quot; title=&quot;Linux的性能&quot;&gt;&lt;/a&gt;Linux的性能&lt;/h2&gt;&lt;h3 id=&quot;一、什么是平均负载&quot;&gt;&lt;a href=&quot;#一、什么是平均负载&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://yimchengjie.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://yimchengjie.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ消息持久化</title>
    <link href="https://yimchengjie.github.io/2020/11/18/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://yimchengjie.github.io/2020/11/18/消息中间件/RocketMQ消息持久化/</id>
    <published>2020-11-18T08:36:45.000Z</published>
    <updated>2021-05-20T09:53:27.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RocketMQ消息持久化"><a href="#RocketMQ消息持久化" class="headerlink" title="RocketMQ消息持久化"></a>RocketMQ消息持久化</h2><hr><p>[toc]</p><hr><h3 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h3><p>所谓持久化，就是把数据保存到可以永久保存的存储设备中，持久化的主要应用是将内存中数据存储到磁盘。</p><h3 id="MQ为什么需要持久化"><a href="#MQ为什么需要持久化" class="headerlink" title="MQ为什么需要持久化"></a>MQ为什么需要持久化</h3><p>持久化，一是防止宕机时的数据丢失，二是可以在高峰期先将数据刷盘，然后再慢慢处理。</p><h3 id="MQ如何持久化"><a href="#MQ如何持久化" class="headerlink" title="MQ如何持久化"></a>MQ如何持久化</h3><ol><li>依赖缓存，比如redis、ZeroMQ，由于分布式缓存的读写能力优于DB，如果你的需求是快产快消的即时消费场景,并且生产的消息立即被消费者消费掉，并且看中速度，那么用这种方式也ok。</li><li>数据库DB，Apache下的ActiveMQ支持数据库的持久化方式，可以实现JDBC消息存储，由于关系型数据库在数据量很大的情况下的IO读写能力会出现瓶颈，而且非常依赖于数据库。</li><li>文件系统，也就是RocketMQ采用的持久化方式，且主流的kafka、rabbitMQ也是采用这种方式，它是将消息刷盘到服务器的文件系统中。它能提供高可靠、高性能，除非MQ挂了或者服务器宕机，不然不会出现无法持久化的问题。</li></ol><h3 id="RocketMQ的持久化流程（存储流程）"><a href="#RocketMQ的持久化流程（存储流程）" class="headerlink" title="RocketMQ的持久化流程（存储流程）"></a>RocketMQ的持久化流程（存储流程）</h3><ol><li>Producer 将消息发送到 Broker 后，Broker 会采用同步或者异步的方式把消息写入到 CommitLog。RocketMQ 所有的消息都会存放在 CommitLog 中，为了保证消息存储不发生混乱，对 CommitLog 写之前会加锁，同时也可以使得消息能够被顺序写入到 CommitLog，只要消息被持久化到磁盘文件 CommitLog，那么就可以保证 Producer 发送的消息不会丢失。</li><li>CommitLog 持久化后，会把里面的消息 Dispatch 到对应的 ConsumeQueue 上，调用 CommitLogDispatcherBuildConsumeQueue，ConsumeQueue 相当于 Kafka 中的 Partition，是一个逻辑队列，存储了这个 Queue 在 CommitLog 中的起始 Offset，log 大小和 MessageTag 的 hashCode。</li><li>同时消息也被 Dispatch 到对应的 IndexFile 上，调用 CommitLogDispatcherBuildIndex 。 每次推送会休息1毫秒，然后继续，IndexService 调用 buildIndex 构建索引。</li><li>当消费者进行消息消费时，会先读取 ConsumerQueue，逻辑消费队列 ConsumeQueue 保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 Offset，消息大小、和消息 Tag 的 HashCode 值。</li><li>然后跟据相关的偏移量到CommitLog中读取消息。</li></ol><h3 id="RocketMQ的存储文件"><a href="#RocketMQ的存储文件" class="headerlink" title="RocketMQ的存储文件"></a>RocketMQ的存储文件</h3><p>Commitlog文件、ConsumeQueue文件、IndexFile文件<br><img src="/2020/11/18/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96/RocketMQ%E6%8C%81%E4%B9%85%E5%8C%96%E6%9E%B6%E6%9E%84.jpg" alt></p><h4 id="1-Commitlog文件"><a href="#1-Commitlog文件" class="headerlink" title="1. Commitlog文件"></a>1. Commitlog文件</h4><h5 id="什么是CommitLog文件"><a href="#什么是CommitLog文件" class="headerlink" title="什么是CommitLog文件"></a>什么是CommitLog文件</h5><p>commitlog文件的存储地址：$HOME\store\commitlog${fileName}，每个文件的大小默认1G =1024<em>1024</em>1024，commitlog的文件名fileName，名字长度为20位，左边补零，剩余为起始偏移量；比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当这个文件满了，第二个文件名字为00000000001073741824，起始偏移量为1073741824，以此类推。</p><p>Commitlog是消息存储的物理文件，为了提高写入的效率，采取顺序写的策略（磁盘的顺序写入不需要重新寻址，效率很高，才机械硬盘中会更明显）。为了实现顺序写，RocketMQ把所有的主题的消息都会存储到同个Commitlog文件中。</p><h5 id="什么是CommitLog条目"><a href="#什么是CommitLog条目" class="headerlink" title="什么是CommitLog条目"></a>什么是CommitLog条目</h5><p><img src="/2020/11/18/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96/commitLogItem.png" alt="CommitLog条目"></p><ol><li>TOTALSIZE: 该消息条目总长度，4字节</li><li>MAGICCODE: 魔法值，固定0xdaa320a7，4字节</li><li>BODYCRC: 消息体crc校验码，4字节</li><li>QUEUEID: ComsumeQueue消息消费队列ID，4字节</li><li>FLAG: 消息FLAG，预留给消费者的标识位，4字节</li><li>QUEUEOFFSET: 消息在ComsumeQueue的偏移量，8字节</li><li>PHYSICALOFFSET: 消息在CommitLog文件中的偏移量，8字节</li><li>SYSFLAG: 消息系统FLAG，例如是否压缩、是否有事务消息，4字节</li><li>BORNTIMESTAMP: 消息产生者调用消息发送API的时间戳，8字节</li><li>BORNHOST: 消息发送者IP、端口号，8字节</li><li>STORETIMESTAMP: 消息存储时间戳，8字节</li><li>STOREHOSPTADDRESS: Broker服务器IP+端口号，8字节</li><li>RECONSUMETIMES: 消息重试次数，4字节</li><li>Prepare Transaction Offset: 事务消息物理偏移量，8字节</li><li>BodyLength: 消息体长度，4字节</li><li>Body: 消息体内容</li><li>TopicLength: 主题存储长度，主题名称不能超过255个字符，1字节</li><li>Topic: 主题内容</li><li>PropertiesLength: 消息属性长度，表示消息属性长度不能超过65536个字符，2字节</li><li>Properties: 消息属性</li></ol><h5 id="CommitLog是怎么工作的"><a href="#CommitLog是怎么工作的" class="headerlink" title="CommitLog是怎么工作的"></a>CommitLog是怎么工作的</h5><ol><li><strong>写入消息：</strong><ol><li>根据MapedFileQueue.getLastMapedFile方法获取最后写的CommitLog文件映射，若都写满了或没有文件，则创建</li><li>MapedFile.appendMessage(Object msg, AppendMessageCallback cb)方法将消息内容写入到消息缓存MappedByteBuffer，由后台服务负责刷盘逻辑</li><li>如果Broker是同步刷盘，并且消息的property属性中”WAIT”参数为空或者为TRUE，则利用GroupCommitService后台线程服务进行刷盘操作，具体刷盘操作为<ol><li>构建GroupCommitRequest对象，其中nextOffset变量的值等于wroteOffset（写入的开始物理位置）加上wroteBytes（写入的大小）,表示下一次写入消息的开始位置；</li><li>将该对象存入GroupCommitService.requestsWrite写请求队列中，并唤醒GroupCommitService线程将写队列的数据与读队列的数据交互（读队列的数据肯定是空）；</li><li>该线程的doCommit方法中遍历读队列的数据，检查MapedFileQueue.committedWhere（刷盘刷到哪里的记录）是否大于等于GroupCommitRequest.nextOffset，若是表示该请求消息表示nextOffset之前的消息已经被刷盘，否则调用CommitLog.MapedFileQueue.commit(int flushLeastPages) 进行刷盘操作；</li><li>用MapedFileQueue的存储时间戳storeTimestamp变量值（在MapedFileQueue.commit方法成功执行后更新）更新StoreCheckpoint.physicMsgTimestamp变量值（checkpoint文件内容中其中一个值）；</li><li>清空读请求队列requestRead；</li></ol></li><li>如果Broker为异步刷盘（ASYNC_FLUSH），唤醒FlushRealTimeService线程服务。在该线程的run方法处理逻辑如下：<ol><li>根据CommitLog刷盘间隔时间（默认是1秒）来间断性的调用CommitLog.MapedFileQueue.commit(int flushLeastPages)方法进行刷盘操作；</li><li>MapedFileQueue的存储时间戳storeTimestamp变量值（在MapedFileQueue.commit方法成功执行后更新）更新StoreCheckpoint.physicMsgTimestamp变量值（checkpoint文件内容中其中一个值）；</li></ol></li><li>如果Broker为同步双写主用（SYNC_MASTER），并且消息的property属性中”WAIT”参数为空或者为TRUE，则等待监听主Broker将数据同步到从Broker的结果，若同步失败，则置PutMessageResult对象的putMessageStatus变量为FLUSH_SLAVE_TIMEOUT，监测方法如下：<ol><li>检查主从数据传输是否正常。备用连接是否大于0，主用put的位置masterPutwhere等于wroteOffset（写入的开始物理位置）加上wroteBytes（写入的大小），masterPutwhere减去HAService.push2SlaveMaxOffset（写入到Slave的最大Offset）的差值不能大于256M，否则视为主备同步异常，置PutMessageResult对象的putMessageStatus变量为SLAVE_NOT_AVAILABLE；</li><li>)若主备同步正常，则利用wroteOffset（写入的开始物理位置）加上wroteBytes（写入的大小）的值为参数构建GroupCommitRequest对象，即该对象的nextOffset值等于wroteOffset+wroteBytes；然后调用HAService.GroupTransferService.putRequest(GroupCommitRequest request)方法将请求对象放入 GroupTransferService服务的队列中，用于监听是否同步完成；再调用GroupCommitRequest.waitForFlush(long timeout)方法，该方法一直处于阻塞状态，直到HAService线程服务完成同步工作或者超时才返回结果；若GroupCommitRequest对象的flushOK变量为true则表示同步成功了，在GroupTransferService服务线程中判断是否同步完成的方法是用该对象中的nextOffset值与HAService.push2SlaveMaxOffset比较。</li></ol></li><li>初始化DispatchRequest对象，其中包括topic、queueID、wroteOffset（写入的开始物理位置）、wroteBytes（写入的大小）、logicsOffset（已经写入的消息块个数）、消息key值等；调用putRequest(DispatchRequest dispatchRequest)将请求消息放入DispatchMessageService.requestsWrite队列中；由DispatchMessageService服务处理该请求；为请求中的信息创建consumequeue数据和index索引。</li></ol></li><li><strong>读取消息：</strong><br> 该方法的入参有两个：读取的起始偏移量offset和读取的大小size。首先调用findMapedFileByOffset方法根据起始偏移量offset所在的MapedFile对象；然后调用MapedFile对象的selectMapedBuffer方法获取从offset开始的size大小的消息内容；由于offset是commitlog文件的全局偏移量，要以offset%mapedFileSize的余数作为单个文件的起始读取位置传入selectMapedBuffer方法中。</li><li><strong>正常状况恢复数据：</strong><ol><li></li></ol></li></ol><h4 id="2-ConsumeQueue消息逻辑队列"><a href="#2-ConsumeQueue消息逻辑队列" class="headerlink" title="2. ConsumeQueue消息逻辑队列"></a>2. ConsumeQueue消息逻辑队列</h4><p>消息逻辑队列文件，每个消息主题会有多个消息消费队列（MessageQueue），每个消息队列会有一个消息文件。它保存了该MessageQueue的所有消息在CommitLog文件中的物理位置（offset偏移量）</p><h4 id="3-IndexFile"><a href="#3-IndexFile" class="headerlink" title="3. IndexFile"></a>3. IndexFile</h4><p>IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p><h4 id="同步刷盘-异步刷盘"><a href="#同步刷盘-异步刷盘" class="headerlink" title="同步刷盘/异步刷盘"></a>同步刷盘/异步刷盘</h4><h4 id="Linux内存工作原理"><a href="#Linux内存工作原理" class="headerlink" title="Linux内存工作原理"></a>Linux内存工作原理</h4><h3 id="Mmap和PageCache"><a href="#Mmap和PageCache" class="headerlink" title="Mmap和PageCache"></a>Mmap和PageCache</h3><p>RocketMQ的读写做法逻辑：</p><ol><li>将数据文件通过Mmap（NIO中的MappedByteBuffer实现）映射到OS的虚拟内存中</li><li>当消息写入时，先写到PageCache，然后异步刷盘到磁盘</li><li>当消息消费者订阅消息时，要读取的数据也通过PageCache，由于PageCache一次读取4k，所以即使数据不到1k也会预加载4k到缓存中，这样下次读取的消息也容易在PageCache中命中。加快消息消费速度</li></ol><h4 id="Mmap"><a href="#Mmap" class="headerlink" title="Mmap"></a>Mmap</h4><p>传统IO和Mmap<br><img src="/2020/11/18/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96/%E4%BC%A0%E7%BB%9FIO%E5%92%8CMmap.jpg" alt="传统IO和Mmap"></p><p>mmap基于OS的mmap内存映射技术，将文件直接映射到用户内存，使得对文件的操作不用再需要拷贝到PageCache，而是转化为对映射地址映射的PageCache的操作，使随机读写文件和读写内存拥有相似的速度（随机地址被映射到了内存）</p><p>注意点：mmap一次只能映射1.5-2G的文件，所以CommitLog限制1G大小。在映射完成后，会占用虚拟内存，并且释放回收后，虽然不占用物理内存了，但是还是会占用虚拟内存空间，回收比较麻烦。</p><h4 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h4><p><img src="/2020/11/18/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96/PageCache%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="PageCache"></p><p>PageCache属于内核，它对于应用提升I/O效率是一个投入产出比很高的解决方案</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息传给MessageStore</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息传给CommitLog</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    putMessageLock.lock();</span><br><span class="line">    result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息传入MappedFile</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(msg, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调CommitLog</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷盘处理</span></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Synchronization flush</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line">        ...</span><br><span class="line">            service.putRequest(request);</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Asynchronous flush</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否开启缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注三个实现累的run方法</span></span><br><span class="line"><span class="comment">// GroupCommitService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">this</span>.doCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        ...</span><br><span class="line">        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.flushedWhere, <span class="keyword">this</span>.flushedWhere == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> offset = mappedFile.flush(flushLeastPages);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据先写入writeBuffer的情况</span></span><br><span class="line">        <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据直接写入mappedByteBuffer</span></span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RocketMQ消息持久化&quot;&gt;&lt;a href=&quot;#RocketMQ消息持久化&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ消息持久化&quot;&gt;&lt;/a&gt;RocketMQ消息持久化&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深RocketMQ</title>
    <link href="https://yimchengjie.github.io/2020/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1RocketMQ/"/>
    <id>https://yimchengjie.github.io/2020/11/10/消息中间件/由浅入深RocketMQ/</id>
    <published>2020-11-10T08:36:45.000Z</published>
    <updated>2021-05-20T09:53:27.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由浅入深RocketMQ"><a href="#由浅入深RocketMQ" class="headerlink" title="由浅入深RocketMQ"></a>由浅入深RocketMQ</h2><p>RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间件，承载了阿里双十一大部分业务。同时使用Java开发语言，成为了互联网行业首选的消息中间件</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/2020/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1RocketMQ/RocketMQ%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="RocketMQ项目结构"></p><ul><li>broker: 接收生产者发来的消息，消费者从这里消费消息</li><li>client: 提供给他人使用的发送、接受消息的客户端API</li><li>namesrv: NameServer实现相关类，类似于Zookeeper，这里保存着消息的TopicName，队列等运行时的元信息</li><li>filter: 消息过滤相关基础类</li><li>filtersrv: 消息过滤服务器实现相关类（filter启动进程）</li><li>remoting: 远程通信模块，基于netty、fastjson序列化</li><li>store: 消息、索引存储实现</li><li>logappender: 日志实现相关类</li><li>common: 通用类、方法、数据结构</li><li>dev: 开发者信息（非源码）</li><li>distribution: 部署实例文件夹（非源码）</li><li>example: RocketMQ示例代码</li><li>openmessaging: 消息开放标准</li><li>srvutil: 服务器工具类</li><li>style: checkstyle相关类</li><li>test: 测试类</li><li>tools: 工具、监控命令</li></ul><p>主要有四大核心模块: <strong>NameServer、Broker、Producer、Consumer</strong></p><h3 id="路由中心NameServer"><a href="#路由中心NameServer" class="headerlink" title="路由中心NameServer"></a>路由中心NameServer</h3><p>NameServer类似于Zookeeper，指引消费者找到提供者，完成网络通信</p><p>消息中间件的设计思路是基于主题的发布订阅机制，生产者发送某一主题的消息到消息服务器，消息服务器负责把消息持久化，消费者订阅感兴趣的主题，消息服务器根据订阅信息，将消息推送到消费者或者消费者主动拉去消息。为了避免消息服务器的单点故障导致系统瘫痪，一般会部署多个消息服务器共同承担消息存储。那生产者如何知道消息要发送到哪一节点？如果某一台消息服务器宕机，那么生产者如何在不重启的情况下进行感知。NameServer就此而生。</p><h4 id="NameServer启动流程"><a href="#NameServer启动流程" class="headerlink" title="NameServer启动流程"></a>NameServer启动流程</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;由浅入深RocketMQ&quot;&gt;&lt;a href=&quot;#由浅入深RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;由浅入深RocketMQ&quot;&gt;&lt;/a&gt;由浅入深RocketMQ&lt;/h2&gt;&lt;p&gt;RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis降低内存占用</title>
    <link href="https://yimchengjie.github.io/2020/11/04/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"/>
    <id>https://yimchengjie.github.io/2020/11/04/缓存中间件/Redis降低内存占用/</id>
    <published>2020-11-04T02:32:23.000Z</published>
    <updated>2021-05-20T09:53:27.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis降低内存占用"><a href="#Redis降低内存占用" class="headerlink" title="Redis降低内存占用"></a>Redis降低内存占用</h2><p>降低redis的内存占用有助于减少创建快照和加载快照的时间，提高载入AOF文件和重写AOF文件的效率，缩短从服务器的同步时间，并且存储更多数据</p><hr><h3 id="短结构"><a href="#短结构" class="headerlink" title="短结构"></a>短结构</h3><p>Redis为集合、列表、散列、有序集提供了配置，可以让redis以更节约空间的方式存储长度较短的结构——压缩列表。<br>压缩列表是列表、散列、有序集的对象的一种非结构化表示。压缩列表以序列化的方式存储数据，每次读取都需要解码，每次写入都需要局部重新编码。</p><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>以列表list为例，列表是由双向链表实现的，它的每一个节点都包含了<code>前指针</code>、<code>后指针</code>、<code>指向本节点数据的指针</code>。本节点的数据含有三部分内容<code>字符串长度</code>、<code>字符串值中剩余可用字节数量</code>、<code>以空字符串结尾的字符串本身</code><br>每个节点需要存储 3个指针 2个整数 字符串本身以及额外的结尾空字符。64位计算机中，除了字符串本身的长度，还需要额外占用41个字节。</p><p>压缩列表是由节点组成的队列，每个节点都是由两个长度值和一个字符串组成，第一个长度值记录上一个节点的长度，这个长度将被用于对压缩表进行从后向前的便利，第二个长度记录了当前节点的长度。将原本需要额外开销的41个字节减少到最多16个字节</p><p>可以使用<code>list-max-ziplist-entries 512</code>和<code>list-max-ziplist-value 64</code>来配置列表会在什么情况使用压缩列表。entries表示压缩列表最大的元素数量，value表示压缩列表节点最大的体积。一旦超过任意一个限制，就会从压缩列表转换为列表。</p><p>可以使用<code>DEBUG_OBJECT</code>命令，了解一个对象是否被存储成压缩列表。</p><h4 id="集合的整数集合编码"><a href="#集合的整数集合编码" class="headerlink" title="集合的整数集合编码"></a>集合的整数集合编码</h4><p>体积较小的集合，可以有自己的紧凑表示，如果存储内容可以用整数表示，并且数量足够少，那么redis会以有序整数数组的方式存储集合。这种存储方式被称为整数集合（intset）</p><p><code>set-max-intset-entries 512</code>配置整数集合最大元素数量</p><h4 id="长压缩列表和大整数集合带来的性能问题"><a href="#长压缩列表和大整数集合带来的性能问题" class="headerlink" title="长压缩列表和大整数集合带来的性能问题"></a>长压缩列表和大整数集合带来的性能问题</h4><p>当存储结构突破了限制条件时，redis就会把压缩列表和整数集合转换为底层数据结构，这是腰围经过压缩的结构体积越来越大，操作的速度也会越来越慢</p><h3 id="分片结"><a href="#分片结" class="headerlink" title="分片结"></a>分片结</h3><p>分片在很多数据库中都使用这种技术来扩展存储空间并且提高自己的负载能力。 分片本质上就是基于某些简单的规则，将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置。</p><h4 id="分片式散列"><a href="#分片式散列" class="headerlink" title="分片式散列"></a>分片式散列</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis降低内存占用&quot;&gt;&lt;a href=&quot;#Redis降低内存占用&quot; class=&quot;headerlink&quot; title=&quot;Redis降低内存占用&quot;&gt;&lt;/a&gt;Redis降低内存占用&lt;/h2&gt;&lt;p&gt;降低redis的内存占用有助于减少创建快照和加载快照的时间，提高载入
      
    
    </summary>
    
    
      <category term="缓存中间件" scheme="https://yimchengjie.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="缓存中间件" scheme="https://yimchengjie.github.io/tags/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="https://yimchengjie.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="https://yimchengjie.github.io/2020/10/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>https://yimchengjie.github.io/2020/10/16/算法与数据结构/AC自动机/</id>
    <published>2020-10-16T04:06:37.000Z</published>
    <updated>2021-05-20T09:53:27.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><hr><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="/2020/10/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/%E5%AD%97%E5%85%B8%E6%A0%91.jpg" alt="字典树"><br>Trie又称单词查找树，或者前缀树。</p><p>它的根结点可以不包含字符。<br>节点中会标识到此节点是否构成一个单词。从根节点到此节点路径上的字符连起来为该节点对应的单词。</p><h4 id="Trie树的实现"><a href="#Trie树的实现" class="headerlink" title="Trie树的实现"></a>Trie树的实现</h4><p>Trie树的构建也很简单，就是把每个单词的每个字母插入Trie。<br>比如上面图中插入”acc”，发现a已存在，继续，发现c边不存在，于是创建a的子节点c，继续创建c的子节点c。并在第二个c节点中标记是一个单词。</p><h3 id="AC自动机-1"><a href="#AC自动机-1" class="headerlink" title="AC自动机"></a>AC自动机</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><img src="/2020/10/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/AC%E8%87%AA%E5%8A%A8%E6%9C%BA.jpg" alt="AC自动机"><br>AC自动机是在Trie树的基础上，加上了fail指针， 如果查询单词时匹配失败，则向fail指针指向的节点移动。这样就不用从头再找了。</p><h4 id="如何构建AC自动机"><a href="#如何构建AC自动机" class="headerlink" title="如何构建AC自动机"></a>如何构建AC自动机</h4><p>首先让每个节点的fail指针为空，构建字典树，然后求解fail指针, 求解过程是BFS的过程</p><ol><li>让根结点的所有子节点的fail指针指向根结点</li><li>其他节点的fail指针–指向—-&gt;它的父节点的fail节点的所有子节点中相同节点；如果没有相同的就指向根节点</li></ol><p>实现思路就是构建树，设置fail指针，进行匹配搜索， Java实现代码较多，就不放出来了，感兴趣私聊。</p><h4 id="AC自动机的原理"><a href="#AC自动机的原理" class="headerlink" title="AC自动机的原理"></a>AC自动机的原理</h4><p>找到了一个单词结点后还应该看看有没有以该单词结点的后缀为前缀的其他单词，比如she的后缀he是单词he和her的前缀。因此就需要一个fail指针在发现失配的时候指向其他存在e的结点，来进行继续匹配</p><h4 id="AC自动机的应用"><a href="#AC自动机的应用" class="headerlink" title="AC自动机的应用"></a>AC自动机的应用</h4><p>基本问题：给出一个单词表，和一段文本串，问文本串中存在哪些单词以及个数。</p><p>高阶应用：结合词典树做特征工程，训练nlp分词模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AC自动机&quot;&gt;&lt;a href=&quot;#AC自动机&quot; class=&quot;headerlink&quot; title=&quot;AC自动机&quot;&gt;&lt;/a&gt;AC自动机&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://yimchengjie.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://yimchengjie.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据安全与性能保障</title>
    <link href="https://yimchengjie.github.io/2020/10/03/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://yimchengjie.github.io/2020/10/03/缓存中间件/Redis持久化与复制/</id>
    <published>2020-10-03T06:32:23.000Z</published>
    <updated>2021-05-20T09:53:27.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化与复制"><a href="#Redis持久化与复制" class="headerlink" title="Redis持久化与复制"></a>Redis持久化与复制</h2><hr><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis提供了两种不同的持久化方法来将数据存储到硬盘。快照（snapshoting）以及只追加文件（AOF）。这两种持久化方法既可以同时使用，又可以单独使用。</p><h4 id="1-快照持久化（snapshoting）"><a href="#1-快照持久化（snapshoting）" class="headerlink" title="1. 快照持久化（snapshoting）"></a>1. 快照持久化（snapshoting）</h4><p>Redis通过创建快照来获得存储在内存里的数据在某个时间点上的副本。<br>在快照创建完成之后，用户可以对快照进行备份。</p><h5 id="创建快照的方式有"><a href="#创建快照的方式有" class="headerlink" title="创建快照的方式有"></a>创建快照的方式有</h5><ol><li>客户端可以通过向redis发送<code>BGSAVE</code>命令来创建一个快照。执行这个命令后，redis会创建一个子进程，然后子进程负责将快照写入到磁盘，而父进程继续处理命令请求。</li><li>客户端可以通过向redis发送<code>SAVE</code>命令来创建一个快照。redis接到<code>SAVE</code>命令后，在快照创建完之前就不会再响应其他命令了。这个命令很少用，一般是内存不够创建子进程或者其他空余时间才会使用。</li><li>如果<code>SAVE</code>命令设置了配置选项，比如<code>SAVE 60 10000</code>，当60秒内有10000次写入，这个条件被出发时，就会自动触发<code>BGSAVE</code>命令。</li><li>当redis通过<code>SHUTDOWN</code>命令接收到关闭服务器请求时，或者接收到标准<code>TERM</code>信号时，会执行一个SAVE命令，完成后关闭服务器。</li><li>当一个redis连接另一个redis服务器。并向对方发送<code>SYNC</code>命令开始一次复制操作的时候，那么主服务器就会执行一次<code>BGSAVE</code>命令。</li></ol><h5 id="快照持久化的使用场景"><a href="#快照持久化的使用场景" class="headerlink" title="快照持久化的使用场景"></a>快照持久化的使用场景</h5><ol><li>对日志进行聚合计算<br> 在日志文件进行聚合计算或者对页面浏览量进行分析的时候，我们只需要考虑：如果redis因为崩溃而未能成为创建新的快照，那么我们能够承受丢失多久时间内的数据。如果一小时内的数据可以被接受，那么使用配置值<code>save 3600 1</code>。在觉得好持久化配置后，就需要解决如果恢复因为故障中断的日志处理操作。把日志的处理进度记录到redis中，在系统崩溃后，根据进度记录继续执行之前的工作。</li><li>大数据<br>当redis存储的数据越来越多以后，BASAVE在创建子进程时的消耗也会越来越多。为了防止redis创建子进程而停顿，可以使用SAVE命令</li></ol><h4 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2. AOF持久化"></a>2. AOF持久化</h4><p>当程序无法接受一定时间的数据丢失时，可以使用AOF持久化。<br>AOF持久化会将被执行的命令写到AOF文件的末尾，以此来记录数据的变化。所以redis只要重新执行以此AOF文件的命令，就可以恢复AOF文件所记录的数据。<br>AOF持久化可以在redis.config文件中修改配置<code>appendonly yes</code>来开启。修改配置<code>appendfsync</code>的选项来改变AOF状态</p><ul><li>always： 每个redis命令都同步写入，这会严重降低redis的速度</li><li>everysec： 每秒执行一次同步</li><li>no： 让操作系统来决定什么时候同步 </li></ul><h5 id="重写-压缩AOF文件"><a href="#重写-压缩AOF文件" class="headerlink" title="重写/压缩AOF文件"></a>重写/压缩AOF文件</h5><p>虽然AOF非常灵活的提供了多个选项来满足不同应用程序的需求，但是AOF持久化也有缺陷，就是AOF文件的体积大小</p><p>随着redis不断运行，AOF文件的体积也在不断增大。这会导致redis还原数据时要执行的AOF文件庞大，耗时很长。</p><p>为了解决AOF文件体积不断增大的问题，可以在客户端使用<code>BGREWRITEAIF</code>命令，它会移除AOF文件中的冗余命令来重写AOF文件，它和<code>BGSAVE</code>类似，也会创建子进程来工作。但这又造成了和快照方式相同的问题，甚至更糟糕，因为移除AOF文件时，可能导致系统长时间挂起。</p><p>AOF持久化也可以设置auto-aof-rewrite-percentage选项和auto-aof-rewrite-min-size选项，来自动执行BGREWRITEAIF，如果重写过于频繁，可以将percentage设置到100以上，比上次文件扩大一倍以上时才触发重写。</p><p>无论是AOF还是快照，都可以将数据持久化到硬盘，但除了持久化，用户还必须对持久化文件进行备份</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制可以让其他服务器拥有一个不断更新的数据副本，从而使得其他服务器可以用于处理客户端发送的读请求。</p><p>关系型数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理读请求。redis也采用了相同的方法来实现。来扩展读请求。</p><h4 id="1-Redis主从复制的过程"><a href="#1-Redis主从复制的过程" class="headerlink" title="1. Redis主从复制的过程"></a>1. Redis主从复制的过程</h4><ol><li>主服务器等待命令，从服务器连接主服务器，发送SYNC命令。</li><li>主服务器开始执行BGSAVE，并用缓冲区记录BGSAVE之后的命令。从服务器根据配置决定继续使用现有数据处理客户端请求，还是返回错误。</li><li>BGSAVE执行完毕，向从服务器发送快照文件，并在发送期间继续记录命令到缓冲区。 从服务器丢弃旧数据，开始载入主服务器发送的快照文件。</li><li>快照文件发送完毕，开始向从服务器发送缓冲区中的命令。从服务器完成快照文件的加载，开始接受请求命令。</li><li>缓冲区存储命令发送完毕，然后每执行一个请求同时就向从服务器发送相同的的命令。 从服务器执行主服务器缓冲区发送的写命令，并执行每个主服务器发送的写命令。</li></ol><h4 id="2-如何配置"><a href="#2-如何配置" class="headerlink" title="2. 如何配置"></a>2. 如何配置</h4><p>配置从服务器很简单， 只需要在从服务器的slave配置文件中加入<code>slave 192.168.1.1 9999</code></p><h4 id="3-Redis主从链"><a href="#3-Redis主从链" class="headerlink" title="3. Redis主从链"></a>3. Redis主从链</h4><p>当Redis出现一主多从的情况时，可能会导致网络资源不够用。</p><p>犹豫redis主服务器和从服务器并没有特别不同的地方，所以从服务器也可以拥有自己的从服务器。组成主从链。</p><h4 id="4-哨兵模式"><a href="#4-哨兵模式" class="headerlink" title="4. 哨兵模式"></a>4. 哨兵模式</h4><p>Redis主从复制会存在一个问题，就是当主机宕机时就会发生群龙无首的情况。</p><p>所以要做的事情就是从从机中选出一个来作为新的主机。</p><ol><li>Redis使用哨兵来监控服务，Sentinel会作为一个独立的进程，通过向redis发送命令，等待redis响应来监控多个redis服务。</li><li>当哨兵检测到master宕机后，会通知其他哨兵来与master通信，如果其他哨兵认为此master以及宕机的数量超过一定值， 哨兵就会让master下线。</li><li>然后会进行slave作为master的选举，每个sentinel对监控的slave进行优先级计算（主要观察slave的健康状态），排序后， 选择优先级最高的slave，执行<code>slaveof no one</code>作为新master。</li><li>然后通知其他服务器，修改配置，切换主机，并且监控老的master，如果恢复，使其成为新master的slave。</li></ol><p><strong>一个问题</strong> 单机时，客户端可以直接连接主服务器。但是主从集群时，如果主服务器变更，客户端如何知晓呢？？</p><p>在使用主从服务哨兵模式时，客户端不能直接连接到redis集群。而是连接到哨兵集群，通过哨兵节点来获取redis主节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis持久化与复制&quot;&gt;&lt;a href=&quot;#Redis持久化与复制&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化与复制&quot;&gt;&lt;/a&gt;Redis持久化与复制&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; clas
      
    
    </summary>
    
    
      <category term="缓存中间件" scheme="https://yimchengjie.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="缓存中间件" scheme="https://yimchengjie.github.io/tags/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Redis" scheme="https://yimchengjie.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重构原则</title>
    <link href="https://yimchengjie.github.io/2020/09/28/%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%81%93/%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/"/>
    <id>https://yimchengjie.github.io/2020/09/28/代码之道/重构原则/</id>
    <published>2020-09-28T08:15:49.000Z</published>
    <updated>2021-05-20T09:53:27.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重构原则&quot;&gt;&lt;a href=&quot;#重构原则&quot; class=&quot;headerlink&quot; title=&quot;重构原则&quot;&gt;&lt;/a&gt;重构原则&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="代码之道" scheme="https://yimchengjie.github.io/categories/%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="重构" scheme="https://yimchengjie.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MyBatis（三）</title>
    <link href="https://yimchengjie.github.io/2020/09/24/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MyBatis%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://yimchengjie.github.io/2020/09/24/Java开发框架/深入理解MyBatis（三）/</id>
    <published>2020-09-24T12:01:38.000Z</published>
    <updated>2021-05-20T09:53:27.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解MyBatis（三）"><a href="#深入理解MyBatis（三）" class="headerlink" title="深入理解MyBatis（三）"></a>深入理解MyBatis（三）</h2><h3 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h3><p>插件是一种常见的扩展方式，Mybatis也提供了插件的功能。虽然叫插件，但实际上就是拦截器（Interceptor）</p><h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h4><p>Mybatis允许用户使用自定义拦截器对SQL语句执行过程中的某一点进行拦截。默认情况下，Mybatis允许拦截Executor、ParameterHandler、ResultSetHandler以及StatementHandler方法，具体方法如下</p><ul><li>Executor中的update()、query()、flushStatements()、commit()、rollback()、getTransaction()、close()、isClosed()</li><li>ParammeterHandler中的getParameterObject()、setParameters()</li><li>ResultSetHandler中的handleResultSets()、handleOutputParameters()</li><li>StatementHandler中的prepare()、parameterize()、batch()、update()</li></ul><p>Mybatis中使用拦截器需要继承Interceptor接口，它的定义如下</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>除了继承Interceptor外，自定义的拦截器还需要使用@Intercepts和@Signature两个注解。<br>@Intercepts中指定@Signature注解列表。每个@Signature注解中都标识了该插件需要拦截的方法信息<br>具体如下</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">        <span class="comment">// type指定类名，method指定方法名，args指定参数。 一个@Signature注解通过三个属性确定唯一方法</span></span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123;</span><br><span class="line">                MappedStatement.class,</span><br><span class="line">                Object.class,</span><br><span class="line">                RowBounds.class,</span><br><span class="line">                ResultHandler.class</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor.class,method = <span class="string">"update"</span>, args = &#123;</span><br><span class="line">                MappedStatement.class,</span><br><span class="line">                Object.class</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>定义完成以后，需要在配置中添加对该拦截器的配置</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"mybatis.ExamplePlugin"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>至此，一个自定义的拦截器就配置好了。在mybatis初始化过程中，会对plugin节点解析，最后将Interceptor添加到Configuration中的interceptorChain中，里面使用List保存了所有拦截器.采用责任链模式处理</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">         target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">        interceptors.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h5><p>用户可以添加自定义的拦截器，拦截Executor.query方法，从参数RowBounds中获取记录的开始位置，然后获取BoundSql参数，修改待执行的SQL语句，拼接”limit offset,length”，来实现分页功能</p><p>以PageHelper为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="meta">@Intercepts</span>(</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="line">                <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Dialect对象，针对不同的数据库，采用不同的实现策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Dialect dialect;</span><br><span class="line">    <span class="keyword">private</span> String countSuffix = <span class="string">"_COUNT"</span>;</span><br><span class="line">    <span class="keyword">protected</span> Cache&lt;String, MappedStatement&gt; msCountMap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String default_dialect_class = <span class="string">"com.github.pagehelper.PageHelper"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体的拦截方法，通过jdk动态代理创建代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从拦截的方法中获取被拦截的方法参数列表，然后进行类型转换</span></span><br><span class="line">            Object[] args = invocation.getArgs();</span><br><span class="line">            MappedStatement ms = (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line">            Object parameter = args[<span class="number">1</span>];</span><br><span class="line">            RowBounds rowBounds = (RowBounds) args[<span class="number">2</span>];</span><br><span class="line">            ResultHandler resultHandler = (ResultHandler) args[<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 获取代理目标</span></span><br><span class="line">            Executor executor = (Executor) invocation.getTarget();</span><br><span class="line">            CacheKey cacheKey;</span><br><span class="line">            BoundSql boundSql;</span><br><span class="line">            <span class="comment">//由于逻辑关系，只会进入一次</span></span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">//4 个参数时</span></span><br><span class="line">                boundSql = ms.getBoundSql(parameter);</span><br><span class="line">                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//6 个参数时</span></span><br><span class="line">                cacheKey = (CacheKey) args[<span class="number">4</span>];</span><br><span class="line">                boundSql = (BoundSql) args[<span class="number">5</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            checkDialectExists();</span><br><span class="line"></span><br><span class="line">            List resultList;</span><br><span class="line">            <span class="comment">//调用方法判断是否需要进行分页，如果不需要，直接返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (!dialect.skip(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                <span class="comment">//判断是否需要进行 count 查询</span></span><br><span class="line">                <span class="keyword">if</span> (dialect.beforeCount(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    <span class="comment">//查询总数</span></span><br><span class="line">                    Long count = count(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                    <span class="comment">//处理查询总数，返回 true 时继续分页查询，false 时直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (!dialect.afterCount(count, parameter, rowBounds)) &#123;</span><br><span class="line">                        <span class="comment">//当查询总数为 0 时，直接返回空的结果</span></span><br><span class="line">                        <span class="keyword">return</span> dialect.afterPage(<span class="keyword">new</span> ArrayList(), parameter, rowBounds);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行分页查询</span></span><br><span class="line">                resultList = ExecutorUtil.pageQuery(dialect, executor,</span><br><span class="line">                        ms, parameter, rowBounds, resultHandler, boundSql, cacheKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页</span></span><br><span class="line">                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialect.afterPage(resultList, parameter, rowBounds);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            dialect.afterAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入理解MyBatis（三）&quot;&gt;&lt;a href=&quot;#深入理解MyBatis（三）&quot; class=&quot;headerlink&quot; title=&quot;深入理解MyBatis（三）&quot;&gt;&lt;/a&gt;深入理解MyBatis（三）&lt;/h2&gt;&lt;h3 id=&quot;插件模块&quot;&gt;&lt;a href=&quot;#插
      
    
    </summary>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Mybatis" scheme="https://yimchengjie.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://yimchengjie.github.io/2020/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yimchengjie.github.io/2020/09/17/设计模式/责任链模式/</id>
    <published>2020-09-17T11:35:45.000Z</published>
    <updated>2021-05-20T09:53:27.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h2 id="责任链模式，顾名思义，就是用一条执行链，每个节点都可能会对请求做出处理，然后传递给下一个节点继续处理或结束。"><a href="#责任链模式，顾名思义，就是用一条执行链，每个节点都可能会对请求做出处理，然后传递给下一个节点继续处理或结束。" class="headerlink" title="责任链模式，顾名思义，就是用一条执行链，每个节点都可能会对请求做出处理，然后传递给下一个节点继续处理或结束。"></a>责任链模式，顾名思义，就是用一条执行链，每个节点都可能会对请求做出处理，然后传递给下一个节点继续处理或结束。</h2><p>废话不多说，直接show code。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request();</span><br><span class="line">    String json = <span class="string">"&#123;\"name\":\"request\",\"age\":\"18\",\"sex\":\"男\"&#125;"</span>;</span><br><span class="line">    request.setRequest(JSONObject.parseObject(json));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.getRequest()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(request.getRequest());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.getRequest().get(<span class="string">"name"</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(request.getRequest().get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.getRequest().get(<span class="string">"age"</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(request.getRequest().get(<span class="string">"age"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.getRequest().get(<span class="string">"sex"</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(request.getRequest().get(<span class="string">"sex"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样多个if组成的链式处理数据，在开发中是非常常见的，但是当处理代码量大的时候、if语句过多的时候，代码会变得很难维护，并且职责不清晰。当整个方法中的代码超过一定的量的时候，再让你去在一个处理中增加一些功能点的时候，想象一下那个画面， 肯定很痛苦。<br>其实责任链模式就是把一个或多个if中的操作，当作一个节点，而所有节点组成的处理链可以说就是责任链。</p><p>我们把if抽象成Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getRequest()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(request.getRequest());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再把要用到的Hander放到HandlerChain中，构成处理链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Handler&gt; handlerChain;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        handlerChain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        handlerChain.add(<span class="keyword">new</span> OneHandler());</span><br><span class="line">        handlerChain.add(<span class="keyword">new</span> TwoHandler());</span><br><span class="line">        handlerChain.add(<span class="keyword">new</span> ThreeHandler());</span><br><span class="line">        handlerChain.add(<span class="keyword">new</span> FourHandler());</span><br><span class="line">        handlerChain.add(<span class="keyword">new</span> FiveHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Handler handler:handlerChain)&#123;</span><br><span class="line">            handler.handler(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，我们只需要把请求交给HandlerChain，由他来处理就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HandlerChain handlerChain = <span class="keyword">new</span> HandlerChain();</span><br><span class="line">handlerChain.handler(request);</span><br></pre></td></tr></table></figure><h2 id="责任链模式的应用"><a href="#责任链模式的应用" class="headerlink" title="责任链模式的应用"></a>责任链模式的应用</h2><ol><li>当请求需要执行多个处理时。</li><li>当程序需要用不同的方法处理不同的请求时。</li><li>需要动态调整处理顺序时。</li></ol><p>以上的一些常见都可以使用责任链模式，其实在很多框架中都用到了责任链模式<br>比如 Netty中的ChannelPipline，SpringMVC中的Filter，OKHttp中的RealInterceptorChain，Tomcat中的Encoding，MyBatis中的Plugin等等。时间有限，这里就不细细展开了。</p><h2 id="责任链模式的优缺点"><a href="#责任链模式的优缺点" class="headerlink" title="责任链模式的优缺点"></a>责任链模式的优缺点</h2><p>优点：</p><ol><li>可以控制处理请求的顺序</li><li>每个处理节点分工明确，符合单一职责</li><li>可以通过添加处理节点来新增处理操作</li></ol><p>缺点：</p><ol><li>由于Hander的增多会导致类的数量很多</li><li>节点过多时影响性能</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了责任链模式，是不是觉得很简单？ 就这？？</p><p>其实设计模式就是这样的，说起来简单，做起来难。 不然也不会有这么多恶心的代码了。<br>作为程序员， 代码是我们的另一张脸。 学好设计模式，让后人看到你的代码的时候再也不会说出 “这TM哪个sb写的代码”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;责任链模式&quot;&gt;&lt;a href=&quot;#责任链模式&quot; class=&quot;headerlink&quot; title=&quot;责任链模式&quot;&gt;&lt;/a&gt;责任链模式&lt;/h2&gt;&lt;h2 id=&quot;责任链模式，顾名思义，就是用一条执行链，每个节点都可能会对请求做出处理，然后传递给下一个节点继续处理或结束
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MyBatis（二）</title>
    <link href="https://yimchengjie.github.io/2020/09/08/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MyBatis%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://yimchengjie.github.io/2020/09/08/Java开发框架/深入理解MyBatis（二）/</id>
    <published>2020-09-08T12:01:38.000Z</published>
    <updated>2021-05-20T09:53:27.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解MyBatis（二）"><a href="#深入理解MyBatis（二）" class="headerlink" title="深入理解MyBatis（二）"></a>深入理解MyBatis（二）</h2><hr><h3 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h3><p>在核心处理层中，实现了包括MyBatis的初始化以及完成一次数据库操作的涉及的全部流程</p><h4 id="MyBatis初始化"><a href="#MyBatis初始化" class="headerlink" title="MyBatis初始化"></a>MyBatis初始化</h4><p>MyBatis的初始化主要工作是加载并解析mybatis-config.xml配置文件、映射配置文件以及相关的注解信息。</p><p>MyBatis的初始化入口是SqlSessionFactoryBuilder.build()方法，此方法会创建XMLConfigBuilder对象来解析mybatis-config.xml配置文件，得到Configuration对象，然后以此创建出DefaultSqlSessionFactory对象，完成初始化。</p><h5 id="XMLConfigBuilder"><a href="#XMLConfigBuilder" class="headerlink" title="XMLConfigBuilder"></a>XMLConfigBuilder</h5><p>XMLConfigBuilder负责解析mybatis-config.xml文件，核心如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来标识是否解析过mybatis-config.xml文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> parsed;</span><br><span class="line"><span class="comment">// 用来解析配置文件的XPathParser</span></span><br><span class="line"><span class="keyword">private</span> XPathParser parser;</span><br><span class="line"><span class="comment">// 标识&lt;environment&gt;配置的名称，默认读区&lt;environment&gt;标签的default属性</span></span><br><span class="line"><span class="keyword">private</span> String environment;</span><br><span class="line"><span class="comment">// 负责创建和缓存Reflector对象</span></span><br><span class="line"><span class="keyword">private</span> ReflectorFactory localReflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据parsed标记判断是否需要解析配置文件</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 在配置文件中寻找&lt;configuration&gt;标签，并开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析&lt;settings&gt;,settings下的属性会影响到MyBatis全局性配置，会改变MyBatis运行时行为。</span></span><br><span class="line">    Properties settings = settingsAsPropertiess(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">    <span class="comment">//issue #117 read properties first</span></span><br><span class="line">    <span class="comment">// 解析&lt;properties&gt;，在之后使用其中的内容替换占位符。</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    <span class="comment">// 类型别名</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">    <span class="comment">// 对象工厂</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">    <span class="comment">// 对象包装工厂</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">    <span class="comment">// 反射工厂</span></span><br><span class="line">    reflectionFactoryElement(root.evalNode(<span class="string">"reflectionFactory"</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    <span class="comment">// 环境</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">    <span class="comment">// 类型处理器</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">    <span class="comment">// 映射器</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XMLMapperBuilder"><a href="#XMLMapperBuilder" class="headerlink" title="XMLMapperBuilder"></a>XMLMapperBuilder</h5><p>最重要的解析映射文件。程序入口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否已经加载过该映射文件</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 处理mapper节点</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    <span class="comment">// 将resouce添加到已加载集合中</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 注册mapper接口</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理上面方法中解析失败的&lt;resultMap&gt;节点</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  <span class="comment">// 处理上面方法中解析失败的&lt;cache-ref&gt;节点</span></span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  <span class="comment">// 处理上面方法中解析失败的SQL语句节点</span></span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>configurationElement(parser.evalNode(&quot;/mapper&quot;))</code>方法中，有着各种节点的处理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取mapper节点的namespace属性，为空时抛出异常</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 解析&lt;cache-ref&gt;节点</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">    <span class="comment">// 解析&lt;cache&gt;节点</span></span><br><span class="line">    cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">    <span class="comment">// 解析&lt;parameterMap&gt;节点（已被废弃）</span></span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">    <span class="comment">// 解析&lt;resultMap&gt;节点</span></span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">    <span class="comment">// 解析&lt;sql&gt;节点</span></span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">    <span class="comment">// 解析sql语句</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当mapper文件解析注册完成以后， 整个MyBatis的初始化也就基本上差不多了。</p><h5 id="MyBatis初始化过程总结"><a href="#MyBatis初始化过程总结" class="headerlink" title="MyBatis初始化过程总结"></a>MyBatis初始化过程总结</h5><p>其实MyBatis的初始化说白了就是把配置文件和映射文件进行解析的过程。里面如何解析一个节点的代码其实不用特别care，因为那都是一些定义好的规则， 重要的时其中用到的思想，设计模式等。</p><p>整个MyBatis初始化看成一个方法，如参是配置文件映射文件，出参是DefaultSqlSessionFactory，而DefaultSqlSessionFactory中最重要的就是Configuration，xml文件解析出来的内容都被注册到了Configuration。然后Configuration影响后续MyBatis的具体行为。</p><h4 id="会话创建过程"><a href="#会话创建过程" class="headerlink" title="会话创建过程"></a>会话创建过程</h4><p>我们每一次跟数据库通信，都要创建一个会话，我们使用openSession()方法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置中获取环境</span></span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="comment">// 获取事务工厂类</span></span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    <span class="comment">// 创建事务</span></span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 创建执行器，以来执行SQL</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="comment">// 默认的SqlSession</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SQL的生成、执行过程"><a href="#SQL的生成、执行过程" class="headerlink" title="SQL的生成、执行过程"></a>SQL的生成、执行过程</h4><p>回顾在JDBC中的过程</p><ol><li>获取Connection</li><li>传入sql语句构建预编译对象</li><li>设置参数</li><li>执行SQL</li><li>从结果集获取数据</li></ol><p>在MyBatis中的过程，简单来说</p><ol><li>通过sqlSession，创建mapper代理类，执行调用SQL的方法，比如selectOne</li><li>获取BoundSql对象，根据参数生成SQL语句</li><li>从数据库连接池获取Connection，并创建代理</li><li>从Connection中构建预编译对象</li><li>设置参数</li><li>执行SQL</li><li>从结果集获取数据</li><li>将数据转换为Java对象</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入理解MyBatis（二）&quot;&gt;&lt;a href=&quot;#深入理解MyBatis（二）&quot; class=&quot;headerlink&quot; title=&quot;深入理解MyBatis（二）&quot;&gt;&lt;/a&gt;深入理解MyBatis（二）&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;核心处理层&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Mybatis" scheme="https://yimchengjie.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MyBatis（一）</title>
    <link href="https://yimchengjie.github.io/2020/09/05/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MyBatis%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://yimchengjie.github.io/2020/09/05/Java开发框架/深入理解MyBatis（一）/</id>
    <published>2020-09-05T06:38:38.000Z</published>
    <updated>2021-05-20T09:53:27.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解MyBatis（一）"><a href="#深入理解MyBatis（一）" class="headerlink" title="深入理解MyBatis（一）"></a>深入理解MyBatis（一）</h2><p>MyBatis的整体架构分为三层，分别是基础支持层、核心接口层和接口层<br><img src="/2020/09/05/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MyBatis%EF%BC%88%E4%B8%80%EF%BC%89/MyBatis%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="MyBatis整体架构"></p><h3 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h3><p>基础支持层位于MyBatis整体架构最底层，支撑者MyBatis的核心业务层，是整个框架的基石。</p><h4 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h4><p>解析起模块主要提供两个功能：一个是对Xpath进行封装，为MyBatis初始化时解析配置文件提供支持，另一个时为了处理SQL动态占位符提供支持。</p><p><img src="/2020/09/05/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MyBatis%EF%BC%88%E4%B8%80%EF%BC%89/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.png" alt="解析器模块"></p><h5 id="XPathParser-封装的XML解析器"><a href="#XPathParser-封装的XML解析器" class="headerlink" title="XPathParser(封装的XML解析器)"></a>XPathParser(封装的XML解析器)</h5><p>Mybatis提供的XPathParser封装了XPath（用来查询XMl文档的语言）、Document、EntityResolver（用于加载本地DTD文件，DTD就是标签的定义字典）</p><p>默认情况，解析mybatis-config.xml配置文件，会加载(<a href="http://mybatis.org/dtd/mybatis-3-config.dtd)这个DTD文档。" target="_blank" rel="noopener">http://mybatis.org/dtd/mybatis-3-config.dtd)这个DTD文档。</a></p><p>XPathParser中提供了一系列的eval方法，用于解析boolean、short、long、int、String、Node等类型的信息，更具路径和表达式找出节点或者属性，进行响应的类型转换</p><p>在XPathParser.evalString()中，调用了PropertyParser.parse()来处理节点中响应的默认值。<br>PropertyParser.parse()会创建GenericTokenParser解析器，并将默认值的处理委托给GenericTokenParser.parse()方法。</p><h6 id="GenericTokenParser-通配符解析器"><a href="#GenericTokenParser-通配符解析器" class="headerlink" title="GenericTokenParser(通配符解析器)"></a>GenericTokenParser(通配符解析器)</h6><p>在GenericTokenParser中标记了两个值，openToken和closeToken，记录了占位符的开始和结束。<br>GenericTokenParser.parse()找出占位符的字面值，并交给TokenHandler处理，返回解析后的结果，然后重新拼接字符串并返回。</p><h6 id="TokenHandler-符号解析器"><a href="#TokenHandler-符号解析器" class="headerlink" title="TokenHandler(符号解析器)"></a>TokenHandler(符号解析器)</h6><p>TokenHandler几口定义了解析符号的方法。</p><p>在PropertyParser中使用了它的一个实现类 VariableTokenHandler来解析占位符。</p><p>GenericTokenParser仅仅是找到占位符，而具体的解析都是又TokenHandler的实现类来做的。</p><h4 id="反射模块"><a href="#反射模块" class="headerlink" title="反射模块"></a>反射模块</h4><p>Mybatis在进行参数处理、结果映射的时候会设计大量的反射操作。为了简化反射操作的相关代码，Mybatis提供了反射模块，对常见的反射操作做了封装，提供简介的API。</p><h5 id="Reflector-amp-ReflectorFactory"><a href="#Reflector-amp-ReflectorFactory" class="headerlink" title="Reflector&amp;ReflectorFactory"></a>Reflector&amp;ReflectorFactory</h5><p>Reflector是MyBatis中反射模块的基础，每一个Reflector对象对于一个类，在Reflector中存储了反射操作需要用到的类的元信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应的类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// 可读熟悉的名称集合，可读熟悉就是存相应的getter方法的属性</span></span><br><span class="line"><span class="keyword">private</span> String[] readablePropertyNames = EMPTY_STRING_ARRAY;</span><br><span class="line"><span class="comment">// 可写属性的名称集合，可写属性就是存相应的setter方法的属性</span></span><br><span class="line"><span class="keyword">private</span> String[] writeablePropertyNames = EMPTY_STRING_ARRAY;</span><br><span class="line"><span class="comment">// 记录了属性的setter方法，key是属性名称，value是Invoker对象，Invoker封装了Method</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;String, Invoker&gt;();</span><br><span class="line"><span class="comment">// 记录了相应的getter方法，key是属性名称，value是Invoker对象</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;String, Invoker&gt;();</span><br><span class="line"><span class="comment">// 记录了属性的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">// 记录了属性的getter方法的返回值类型，key是属性名称，value是getter方法的返回类型</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">// 记录了默认的构造方法</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line"><span class="comment">// 记录了所有属性名称的集合</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure><p>ReflectorFactory接口实现了对Reflector的创建和缓存。<br>Default是一个具体实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否开启Reflector对象的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> classCacheEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 使用ConcurrentMap实现对Reflector对象的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Reflector&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为指定的Class创建Reflector对象，并将对象缓存到reflectorMap中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">            <span class="comment">// synchronized (type) removed see issue #461</span></span><br><span class="line">        Reflector cached = reflectorMap.get(type);</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached = <span class="keyword">new</span> Reflector(type);</span><br><span class="line">        reflectorMap.put(type, cached);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换模块"><a href="#类型转换模块" class="headerlink" title="类型转换模块"></a>类型转换模块</h4><p>类型转换模块为简化配置文件提供了别名机制。另外，实现了JDBC类型与JAVA类型之间的转换，该功能在SQL语句绑定实参以及映射查询结果集时都会涉及。为SQL绑定参数是，为将Java数据转换为JDBC类型，而在结果映射时，会将数据转换为Java类型。</p><h5 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h5><p>MyBatis中所有的类型转换器都继承了TypeHandler接口，在TypeHandler定义了四个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 在通过PreparedStatement为SQL语句绑定参数时，会将数据由Java类型转换为JdbcType类型</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从ResultSet中获取数据时会调用get方法，会将数据由JdbcType类型转换为Java类型</span></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TypeAliasRegeistry"><a href="#TypeAliasRegeistry" class="headerlink" title="TypeAliasRegeistry"></a>TypeAliasRegeistry</h5><p>Mybatis可以为一个类添加一个别名，之后通过别名引用该类。它的结构比较简单，用<code>Map&lt;String,Class&lt;?&gt;&gt;</code>来管理别名与类型之间的关系</p><h4 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h4><p>日志可以帮互助运维人员和管理人员快速找出系统的故障和瓶颈，也可以帮助开发人员与运维人员沟通。<br>在Java开发中常用的日志框架有Log4j、Log4j2、Appache Commons Log、java.util.logging、slf4j等。这些工具对外的接口不经相同，为了统一这些工具的接口，MyBatis定义了一套统一的日志接口供上层使用，并为上述常用的日志框架提供了相应的适配器。</p><h4 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h4><p>资源加载模块主要是对类的加载起进行封装，确定类加载起的使用顺序，并且提供了加载类文件和其他资源文件的功能，</p><h4 id="数据源模块"><a href="#数据源模块" class="headerlink" title="数据源模块"></a>数据源模块</h4><p>在数据持久层中，数据源是一个非常重要的组建，其性能直接关系到整个数据持久层的性能。</p><h4 id="事务管理模块"><a href="#事务管理模块" class="headerlink" title="事务管理模块"></a>事务管理模块</h4><p>控制数据库事务是一件非常重要的工作。MyBatis使用了Transaction接口对数据库事务进行了抽象。</p><h4 id="binding模块"><a href="#binding模块" class="headerlink" title="binding模块"></a>binding模块</h4><p>binding模块用来将用户自定义的Mapper几口与映射配置文件关联起来。</p><h4 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h4><p>MyBatis提供了两层缓存结构，使用Cache接口的实现。</p><h5 id="Cache接口"><a href="#Cache接口" class="headerlink" title="Cache接口"></a>Cache接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 该缓存对象的id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存中添加数据，一般情况下，key是CacheKey，value是查询结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据指定的key，在缓存中查找结果对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除key对于的缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存的个数，这个方法不会被Mybatis核心功能使用，所以可以提供空实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 获取读写锁，这个方法不会被Mybatis核心功能使用，所以可以提供空实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h5><p>由于MyBatis中涉及动态SQL等多方面因素，缓存Key不能仅仅通过一个String来表示，所以MyBatis通过CacheKey表示缓存key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乘数，固定初始值质数37，不会变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="comment">// 当前hashCode值，初始值是质数17，</span></span><br><span class="line"><span class="comment">// 计算公式：hashcode=hashcode * multiplier  + object.hashCode()*count</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="comment">// 所有更新对象的初始hashCode的和</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="comment">// 当前组合中对象的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 此List保存当前组合中所有的对象</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入理解MyBatis（一）&quot;&gt;&lt;a href=&quot;#深入理解MyBatis（一）&quot; class=&quot;headerlink&quot; title=&quot;深入理解MyBatis（一）&quot;&gt;&lt;/a&gt;深入理解MyBatis（一）&lt;/h2&gt;&lt;p&gt;MyBatis的整体架构分为三层，分别是基础
      
    
    </summary>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Mybatis" scheme="https://yimchengjie.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的锁设计</title>
    <link href="https://yimchengjie.github.io/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%9A%84%E9%94%81%E8%AE%BE%E8%AE%A1/"/>
    <id>https://yimchengjie.github.io/2020/08/27/数据库/MySQL的锁设计/</id>
    <published>2020-08-27T06:57:20.000Z</published>
    <updated>2021-05-20T09:53:27.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL的锁设计"><a href="#MySQL的锁设计" class="headerlink" title="MySQL的锁设计"></a>MySQL的锁设计</h2><p>MySQL数据库的锁设计初衷是处理并发问题，数据库需要合理的控制资源的访问规则。</p><p>根据加锁的番位，MySQL里的锁大致可以分为全局锁、表级锁和行锁三类。</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁是对整个数据库实例的加锁。</p><p>MySQL提供了全局读锁的方法，使用命令<code>Flush tables with read lock(FTWRL)</code>。<br>对数据库加全局读锁后，数据库处于只读状态，所有修改命令都会被阻塞。</p><p>全局锁的经典场景就是全库的逻辑备份。也就是把整个库的数据select出来存档。</p><p>但是让数据库处于只读状态，听上去就很危险：</p><ul><li>如果在主库上备份，那么整个备份期间，业务基本上无法正常使用。</li><li>如果在从库上备份，那么备份期间从库就不能执行从主库同步过来的binlog，导致主从延迟。</li></ul><p>那为什么还需要全局锁呢？</p><p>MySQL自带的逻辑备份根据是mysqldump。使用参数<code>-single-transaction</code>，导数据之前会启动一个事务，这样就确保了一致性视图，通过MVCC的支持，就能实现数据一致。<br>但是这是数据库引擎支持的， 对于MyISAM这种不支持事务的引擎，就需要用到FTWRL命令了。</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL中的表级锁又分为两种：一种是表锁，一种是元数据锁（meta data lock，MDL）</p><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁的语法是<code>lock tables...read/write</code>。 与FTWRL类似，可以使用<code>unlock tables</code>主动释放锁，可以在客户端断开的时候自动释放。<br><code>lock tables</code>语法除了会限制别的线程的读写外，也会限定本线程接下来的操作对象；即只能访问它持有的锁资源。</p><p>所以锁表的操作一般不会使用，影响面还是太大了。</p><h4 id="MDL元数据锁"><a href="#MDL元数据锁" class="headerlink" title="MDL元数据锁"></a>MDL元数据锁</h4><p>MDL不需要显示的使用，在访问一个表的时候会自动加锁。 MDL的作用是保证读写的正确性。<br>比如一个查询正在遍历一个表的数据，而期间另一个线程对这个表结构做了变更，删除了一个字段，那么查询拿到的数据跟表结构对不上了。</p><p>MDL锁就是当一个表做增删改操作的时候，会加上MDL读锁，当对表做结构变更时，加MDL写锁。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是由引擎层各自实现的，但并不是所有有的引擎都支持行锁。MyISAM就不支持行锁。不支持行锁就意味着，同一张表同时只能有一个更新在执行，这样就无法应对并发需求。<br>InnoDB支持行锁，所谓行锁就是正对一张表中的行记录的锁。</p><p>在InnoDB的事务中，行锁是在需要的时候才加上，但是并不是不需要的时候就立刻释放的。 它要等到事务结束才会释放。 <strong>因此，如果事务中需要锁多个行，那么要把最可能造成锁冲突，最可能影响并发的锁放在后面。</strong> 也就是说，把最可能被多个事务同时加锁的操作放在最后。这样对于一个事务来说，它占用这个热点锁的时间就少，也就减少了其他事务等待的时间。</p><h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>现在有这样一个场景。<br>线程A开启事务<br>-&gt;修改记录1<br>-&gt;线程B开启事务<br>-&gt;修改记录2<br>-&gt;线程A修改记录2(记录2已被线程B加锁，线程A进入等待)<br>-&gt;线程B修改记录1(记录1已被线程A加锁，线程B进入等待)<br>-&gt;死锁</p><p>当出现死锁时，有两种解决策略：</p><ol><li>第一等待直到超时。这个等待阈值可以通过mysql参数<code>innodb_lock_wait_timeout</code>来设置。</li><li>发起死锁检测，当出现死锁时，主动回滚死锁链中的某一个事务，让它为其他事务让道。通过mysql参数<code>innodb_deadlock_detect</code>设为on，开启死锁检测。</li></ol><p>一般会采用第二种策略，因为第一种如果设置等待时间过长，那线程的等待时间过长，是无法接受的。但如果设置等待时间过短，又可能会影响到正常业务。</p><p>但第二种策略也有问题，当每一个事务要访问的行被锁的时候，就要遍历它所等待的线程要访问的行有没有被别人锁住，如此循环，最后判断时候出现循环等待（即死锁）。虽然解决了死锁，但是死锁检测的操作占用了巨大资源。<br>如何解决这一问题？ 一种思路是控制并发度。比如同一行最多只能有10个线程来更新，那么死锁检测的成本就不会太高。<br>这个并发控制如果做到数据库服务端，可以考虑用中间件实现，或者有能力的修改MySQL源码，使其在进入引擎之前排队。</p><p>那有什么办法可以从业务的角度解决这一问题？<br>那就是尽量细化记录，而不是记录一个行。比如账户的金额，可以用多个记录的合来表示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL的锁设计&quot;&gt;&lt;a href=&quot;#MySQL的锁设计&quot; class=&quot;headerlink&quot; title=&quot;MySQL的锁设计&quot;&gt;&lt;/a&gt;MySQL的锁设计&lt;/h2&gt;&lt;p&gt;MySQL数据库的锁设计初衷是处理并发问题，数据库需要合理的控制资源的访问规则。&lt;/
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://yimchengjie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://yimchengjie.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务原理</title>
    <link href="https://yimchengjie.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://yimchengjie.github.io/2020/08/26/数据库/MySQL事务原理/</id>
    <published>2020-08-26T02:05:20.000Z</published>
    <updated>2021-05-20T09:53:27.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL事务原理"><a href="#MySQL事务原理" class="headerlink" title="MySQL事务原理"></a>MySQL事务原理</h2><h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>当数据库上有多个事务同时执行的时候， 就会出现脏读、不可重复读<br>幻读的问题，为了解决这些问题，引出了事<strong>务隔离级别</strong>。</p><p>SQL的事务隔离级别包括：</p><ul><li>读未提交(read uncommitted): 一个事务还没提交时，它的修改就被其他事务看到了</li><li>读提交(read committed): 一个事务提交之后， 它的变更才能被其他事务看到</li><li>可重复读(repeatable read): 一个事务执行过程中看到的数据总是和这个事务在启动之初的数据是一致的</li><li>串行化(serializable): 对于同一行记录，会加读锁、写锁。后访问的事务必须等前一个事务完成才能执行</li></ul><h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>在MySQL中，每一条记录在更新时都会记录一条回滚操作，记录上一次的最新值，通过一次次回滚，可以得到以前的某状态下的值。</p><p>数据库用视图记录一条记录某一状态，所以一条记录在系统中就存在多个视图版本，这就是数据库的<strong>多版本并发控制(MVCC)</strong></p><p>回滚日志在不需要的时候被删除， 当系统里没有视图需要用到这次回滚的时候就会被删除。</p><h4 id="视图概念"><a href="#视图概念" class="headerlink" title="视图概念"></a>视图概念</h4><p>在MySQL中，有两个“视图”</p><ol><li>view。它是一个查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果.创建视图的语法是create view</li><li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持读提交和可重复读隔离级别的实现</li></ol><h5 id="视图在MVCC中是怎么工作的"><a href="#视图在MVCC中是怎么工作的" class="headerlink" title="视图在MVCC中是怎么工作的"></a>视图在MVCC中是怎么工作的</h5><p>在可重复读隔离级别下，事务在启动后就记录了“快照”，这个快照是基于整个数据库的。<br>那这个快照是怎么实现的呢，肯定不是拷贝整个库。</p><p>在InnoDB中每个事务都有一个唯一的事务ID，transaction id， 它在事务开始时向InnoDB申请，保证严格的递增。<br>数据库中的每一行都有多个版本，每次事务在更新数据的时候，都会产生一个新数据版本，并且记录transaction id为<code>row trx_id</code>。同时记录指向旧数据的位置，以便能够拿到旧数据。</p><p><img src="/2020/08/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/rowTrx_id.jpg" alt="&quot;row trx_id&quot;"></p><p>而这个记录了指向旧数据位置的东西，就是undo log（回滚日志），而且不同版本的数据并不是真实存储在数据库中的，而是更具undo log计算出来的。</p><p>因此，可重复读，就是一个事务启动后，访问数据行，如果这个数据行的事务id不在已提交事务id数组中，就往前找，直到找到一个可见的版本。</p><h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><ol><li>显示启动事务语句， begin/start transaction。 提交commit，回滚rollback</li><li>set autocommit=0 ，关闭线程的自动提交。这意味着每个SQL执行都会开启事务，事务持续直到你主动执行commit或者rollback</li></ol><p>不推荐用2，因为如果设置了关闭自动提交，那这次长连接都需要手动提交事务</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL事务原理&quot;&gt;&lt;a href=&quot;#MySQL事务原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL事务原理&quot;&gt;&lt;/a&gt;MySQL事务原理&lt;/h2&gt;&lt;h3 id=&quot;事务隔离&quot;&gt;&lt;a href=&quot;#事务隔离&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://yimchengjie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://yimchengjie.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中如何执行一句SQL</title>
    <link href="https://yimchengjie.github.io/2020/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E5%8F%A5SQL/"/>
    <id>https://yimchengjie.github.io/2020/08/25/数据库/MySQL中如何执行一句SQL/</id>
    <published>2020-08-25T02:32:20.000Z</published>
    <updated>2021-05-20T09:53:27.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL中如何执行一句SQL"><a href="#MySQL中如何执行一句SQL" class="headerlink" title="MySQL中如何执行一句SQL"></a>MySQL中如何执行一句SQL</h2><p><img src="/2020/08/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E5%8F%A5SQL/MySQl%E7%BB%93%E6%9E%84.jpg" alt="MySQL结构"></p><p>MySQL大体上的结构分为两部分，服务层和引擎层</p><p>服务层包括了连接器、缓存、分析器、优化器、执行器； 这一层涵盖了大部分的服务功能</p><p>引擎层是可插拔的存储引擎，支持InnoDB、MyISAM等多种存储引擎</p><h3 id="MySQL结构解析"><a href="#MySQL结构解析" class="headerlink" title="MySQL结构解析"></a>MySQL结构解析</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>连接器负责和客户端建立连接、获取权限、维持、管理连接等。</p><p>在完成TCP握手后，连接器开始验证身份，如果用户名密码认证通过，会获取当前拥有权限。这断开本次连接之前，权限都不会改变。<br>这就意味着，只要连接建立，那这次连接的权限就无法修改。</p><p>对于一个MySQL连接，它会把执行中的临时内存管理在连接对象中，这些资源会在连接断开时才释放，所以一个长连接累计下来会导致内存占用过大的问题。<br>针对这一问题，可以采用两种方案： </p><ol><li>定期断开连接，释放资源。</li><li>在执行一次较大的操作后，执行<code>mysql_reset_connection</code>来初始化连接；这个过程不需要重建连接和重新鉴权，会把连接重置到刚刚创建完的状态。</li></ol><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>MySQL在拿到一个查询语句的时候，会先到缓存中查看是否之前执行过这条查询语句。之前执行过的语句以及结果，被保存在缓存中，就直接把结果返回客户端。<br>如果语句不在缓存，就会继续后面的流程，最后会把结果存入缓存。</p><p>MySQL的缓存看上去很美好，但它其实很不实用！</p><p>查询缓存的过程是极容易失效的，因为只要当前查询的表被更新了，那么这个表上的缓存结果就会被清空。所以除非是一张静态表，或者更新频率很低，那这才会适合使用查询缓存。</p><p>幸运的是，MySQL提供了选择，可以使用参数<code>query_cache_type=DEMAND</code>。这样默认的SQL语句就不会使用缓存，而对于需要缓存的查询， 可以用<code>select SQL_CACHE * from xxx</code>这样的方式来指定。</p><p><strong>需要注意的是，MySQL8.0删除了缓存模块，整个功能都没有了</strong><br>大多数应用会把缓存做在应用级，比如MyBatis、redis、memcache等；这样直接在内存中查询缓存，少了一次网络I/O，效率更高了。也就不会在MySQL中使用缓存了。</p><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>分析器是MySQL把一句SQL解析的过程。</p><p>第一步，词法分析，把一句SQL分成多个词，赋予每一个词意义；即识别每一个词，比如把“select”识别为查询，把“table_A”识别为表A，把“id”识别为字段等。</p><p>第二部，语法分析，确保一句SQL符合MySQL的语法规范。</p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>经过分析器分析后，MySQL已经知道这句SQL要干嘛了。但在开始执行之前， 还要经过优化器。<br>它的作用是在一个表中有多个索引的情况下决定使用哪个索引；以及一个语句有多表连接时，决定表的连接顺序。</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>开始执行时，会先判断当前连接对该操作的表有无对应的读写权限，没有就返回没有权限的错误。（在查询缓存中，会在结果返回前做鉴权）<br>如果通过，就会打开表，然后根据表的引擎定义，去调用相应的引擎提供的接口。</p><h3 id="日志模块redo-log"><a href="#日志模块redo-log" class="headerlink" title="日志模块redo log"></a>日志模块redo log</h3><p>在MySQL中，如果每一次更新操作都直接写入磁盘，然后在磁盘中找到响应位置更新记录，整个过程的IO成本，查找成本都很高。<br>MySQL采用WAL技术，全称是Write-Ahead Logging， 它的关键就是先记录操作日志， 再写入磁盘。<br>redo log记录的是“在某个数据页做了什么修改”</p><p>当一个记录需要进行更新操作时， InnoDB引擎会先把记录写到redo log中，并更新内存，这样这个操作就算完成了。 然后InnoDB会在适当的时候，将操作记录更新到磁盘里， 这个更新往往就是在系统比较空闲的时候。</p><p>在InnoDB中，redo log是固定大小的，整个redo log由一块块小的文件组成。结构类似与一个循环队列或者循环链表，从头开始写，写到末尾再回到开头循环写。采用类似于双指针追逐算法来控制是否要将记录更新到硬盘。redo log被提交后，写入磁盘（redo log持久化默认策略）。由于redo log是顺序写入磁盘的，所以开销不会很大。</p><h3 id="日志模块binlog"><a href="#日志模块binlog" class="headerlink" title="日志模块binlog"></a>日志模块binlog</h3><p>上面的redo log日志是在InnoDB中的，服务层也有它的日志，称为binlog（归档日志）</p><p>这是因为以前的MyISAM没有日志记录能力，只能依靠binlog实现crash-safe（安全宕机）</p><p>binlog是可追加写入的，不像redo log只有固定大小</p><h4 id="一条update语句在InnoDB引擎中的流程："><a href="#一条update语句在InnoDB引擎中的流程：" class="headerlink" title="一条update语句在InnoDB引擎中的流程："></a>一条update语句在InnoDB引擎中的流程：</h4><ol><li>执行器通过引擎找到id=1的这一行，id为主键，引擎直接用树搜索到这一行，如果id=2这条数据所在的数据页本来就在内存中，就直接返回给执行器；否则把这个数据页读入内存，再返回。</li><li>执行器拿到引擎给的行数据，把这个值+1，那么旧值就是N，新值为N+1，将新的数据通过引擎写入这行。</li><li>引擎将这个数据写入（更新内存中数据页），同事将操作记录写到redo log，此时redo log的状态是prepare。然后告知执行器执行完，可以进行事务提交</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘</li><li>执行器调用引擎的事务提交接口，引擎把刚刚写入的redo log状态改为commit，更新完成。</li></ol><h4 id="redo-log的prepare和commit两种状态"><a href="#redo-log的prepare和commit两种状态" class="headerlink" title="redo log的prepare和commit两种状态"></a>redo log的prepare和commit两种状态</h4><p>为什么要给redo log设置两种状态呢？采用两阶段提交，这是为了让两份日志之间的逻辑一致。</p><p>一个事务必须要将两个日志都写完，才算完成提交。这样就保证了两份日志的同步。</p><p>两阶段提交，是跨系统维持数据逻辑一致性常用的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL中如何执行一句SQL&quot;&gt;&lt;a href=&quot;#MySQL中如何执行一句SQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL中如何执行一句SQL&quot;&gt;&lt;/a&gt;MySQL中如何执行一句SQL&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/08
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://yimchengjie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://yimchengjie.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>从Java的Type到Spring的ResolvableType</title>
    <link href="https://yimchengjie.github.io/2020/08/10/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E4%BB%8EJava%E7%9A%84Type%E5%88%B0Spring%E7%9A%84ResolvableType/"/>
    <id>https://yimchengjie.github.io/2020/08/10/Java开发框架/从Java的Type到Spring的ResolvableType/</id>
    <published>2020-08-10T03:39:45.000Z</published>
    <updated>2021-05-20T09:53:27.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从Java的Type到Spring的ResolvableType"><a href="#从Java的Type到Spring的ResolvableType" class="headerlink" title="从Java的Type到Spring的ResolvableType"></a>从Java的Type到Spring的ResolvableType</h2><hr><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Type是Java编程语言中所有类型的公共高级接口。</p><p><img src="/2020/08/10/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E4%BB%8EJava%E7%9A%84Type%E5%88%B0Spring%E7%9A%84ResolvableType/Type%E5%AE%B6%E6%97%8F.png" alt="Type家族"></p><p>Type体系包括以下: </p><ol><li>原始类型(Class)</li><li>参数化类型(ParameterizedType)</li><li>数组类型(GenericArrayType)</li><li>类型变量(TypeVariable)</li><li>基本类型(Class)</li></ol><h4 id="ParameterizedType-参数化类型"><a href="#ParameterizedType-参数化类型" class="headerlink" title="ParameterizedType 参数化类型"></a>ParameterizedType 参数化类型</h4><p>ParameterizedType表示参数化类型，比如Collection&lt;String&gt;<br>但不限于集合， 还包括其他平常用到的范型类，比如Class&lt;?&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取&lt;&gt;中的实际类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取&lt;&gt;前的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果一个类型是内部类，则返回这个类型的所属者，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GenericArrayType-数组类型"><a href="#GenericArrayType-数组类型" class="headerlink" title="GenericArrayType 数组类型"></a>GenericArrayType 数组类型</h4><p>GenericArrayType表示其组件类型为参数化类型或类型变量的数组类型。比如<code>T[]</code>,<code>List&lt;T&gt;[]</code><br>它表示的是范型数组，而不是普通的String[]这样的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericArrayType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得这个数组的元素类型，比如T[]  则获得T的type</span></span><br><span class="line">    <span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TypeVariable-类型变量"><a href="#TypeVariable-类型变量" class="headerlink" title="TypeVariable 类型变量"></a>TypeVariable 类型变量</h4><p>TypeVariable是用于类型变量的通用超接口。<br>它代表范型类型中的变量，即T、K、V</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取范型的上限，比如List&lt;T extends Exception&gt;,则返回Exception； 默认是Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取范型左边的实体，比如List&lt;T&gt;中的List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回在源码中的名称，比如T、K</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取范型的上限，不同于getBounds()的是，它可以获取到范型上界上添加的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Class-原始类型、基本类型"><a href="#Class-原始类型、基本类型" class="headerlink" title="Class 原始类型、基本类型"></a>Class 原始类型、基本类型</h4><p>与上面三个不同的是，Class是Type的一个实现类，属于原始类型，是Java反射的基础。<br>在程序运行期间，每一个类都对应一个Class对象，这个对象包含了类基本信息。</p><h3 id="ResolvableType"><a href="#ResolvableType" class="headerlink" title="ResolvableType"></a>ResolvableType</h3><p>ResolvableType是Spring对Type家族的一个封装，用于简化范型的处理</p><p>ResolvableType的所有构造方法都是私有化的， 但是它提供了静态方法来构造。</p><p><img src="/2020/08/10/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E4%BB%8EJava%E7%9A%84Type%E5%88%B0Spring%E7%9A%84ResolvableType/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95.png" alt="静态方法"></p><h4 id="forClass系列方法"><a href="#forClass系列方法" class="headerlink" title="forClass系列方法"></a>forClass系列方法</h4><p>直接封装指定的类型</p><h5 id="forRawClass-Class-lt-gt-clazz"><a href="#forRawClass-Class-lt-gt-clazz" class="headerlink" title="forRawClass(Class&lt;?&gt; clazz)"></a>forRawClass(Class&lt;?&gt; clazz)</h5><p>调用构造方法，并重写了三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResolvableType <span class="title">forRawClass</span><span class="params">(@Nullable Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResolvableType(clazz) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ResolvableType[] getGenerics() &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_TYPES_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAssignableFrom</span><span class="params">(Class&lt;?&gt; other)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (clazz == <span class="keyword">null</span> || ClassUtils.isAssignable(clazz, other));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAssignableFrom</span><span class="params">(ResolvableType other)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; otherClass = other.getRawClass();</span><br><span class="line">            <span class="keyword">return</span> (otherClass != <span class="keyword">null</span> &amp;&amp; (clazz == <span class="keyword">null</span> || ClassUtils.isAssignable(clazz, otherClass)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="forClass-Class-lt-gt-clazz"><a href="#forClass-Class-lt-gt-clazz" class="headerlink" title="forClass(Class&lt;?&gt; clazz)"></a>forClass(Class&lt;?&gt; clazz)</h5><p>直接调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResolvableType <span class="title">forClass</span><span class="params">(@Nullable Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResolvableType(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="forClass-Class-baseType-Class-implementationClass"><a href="#forClass-Class-baseType-Class-implementationClass" class="headerlink" title="forClass(Class baseType, Class implementationClass)"></a>forClass(Class<?> baseType, Class<?> implementationClass)</h5><p>传入基础类和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResolvableType <span class="title">forClass</span><span class="params">(Class&lt;?&gt; baseType, Class&lt;?&gt; implementationClass)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(baseType, <span class="string">"Base type must not be null"</span>);</span><br><span class="line">    ResolvableType asType = forType(implementationClass).as(baseType);</span><br><span class="line">    <span class="comment">// 如果实现类是空的，那么返回基础类</span></span><br><span class="line">    <span class="keyword">return</span> (asType == NONE ? forType(baseType) : asType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forMethod系列方法"><a href="#forMethod系列方法" class="headerlink" title="forMethod系列方法"></a>forMethod系列方法</h4><p>获取方法上的参数或返回值的类型信息</p><h5 id="forMethodParameter-Method-method-int-parameterIndex"><a href="#forMethodParameter-Method-method-int-parameterIndex" class="headerlink" title="forMethodParameter(Method method, int parameterIndex)"></a>forMethodParameter(Method method, int parameterIndex)</h5><p>传入方法， index=-1时返回方法返回值的类型， 1返回方法的第一个参数的类型，2返回第二个，以此类推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResolvableType <span class="title">forMethodParameter</span><span class="params">(Method method, <span class="keyword">int</span> parameterIndex)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(method, <span class="string">"Method must not be null"</span>);</span><br><span class="line">    <span class="keyword">return</span> forMethodParameter(<span class="keyword">new</span> MethodParameter(method, parameterIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="forMethodReturnType-Method-method"><a href="#forMethodReturnType-Method-method" class="headerlink" title="forMethodReturnType(Method method)"></a>forMethodReturnType(Method method)</h5><p>将方法的参数索引设为-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResolvableType <span class="title">forMethodReturnType</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(method, <span class="string">"Method must not be null"</span>);</span><br><span class="line">    <span class="keyword">return</span> forMethodParameter(<span class="keyword">new</span> MethodParameter(method, -<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forField系列"><a href="#forField系列" class="headerlink" title="forField系列"></a>forField系列</h4><p>用于处理字段的类型</p><h5 id="forType-Type-type-TypeProvider-typeProvider-VariableResolver-variableResolver"><a href="#forType-Type-type-TypeProvider-typeProvider-VariableResolver-variableResolver" class="headerlink" title="forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver)"></a>forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver)</h5><p>系列方法会调用到这个核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ResolvableType <span class="title">forType</span><span class="params">(@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对TypeProvider进一步进行封装，为了得到一个可以序列化的TypeProvider</span></span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> &amp;&amp; typeProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        type = SerializableTypeWrapper.forTypeProvider(typeProvider);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResolvableType(type, typeProvider, variableResolver, (ResolvableType) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存相关</span></span><br><span class="line">    cache.purgeUnreferencedEntries();</span><br><span class="line">    ResolvableType key = <span class="keyword">new</span> ResolvableType(type, typeProvider, variableResolver);</span><br><span class="line">    ResolvableType resolvableType = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (resolvableType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolvableType = <span class="keyword">new</span> ResolvableType(type, typeProvider, variableResolver, key.hash);</span><br><span class="line">        cache.put(resolvableType, resolvableType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolvableType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Spring提供的ResolvableType是对Java原生Type家族的一个封装，它包含了类、方法、字段、构造函数，当我们需要处理它们时，只需要调用响应的方法就能获取它们的ResolvableType，ResolvableType就包含了这个对象的所有类型信息</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从Java的Type到Spring的ResolvableType&quot;&gt;&lt;a href=&quot;#从Java的Type到Spring的ResolvableType&quot; class=&quot;headerlink&quot; title=&quot;从Java的Type到Spring的Resolvable
      
    
    </summary>
    
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaSE" scheme="https://yimchengjie.github.io/tags/JavaSE/"/>
    
      <category term="Spring" scheme="https://yimchengjie.github.io/tags/Spring/"/>
    
      <category term="Java开发框架" scheme="https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
