<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ycjBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuyiting.xyz/"/>
  <updated>2019-12-26T09:12:34.938Z</updated>
  <id>https://zhuyiting.xyz/</id>
  
  <author>
    <name>yanchengjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解SpringAOP</title>
    <link href="https://zhuyiting.xyz/2019/07/21/JavaWeb%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/"/>
    <id>https://zhuyiting.xyz/2019/07/21/JavaWeb框架/深入理解SpringAOP/</id>
    <published>2019-07-21T13:30:45.000Z</published>
    <updated>2019-12-26T09:12:34.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解-SpringAOP"><a href="#深入理解-SpringAOP" class="headerlink" title="深入理解 SpringAOP"></a>深入理解 SpringAOP</h2><p>AOP 是指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式</p><p>SpringAOP 的底层其实就是动态代理</p><h3 id="Spring-是如何使用动态代理的"><a href="#Spring-是如何使用动态代理的" class="headerlink" title="Spring 是如何使用动态代理的"></a>Spring 是如何使用动态代理的</h3><ol><li>将业务组件和切面组件添加到容器中,</li><li>创建对象的时候, 根据切入点表达式拦截的类, 加入通知,生成代理对象.</li><li>如果目标对象有实现接口就用 JDK 代理, 反之就用 CGLIB 代理.</li></ol><h3 id="SpringAOP-注解驱动原理"><a href="#SpringAOP-注解驱动原理" class="headerlink" title="SpringAOP 注解驱动原理"></a>SpringAOP 注解驱动原理</h3><p>IoC容器启动中,创建了哪些和AOP有关的组件? 这些组件什么时候工作? 工作内容是什么?</p><h4 id="1-实现入口-EnableAspectJAutoProxy"><a href="#1-实现入口-EnableAspectJAutoProxy" class="headerlink" title="1. 实现入口@EnableAspectJAutoProxy"></a>1. 实现入口@EnableAspectJAutoProxy</h4><p>主要工作:</p><ul><li>@Import(AspectJAutoProxyRegistrar.class)给容器导入 <code>AspectJAutoProxyRegistrar</code> 组件(切面自动代理注册器)</li><li>利用 AspectJAutoProxyRegistrar 给容器中注册一个切面相关的 bean<code>AnnotationAwareAspectJAutoProxyCreator</code>(支持注解的 AspectJ 自动代理创建器)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *代码跟进演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//出发点</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">//跟进</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AspectJAutoProxyRegistrar.class&#125;)</span><br><span class="line"><span class="comment">//点进AspectJAutoProxyRegistrar</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"><span class="comment">//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary方法</span></span><br><span class="line"><span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary</span></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line"><span class="comment">//点进AnnotationAwareAspectJAutoProxyCreator</span></span><br></pre></td></tr></table></figure><h4 id="2-AnnotationAwareAspectJAutoProxyCreator-创建过程"><a href="#2-AnnotationAwareAspectJAutoProxyCreator-创建过程" class="headerlink" title="2. AnnotationAwareAspectJAutoProxyCreator 创建过程"></a>2. AnnotationAwareAspectJAutoProxyCreator 创建过程</h4><p><img src="/2019/07/21/JavaWeb%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/AnnotationAwareAspectJAutoProxyCreator%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="AnnotationAwareAspectJAutoProxyCreator继承关系"></p><p>主要关注的是它继承了BeanFactoryAware和BeanPostProcessor接口,</p><p>所以它的创建是在BeanFactory进行初始化,注册BeanPostProcessor阶段(也就是BeanFactoryPostProcessor注册完成之后)</p><p>registerBeanPostProcessors(beanFactory);注册 BeanPostProcessor 来处理拦截 bean 的创建(在bean创建前后执行)；</p><ol><li>先获取 IOC 容器已经定义的需要创建对象的所有 BeanPostProcessor</li><li>注册 BeanPostProcessor,实际上就是创建 BeanPostProcessor 对象，保存在容器中；<br>创建 internalAutoProxyCreator 的 BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】<ol><li>创建 Bean 的实例</li><li>populateBean；给 bean 的各种属性赋值</li><li>initializeBean</li><li>invokeAwareMethods()：处理 Aware 接口的方法回调</li><li>applyBeanPostProcessorsBeforeInitialization();应用后置处理器的 postProcessBeforeInitialization();</li><li>invokeInitMethods()；执行自定义的初始化方法</li><li>applyBeanPostProcessorsAfterInitialization()；执行后置处理器的 postProcessAfterInitialization();</li><li>BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–》aspectJAdvisorsBuilder</li></ol></li><li>把 BeanPostProcessor 注册到 BeanFactory 中；<br>beanFactory.addBeanPostProcessor(postProcessor);</li></ol><h4 id="3-起作用阶段"><a href="#3-起作用阶段" class="headerlink" title="3. 起作用阶段"></a>3. 起作用阶段</h4><p>BeanPostProcessor是在bean实例化前后起作用的, 所以它的执行是在beanFactroy对bean实例化的阶段进行</p><p>finishBeanFactoryInitialization(beanFactory);实例化所有单例 bean</p><ol><li>遍历所有Bean,依次创建对象,使用getBean(beanName);方法</li><li>创建bean<ol><li>先看看容器中是否存在bean,如果存在直接使用,没有再创建</li><li>创建bean;<ol><li>resolveBeforeInstantiation解析,如果能返回一个代理对象则直接用,不能继续</li><li>createBean<ol><li>拿到所有BeanPostProcessor并执行postProcessBeforeInstantiation</li><li>doCreateBean真正的创建bean</li><li>创建完,执行</li></ol></li></ol></li></ol></li></ol><h4 id="4-AnnotationAwareAspectJAutoProxyCreator的作用"><a href="#4-AnnotationAwareAspectJAutoProxyCreator的作用" class="headerlink" title="4. AnnotationAwareAspectJAutoProxyCreator的作用"></a>4. AnnotationAwareAspectJAutoProxyCreator的作用</h4><h5 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h5><p>每一个bean创建之前,调用postProcessBeforeInstantiation</p><p>前提: 容器加载了@AspectJ注解的类,并加载了信息,再匹配切入点表达式与哪些类、方法匹配</p><ol><li>判断当前的bean是否在advisedBeans中(里面保存了所有需要增强的bean)</li><li>判断当前bean是否Advice、Pointcut、Advisor、AopInfrastructureBean、被@Aspect注解的类型 或者是设置了跳过自动代理</li><li>是否配置了跳过通知</li></ol><h5 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h5><p>前提：bean实例化完成</p><ol><li>获取bean的所有通知器</li><li>找到当前bean所匹配的通知器</li><li>对通知器进行优先级排序</li><li>将通知器存入adviseBeans</li><li>如果当前的bean需要注入切面,创建bean的代理对象(jdk代理或者cglib代理)</li><li>向容器返回增强后的代理对象</li></ol><h4 id="代理对象如何工作"><a href="#代理对象如何工作" class="headerlink" title="代理对象如何工作"></a>代理对象如何工作</h4><p>容器中保存了基础组件的代理对象</p><ol><li>拦截器拦截目标方法的执行</li><li>根据ProxyFactory对象获取将要执行的目标方法的增强器链</li><li>以任务栏的形式执行通知和目标方法</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>@EnableAspectJAutoProxy</code> 开启AOP功能<br>会在容器启动阶段注册一个组件 <code>AnnotationAwareAspectJAutoProxyCreator</code></li><li>容器开始创建</li><li>容器注册后置处理器;<br><code>AnnotationAwareAspectJAutoProxyCreator</code> 继承了后置处理器接口. 被创建并注册进容器</li><li>容器开始创建bean;<ol><li>创建业务逻辑bean;和切面bean</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>拦截组件创建,如果有已代理对象,直接返回</li><li>组件创建</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>执行postProcessBeforeInstantiation,给需要增强bean创建代理对象<br>获取目标对象以及advisor(增强器,切面的通知方法) 创建代理</li></ol></li><li>执行目标方法<ol><li>CglibAopProxy.intercept();拦截</li><li>执行通知任务链和目标方法</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入理解-SpringAOP&quot;&gt;&lt;a href=&quot;#深入理解-SpringAOP&quot; class=&quot;headerlink&quot; title=&quot;深入理解 SpringAOP&quot;&gt;&lt;/a&gt;深入理解 SpringAOP&lt;/h2&gt;&lt;p&gt;AOP 是指在程序运行期间动态的将某段代码切
      
    
    </summary>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://zhuyiting.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringIoC详解</title>
    <link href="https://zhuyiting.xyz/2019/07/10/JavaWeb%E6%A1%86%E6%9E%B6/SpringIoC%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhuyiting.xyz/2019/07/10/JavaWeb框架/SpringIoC详解/</id>
    <published>2019-07-10T08:30:45.000Z</published>
    <updated>2019-12-26T09:12:31.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringIoC详解"><a href="#SpringIoC详解" class="headerlink" title="SpringIoC详解"></a>SpringIoC详解</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>对于SpringIoC来说,最重要的就是容器了,容器管理这所有的Bean,控制这Bean的依赖注入</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>早期基础容器, 可以理解成一个HashMap,key是BeanName,value是Bean实例.</p><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>应用上下午,高级容器,相比BeanFactory功能全面很多</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>Bean对象在Spring中是以BeanDefinition来描述的</p><p>Bean的解析主要就是对配置文件或者配置类的解析</p><h3 id="SpringIoC注解驱动初始化过程"><a href="#SpringIoC注解驱动初始化过程" class="headerlink" title="SpringIoC注解驱动初始化过程"></a>SpringIoC注解驱动初始化过程</h3><p>SpringIoC的初始化过程也是ApplicationContext容器的初始化过程</p><p>入口:<code>AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);</code></p><ol><li><p>调用AnnotationConfigApplicationContext构造函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先执行父类构造方法,再执行本类无参构造方法</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 2. 注册带注解的类</span></span><br><span class="line">    <span class="keyword">this</span>.register(annotatedClasses);</span><br><span class="line">    <span class="comment">// 3. 更新容器</span></span><br><span class="line">    <span class="keyword">this</span>.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this(); 默认先调用父类无参构造函数,构建初始对象<strong>DefaultListableBeanFactory</strong>,最基础的BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.customClassLoader = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">this</span>.refreshed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">     <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>再调用当前类this();创建读取器和扫描器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//BeanDefinition解析器; 用来解析带注解的bean</span></span><br><span class="line">     <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">//ClassPath下的BeanDefinition的扫描器(用来扫描类)</span></span><br><span class="line">     <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建注解模式下的BeanDefinition解析器AnnotatedBeanDefinitionReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// BeanName产生器</span></span><br><span class="line">     <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">     <span class="comment">// 作用域元数据解析器</span></span><br><span class="line">     <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">     Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">     <span class="keyword">this</span>.registry = registry;</span><br><span class="line">     <span class="comment">// @Conditionl条件表达式鉴别器</span></span><br><span class="line">     <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, (ResourceLoader)<span class="keyword">null</span>);</span><br><span class="line">     AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">     DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">     <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">             beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">             beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet(<span class="number">4</span>);</span><br><span class="line">     RootBeanDefinition def;</span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册主配置类的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理@Autowired注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理@Required注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         <span class="comment">// 注册处理JSR规范注解的后置处理器</span></span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册处理jpa的后置处理器</span></span><br><span class="line">     <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(<span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             def.setBeanClass(ClassUtils.forName(<span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>, AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassNotFoundException var6) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot load optional framework class: org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>, var6);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册处理事件监听方法的处理器</span></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注册事件监听工厂</span></span><br><span class="line">     <span class="keyword">if</span> (!registry.containsBeanDefinition(<span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>)) &#123;</span><br><span class="line">         def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">         def.setSource(source);</span><br><span class="line">         beanDefs.add(registerPostProcessor(registry, def, <span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//完成spring自身的后置处理器注册</span></span><br><span class="line">     <span class="comment">//到这一步, BeanDefinitionMap中已经保存了一些spring自带的后置处理器的定义信息了</span></span><br><span class="line">     <span class="keyword">return</span> beanDefs;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建ClassPath下的BeanDefinition的扫描器ClassPathBeanDefinitionScanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters, Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.beanDefinitionDefaults = <span class="keyword">new</span> BeanDefinitionDefaults();</span><br><span class="line">     <span class="keyword">this</span>.beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line">     <span class="keyword">this</span>.scopeMetadataResolver = <span class="keyword">new</span> AnnotationScopeMetadataResolver();</span><br><span class="line">     <span class="keyword">this</span>.includeAnnotationConfig = <span class="keyword">true</span>;</span><br><span class="line">     Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">     <span class="comment">//设置加载BeanDefinition的注册器</span></span><br><span class="line">     <span class="keyword">this</span>.registry = registry;</span><br><span class="line">     <span class="comment">//是否使用默认的过滤规则</span></span><br><span class="line">     <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">         <span class="keyword">this</span>.registerDefaultFilters();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//设置环境</span></span><br><span class="line">     <span class="keyword">this</span>.setEnvironment(environment);</span><br><span class="line">     <span class="comment">//设置资源加载器</span></span><br><span class="line">     <span class="keyword">this</span>.setResourceLoader(resourceLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>跟进this.registerDefaultFilters();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 向includeFilters中添加所有@Component注解的类(其他的一些Bean注解也都有@Component)</span></span><br><span class="line">     <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">     ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl), <span class="keyword">false</span>));</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="function">AnnotationTypeFil        <span class="title">ter</span><span class="params">(ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)</span>, <span class="keyword">false</span>))</span>;</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>注册Bean配置类register(annotatedClasses)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, String name, Class... qualifiers)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 将Bean配置信息转换成AnnotatedGenericBeanDefinition  注解通用BeanDefinition</span></span><br><span class="line">     AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">     <span class="comment">// 判断@Conditionl条件是否有跳过注册的</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">         <span class="comment">// 解析@Scope作用域, 没有则默认Singleton</span></span><br><span class="line">         ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">         <span class="comment">// 将作用域信息添加到BeanDefinition</span></span><br><span class="line">         abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">         <span class="comment">// 设置beanName</span></span><br><span class="line">         String beanName = name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry);</span><br><span class="line">         AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">         <span class="comment">// 解析@Qualifier</span></span><br><span class="line">         <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Class[] var7 = qualifiers;</span><br><span class="line">             <span class="keyword">int</span> var8 = qualifiers.length;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> var9 = <span class="number">0</span>; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">                 Class&lt;? extends Annotation&gt; qualifier = var7[var9];</span><br><span class="line">                 <span class="comment">// 如果有@Primary注解,向BeanDefinition中写入首选bean</span></span><br><span class="line">                 <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">                     abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">                 <span class="comment">// 如果有@Lazy注解, 设置懒加载</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">                     abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 封装一个BeanName和BeanDefinition之间的映射关系</span></span><br><span class="line">         BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">         <span class="comment">// 创建代理对象</span></span><br><span class="line">         definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">         <span class="comment">// 按BeanName将BeanDefinition注册到容器中</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>refresh();  IoC容器启动的核心</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">         <span class="comment">// 1. 刷新上下文之前的准备工作</span></span><br><span class="line">         <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">         <span class="comment">// 2. 获取初始化BeanFactory</span></span><br><span class="line">         ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">         <span class="comment">// 3. 对BeanFactory进行属性填充</span></span><br><span class="line">         <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 4. 模板方法，注册自己添加的BeanPostFactoryProcessor</span></span><br><span class="line">             <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">             <span class="comment">// 5. 执行BeanFactory后置处理器</span></span><br><span class="line">             <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">             <span class="comment">// 6. 注册Bean后置注册器</span></span><br><span class="line">             <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">             <span class="comment">// 7. 初始化国际化资源处理器</span></span><br><span class="line">             <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">             <span class="comment">// 8. 初始化应用事件多播器</span></span><br><span class="line">             <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">             <span class="comment">// 9. 模板方法，调用某些特殊的bean的初始化，springboot中在这个地方启动tomcat</span></span><br><span class="line">             <span class="keyword">this</span>.onRefresh();</span><br><span class="line">             <span class="comment">// 10. 注册监听器到多播器上</span></span><br><span class="line">             <span class="keyword">this</span>.registerListeners();</span><br><span class="line">             <span class="comment">// 11. 实例化所有非懒加载的单例Bean</span></span><br><span class="line">             <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">             <span class="comment">// 12. 初始化容器生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">             <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                 <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">             <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">             <span class="keyword">throw</span> var9;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对代码进行进一步跟进,看看每一步中都做了什么</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1. prepareRefresh()</span></span><br><span class="line"><span class="comment">    1. this.startupDate = System.currentTimeMillis();设置启动时间</span></span><br><span class="line"><span class="comment">    2. initPropertySources();自定义属性设置</span></span><br><span class="line"><span class="comment">    3. getEnvironment().validateRequiredProperties();检验属性的合法性</span></span><br><span class="line"><span class="comment">    4. earlyApplicationEvents = new LinkedHashSet();创建早期应用事件集合</span></span><br><span class="line"><span class="comment"> 2. beanFactory = this.obtainFreshBeanFactory();</span></span><br><span class="line"><span class="comment">    1. this.beanFactory.setSerializationId(this.getId());设置BeanFactoryID</span></span><br><span class="line"><span class="comment"> 3. prepareBeanFactory(beanFactory);</span></span><br><span class="line"><span class="comment">    1. addBeanPostProcessor(new ApplicationContextAwareProcessor(this));添加一个ApplicationContextAwareProcessor</span></span><br><span class="line"><span class="comment">    2. ignoreDependencyInterface(XXX.class); 设置忽略注入的接口实现类</span></span><br><span class="line"><span class="comment">    3. registerResolvableDependency(XXX.class,beanFactory); 注册可解析的注入的组件</span></span><br><span class="line"><span class="comment">    4. 添加编译时的AOP组件</span></span><br><span class="line"><span class="comment">    5. 注册环境组件,系统属性组件,系统环境组件</span></span><br><span class="line"><span class="comment"> 4. postProcessBeanFactory(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 子类重写这个方法,在BeanFactory准备完成创建之前做最后的步骤</span></span><br><span class="line"><span class="comment"> 5. invokeBeanFactoryPostProcessors(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 执行BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       1. 获取所有BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       2. 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       3. 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">       4. 最后执行其他的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    2. 执行BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       1. 获取所有BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       2. 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       3. 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">       4. 最后执行其他的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> 6. registerBeanPostProcessors(beanFactory);</span></span><br><span class="line"><span class="comment">    1. 获取所有的BeanPostProcessor</span></span><br><span class="line"><span class="comment">    2. 先BeanPostProcessor</span></span><br><span class="line"><span class="comment">    3. 注册MergedBeanDefinitionPostProcessor</span></span><br><span class="line"><span class="comment">    4. 最后创建一个ApplicationListenerDetector;检查是ApplicationListener的bean</span></span><br><span class="line"><span class="comment"> 7. initMessageSource();</span></span><br><span class="line"><span class="comment">    1. 获取BeanFactory</span></span><br><span class="line"><span class="comment">    2. 判断容器中是否有MessageSource的组件</span></span><br><span class="line"><span class="comment">    3. 如果有则取用, 没有则创建DelegatingMessageSource</span></span><br><span class="line"><span class="comment">    4. 将国际化组件祖册到容器</span></span><br><span class="line"><span class="comment"> 8. initApplicationEventMulticaster();</span></span><br><span class="line"><span class="comment">    1. 获取BeanFactory</span></span><br><span class="line"><span class="comment">    2. 判断容器是否有ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">    3. 如果有取用, 没有则创建SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">    4. 将ApplicationEventMulticaster组件添加到BeanFactory</span></span><br><span class="line"><span class="comment"> 9. onRefresh();</span></span><br><span class="line"><span class="comment">    1.  留给子类,子类重写这个方法, 在容器刷新时可以自定义一些逻辑</span></span><br><span class="line"><span class="comment"> 10. registerListeners();</span></span><br><span class="line"><span class="comment">     1.  获取容器中的ApplicationListener</span></span><br><span class="line"><span class="comment">     2.  将所有ApplicationListener添加到ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">     3.  派发早期事件earlyApplicationEvents</span></span><br><span class="line"><span class="comment"> 11. finishBeanFactoryInitialization(beanFactory);</span></span><br><span class="line"><span class="comment">     1.  preInstantiateSingletons;初始化剩下的所有单实例Bean</span></span><br><span class="line"><span class="comment">         1.  获取容器中的单例beanName</span></span><br><span class="line"><span class="comment">         2.  如果beanName对应的bean不是抽象不是懒加载不是多实例的</span></span><br><span class="line"><span class="comment">         3.  getBean(beanName);</span></span><br><span class="line"><span class="comment">         4.  doGetBean(beanName);</span></span><br><span class="line"><span class="comment">         5.  标记要创建bean了,保证线程安全</span></span><br><span class="line"><span class="comment">         6.  getMergedLocalBeanDefinition(beanName);获得BeanDefinition</span></span><br><span class="line"><span class="comment">         7.  getDependsOn();获取依赖</span></span><br><span class="line"><span class="comment">         8.  递归getBean;创建所依赖Bean</span></span><br><span class="line"><span class="comment">         9.  将获取的依赖bean注册到denpendsOn集合</span></span><br><span class="line"><span class="comment">         10. createBean(beanName, ex1, args);创建bean</span></span><br><span class="line"><span class="comment">         11. doCreateBean(beanName, mbdToUse, args);</span></span><br><span class="line"><span class="comment">             1.  createBeanInstance(beanName, mbd, args);</span></span><br><span class="line"><span class="comment">             2.  调用前置处理器</span></span><br><span class="line"><span class="comment">             3.  属性赋值</span></span><br><span class="line"><span class="comment">             4.  执行初始化</span></span><br><span class="line"><span class="comment">             5.  执行后置处理器</span></span><br><span class="line"><span class="comment">             6.  注册bean销毁方法</span></span><br><span class="line"><span class="comment">             7.  添加到单例bean集合</span></span><br><span class="line"><span class="comment"> 12. finishRefresh();</span></span><br><span class="line"><span class="comment">     1.  初始化生命周期有关后置处理器</span></span><br><span class="line"><span class="comment">     2.  执行容器刷新完成事件</span></span><br><span class="line"><span class="comment">     3.  将ApplicationContext注册到视图中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><blockquote><ol><li>Spring容器在启动时,会先加载有关Bean定义信息的配置文件或者配置类(xml注册bean/注解注册bean)</li><li>BeanDefinitionReader将配置文件或者配置类解析成BeanDefinition,并存入容器中BeanDefinitionRegistry</li><li>Spring容器扫描BeanDefinitionRegistry中的所有BeanDefinition,使用BeanFactoryPostProcessor对它们进行加工, 主要是依赖处理和属性赋值</li><li>实例化Bean时,封装Bean然后完成对Bean的属性设置工作</li><li>利用Bean后置处理器,对完成的Bean进行加工</li></ol></blockquote><h5 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h5><ol><li><p>Resource<br>xml、properties资源文件的抽象</p></li><li><p>ResourceLoader<br>资源的加载, 解析xml、properties返回Resource</p></li><li><p>BeanDefinition<br>保存了从配置文件中读取到的bean的各种信息,一个bean对应一个BeanDefinition<br>有beanClass、scope、lazyInit等属性</p></li><li><p>BeanDefinitionReader<br>定义读取组件，从Resource资源中读取出BeanDefinition</p></li><li><p>BeanDefinitionRegistry<br>BeanFactory的实现类需要实现这个接口，所以所有BeanFactory都有注册BeanDefinition的功能<br>其内部维护了一个Map，可以将BeanDefinition和beanName的对应关系添加进去</p></li><li><p>Enviroment<br>环境，保存了程序运行的环境参数（JDK版本，jre等等）</p></li><li><p>BeanFactoryPostProcessor接口<br>BeanFactory后置处理器, 扩展切口, 允许它的实现类在容器初始化前后进行相应操作<br>典型的有PropertyPlaceholderConfigurer,占位符配置处理器</p></li><li><p>Aware接口<br>对于实现了XXXXAware的bean,spring会注入相应的XXXX, 通过重写setXXXX的方法</p></li><li><p>BeanPostProcessor接口<br>允许实现它的bean,在实例化前后做相应操作,在最前最后位置</p></li><li><p>InitializingBean接口<br>允许实现它的bean,在实例化前后做相应操作, 在处理器before之后和after之前</p></li><li><p>DisposableBean接口<br>允许实现它的bean,在摧毁前后做相应操作</p></li><li><p>FactoryBean接口<br>允许实现它的bean,在beanFactory.getBean()获取该bean时, 会调用这个bean中重写的方法getObject,而不是直接返回该bean<br>工厂模式的体现</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringIoC详解&quot;&gt;&lt;a href=&quot;#SpringIoC详解&quot; class=&quot;headerlink&quot; title=&quot;SpringIoC详解&quot;&gt;&lt;/a&gt;SpringIoC详解&lt;/h2&gt;&lt;h3 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JavaWeb框架" scheme="https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://zhuyiting.xyz/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://zhuyiting.xyz/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuyiting.xyz/2019/07/02/设计模式/代理模式/</id>
    <published>2019-07-02T11:35:45.000Z</published>
    <updated>2019-12-26T08:41:46.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p>Proxy-代理模式是指为其他对象提供一种代理,来控制对这个对象的访问</p><p>即对A对象进行代理后, 本来A对象的功能交给代理B来做; 代理就是原实例前后添加一层处理.</p><h3 id="为什么使用代理模式"><a href="#为什么使用代理模式" class="headerlink" title="为什么使用代理模式"></a>为什么使用代理模式</h3><ul><li>授权机制: 不同级别的用户对于同一对象的访问权限是不同的, 要用代理实现对不同用户的访问权限的控制</li><li>某个客户端不能直接操作一个对象, 但又要和那个对象互动, 也要通过代理实现间接互动</li><li>代理类为委托类预处理消息,过滤消息,把消息传递给委托类, 以及事后对返回结果的处理等.</li></ul><h3 id="3种代理模式"><a href="#3种代理模式" class="headerlink" title="3种代理模式"></a>3种代理模式</h3><h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h4><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:创建服务类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:实现服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步:创建代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(<span class="keyword">final</span> UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService=userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备登录"</span>);</span><br><span class="line">        userService.login();</span><br><span class="line">        System.out.println(<span class="string">"登录完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四步:测试运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceProxy userServiceProxy=<span class="keyword">new</span> UserServiceProxy(userService);</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理可以做到符合开闭原则的对目标对象进行功能扩展, 但是工作量大, 要给每个对象创建代理类, 而且不易管理, 接口发生改变, 代理类也要改变</p><h4 id="2-JDK动态代理"><a href="#2-JDK动态代理" class="headerlink" title="2. JDK动态代理"></a>2. JDK动态代理</h4><p>动态代理中, 不需要手动创建代理类了, 只要编写一个动态处理器就OK了</p><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:编写动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] agrs)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">        Object result=method.invoke(Object,args);</span><br><span class="line">        System.out.println(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:编写测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService userServiceProxy=(UserService)Proxy.newProxyInstnce(UserService.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;UserService.class&#125;,<span class="keyword">new</span> DynamicProxyHandler(userService));</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-CGLIB代理"><a href="#3-CGLIB代理" class="headerlink" title="3. CGLIB代理"></a>3. CGLIB代理</h4><p>JDK实现动态代理需要实现类通过接口定义业务的方法, 对于没有接口的类就不能实现代理.这就需要CGLIB了</p><p>实现步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步:创建CGLIB代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object</span></span></span><br><span class="line"><span class="function"><span class="params">    target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(This.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args,MeyhodProxy methodProxy)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">        Object result=method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步:创建测试类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        CglibProxy cglibProxy=<span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserService userServiceProxy=(UserService)cglibProxy.getInstance(userService1;)</span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLIB代理比JDK代理的性能更高,但是CGLIB比JDK创建代理的耗时要更高,所以单例对象CGLIB更合适, 反之JDK更合适.</p><p><img src="/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="CGLIB动态代理执行流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式-Proxy&quot;&gt;&lt;a href=&quot;#代理模式-Proxy&quot; class=&quot;headerlink&quot; title=&quot;代理模式(Proxy)&quot;&gt;&lt;/a&gt;代理模式(Proxy)&lt;/h2&gt;&lt;p&gt;Proxy-代理模式是指为其他对象提供一种代理,来控制对这个对象的访问&lt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://zhuyiting.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://zhuyiting.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ入门</title>
    <link href="https://zhuyiting.xyz/2019/06/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://zhuyiting.xyz/2019/06/30/消息中间件/ActiveMQ入门/</id>
    <published>2019-06-30T14:10:45.000Z</published>
    <updated>2019-12-23T01:40:26.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ入门"><a href="#ActiveMQ入门" class="headerlink" title="ActiveMQ入门"></a>ActiveMQ入门</h2><p>ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现<br>尽管JMS已经出台很久, 但在J2EE中仍然扮演者重要角色</p><h3 id="ActiveMQ特性"><a href="#ActiveMQ特性" class="headerlink" title="ActiveMQ特性"></a>ActiveMQ特性</h3><ol><li>支持多种编程语言</li><li>支持多种传输协议</li><li>支持多种持久化方式(文件系统/数据库)</li></ol><h3 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h3><ol><li>从官网下载ActiveMQ</li><li>利用Xftp将文件传到服务器</li><li>解压到<code>/var</code>目录下</li><li>修改文件名为<code>activemq</code></li></ol><h3 id="ActiveMQ启动"><a href="#ActiveMQ启动" class="headerlink" title="ActiveMQ启动"></a>ActiveMQ启动</h3><p>在activemq文件下使用命令<code>./bin/activemq start</code> 后台启动ActiveMQ</p><p>但最好是将ActiveMQ作为一个服务来启动,这样可以使activemq在系统启动时自动启动</p><h4 id="创建ActiveMQ服务"><a href="#创建ActiveMQ服务" class="headerlink" title="创建ActiveMQ服务"></a>创建ActiveMQ服务</h4><ol><li><p>使用vim创建一个服务文件<br><code>vi /usr/lib/systemd/system/activemq.service</code></p></li><li><p>输入内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ActiveMQ service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/var/activemq/bin/activemq start</span><br><span class="line">ExecStop=/var/activemq/bin/activemq stop</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=9</span><br><span class="line">StandardOutput=syslog</span><br><span class="line">StandardError=syslog</span><br><span class="line">SyslogIdentifier=activemq</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>修改<code>/var/activemq/bin/env</code>文件<br> 将JAVA_HOME的注释删除,然后填入系统jdk的安装路径</p></li><li><p>启动ActiveMQ服务<br> 使用<code>systemctl start activemq</code>来启动服务</p></li><li><p>查看服务状态<br> 使用命令<code>systemctl status activemq</code></p></li><li><p>设置开机自动启动<br> <code>ln -s /usr/lib/systemd/system/activemq.service/etc/systemd/system/multi-user.target.wants/activemq.service</code><br> <code>systemctl enable activemq</code></p></li><li><p>在防火墙添加ActiveMQ的Web管理端口和通讯端口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Web管理端口默认为8161,通讯端口默认为61616</span><br><span class="line">ufw allow 8161</span><br><span class="line">ufw allow 61616</span><br><span class="line"># 部分服务器需要在对应的服务提供商管理页面修改出入站规则</span><br></pre></td></tr></table></figure></li><li><p>浏览器访问<code>http://服务IP:8161/admin</code>进入管理平台<br>账户默认:admin<br>密码默认:admin</p></li></ol><h4 id="Web管理平台配置"><a href="#Web管理平台配置" class="headerlink" title="Web管理平台配置"></a>Web管理平台配置</h4><p>ActiveMQ的Web管理平台是基于jetty运行,因此在/var/activemq/conf目录可以查看jetty的配置文件</p><p>在<code>/var/activemq/conf/jetty.xml</code>文件中,可以进行修改端口,密码等内容</p><h3 id="使用ActiveMQ"><a href="#使用ActiveMQ" class="headerlink" title="使用ActiveMQ"></a>使用ActiveMQ</h3><p>在Java中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Spring中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-broker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>geronimo-jms_1.1_spec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.apache.geronimo.specs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ActiveMQ支持的协议"><a href="#ActiveMQ支持的协议" class="headerlink" title="ActiveMQ支持的协议"></a>ActiveMQ支持的协议</h3><p>ActiveMQ支持多种协议传输和传输方式,允许客户端使用多种协议连接.</p><p>ActiveMQ支持的协议: AUTO、OpenWire、AMQP、Stomp、MQTT等<br>在${ACTIVE_HOME}/conf/activemq.xml中, 通过配置<code>&lt;transportConnectors&gt;</code>就可以使用多种传输方式</p><p>ActiveMQ支持的基础传输方式有: VM、TCP、SSL、UDP、Peer、Multicast、HTTP(S)等\</p><p>由于TCP的稳定性, 它也是ActiveMQ中最常用的一种协议. 在默认的设置中, TCP连接的端口为61616</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ入门&quot;&gt;&lt;a href=&quot;#ActiveMQ入门&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ入门&quot;&gt;&lt;/a&gt;ActiveMQ入门&lt;/h2&gt;&lt;p&gt;ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="ActiveMQ" scheme="https://zhuyiting.xyz/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="https://zhuyiting.xyz/2019/06/27/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8CPU100%25%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://zhuyiting.xyz/2019/06/27/Java系统调优/内存爆炸CPU100%问题分析/</id>
    <published>2019-06-27T13:36:45.000Z</published>
    <updated>2019-12-22T06:45:07.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存爆炸和CPU100-问题分析"><a href="#内存爆炸和CPU100-问题分析" class="headerlink" title="内存爆炸和CPU100%问题分析"></a>内存爆炸和CPU100%问题分析</h2><p>当线上的系统突然请求缓慢, CPU100%, 内存占用巨大, 当JVM出现问题时,应该如何排查问题呢</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>登录服务器, 使用<code>top</code>命令查看系统资源使用情况<br>一般出问题时java程序的占用是最高的</p></li><li><p>找到CPU或者内存占用高的java进程PID, 使用命令<code>top -Hp 进程ID</code>, <strong>查询该进程中线程的运行情况</strong></p></li><li><p>使用<code>printf &quot;%x\n&quot; 线程ID</code><strong>查看线程PID的16进制</strong>形式<br> 因为在java日志中记录的PID是16进制的形式</p></li><li><p><code>jstack 进程ID &gt; ./threadDump.log</code> <strong>打印JVM堆栈信息</strong>到文件threadDump.log中<br>在该堆栈信息文件中,找到第3步的线程, 查看具体信息</p></li><li><p>使用<code>jstat -gcutil 进程号 统计间隔时间 统计次数</code><strong>查看GC的变化情况</strong>, 当发现<code>FGC</code>的值一直增大时, 继续使用<code>jmap -heap 进程ID</code> 查看进程堆内存的情况, 特别是老年代的使用情况.<br>老年代内存占用达到阈值时就会触发Full GC</p></li><li><p><code>jmap -dump:format=b,file=filename 进程ID</code> ,导出Java进程下内存堆到文件中, 再把内存镜像dump文件传到本地, 利用工具进行分析<br>可以使用<code>jhat</code>、<code>VisualVM</code>等工具分析dump文件</p></li></ol><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h4 id="Full-GC次数过多"><a href="#Full-GC次数过多" class="headerlink" title="Full GC次数过多"></a>Full GC次数过多</h4><ol><li>jstat命令发现GC次数很多,并且不断增加</li><li>分析dump文件,查看具体对象的内存占用情况<br>如果内存占用情况不多, 说明代码中频繁使用了System.gc()</li></ol><h4 id="代码中消耗CPU的操作太多"><a href="#代码中消耗CPU的操作太多" class="headerlink" title="代码中消耗CPU的操作太多"></a>代码中消耗CPU的操作太多</h4><p>比如复杂的算法,递归的循环等,甚至是代码BUG</p><h4 id="锁的使用不正确-造成死锁"><a href="#锁的使用不正确-造成死锁" class="headerlink" title="锁的使用不正确, 造成死锁"></a>锁的使用不正确, 造成死锁</h4><p>分析JVM堆栈信息,看是否有死锁deadlock</p><h4 id="不定期的接口耗时现象"><a href="#不定期的接口耗时现象" class="headerlink" title="不定期的接口耗时现象"></a>不定期的接口耗时现象</h4><p>这主要是因为不定期的高并发带来的问题, 要通过压测工具不断加大访问力度, 发现某个接口某个位置响应缓慢, 再查看堆栈日志, 发现大量线程被阻塞在同一位置, 就能查到我们哪个业务代码出了问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存爆炸和CPU100-问题分析&quot;&gt;&lt;a href=&quot;#内存爆炸和CPU100-问题分析&quot; class=&quot;headerlink&quot; title=&quot;内存爆炸和CPU100%问题分析&quot;&gt;&lt;/a&gt;内存爆炸和CPU100%问题分析&lt;/h2&gt;&lt;p&gt;当线上的系统突然请求缓慢, 
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
      <category term="JDK" scheme="https://zhuyiting.xyz/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>分布式消息中间件</title>
    <link href="https://zhuyiting.xyz/2019/06/27/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://zhuyiting.xyz/2019/06/27/消息中间件/分布式消息中间件/</id>
    <published>2019-06-27T13:36:45.000Z</published>
    <updated>2019-12-22T11:48:47.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式消息中间件"><a href="#分布式消息中间件" class="headerlink" title="分布式消息中间件"></a>分布式消息中间件</h2><p><strong>生产者</strong>(客户端)–发送消息–&gt;<strong>消息中间件</strong>–分发消息–&gt;<strong>消费者</strong>(服务器)</p><h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><ol><li>利用高效可靠的消息传递机制进行平台无关的数据交互;<br> 把用户消息暂存到消息中间件, 消息中间件在把消息分发到对应分布式模块</li><li>基于数据通信来集成分布式系统<br> 分布式系统之间完全通过数据来连接,后台系统之间不需要接口调用</li><li>通过提供消息传递和消息队列模型, 它可以在分布式环境下扩展进程间的通信<br> 跨系统跨进程通信</li></ol><h4 id="消息中间件的应用场景"><a href="#消息中间件的应用场景" class="headerlink" title="消息中间件的应用场景"></a>消息中间件的应用场景</h4><p>跨系统数据传递、高并发流量削峰填谷、数据异步处理…等等</p><h4 id="常用的消息中间件"><a href="#常用的消息中间件" class="headerlink" title="常用的消息中间件"></a>常用的消息中间件</h4><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ</p><h3 id="消息中间件的核心设计"><a href="#消息中间件的核心设计" class="headerlink" title="消息中间件的核心设计"></a>消息中间件的核心设计</h3><h4 id="消息中间件的本质"><a href="#消息中间件的本质" class="headerlink" title="消息中间件的本质"></a>消息中间件的本质</h4><p>一种具备<strong>接收请求、保存数据、发送数据</strong>等功能的网络应用；和一般网络应用的区别是它主要负责数据的接收和传递，所以性能一般高于普通程序</p><h4 id="消息中间件的5大核心组成"><a href="#消息中间件的5大核心组成" class="headerlink" title="消息中间件的5大核心组成"></a>消息中间件的5大核心组成</h4><h5 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h5><p>计算机之间通信共同遵循的一组约定<br>协议三要素:</p><ol><li>语法</li><li>语义</li><li>时序</li></ol><p><strong>消息中间件常用的协议:</strong> OpenWire、AMQP、MQTT、Kafka、OpenMessage(国内发起)</p><h5 id="2-持久化机制"><a href="#2-持久化机制" class="headerlink" title="2. 持久化机制"></a>2. 持久化机制</h5><p>简单来说就是将数据存入磁盘,而不是在内存中,不会因为服务器宕机而丢失数据,能够让数据永久保存就叫持久化</p><p>常用持久化方式就是文件系统</p><h5 id="3-消息分发机制"><a href="#3-消息分发机制" class="headerlink" title="3. 消息分发机制"></a>3. 消息分发机制</h5><p>为什么要有消息分发策略</p><ol><li>消息要被特定的系统接收到, 其他的系统不需要接收</li><li>试错机制:后台出错,需要重新发送消息</li></ol><p>要解决的问题:</p><ol><li>消息传递是推还是拉</li><li>是主动分发还是轮询分发</li><li>有无重发功能</li></ol><h5 id="4-高可用设计"><a href="#4-高可用设计" class="headerlink" title="4. 高可用设计"></a>4. 高可用设计</h5><p>指服务可用性,保持能够使用的状态, 避免服务中断.消息中间件可以使用集群部署, 来达到高可用</p><p>分布式消息中间件实现方式:</p><ol><li>Master-Slave主从共享数据<br>服务器共用同一份数据</li><li>Master-Slave主从同步部署方式<br>主服务器同步数据到所有服务器</li><li>Broker-Cluster多主集群同步<br>所有服务器都可以进行同步数据</li><li>Broker-Cluster多主集群转发<br>只同步数据信息,不同步数据内容, 服务器将请求转发给存有消息内容的服务器</li><li>Master-Slave与Broker-Cluster结合<br>分区同步数据</li></ol><h5 id="5-高可靠设计"><a href="#5-高可靠设计" class="headerlink" title="5. 高可靠设计"></a>5. 高可靠设计</h5><p>消息传输可靠:通过协议保证系统数据解析的正确性<br>消息存储可靠:通过持久化保证存储消息的可靠性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式消息中间件&quot;&gt;&lt;a href=&quot;#分布式消息中间件&quot; class=&quot;headerlink&quot; title=&quot;分布式消息中间件&quot;&gt;&lt;/a&gt;分布式消息中间件&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;生产者&lt;/strong&gt;(客户端)–发送消息–&amp;gt;&lt;strong&gt;消息中
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://zhuyiting.xyz/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数以及调优</title>
    <link href="https://zhuyiting.xyz/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
    <id>https://zhuyiting.xyz/2019/06/18/Java系统调优/JVM参数以及调优/</id>
    <published>2019-06-18T06:56:05.000Z</published>
    <updated>2019-12-20T06:17:18.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM参数以及调优"><a href="#JVM参数以及调优" class="headerlink" title="JVM参数以及调优"></a>JVM参数以及调优</h2><h3 id="JVM调优基本概念"><a href="#JVM调优基本概念" class="headerlink" title="JVM调优基本概念"></a>JVM调优基本概念</h3><ol><li>堆大小调整</li><li>垃圾收集器调整</li><li>JIT编译器</li></ol><p>大多数调优选项都与调整堆大小和根据情况选择最合适的垃圾收集器有关.</p><h4 id="调优的主要目标"><a href="#调优的主要目标" class="headerlink" title="调优的主要目标"></a>调优的主要目标</h4><p><strong>响应性:</strong> 应用程序或系统对请求的数据进行响应的速度, 对于响应性要求高的程序,重点是在短时间内做出回应, 不接受长暂停.</p><p><strong>吞吐量:</strong> 侧重于在特定时间段内最大化应用程序的工作量. 高暂停是可接受的.</p><p><strong>系统瓶颈核心还是在应用代码, 一般情况下无需过多调优, JVM本身在不断优化.</strong></p><h3 id="GC调优思路"><a href="#GC调优思路" class="headerlink" title="GC调优思路"></a>GC调优思路</h3><ol><li>分析场景</li><li>确定目标<br>内存占用、低延时、吞吐量</li><li>收集日志<br>通过参数配置收集GC日志; 通过JVM分析GC状态看GC状态</li><li>分析日志<br>使用工具辅助分析日志, 查看GC次数, GC时间</li><li>调整参数<br>切换垃圾收集器或者调整垃圾收集器参数</li></ol><h4 id="通用GC参数"><a href="#通用GC参数" class="headerlink" title="通用GC参数"></a>通用GC参数</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM参数以及调优&quot;&gt;&lt;a href=&quot;#JVM参数以及调优&quot; class=&quot;headerlink&quot; title=&quot;JVM参数以及调优&quot;&gt;&lt;/a&gt;JVM参数以及调优&lt;/h2&gt;&lt;h3 id=&quot;JVM调优基本概念&quot;&gt;&lt;a href=&quot;#JVM调优基本概念&quot; class
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK内置命令工具</title>
    <link href="https://zhuyiting.xyz/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <id>https://zhuyiting.xyz/2019/06/18/Java系统调优/JDK内置命令工具/</id>
    <published>2019-06-18T06:56:05.000Z</published>
    <updated>2019-12-19T11:09:06.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK内置命令工具"><a href="#JDK内置命令工具" class="headerlink" title="JDK内置命令工具"></a>JDK内置命令工具</h2><h3 id="javap命令"><a href="#javap命令" class="headerlink" title="javap命令"></a>javap命令</h3><p>java反编译工具, 主要用于根据Java字节码文件反汇编为Java源代码文件.</p><h3 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h3><p>显示当前所有java进程pid的命令</p><h3 id="jstat命令"><a href="#jstat命令" class="headerlink" title="jstat命令"></a>jstat命令</h3><p>监视Java虚拟机统计信息</p><h3 id="jcmd命令"><a href="#jcmd命令" class="headerlink" title="jcmd命令"></a>jcmd命令</h3><p>可以替代jps工具查看本地的jvm信息</p><h3 id="jinfo命令"><a href="#jinfo命令" class="headerlink" title="jinfo命令"></a>jinfo命令</h3><p>可以查看运行中的jvm的全部参数, 还可以设置部分参数</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>分析java堆的命令,可以将堆中的对象以html的形式展现出来,支持对象查询语言SQL</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>打印出java进程内存中对象的情况,或者将JVM中的堆,以二进制输出成文本</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于打印出给定的java进程ID或core file或远程调试服务的堆栈信息, 如果在64位机器, 需要指定选项<code>-J-d64</code></p><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h3><p>可视化的监视管理控制台</p><h3 id="JvisualVM"><a href="#JvisualVM" class="headerlink" title="JvisualVM"></a>JvisualVM</h3><p>可视化的JVM监控工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK内置命令工具&quot;&gt;&lt;a href=&quot;#JDK内置命令工具&quot; class=&quot;headerlink&quot; title=&quot;JDK内置命令工具&quot;&gt;&lt;/a&gt;JDK内置命令工具&lt;/h2&gt;&lt;h3 id=&quot;javap命令&quot;&gt;&lt;a href=&quot;#javap命令&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
      <category term="JDK" scheme="https://zhuyiting.xyz/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="https://zhuyiting.xyz/2019/06/10/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://zhuyiting.xyz/2019/06/10/Java系统调优/JVM垃圾回收机制/</id>
    <published>2019-06-10T09:23:11.000Z</published>
    <updated>2019-12-19T08:46:04.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><h3 id="自动垃圾收集"><a href="#自动垃圾收集" class="headerlink" title="自动垃圾收集"></a>自动垃圾收集</h3><p>自动垃圾收集是<strong>查看堆内存</strong>,<strong>识别正在使用哪些对象</strong>以及<strong>哪些对象未被删除</strong>以及<strong>删除未使用对象</strong>的过程</p><p>正在使用的对象是指,程序的某些部分仍然维护指向该对象的指针<br>未使用的对象是指,程序的任何部分都不再引用的对象,因此需要回收未引用对象的内存</p><p>自动垃圾收集机制也是java非常重要的一大特性</p><h3 id="如何确定内存需要被回收"><a href="#如何确定内存需要被回收" class="headerlink" title="如何确定内存需要被回收"></a>如何确定内存需要被回收</h3><p>第一步,称为<strong>标记</strong>.这是垃圾收集器识别哪些内存正在使用而哪些不在使用的</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>就是将对象及其引用关系看做一个图,选定<strong>活动的对象</strong>作为GC Roots;<br>然后跟踪引用链,如果一个对象和GC Roots之间没有连通性,也就是不存在引用,那么可以认为是可回收对象.</p><h5 id="可以用作GC-Root的对象"><a href="#可以用作GC-Root的对象" class="headerlink" title="可以用作GC Root的对象"></a>可以用作GC Root的对象</h5><ol><li>虚拟机栈中正在引用的对象</li><li>本地方法栈中正在引用的对象</li><li>静态属性引用的对象</li><li>方法区常量引用的对象</li></ol><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><ol><li>强引用:最常见的普通对象引用,只要还有强引用指向一个对象,就不会回收(new出来的对象)</li><li>软引用:JVM认为内存不足,才会去试图回收软引用指向的对象.(缓存场景)</li><li>弱引用:虽然是引用,但随时可能被回收掉</li><li>虚引用:不能通过它访问对象. 通常是在GC时做一些操作</li></ol><h5 id="可达性级别"><a href="#可达性级别" class="headerlink" title="可达性级别"></a>可达性级别</h5><ol><li>强可达:一个对象可以有一个或多个线程可以通过各种引用访问</li><li>软可达:只能通过软引用才能访问</li><li>弱引用:只能通过弱引用访问</li><li>幻象可达:不存在其他引用,并且finalize过了,只有虚引用指向它</li><li>不可达:意味着可以被GC了</li></ol><h3 id="怎么清楚垃圾"><a href="#怎么清楚垃圾" class="headerlink" title="怎么清楚垃圾"></a>怎么清楚垃圾</h3><p>第二步, 定义如何清除垃圾</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除-mark-sweep-算法"><a href="#标记-清除-mark-sweep-算法" class="headerlink" title="标记-清除(mark-sweep)算法"></a>标记-清除(mark-sweep)算法</h5><p>首先标识出所有要回收的对象,然后清除,标记-清除算法效率优先,有内存碎片化问题,不适合特别大的堆;分代收集算法基本基于标记-清除算法的思路改进.</p><h5 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h5><p>划分两块同等大小的区域,收集时将活着的对象复制到另一块区域. 拷贝过程中将对象顺序放置,就可以避免内存碎片化. 复制+预留内存, 有一定的资源浪费.</p><h5 id="标记-整理-mark-compact"><a href="#标记-整理-mark-compact" class="headerlink" title="标记-整理(mark-compact)"></a>标记-整理(mark-compact)</h5><p>类似于标记-清除,但是为了避免内存碎片化,会在清理过程中将对象移动,已确保对象占用连续的内存空间.</p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前商业虚拟机常用的算法,根据对象存活周期的不同,将内存划分为几块,一般是把堆划分为新生代和老年代,这样就可以根据各个年代的特点采用最适合的收集算发.<br>在新生代中,每次垃圾收集都有大量对象死去,少量存活,就用复制算法,只需要付出少量存活对象的复制成本就可以完成收集,<br>而老年代中因为对象存活率高,没有额外的空间对它进行分配担保,必须使用标记-清除或者标记-整理算法来回收,不需要大量的移动对象.</p><p>新对象会被分配到新生代(Eden),如果超过<code>-XX:+PretenureSizeThreshold</code>:设置的大对象直接进入老年代的阈值, 直接存放到老年代</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h4><h5 id="Serial-GC-XX-UseSerialGC"><a href="#Serial-GC-XX-UseSerialGC" class="headerlink" title="-Serial GC -XX:UseSerialGC"></a>-Serial GC -XX:UseSerialGC</h5><p>单个线程来执行所有垃圾收集工作,适合单处理器机器,Glient模式下JVM的默认选项</p><h5 id="Serial-Old-XX-UseSeriaOldlGC"><a href="#Serial-Old-XX-UseSeriaOldlGC" class="headerlink" title="-Serial Old -XX:UseSeriaOldlGC"></a>-Serial Old -XX:UseSeriaOldlGC</h5><p>Serial的老年代版本,可以在老年代使用, 它采用了标记-整理(Mark-Compact)算法,区别于新生代的复制算法</p><h4 id="并行收集器Parallel"><a href="#并行收集器Parallel" class="headerlink" title="并行收集器Parallel"></a>并行收集器Parallel</h4><h5 id="Parallel-GC-XX-UseParallelGC"><a href="#Parallel-GC-XX-UseParallelGC" class="headerlink" title="-Parallel GC -XX:+UseParallelGC"></a>-Parallel GC -XX:+UseParallelGC</h5><h5 id="Parallel-Old-GC-XX-UseParallelGC"><a href="#Parallel-Old-GC-XX-UseParallelGC" class="headerlink" title="-Parallel Old GC -XX:+UseParallelGC"></a>-Parallel Old GC -XX:+UseParallelGC</h5><p>server模式JVM的默认GC选择,整体算法和Serial类似,区别是新生代和老年代GC都是并行进行;<br>可以设置GC时间或吞吐量等,可以自动进行适应性调整Eden,Survivor大小和MaxTenuringThreshold的值.</p><p>也称为吞吐量优先的GC: 吞吐量=用户代码运行时间/(用户代码运行时间+GC时间)</p><p>-XX:ParallelGCThreads: 设置用于垃圾回收的线程数. 通常和CPU数相等<br>-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间. 值是大于0的整数.<br>-XX:GCTimeRatio: 设置吞吐量大小,它的值是一个0-100之间的整数.<br>-XX:+UseAdaptiveSizePolicy: 打开自适应GC策略. 以达到在堆大小,吞吐量和停顿时间之间的平衡点</p><h5 id="ParNew-GC-XX-UseParNewGC"><a href="#ParNew-GC-XX-UseParNewGC" class="headerlink" title="-ParNew GC -XX:+UseParNewGC"></a>-ParNew GC -XX:+UseParNewGC</h5><p>新生代GC的实现, 它实际是Serial GC的多线程版本. 可以控制线程数量, 参数: -XX:ParallelGCThreads<br>最常见的场景是配合老年代的CMS GC工作. 参数: -XX:+UseConcMarkSweepGC</p><h4 id="并发收集器CMS-Concurrent-Mark-Sweep"><a href="#并发收集器CMS-Concurrent-Mark-Sweep" class="headerlink" title="并发收集器CMS(Concurrent Mark Sweep)"></a>并发收集器CMS(Concurrent Mark Sweep)</h4><h5 id="CMS-GC-XX-UseConcMarkSweepGC"><a href="#CMS-GC-XX-UseConcMarkSweepGC" class="headerlink" title="-CMS GC -XX:+UseConcMarkSweepGC"></a>-CMS GC -XX:+UseConcMarkSweepGC</h5><p>专用老年代,基于标记-清除算法,设计目标是尽量减少停顿时间.<br>但会占用更多的CPU资源,并和用户线程争抢</p><h5 id="G1-XX-UseG1GC"><a href="#G1-XX-UseG1GC" class="headerlink" title="-G1 -XX:+UseG1GC"></a>-G1 -XX:+UseG1GC</h5><p>针对大堆内存设计的收集器,兼顾吞吐量和停顿时间, JDK9后为默认选项, 目标是替代GMC;<br>G1将堆分为多个固定大小, 堆之间是复制算法, 但整体上可以理解为标记-整理算法,可以有效避免内存碎片化.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM垃圾回收机制&quot;&gt;&lt;a href=&quot;#JVM垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾回收机制&quot;&gt;&lt;/a&gt;JVM垃圾回收机制&lt;/h2&gt;&lt;h3 id=&quot;自动垃圾收集&quot;&gt;&lt;a href=&quot;#自动垃圾收集&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="https://zhuyiting.xyz/2019/06/03/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://zhuyiting.xyz/2019/06/03/Java系统调优/类加载机制/</id>
    <published>2019-06-03T02:53:51.000Z</published>
    <updated>2019-12-19T08:19:01.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h2><p><strong>1. 加载</strong>:读取二进制内容<br><strong>2. 验证</strong>:验证class文件格式规范、语义分析、引用验证、字节码验证<br><strong>3. 准备</strong>:分配内存、设置类static修饰的变量初始值<br><strong>4. 解析</strong>:类、接口、字段、类方法等解析<br><strong>5. 初始化</strong>:为静态变量赋值；执行静态代码块<br><strong>6. 使用</strong>:创建实例对象<br><strong>7. 卸载</strong>:从JVM方法区中卸载</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器负责装入类,搜索各个位置的类资源.<br>一个Java程序运行,至少有三个类加载器实例,负责不同类的加载</p><ol><li><strong>Bootstrap Loader 核心类库加载器</strong>,由C语言实现,加载JDK核心类库</li><li><strong>Extension Class Loader 拓展类库加载器</strong>,加载JDK拓展包</li><li><strong>application class loader 用户应用程序加载器</strong>,加载classpath路径下的包</li></ol><h3 id="类不会重复加载"><a href="#类不会重复加载" class="headerlink" title="类不会重复加载"></a>类不会重复加载</h3><p>类的唯一性:同一个类加载器,类名一样,代表同一个类.</p><h4 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h4><p>某一个类加载器想要去加载一个类,并不会立刻去加载,而是委托给父亲,如果父亲上面还有父亲,则继续向上委托,最终到达核心类库加载器,如果核心类库无法记载,再向下一个个委托.<br><strong>即,有父类交给父类加载,没父类了开始加载,无法加载向下委托,全都不能加载则失败</strong></p><p>通过双亲委派机制</p><ol><li>建立类的层级关系可以避免类的重复加载,当父亲已经加载该类时,就没必要再加载一次了.</li><li>优先加载核心类库, 这样防止用户恶意的同名类,因为永远是核心的类先被加载.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类生命周期&quot;&gt;&lt;a href=&quot;#类生命周期&quot; class=&quot;headerlink&quot; title=&quot;类生命周期&quot;&gt;&lt;/a&gt;类生命周期&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 加载&lt;/strong&gt;:读取二进制内容&lt;br&gt;&lt;strong&gt;2. 验证&lt;/strong&gt;:验
      
    
    </summary>
    
    
      <category term="Java系统调优" scheme="https://zhuyiting.xyz/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
    
      <category term="JVM" scheme="https://zhuyiting.xyz/tags/JVM/"/>
    
      <category term="Java" scheme="https://zhuyiting.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty网络编程框架</title>
    <link href="https://zhuyiting.xyz/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/"/>
    <id>https://zhuyiting.xyz/2019/05/07/网络编程/Netty网络编程框架/</id>
    <published>2019-05-07T12:59:55.000Z</published>
    <updated>2019-11-25T05:34:33.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty网络编程框架"><a href="#Netty网络编程框架" class="headerlink" title="Netty网络编程框架"></a>Netty网络编程框架</h2><p>Netty是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，它极大的简化了TCP和UDP客户端和服务器开发等网络编程</p><p>Netty支持BIO、NIO，支持各种协议</p><h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>Reactor模型也叫Dispatcher模式,服务器接收多路请求,并同步反派给请求对应的线程</p><h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty线程模型基于主从Reactor线程模型,有多个Reactor</p><h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul><li><strong>Bootstrap引导</strong>: 一个Netty应用通常由一个Bootstrap开始,主要作用是配置整个Netty程序,串联各个组件,Netty中Bootstrap类是客户端程序的启动引导类,ServerBootstrap是服务端启动引导类</li><li><strong>Future ChannelFuture</strong>: 可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</li><li><strong>Channel</strong>: 网络通信通道,发送接收数据</li><li><strong>Selector</strong>: 实现I/O多路复用,一个Selector线程可以监听多个线程的Channel事件</li><li><strong>NioEventLoop</strong>: 类似线程池,维护了一个线程和任务队列,支持异步提交执行,线程启动时,会调用run()方法,执行IO任务和非IO任务</li><li><strong>NioEventLoopGroup</strong>: 用于管理eventLoop的生命周期,可以理解为大线程池,内部维护了一组小线程池</li><li><strong>ChannelHandler</strong>: 处理IO事件或者拦截IO操作,并转发到ChannelPipeline(业务处理链)中<br>Handler可以被共享,但是要注意防止共享变量,比如解码器是不能被共享的<br>耗时的业务不要放在Handler,要单独交给指定的线程池中</li><li><strong>ChannelHandlerContext</strong>: 保存Channel相关的上下文信息,每一个ChannelHandlerContext关联一个ChannelHandler</li><li><strong>ChannelPipline</strong>: 责任链,业务处理链,保存了ChannelHandler的List,用于处理或拦截Channel的入站事件或者出站操作.</li></ul><p><img src="/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/netty%E6%B5%81%E7%A8%8B.jpg" alt="netty流程"></p><p><a href="https://luan.ma/post/netty-flow/" target="_blank" rel="noopener">netty服务端处理用户请求流程图解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netty网络编程框架&quot;&gt;&lt;a href=&quot;#Netty网络编程框架&quot; class=&quot;headerlink&quot; title=&quot;Netty网络编程框架&quot;&gt;&lt;/a&gt;Netty网络编程框架&lt;/h2&gt;&lt;p&gt;Netty是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Netty" scheme="https://zhuyiting.xyz/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>NIO网络编程</title>
    <link href="https://zhuyiting.xyz/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2019/04/30/网络编程/NIO网络编程/</id>
    <published>2019-04-30T14:19:55.000Z</published>
    <updated>2019-11-23T06:37:07.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO网络编程"><a href="#NIO网络编程" class="headerlink" title="NIO网络编程"></a>NIO网络编程</h2><p>非阻塞IO</p><p>NIO是Java提供的替代BIO的相关API</p><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p>Buffr 缓冲区<br>Channel 通道<br>Selector 选择器</p><h4 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h4><p>Java提供Buffer API, 可以让我们更轻松的使用内存块</p><p>使用Buffer对象,对数据进行写入和读取</p><ol><li>将数据写入缓冲区</li><li>调用buffer.flip(),转换为读取模式</li><li>缓冲区读取数据</li><li>调用buffer.clear()或buffer.compact() 清楚缓冲区</li></ol><p>Buffer的三个属性<br>capacity容量: 缓冲区内存块大小<br>position位置: 写入或读取时的位置<br>limit限制: 限制每次读取或者写入的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建一个byte字节缓冲区，容量是4</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认写入模式，查看三个重要的指标</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"初始化：capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line">        <span class="comment">// 写入2字节的数据</span></span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">2</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 再看数据</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对)</span></span><br><span class="line">        System.out.println(<span class="string">"#######开始读取"</span>);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="keyword">byte</span> a = byteBuffer.get();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">byte</span> b = byteBuffer.get();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(String.format(<span class="string">"读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据</span></span><br><span class="line">        <span class="comment">// clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式</span></span><br><span class="line">        byteBuffer.compact(); <span class="comment">// buffer : 1 , 3</span></span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">4</span>);</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>) <span class="number">5</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"最终的情况，capacity容量：%s, position位置：%s, limit限制：%s"</span>, byteBuffer.capacity(),</span><br><span class="line">                byteBuffer.position(), byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rewind() 重置position为0</span></span><br><span class="line">        <span class="comment">// mark() 标记position的位置</span></span><br><span class="line">        <span class="comment">// reset() 重置position为上次mark()标记的位置</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer可以直接获取直接内存<br>ByteBuffer directByteBuffer=ByteBuffer.allocateDirect(n);<br>内部有一个回收对象, 可以进行垃圾回收, 否则JVM的垃圾回收无法管理堆外内存</p><p>否则使用JVM堆内存,写入时用堆内存会复制一份数据到堆外内存</p><h4 id="Channel通道"><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h4><p>通道从ByteBuffer中读取数据或者写入数据</p><h5 id="Channel四种实现类型"><a href="#Channel四种实现类型" class="headerlink" title="Channel四种实现类型"></a>Channel四种实现类型</h5><p><strong>1. FileChannel</strong>: 用于文件的数据读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FileChannel通道</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>，<span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure><p><strong>2. DatagramChannel</strong>: 用于UDP的数据读写。<br><strong>3. SocketChannel</strong>: 用于TCP的数据读写。<br><strong>4. ServerSocketChannel</strong>: 监听TCP链接请求，每个请求会创建会一个SocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h4><p>可以检查一个或多个NIO通道,实现单个线程管理多个通道,从而管理多个网络连接</p><p>比如:当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务,不会阻塞</p><p>一个通道继承了SelectableChannel,那么他就可以被Selector复用</p><p><strong>一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</strong><br>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上，在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。</p><p>使用Channel.register（Selector sel，int ops）方法, 将通道注册到选择器上,这里的操作指的是当前通道已经准备就绪,能够进行的操作类型<br>int ops包括</p><ol><li>可读 : SelectionKey.OP_READ</li><li>可写 : SelectionKey.OP_WRITE</li><li>连接 : SelectionKey.OP_CONNECT</li><li>接收 : SelectionKey.OP_ACCEPT</li></ol><p><code>selector.select();</code> 查找准备就绪的通道</p><h5 id="Selector使用流程"><a href="#Selector使用流程" class="headerlink" title="Selector使用流程"></a>Selector使用流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建通道</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//设置非租塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//绑定连接</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(SystemConfig.SOCKET_SERVER_PORT));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将通道注册到选择器,并指定为可接收</span></span><br><span class="line">serverSocketChannel.register(selector，SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用轮询的方式，查询获取“准备就绪”的注册过的操作</span></span><br><span class="line"><span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前选择器中所有注册的选择键（“已经准备就绪的操作”）</span></span><br><span class="line">    Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator();</span><br><span class="line">    <span class="keyword">while</span> (selectedKeys.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取“准备就绪”的事件</span></span><br><span class="line">        SelectionKey selectedKey = selectedKeys.next();</span><br><span class="line">        <span class="comment">// 判断key是具体的什么事件</span></span><br><span class="line">        <span class="keyword">if</span> (selectedKey.isAcceptable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若接受的事件是“接收就绪” 操作,就获取客户端连接</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="comment">// 切换为非阻塞模式</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将该通道注册到selector选择器上,并指定为可读</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (selectedKey.isReadable())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取该选择器上的“读就绪”状态的通道</span></span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) selectedKey.channel();</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = socketChannel.read(byteBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, length));</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除选择键</span></span><br><span class="line">        selectedKeys.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">serverSocketChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:要注册到选择器, 通道必须是非租塞的</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>基于Java NIO, 在此基础, 抽象出来两个组件–Reactor和Handler</p><ol><li>Reactor: 负责响应IO事件,当检测到新的时间, 发送给相应的Handler</li><li>Handler: 执行处理</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO网络编程&quot;&gt;&lt;a href=&quot;#NIO网络编程&quot; class=&quot;headerlink&quot; title=&quot;NIO网络编程&quot;&gt;&lt;/a&gt;NIO网络编程&lt;/h2&gt;&lt;p&gt;非阻塞IO&lt;/p&gt;
&lt;p&gt;NIO是Java提供的替代BIO的相关API&lt;/p&gt;
&lt;h3 id=&quot;NI
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BIO网络编程</title>
    <link href="https://zhuyiting.xyz/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/BIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://zhuyiting.xyz/2019/04/30/网络编程/BIO网络编程/</id>
    <published>2019-04-30T11:29:55.000Z</published>
    <updated>2019-11-22T05:58:00.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BIO网络编程"><a href="#BIO网络编程" class="headerlink" title="BIO网络编程"></a>BIO网络编程</h2><p>同步阻塞网络编程</p><h3 id="阻塞IO的含义"><a href="#阻塞IO的含义" class="headerlink" title="阻塞IO的含义"></a>阻塞IO的含义</h3><p>阻塞IO: 资源不可用时,IO请求一直阻塞,直到有数据或者阻塞超时<br>非阻塞IO: 资源不可用时,IO请求离开返回,返回数据标识资源不可用<br>阻塞非阻塞描述请求,即如何获取数据</p><p>同步IO: 应用阻塞在发送或者接受数据的状态,直到数据成功传输或者返回失败<br>异步IO: 应用发送或接受数据后立刻返回,实际处理是异步执行<br>同步异步描述响应,即如何拿数据</p><p>Java中的<br>ServerSocket类的accept方法和InputStream类的read方法,都是阻塞API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="comment">// 初始化服务端Socket</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">System.out.println(<span class="string">"服务器启动成功"</span>);</span><br><span class="line"><span class="keyword">while</span> (!serverSocket.isClosed()) &#123;</span><br><span class="line">    Socket request = serverSocket.accept();<span class="comment">// 阻塞</span></span><br><span class="line">    System.out.println(<span class="string">"收到新连接 : "</span> + request.toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据、打印</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"utf-8"</span>));</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">while</span> ((msg = reader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 没有数据，阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (msg.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"收到数据,来自："</span>+ request.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">serverSocket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">String msg = scanner.nextLine();</span><br><span class="line">out.write(msg.getBytes(charset)); <span class="comment">// 阻塞，写完成</span></span><br><span class="line">scanner.close();</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BIO网络编程&quot;&gt;&lt;a href=&quot;#BIO网络编程&quot; class=&quot;headerlink&quot; title=&quot;BIO网络编程&quot;&gt;&lt;/a&gt;BIO网络编程&lt;/h2&gt;&lt;p&gt;同步阻塞网络编程&lt;/p&gt;
&lt;h3 id=&quot;阻塞IO的含义&quot;&gt;&lt;a href=&quot;#阻塞IO的含义&quot; c
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://zhuyiting.xyz/2019/04/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhuyiting.xyz/2019/04/27/网络编程/网络协议/</id>
    <published>2019-04-27T05:25:11.000Z</published>
    <updated>2019-11-23T09:26:07.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI网络七层模型"><a href="#OSI网络七层模型" class="headerlink" title="OSI网络七层模型"></a>OSI网络七层模型</h3><p><strong>物理层</strong>: 使原始的数据比特流能在物理介质上传输<br><strong>数据链路层</strong>: 封装成帧、透明传输、差错检测。<br><strong>网络层</strong>: 路由选择、流量控制（IP协议）</p><p><strong>传输层</strong>： 提供可靠的端口到端口的数据传输服务（TCP/UDP协议）</p><p><strong>会话层</strong>: 建立、管理、终止进程之间的会话和数据交换<br><strong>表示层</strong>: 数据格式转换，加密解密，压缩解压等<br><strong>应用层</strong>: 为用户的应用进程提供网络服务</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP提供面向连接、可靠、有序、字节流传输服务。<br>应用程序在使用TCP之前，必须先建立TCP连接。</p><h5 id="TCO三次握手"><a href="#TCO三次握手" class="headerlink" title="TCO三次握手"></a>TCO三次握手</h5><p>在正式发送数据之前，做的检验机制<br>通过以后就成功建立了TCP连接，然后开始传输数据</p><h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><p>在断开连接之前，做的确认机制</p><p>TCP三次握手和四次挥手，都是为了让连接的可靠性更高</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP提供无连接、不可靠、数据报尽力传输服务。</p><p>比如语言视频聊天， 日志上报等， 会用到</p><h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><p>一个http请求包含四个部分</p><ol><li>请求行: 请求类型,资源路径,以及http版本</li><li>请求头部: 用来说明服务器要使用的附加信息</li><li>空行: 请求头和数据主体之间必须有换行,作为分隔标记</li><li>主体: 即请求数据</li></ol><p>一个http响应数据包含</p><ol><li>状态行: HTTP版本、状态码、状态消息</li><li>响应报头部: 用来说明服务器要使用的附加信息</li><li>空行: 头部和数据之间的换行</li><li>响应正文: 即响应数据</li></ol><h4 id="HTTP协议响应状态码"><a href="#HTTP协议响应状态码" class="headerlink" title="HTTP协议响应状态码"></a>HTTP协议响应状态码</h4><ul><li>1XX: 临时响应<br>握手成功,TCP建立</li><li>2XX: 成功<br>表示已成功处理了请求</li><li>3XX: 重定向<br>表示要完成请求,需要进一步操作</li><li>4XX: 请求错误<br>请求可能出错</li><li>5XX: 服务器错误<br>服务器内部出错</li></ul><h4 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h4><p>WebSocket是基于TCP的一种新的网络协议<br>它实现了服务器和客户端全双工通信</p><p>支持多客服端,多语言,多服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OSI网络七层模型&quot;&gt;&lt;a href=&quot;#OSI网络七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI网络七层模型&quot;&gt;&lt;/a&gt;OSI网络七层模型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;: 使原始的数据比特流能在物理介质上传输&lt;b
      
    
    </summary>
    
    
      <category term="网络编程" scheme="https://zhuyiting.xyz/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络协议" scheme="https://zhuyiting.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>并发工具类</title>
    <link href="https://zhuyiting.xyz/2019/04/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://zhuyiting.xyz/2019/04/19/Java并发编程/并发工具类/</id>
    <published>2019-04-19T10:17:31.000Z</published>
    <updated>2019-11-22T03:45:42.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future可以实现异步执行,并且收集结果, 可以在其他线程中获取线程的返回结果<br>Future是一个接口,FutureTask是它的实现类</p><h4 id="FutureTask解读"><a href="#FutureTask解读" class="headerlink" title="FutureTask解读"></a>FutureTask解读</h4><p><strong>注意</strong></p><ol><li>FutureTask类实现了Runable接口</li><li>所以要想执行FutureTask类,需要利用它构造Thead类</li><li>FutureTask的构造函数需要一个Callable接口, 来定义操作,Callable相比Runable多了返回值</li><li>Callable中的call方法,最终会在Runable接口的run方法中执行</li></ol><p>多个FutureTask执行流程<br><img src="/2019/04/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/FutureTask%E6%B5%81%E7%A8%8B.png" alt="FutureTask流程"></p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>倒计数器,实现异步执行<br>它可以用来记录线程池中任务完成的情况</p><ol><li>定义任务数量</li><li>每次任务完成,任务数减1,减1操作是同步操作</li><li>await方法,等待计数器归0,当任务数清零后,任务全部完成</li></ol><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>线程栅栏,功能和CountDownLatch类似,但是CyclicBarrier对象可以重复执行多次</p><p>类似于线程池,提供了启动方法,用来指定任务数, 只有任务达到启动数量,才开启任务</p><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>Fork/Join是一个用来<strong>切分任务</strong>和<strong>合并结果</strong>的框架<br>专为可以递归分解成小块的工作而设计的<br>Fork/Join将任务分配给线程池中的工作线程,充分利用资源,提高性能</p><p>适合数据处理,结果汇总,统计等场景</p><h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><ul><li>本质是一个线程池,它的默认的线程数量是CPU的核心数量</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发工具类&quot;&gt;&lt;a href=&quot;#并发工具类&quot; class=&quot;headerlink&quot; title=&quot;并发工具类&quot;&gt;&lt;/a&gt;并发工具类&lt;/h2&gt;&lt;h3 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;F
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发工具类" scheme="https://zhuyiting.xyz/tags/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>并发容器类</title>
    <link href="https://zhuyiting.xyz/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/"/>
    <id>https://zhuyiting.xyz/2019/04/11/Java并发编程/并发容器类/</id>
    <published>2019-04-11T14:17:53.000Z</published>
    <updated>2019-11-21T06:41:27.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><h3 id="一-HashMap源码分析"><a href="#一-HashMap源码分析" class="headerlink" title="(一)HashMap源码分析"></a>(一)HashMap源码分析</h3><p>非线程安全容器类</p><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h4><p>HashMap是依据哈希表（数组和链表的结合）实现的<br><u>内部使用Node类型的数组，即一个数组，数组的元素是链表</u></p><p>每一个Node都存储着四个字段，如下：<br><img src="/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="数组链表结构图"></p><p>从next字段我们可以看出Node 是一个链表.即数组中的每一个位置存储一个链表的头结点,HashMap使用链表法来解决冲突,同一个链表中存放着 hash(key)%len( 元素key的哈希值和数组长度取模运算) 结果相同的元素</p><h4 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h4><p><strong>拉链法:</strong> 就是把具有相同哈希值的关键字值放在同一个单链表中<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个默认大小16的HashMap</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的下标 115%16=3。那么插入到数组下标为3的位置</span></span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line"><span class="comment">// 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。那么插入到数组下标为6的位置</span></span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line"><span class="comment">// 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，数组下标6的位置,即插在 &lt;K2,V2&gt; 前面。</span></span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure><h4 id="3-JDK1-7和JDK1-8中HashMap的区别"><a href="#3-JDK1-7和JDK1-8中HashMap的区别" class="headerlink" title="3. JDK1.7和JDK1.8中HashMap的区别"></a>3. JDK1.7和JDK1.8中HashMap的区别</h4><h5 id="单链表数组结构的缺陷"><a href="#单链表数组结构的缺陷" class="headerlink" title="单链表数组结构的缺陷"></a>单链表数组结构的缺陷</h5><p>JDK1.7采用的是单链表数组的结构,这样的结构,在查找的时候是分为两步的;</p><ol><li>先计算要查找的元素的键<code>key</code>所对应的hashCode,然后除留语法得到链表头所在数组的位置</li><li>然后从这个头结点,按顺序查找比对.</li></ol><p><u>所以,单链表数组结构的查询算法的时间复杂度与链表的长度成正比,和数组的长度无关.</u></p><h5 id="单链表数组的扩容机制"><a href="#单链表数组的扩容机制" class="headerlink" title="单链表数组的扩容机制"></a>单链表数组的扩容机制</h5><p>因为查询的时间复杂度与链表长度成正比, 所以需要尽量让链表保持较短<br>这就引入了扩容机制,扩大数组的长度,从而减少了链表的长度.</p><p>但是<strong>扩容机制成本非常大</strong>, 因为它需要新建一个长数组,然后把之前的每个节点都重新计算hash值,再复制到新数组中,构成新的链表数组</p><p>扩容机制的新数组长度为旧数组的两倍， 这就保证了旧数组中的节点所在位置index在新数组中，要么还是index，要么就是index+oldTable.lenth()</p><h5 id="JDK1-8的红黑树"><a href="#JDK1-8的红黑树" class="headerlink" title="JDK1.8的红黑树"></a>JDK1.8的红黑树</h5><p>由于扩容机制的成本太大，所以JDK1.8中引入了红黑树的数据结构，它是一种自平衡二叉树，它不要求平衡二叉树那样的绝对平衡，但是每次添加操作，都能保证只做三次旋转，就能达到自平衡二叉树的要求，而平衡二叉树插入新节点的旋转次数却不可预知。</p><p>红黑树保证了用少量的算力换取相对的平衡。</p><p>在JDK1.8中设计了每个链表长度都有阈值，超过阈值后，链表就会转换成红黑树。以降低时间复杂度和减少扩容次数。</p><h5 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h5><p>JDK1.7采用头插法，但是由于每次插入操作之前,都会遍历一遍链表,已判断是更新还是插入,所以头插法并没有提高插入效率 ,其次可能是考虑到新插入的元素更可能被先使用，所以使用头插法，让先头插法让新插入的元素更容易的被查找到</p><p>JDK1.8开始采用尾插法</p><ol><li>是因为JDK1.7中的扩容机制，是从表头开始复制到新数组,这就和原来的旧的链表相反了, 由于头插法, 后插入的数据本来应该在表头,可是复制到新数组中成了链表的尾结点. 这使得新插先用的想法成为了伪命题.</li><li>头插法在并发情况下,容易造成循环链<h4 id="HashMap在JDK1-8中的简单流程"><a href="#HashMap在JDK1-8中的简单流程" class="headerlink" title="HashMap在JDK1.8中的简单流程"></a>HashMap在JDK1.8中的简单流程</h4><img src="/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/HashMap%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="HashMap流程图"></li></ol><h3 id="二-HashTable"><a href="#二-HashTable" class="headerlink" title="(二)HashTable"></a>(二)HashTable</h3><p>一个synchronized的HashMap,只是在HasMap上加了synchronized关键字,它是遗留类,现在不推荐使用,因为全程都是重量级锁<br>它不允许记录的键或者值为空</p><h3 id="三-ConcurrentHashMap源码分析"><a href="#三-ConcurrentHashMap源码分析" class="headerlink" title="(三)ConcurrentHashMap源码分析"></a>(三)ConcurrentHashMap源码分析</h3><p>ConcurrentHashMap支持线程安全，并且ConcurrentHashMap的效率会比HashTable更高，因为它引入了分段锁。</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><strong>在JDK1.7中</strong><br><code>Segment&lt;K,V&gt;[]</code><br><code>Segment&lt;K,V&gt;</code>对象中含有<code>HashEntry&lt;K,V&gt;[]</code>table数组<br>每一个Segment都是一把锁<br>结构如图:<br><img src="/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/ConcurrentHashMap1.7.png" alt="ConcurrentHashMap1.7"></p><p><strong>在JDK1.8中</strong><br>结构和HashMap类似,但操作的时候,产生Hash冲突时,对于当前的桶的头结点加锁.没有Hash冲突时采用CAS机制来操作数组</p><p><u>hash冲突的几率是小的,JDK1.8的设计,减少了加锁次数和加锁范围, 只有hash冲突时加锁,且只加在一个桶</u></p><h3 id="四-ArrayList"><a href="#四-ArrayList" class="headerlink" title="(四)ArrayList"></a>(四)ArrayList</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>ArrayList是基于数组实现的,默认的大小是10, 它继承了RandomAccess接口, 意味着支持随机访问</p><h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p>size属性记录了保存的元素数量,当容量不够时就会扩容<br>新的数组长度是oldCapacity+(oldCapacity&gt;&gt;1),也就是原来的1.5倍</p><p>扩容时会把所有元素复制到新数组,代价很高, 所以最好能在一开始就知道要存的量,并在初始化的时候指定大小</p><h4 id="modCount标记位"><a href="#modCount标记位" class="headerlink" title="modCount标记位"></a>modCount标记位</h4><p>ArrayList有一个modCount标记位, 用来记录修改移除添加的操作的次数, 当利用迭代器对它进行遍历操作时, 会拷贝一个expectModCount, 用来判断是否有修改操作, 当ArrayList被修改(修改,添加,移除),modCount和expectModCount不一致, 就会抛出异常</p><h3 id="五-CopyOnWriteArrayList"><a href="#五-CopyOnWriteArrayList" class="headerlink" title="(五)CopyOnWriteArrayList"></a>(五)CopyOnWriteArrayList</h3><p>ArrayList的并发版本,由J.U.C包提供,采取读写分离的思想</p><p>添加数据的时候执行加锁,然后(拷贝原数组, 添加元素, 再替换),保证这些操作的线程安全</p><p>但这样做有两个问题:</p><ol><li>占用内存, 因为会复制一份完整的数组</li><li>读取会有时间滞后性, 其他线程进入读操作,读到的是旧数组的内容. 要替换操作完成, 才能读到</li></ol><h3 id="六-Vector"><a href="#六-Vector" class="headerlink" title="(六)Vector"></a>(六)Vector</h3><p>同步关键字版本的ArrayList,遗留容器</p><h3 id="七-HashSet"><a href="#七-HashSet" class="headerlink" title="(七)HashSet"></a>(七)HashSet</h3><p>基于HashMap实现 Set与List的区别是,Set元素不能重复, 这也叫就是HashMap的一个特性</p><h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><p>内部有一个HashMap</p><h3 id="八-CopyOnWriteArraySet"><a href="#八-CopyOnWriteArraySet" class="headerlink" title="(八)CopyOnWriteArraySet"></a>(八)CopyOnWriteArraySet</h3><p>基于CopyOnWriteArrayList<br>基本原理就是添加时先进行比对操作,没有重复值才插入</p><h3 id="九-PriorityQueue"><a href="#九-PriorityQueue" class="headerlink" title="(九)PriorityQueue"></a>(九)PriorityQueue</h3><p>采用数组结构, 引入完全二叉树概念</p><p>所以是有序队列</p><h3 id="十-LinkedList"><a href="#十-LinkedList" class="headerlink" title="(十)LinkedList"></a>(十)LinkedList</h3><p>双链表结构</p><p>前指针<br>数据类型<br>后指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发容器类&quot;&gt;&lt;a href=&quot;#并发容器类&quot; class=&quot;headerlink&quot; title=&quot;并发容器类&quot;&gt;&lt;/a&gt;并发容器类&lt;/h2&gt;&lt;h3 id=&quot;一-HashMap源码分析&quot;&gt;&lt;a href=&quot;#一-HashMap源码分析&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java集合容器" scheme="https://zhuyiting.xyz/tags/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS抽象队列同步器详解</title>
    <link href="https://zhuyiting.xyz/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://zhuyiting.xyz/2019/03/25/Java并发编程/AQS抽象队列同步器详解/</id>
    <published>2019-03-25T14:17:53.000Z</published>
    <updated>2019-11-19T03:30:55.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS抽象队列同步器详解"><a href="#AQS抽象队列同步器详解" class="headerlink" title="AQS抽象队列同步器详解"></a>AQS抽象队列同步器详解</h2><h3 id="同步锁的本质是什么"><a href="#同步锁的本质是什么" class="headerlink" title="同步锁的本质是什么?"></a>同步锁的本质是什么?</h3><p>同步的方法:独享-单个排队窗口,共享-多个排队窗口<br>抢锁的方法:不公平-插队抢,公平-先来后到排队<br>没抢到锁怎么办:反复询问窗口是否有空(CAS自旋),等待叫号(阻塞等待)<br>唤醒阻塞线程:全部通知,通知下一个(叫号器)</p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS全称AbstractQueuedSynchronizer  被认为是J.U.C的核心，和CAS共同撑起了整个J.U.C包（java.util.concurrent）<br>J.U.C中的大多数同步器都是基于AQS来构建的.</p><p>抽象队列同步器AQS，用于解决的就是多线程并发访问控制问题，在传统的多线程编程中，如果有多个线程需要访问同一个变量，就需要使用sychronized来为临界值区加锁，但是这种方法即不优雅，也不高效，更重要的是，不能实现更细粒度的控制，这时候AQS提供了一种简洁优雅的机制来实现线程安全:<strong>管理同步状态、阻塞/唤醒线程、管理等待队列</strong></p><p>本质上来说，<u>AQS是构建（包括锁在内）大部分同步组件的基本基础框架</u>，它<strong>实现了对资源的占用,释放;线程的等待唤醒,等相关接口的实现。</strong></p><p>比如ReentrantLock、CountDownLatch、CyclicBarrier等同步起， 其实都是通过内部类实现了AQS框架暴露的API，以此实现各类同步器功能，这些同步器的主要区别其实就是对同步状态（synchronion state）的定义不同。</p><h3 id="AQS的作用"><a href="#AQS的作用" class="headerlink" title="AQS的作用"></a>AQS的作用</h3><p>AQS框架， 分裂了构建同步器时的一系列关注点，它的额所有操作都围绕着资源——同步状态（synchronization state）来展开，并且解决了如下问题</p><ol><li>资源时可以被同时访问？ 还是在同一时间只能被一个线程访问（共享/独占功能）</li><li>访问资源的线程如何进行并发管理？（等待队列）</li><li>如果线程等不及资源了，如何从等待队列退出（超时/中断）</li></ol><p>这相当于时<strong>模板方法设计模式</strong>， AQS作为父类 定义好框架和内部操作细节， 具体的<strong>实现则由子类来操作</strong></p><p>AQS框架将剩下的一个问题留给用户：<br>什么是资源？ 如何定义资源是否可以被访问？</p><p>以下则是具体同步器<br><img src="/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/%E5%85%B7%E4%BD%93%E5%90%8C%E6%AD%A5%E5%99%A8.png" alt="具体同步器"></p><p>综上所述：<br><strong>AQS提供了一套模板框架：</strong><br>由于并发的存在，需要考虑的情况很多，因此能否以一种相对简单的方法来完成这两个目标就非常重要， 因为对于用户（AQS框架的使用者），很多时候并不关心内部复杂的细节。而AQS其实就是利用模板方法来实现这一点，AQS中大多数方法都是final或者private的。<br>AQS通过暴露以下API来让用户自己解决上面提到的“什么是资源？ 如何定义资源是否可以被访问？”的问题。<br><img src="/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.png" alt="钩子方法"><br><strong>AQS支持中断、超时：</strong><br>使用了AQS框架的同步器，都支持下面的操作：<br>阻塞和非阻塞（例如tryLock）同步；<br>可选的超时设置，让调用者可以放弃等待；<br>可中断的阻塞操作。</p><p><strong>AQS支持独占模式和共享模式：</strong><br>AQS框架内部通过一个内部类ConditionObject，实现了Condition接口，以此来为子类提供条件等待的功能。</p><h3 id="AQS原理简述"><a href="#AQS原理简述" class="headerlink" title="AQS原理简述"></a>AQS原理简述</h3><p>AQS所有操作都围绕着资源——同步状态（synchronization state）来展开，围绕着资源，衍生出三个基本问题：</p><ol><li>同步状态（synchronization state）的管理</li><li>阻塞/唤醒线程的操作</li><li>线程等待队列的管理<h4 id="AQS内部主体"><a href="#AQS内部主体" class="headerlink" title="AQS内部主体"></a>AQS内部主体</h4></li></ol><p><strong>属性</strong><br>state:同步状态位,锁的数量,加锁+1,释放-1<br>owner:资源拥有者<br>node:锁的等待者<br><strong>方法</strong><br>acquire,acquireShared:定义了资源争用逻辑,如果没拿到,进入等待队列<br>tryAcquire,tryAcquireShared:实际占用资源的操作, 需要具体使用者来实现<br>release,releaseShared:定义了释放资源的逻辑,释放之后,通知队列进行争抢<br>tryRelease,tryReleaseShared:实际执行资源释放的操作,由具体使用者来实现</p><h4 id="AQS实现一把简单的独享锁流程图"><a href="#AQS实现一把简单的独享锁流程图" class="headerlink" title="AQS实现一把简单的独享锁流程图"></a>AQS实现一把简单的独享锁流程图</h4><p><img src="/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/AQS%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="独享锁流程图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AQS抽象队列同步器详解&quot;&gt;&lt;a href=&quot;#AQS抽象队列同步器详解&quot; class=&quot;headerlink&quot; title=&quot;AQS抽象队列同步器详解&quot;&gt;&lt;/a&gt;AQS抽象队列同步器详解&lt;/h2&gt;&lt;h3 id=&quot;同步锁的本质是什么&quot;&gt;&lt;a href=&quot;#同步锁的
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java锁" scheme="https://zhuyiting.xyz/tags/Java%E9%94%81/"/>
    
      <category term="AQS" scheme="https://zhuyiting.xyz/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Lock锁</title>
    <link href="https://zhuyiting.xyz/2019/03/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Lock%E9%94%81/"/>
    <id>https://zhuyiting.xyz/2019/03/17/Java并发编程/Lock锁/</id>
    <published>2019-03-17T10:17:53.000Z</published>
    <updated>2019-11-19T01:23:04.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock是一个锁的接口， 提供获取锁和解锁的方法（lock，trylock，unlock）<br>是一种用代码实现的锁<br><strong>注意:</strong>当Lock没有指向unlock释放锁的时候,即为可重入锁,其他线程在锁没有释放的时候还是无法获取锁,即使没有线程在使用锁, 但还是有一个线程在占用锁<br><strong>ReentrantLock</strong>是Lock接口的一个实现类， 它实现了Lock中的方法， 但是使用Lock的时候必须注意它不会像synchronized执行完后或者抛出异常后自动释放锁， 而是需要你主动释放锁， 所以我们必须在使用Lock时加上try{}catch{}finally{}块，并且在finally中释放占用的锁资源。</p><p>使用Lock和synchronized最大的区别就是当<strong>使用synchroniized时一个线程抢占资源，其他线程必须等待</strong>，而<strong>使用Lock，一个线程抢占到锁资源，其他的线程可以不等待或者设置等待时间</strong>， 实在抢不到可以去做其他的业务逻辑</p><h4 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a><strong>ReadWriteLock读写锁</strong></h4><p>它可以实现读写锁， 当读取的时候线程会获得read锁， 其他线程也可以获取read锁，同时并发的去读取，但是写程序运行获取到write锁时， 其他线程是不能进行操作的，因为write是排它锁，而上面介绍的两种Lock和synchronized不管是read还是write没有抢到锁的线程都会被阻塞或者中断，ReadWriteLock也是个接口，里面定义了两种方法readLock()和writeLock()，他的一个实现类是ReentrantReadWriteLock是ReadWriteLock的实现类<br><strong>注意</strong>读锁被占用的时候,写锁不能被占用</p><h3 id="小记"><a href="#小记" class="headerlink" title="小记:"></a><strong>小记:</strong></h3><p><strong>Lock比内置锁更具灵活性,可以设置方法不去等待锁,做其他的逻辑操作. 它具备和内置锁同样的内存语义</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h3&gt;&lt;p&gt;Lock是一个锁的接口， 提供获取锁和解锁的方法（lock，trylock，unlock）&lt;br&gt;是一种用代码实现的锁&lt;br
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java锁" scheme="https://zhuyiting.xyz/tags/Java%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java锁与synchronized</title>
    <link href="https://zhuyiting.xyz/2019/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E9%94%81%E4%B8%8Esynchronized/"/>
    <id>https://zhuyiting.xyz/2019/03/15/Java并发编程/Java锁与synchronized/</id>
    <published>2019-03-15T06:04:30.000Z</published>
    <updated>2019-11-19T01:26:04.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java锁与synchronized"><a href="#Java锁与synchronized" class="headerlink" title="Java锁与synchronized"></a>Java锁与synchronized</h2><p>Java内置锁synchronized是一把互斥锁, 这意味这同时只有一个线程能够进入锁</p><h3 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h3><ol><li>自旋锁: 为了不放弃CPU执行事件,循环的使用CAS技术对数据尝试进行更新,直到成功,本质上是乐观锁的一种实现</li><li>悲观锁: 假定会发生并发冲突,同步所有对数据的相关的操作,从读数据就开始上锁</li><li>乐观锁: 假定没有冲突,在修改数据时如果发现数据和之前不一致,则读最新数据,再重试修改</li><li>独享锁(写): 给资源加上写锁,只有一个线程可以修改,其他线程排队</li><li>共享锁(读): 给资源加上读锁,其他线程只能加读锁,不能加写锁</li><li>可重入锁、不可重入锁: 线程拿到锁后可以、不可以重用锁资源</li><li>公平锁、不公平锁: 争抢锁的顺序,如先来后到则是公平锁</li></ol><p><strong>注意</strong>:不同的锁应对不同的场景,没有优劣之分,只有最适合场景的锁.</p><h3 id="同步关键字synchronized："><a href="#同步关键字synchronized：" class="headerlink" title="同步关键字synchronized："></a>同步关键字synchronized：</h3><p>Java内置锁synchronized<br><strong>同步关键字synchronized属于悲观锁</strong><br>属于最基本的线程通信机制，基于对象监视器实现的。<br>Java中的每个对象都与一个监视器相关联，<br>一个线程可以锁定或解锁监视器，一次只有一个线程可以锁定监视器<br>特性：synchronized是一个可重入、独享、悲观锁</p><p>synchronized用于同步方法和代码块，执行完后自动释放锁</p><h4 id="锁的范围"><a href="#锁的范围" class="headerlink" title="锁的范围:"></a><strong>锁的范围:</strong></h4><p>修饰类或静态方法,<strong>类锁</strong>, 同步的内容是class对象和静态方法</p><p>修饰非静态方法或者this,<strong>对象锁</strong>,同步的内容是单个对象资源</p><h3 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h3><h4 id="理解Java对象头与Monitor"><a href="#理解Java对象头与Monitor" class="headerlink" title="理解Java对象头与Monitor"></a>理解Java对象头与Monitor</h4><p>对象在内存中，有一块对象头区域，它是实现synchronized的基础，</p><p><strong>对象头区域</strong>有两个部分：<br>第一部分(markword)，存放<strong>hashCode值</strong>、<strong>锁状态</strong>、<strong>GC标志</strong>等信息<br>第二部分，存放<strong>类型指针</strong>，指向类元数据，表名该对象属于哪个类</p><p>第一部分除了锁状态，Java6还新增了轻量级锁和偏向锁。<br>synchronized属于重量级锁</p><h5 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h5><p>对象头中的锁状态，存放这锁的信息</p><ol><li><p>有一个<strong>线程ID</strong><br>是标记线程对象的<br>线程中也有一个锁记录,来标记到锁</p></li><li><p>有一个<strong>锁状态位</strong><br>标记当前锁的状态<br>01:unlocked(未锁定)<br>00:轻量级锁<br>10:重量级锁<br>11:要被GC回收<br><u>线程可以通过CAS机制来修改锁的状态位</u></p></li><li><p>有一个<strong>偏向锁锁状态位</strong><br>偏向锁锁状态位只有一位<br>0/1: 开启或者关闭</p></li><li><p>有一个<strong>锁监视器标志位</strong></p></li></ol><p><strong>锁监视器标志位</strong>中指针指向<strong>Monitor对象（锁监视器）</strong>的起始地址<br>每个对象都有一个<strong>Monitor对象（锁监视器）</strong>与其关联</p><h5 id="Monitor对象（锁监视器）"><a href="#Monitor对象（锁监视器）" class="headerlink" title="Monitor对象（锁监视器）"></a>Monitor对象（锁监视器）</h5><p>Monitor对象（锁监视器）中有一个指针，指向持有它的线程(_owner)<br>Monitor对象还拥有两个队列， 一个是<strong>线程排队队列(_EntryList)</strong>，一个是<strong>线程阻塞队列(_WaitList)</strong>。</p><p>当持有它的对象释放它的时候，指针会重制，指向等待队列中的下一个线程，</p><p>当线程执行wait时,它会进入阻塞队列_WaitList,唤醒后,进入排队队列_EntryList</p><p>synchronized就是通过这种方法来实现锁的， 这也是为什么Java中任意对象都可以是锁的原因。<br>监视器跟对象共同的生命周期,但是在没有开启重量级锁之前,监视器是空对象,_owner在开启重量级锁后才会指向线程</p><h3 id="偏向锁、轻量级锁、自旋锁、锁消除"><a href="#偏向锁、轻量级锁、自旋锁、锁消除" class="headerlink" title="偏向锁、轻量级锁、自旋锁、锁消除"></a>偏向锁、轻量级锁、自旋锁、锁消除</h3><p><strong>偏向锁</strong><br>偏向锁就是，当一个线程获得了锁，就会进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁(<strong>本质可以理解为单线程情况无锁</strong>)<br><u>(因为当只有一个线程反复操作锁的时候,不应该反复加锁, 这是额外的消耗,是需要尽量降低的)</u></p><p>当一个线程来获取锁,并不会第一时间修改锁状态位,而是先修改偏向锁的标志位,偏向锁默认为1 即开启状态,还有一个线程标记,指向获取偏向锁的线程,线程要获取偏向锁,修改线程标记指向自己, 操作成功即得到锁,第二次再来访问锁时,比较当前的线程标记是否是自己,如果是,就直接访问. 但如果是第二个线程想要来获取锁,发现线程标记不是自己,就会锁升级到轻量级锁,升级后,偏向锁改为0,即关闭偏向锁</p><p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，当每次申请锁的线程都是不相同的,每个线程都获得了偏向锁,就没有了偏向锁的效果了</p><p>偏向锁失败后，会升级为轻量级锁</p><p><strong>轻量级锁</strong><br>当一个线程进入锁,有线程来争抢锁时,偏向锁升级为轻量级锁<br>来争抢的线程会进入自旋,即循坏等待锁被释放,即<strong>自旋锁</strong></p><p>轻量级锁所适应的场景是线程交替执行同步块的场合</p><p>如果存在同一时间多个线程访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><p><strong>重量级锁</strong><br>重量级锁即synchronized实现的锁, 启用锁监视器Monitor对象<br>线程自旋次数增加后升级到重量级锁, 停止自旋, 监视器启动, 监视器中的_owner属性指向当前占有锁的线程,</p><p><u>锁升级是单向的,即从低到高,从轻到重,锁的等级是通过对象中的锁信息里的状态位来标识,而多线程争抢锁,就会改变这个状态位</u></p><p><strong>锁消除</strong><br>锁消除即消除不必要的锁,或者缩小锁的范围</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java锁与synchronized&quot;&gt;&lt;a href=&quot;#Java锁与synchronized&quot; class=&quot;headerlink&quot; title=&quot;Java锁与synchronized&quot;&gt;&lt;/a&gt;Java锁与synchronized&lt;/h2&gt;&lt;p&gt;Java内置
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java锁" scheme="https://zhuyiting.xyz/tags/Java%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>使用volatile解决可见性问题及阻止指令重排序</title>
    <link href="https://zhuyiting.xyz/2019/03/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BD%BF%E7%94%A8volatile%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E9%98%BB%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <id>https://zhuyiting.xyz/2019/03/03/Java并发编程/使用volatile解决可见性问题及阻止指令重排序/</id>
    <published>2019-03-03T14:52:41.000Z</published>
    <updated>2019-11-18T01:24:38.529Z</updated>
    
    <content type="html"><![CDATA[<h4 id="volatile解决可见性问题"><a href="#volatile解决可见性问题" class="headerlink" title="volatile解决可见性问题"></a>volatile解决可见性问题</h4><p>volatile关键字的作用之一，是系统每次使用被它修饰过的变量时都时直接从内存中提取，而不是从缓存Cache中提取，同时对于该变量的更改会马上刷新回主存，使得各个线程取出的值相同，这里的Cache可以理解为线程的工作内存。<br><strong>volatile可以解决可见性问题，但无法解决原子性问题</strong><br>（synchronized或其他的加锁，也能保证内存的可见性，但实现方式略有不同，<strong>volatile的使用成本更低，因为它不会引起线程上下文的切换和调度。</strong>）</p><h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p>对于volatile修饰的变量的写操作会有一行以lock作为前缀的汇编代码。这个指令在多核处理器下会引发两件事，</p><ol><li>将当前处理器缓存行的数据写回到主内存；</li><li>这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效(<strong>禁用缓存</strong>)<br>lock前缀的指令会锁住系统总线或者缓存，目的就是保证在同一时间只有一个CPU可以修改数据。</li></ol><h4 id="volatile解决指令重排序问题"><a href="#volatile解决指令重排序问题" class="headerlink" title="volatile解决指令重排序问题"></a>volatile解决指令重排序问题</h4><p>volatile的另外一个作用就是阻止指令重排序<br>JVM会在不改变数据依赖的前提下对指令进行任意排序以提高程序性能。如果不存在数据依赖性，处理器也可以改变语句对应机器指令的执行顺序；</p><p>volatile通过插入内存屏障来实现阻止指令重排序</p><p>happens-before原则：它保证了程序的有序性，它规定如果两个操作的执行顺序无法从happens-before原则中推出来，那么它们就不能保证有序性，可以随意进行重排序：</p><p><strong>总结:</strong> volatile可以保证可见性和有序性,但不能保证原子性.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;volatile解决可见性问题&quot;&gt;&lt;a href=&quot;#volatile解决可见性问题&quot; class=&quot;headerlink&quot; title=&quot;volatile解决可见性问题&quot;&gt;&lt;/a&gt;volatile解决可见性问题&lt;/h4&gt;&lt;p&gt;volatile关键字的作用之一，是
      
    
    </summary>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java并发编程" scheme="https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="volatile" scheme="https://zhuyiting.xyz/tags/volatile/"/>
    
  </entry>
  
</feed>
