---
title: JVM垃圾回收机制
categories:
  - Java系统调优
tags:
  - Java
  - JVM
toc: true
date: 2019-06-10 17:23:11
---
## JVM垃圾回收机制

### 自动垃圾收集

自动垃圾收集是**查看堆内存**,**识别正在使用哪些对象**以及**哪些对象未被删除**以及**删除未使用对象**的过程

正在使用的对象是指,程序的某些部分仍然维护指向该对象的指针
未使用的对象是指,程序的任何部分都不再引用的对象,因此需要回收未引用对象的内存

自动垃圾收集机制也是java非常重要的一大特性

### 如何确定内存需要被回收

第一步,称为**标记**.这是垃圾收集器识别哪些内存正在使用而哪些不在使用的

#### 可达性分析算法

就是将对象及其引用关系看做一个图,选定**活动的对象**作为GC Roots;
然后跟踪引用链,如果一个对象和GC Roots之间没有连通性,也就是不存在引用,那么可以认为是可回收对象.

##### 可以用作GC Root的对象

1. 虚拟机栈中正在引用的对象
2. 本地方法栈中正在引用的对象
3. 静态属性引用的对象
4. 方法区常量引用的对象

##### 引用类型

1. 强引用:最常见的普通对象引用,只要还有强引用指向一个对象,就不会回收(new出来的对象)
2. 软引用:JVM认为内存不足,才会去试图回收软引用指向的对象.(缓存场景)
3. 弱引用:虽然是引用,但随时可能被回收掉
4. 虚引用:不能通过它访问对象. 通常是在GC时做一些操作

##### 可达性级别

1. 强可达:一个对象可以有一个或多个线程可以通过各种引用访问
2. 软可达:只能通过软引用才能访问
3. 弱引用:只能通过弱引用访问
4. 幻象可达:不存在其他引用,并且finalize过了,只有虚引用指向它
5. 不可达:意味着可以被GC了

### 怎么清楚垃圾

第二步, 定义如何清除垃圾

#### 垃圾收集算法

##### 标记-清除(mark-sweep)算法

首先标识出所有要回收的对象,然后清除,标记-清除算法效率优先,有内存碎片化问题,不适合特别大的堆;分代收集算法基本基于标记-清除算法的思路改进.

##### 复制(Copying)算法

划分两块同等大小的区域,收集时将活着的对象复制到另一块区域. 拷贝过程中将对象顺序放置,就可以避免内存碎片化. 复制+预留内存, 有一定的资源浪费.

##### 标记-整理(mark-compact)

类似于标记-清除,但是为了避免内存碎片化,会在清理过程中将对象移动,已确保对象占用连续的内存空间.

##### 分代收集算法

当前商业虚拟机常用的算法,根据对象存活周期的不同,将内存划分为几块,一般是把堆划分为新生代和老年代,这样就可以根据各个年代的特点采用最适合的收集算发.
在新生代中,每次垃圾收集都有大量对象死去,少量存活,就用复制算法,只需要付出少量存活对象的复制成本就可以完成收集,
而老年代中因为对象存活率高,没有额外的空间对它进行分配担保,必须使用标记-清除或者标记-整理算法来回收,不需要大量的移动对象.

新对象会被分配到新生代(Eden),如果超过`-XX:+PretenureSizeThreshold`:设置的大对象直接进入老年代的阈值, 直接存放到老年代

### 垃圾收集器

#### 串行收集器Serial

##### -Serial GC -XX:UseSerialGC

单个线程来执行所有垃圾收集工作,适合单处理器机器,Glient模式下JVM的默认选项

##### -Serial Old -XX:UseSeriaOldlGC

Serial的老年代版本,可以在老年代使用, 它采用了标记-整理(Mark-Compact)算法,区别于新生代的复制算法

#### 并行收集器Parallel

##### -Parallel GC -XX:+UseParallelGC

##### -Parallel Old GC -XX:+UseParallelGC

server模式JVM的默认GC选择,整体算法和Serial类似,区别是新生代和老年代GC都是并行进行;
可以设置GC时间或吞吐量等,可以自动进行适应性调整Eden,Survivor大小和MaxTenuringThreshold的值.

也称为吞吐量优先的GC: 吞吐量=用户代码运行时间/(用户代码运行时间+GC时间)

-XX:ParallelGCThreads: 设置用于垃圾回收的线程数. 通常和CPU数相等
-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间. 值是大于0的整数.
-XX:GCTimeRatio: 设置吞吐量大小,它的值是一个0-100之间的整数.
-XX:+UseAdaptiveSizePolicy: 打开自适应GC策略. 以达到在堆大小,吞吐量和停顿时间之间的平衡点

##### -ParNew GC -XX:+UseParNewGC

新生代GC的实现, 它实际是Serial GC的多线程版本. 可以控制线程数量, 参数: -XX:ParallelGCThreads
最常见的场景是配合老年代的CMS GC工作. 参数: -XX:+UseConcMarkSweepGC

#### 并发收集器CMS(Concurrent Mark Sweep)

##### -CMS GC -XX:+UseConcMarkSweepGC

专用老年代,基于标记-清除算法,设计目标是尽量减少停顿时间.
但会占用更多的CPU资源,并和用户线程争抢

##### -G1 -XX:+UseG1GC

针对大堆内存设计的收集器,兼顾吞吐量和停顿时间, JDK9后为默认选项, 目标是替代GMC;
G1将堆分为多个固定大小, 堆之间是复制算法, 但整体上可以理解为标记-整理算法,可以有效避免内存碎片化.
