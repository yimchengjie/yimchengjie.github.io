---
title: Java程序运行堆栈分析
categories:
  - Java并发编程
tags:
  - JavaSE
  - Java并发编程
date: 2018-04-17 11:05
---

### Java 程序运行堆栈分析

class 文件包含 JAVA 程序执行的字节码,数据严格按照格式紧凑排列在 class 文件中的二进制流中间
**.java->编译->.class->JVM 运行时数据区**

1. **寄存器**:最快的存储区,由编译器更具需求进行分配,我们在程序中无法控制
2. **栈**:存放函数中定义的基本类型的变量数据和对象的引用(指向堆中对应对象的地址,把对象的地址赋值给栈),但对象本身不存放在栈中,而是存放在堆(new 出来的对象)或者常量池中(字符串常量对象存放在常量池中.).栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。栈内存中的数据，没有默认初始化值，需要手动设置。
3. **堆**:存放所有 new 出来的对象.用完之后靠垃圾回收机制不定期自动消除(当栈中没有指向当前对象时,被视为垃圾,JVM 启动垃圾回收机制).堆内存中所有的实体都有内存地址值。堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。

   ```java
   Car c=new Car;
   c.num=5;
   Car c1=c;
   c1.color="green";
   c.run();
   Car c1=c;
   ```

   这句话相当于将对象复制一份出来，两个对象的内存地址值一样。所以指向同一个实体，对 c1 的属性修改，相当于 c 的属性也改了。
4. **静态域**:存放静态成员(static 定义的)
5. **常量池**:存放字符串常量和基本类型常量(public static final).编译期已经创建好(直接用双引号定义的)的就存储在常量池中

   ```java
   String s1 = "china";
   String s2 = "china";
   String s3 = "china";
   String ss1 = new String("china");
   String ss2 = new String("china");
   String ss3 = new String("china");
   ```

   s1 s2 s3 指向常量池中的同一个对象 ss1 ss2 ss3 指向堆中的三个不同对象但是 ss1 ss2 ss3 创建对象前会先去常量池中查找是否存在"china" 如果不存在 则需要在常量池中先创建一个对象,然后再在队中创建常量池中该对象的拷贝对象. 这也就是有道面试题：String s = new String(“xyz”);产生几个对象？一个或两个，如果常量池中原来没有”xyz”,就是两个。
6. **非 RAM 存储**:硬盘等永久存储空间

### java 线程模型和 cpu 缓存模型

cpu 缓存模型
![cpu缓存模型](cpu缓存模型.png)

java 线程模型
![java线程模型](java线程模型.png)

<u>Java 线程内存模型跟 cpu 缓存模型类似，是基于 cpu 缓存模型来建立的</u>

java 同步规则
![java内存模型同步规则](java内存模型同步规则.png)
