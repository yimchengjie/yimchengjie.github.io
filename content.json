{"meta":{"title":"ycjBlog","subtitle":null,"description":null,"author":"yanchengjie","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-10-18T07:42:59.000Z","updated":"2019-10-18T07:42:59.817Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-10-18T08:58:07.896Z","updated":"2019-10-18T08:58:07.896Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM指令手册","slug":"JVM指令手册","date":"2019-07-30T07:18:00.000Z","updated":"2019-10-19T00:10:20.374Z","comments":true,"path":"2019/07/30/JVM指令手册/","link":"","permalink":"http://yoursite.com/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/","excerpt":"","text":"栈和局部变量操作将常量压入栈的指令aconst_null 将null对象引用压入栈iconst_m1 将int类型常量-1压入栈iconst_0 将int类型常量0压入栈iconst_1 将int类型常量1压入栈iconst_2 将int类型常量2压入栈iconst_3 将int类型常量3压入栈iconst_4 将int类型常量4压入栈iconst_5 将int类型常量5压入栈lconst_0 将long类型常量0压入栈lconst_1 将long类型常量1压入栈fconst_0 将float类型常量0压入栈fconst_1 将float类型常量1压入栈dconst_0 将double类型常量0压入栈dconst_1 将double类型常量1压入栈bipush 将一个8位带符号整数压入栈sipush 将16位带符号整数压入栈ldc 把常量池中的项压入栈ldc_w 把常量池中的项压入栈（使用宽索引）ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）从栈中的局部变量中装载值的指令iload 从局部变量中装载int类型值lload 从局部变量中装载long类型值fload 从局部变量中装载float类型值dload 从局部变量中装载double类型值aload 从局部变量中装载引用类型值（refernce）iload_0 从局部变量0中装载int类型值iload_1 从局部变量1中装载int类型值iload_2 从局部变量2中装载int类型值iload_3 从局部变量3中装载int类型值lload_0 从局部变量0中装载long类型值lload_1 从局部变量1中装载long类型值lload_2 从局部变量2中装载long类型值lload_3 从局部变量3中装载long类型值fload_0 从局部变量0中装载float类型值fload_1 从局部变量1中装载float类型值fload_2 从局部变量2中装载float类型值fload_3 从局部变量3中装载float类型值dload_0 从局部变量0中装载double类型值dload_1 从局部变量1中装载double类型值dload_2 从局部变量2中装载double类型值dload_3 从局部变量3中装载double类型值aload_0 从局部变量0中装载引用类型值aload_1 从局部变量1中装载引用类型值aload_2 从局部变量2中装载引用类型值aload_3 从局部变量3中装载引用类型值iaload 从数组中装载int类型值laload 从数组中装载long类型值faload 从数组中装载float类型值daload 从数组中装载double类型值aaload 从数组中装载引用类型值baload 从数组中装载byte类型或boolean类型值caload 从数组中装载char类型值saload 从数组中装载short类型值将栈中的值存入局部变量的指令istore 将int类型值存入局部变量lstore 将long类型值存入局部变量fstore 将float类型值存入局部变量dstore 将double类型值存入局部变量astore 将将引用类型或returnAddress类型值存入局部变量istore_0 将int类型值存入局部变量0istore_1 将int类型值存入局部变量1istore_2 将int类型值存入局部变量2istore_3 将int类型值存入局部变量3lstore_0 将long类型值存入局部变量0lstore_1 将long类型值存入局部变量1lstore_2 将long类型值存入局部变量2lstore_3 将long类型值存入局部变量3fstore_0 将float类型值存入局部变量0fstore_1 将float类型值存入局部变量1fstore_2 将float类型值存入局部变量2fstore_3 将float类型值存入局部变量3dstore_0 将double类型值存入局部变量0dstore_1 将double类型值存入局部变量1dstore_2 将double类型值存入局部变量2dstore_3 将double类型值存入局部变量3astore_0 将引用类型或returnAddress类型值存入局部变量0astore_1 将引用类型或returnAddress类型值存入局部变量1astore_2 将引用类型或returnAddress类型值存入局部变量2astore_3 将引用类型或returnAddress类型值存入局部变量3iastore 将int类型值存入数组中lastore 将long类型值存入数组中fastore 将float类型值存入数组中dastore 将double类型值存入数组中aastore 将引用类型值存入数组中bastore 将byte类型或者boolean类型值存入数组中castore 将char类型值存入数组中sastore 将short类型值存入数组中wide指令wide 使用附加字节扩展局部变量索引通用(无类型）栈操作nop 不做任何操作pop 弹出栈顶端一个字长的内容pop2 弹出栈顶端两个字长的内容dup 复制栈顶部一个字长内容dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2 复制栈顶部两个字长内容dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈swap 交换栈顶部两个字长内容类型转换i2l 把int类型的数据转化为long类型i2f 把int类型的数据转化为float类型i2d 把int类型的数据转化为double类型l2i 把long类型的数据转化为int类型l2f 把long类型的数据转化为float类型l2d 把long类型的数据转化为double类型f2i 把float类型的数据转化为int类型f2l 把float类型的数据转化为long类型f2d 把float类型的数据转化为double类型d2i 把double类型的数据转化为int类型d2l 把double类型的数据转化为long类型d2f 把double类型的数据转化为float类型i2b 把int类型的数据转化为byte类型i2c 把int类型的数据转化为char类型i2s 把int类型的数据转化为short类型整数运算iadd 执行int类型的加法ladd 执行long类型的加法isub 执行int类型的减法lsub 执行long类型的减法imul 执行int类型的乘法lmul 执行long类型的乘法idiv 执行int类型的除法ldiv 执行long类型的除法irem 计算int类型除法的余数lrem 计算long类型除法的余数ineg 对一个int类型值进行取反操作lneg 对一个long类型值进行取反操作iinc 把一个常量值加到一个int类型的局部变量上逻辑运算移位操作ishl 执行int类型的向左移位操作lshl 执行long类型的向左移位操作ishr 执行int类型的向右移位操作lshr 执行long类型的向右移位操作iushr 执行int类型的向右逻辑移位操作lushr 执行long类型的向右逻辑移位操作按位布尔运算iand 对int类型值进行“逻辑与”操作land 对long类型值进行“逻辑与”操作ior 对int类型值进行“逻辑或”操作lor 对long类型值进行“逻辑或”操作ixor 对int类型值进行“逻辑异或”操作lxor 对long类型值进行“逻辑异或”操作浮点运算fadd 执行float类型的加法dadd 执行double类型的加法fsub 执行float类型的减法dsub 执行double类型的减法fmul 执行float类型的乘法dmul 执行double类型的乘法fdiv 执行float类型的除法ddiv 执行double类型的除法frem 计算float类型除法的余数drem 计算double类型除法的余数fneg 将一个float类型的数值取反dneg 将一个double类型的数值取反对象和数组对象操作指令new 创建一个新对象checkcast 确定对象为所给定的类型getfield 从对象中获取字段putfield 设置对象中字段的值getstatic 从类中获取静态字段putstatic 设置类中静态字段的值instanceof 判断对象是否为给定的类型数组操作指令newarray 分配数据成员类型为基本上数据类型的新数组anewarray 分配数据成员类型为引用类型的新数组arraylength 获取数组长度multianewarray 分配新的多维数组控制流条件分支指令ifeq 如果等于0，则跳转ifne 如果不等于0，则跳转iflt 如果小于0，则跳转ifge 如果大于等于0，则跳转ifgt 如果大于0，则跳转ifle 如果小于等于0，则跳转if_icmpcq 如果两个int值相等，则跳转if_icmpne 如果两个int类型值不相等，则跳转if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转ifnull 如果等于null，则跳转ifnonnull 如果不等于null，则跳转if_acmpeq 如果两个对象引用相等，则跳转if_acmpnc 如果两个对象引用不相等，则跳转比较指令lcmp 比较long类型值fcmpl 比较float类型值（当遇到NaN时，返回-1）fcmpg 比较float类型值（当遇到NaN时，返回1）dcmpl 比较double类型值（当遇到NaN时，返回-1）dcmpg 比较double类型值（当遇到NaN时，返回1）无条件转移指令goto 无条件跳转goto_w 无条件跳转（宽索引）表跳转指令tableswitch 通过索引访问跳转表，并跳转lookupswitch 通过键值匹配访问跳转表，并执行跳转操作异常athrow 抛出异常或错误finally子句jsr 跳转到子例程jsr_w 跳转到子例程（宽索引）rct 从子例程返回方法调用与返回方法调用指令invokcvirtual 运行时按照对象的类来调用实例方法invokespecial 根据编译时类型来调用实例方法invokestatic 调用类（静态）方法invokcinterface 调用接口方法方法返回指令ireturn 从方法中返回int类型的数据lreturn 从方法中返回long类型的数据freturn 从方法中返回float类型的数据dreturn 从方法中返回double类型的数据areturn 从方法中返回引用类型的数据return 从方法中返回，返回值为void线程同步montiorenter 进入并获取对象监视器monitorexit 释放并退出对象监视器 JVM指令助记符变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_加：iadd,ladd,fadd,dadd减：isub,lsub,fsub,dsub乘：imul,lmul,fmul,dmul除：idiv,ldiv,fdiv,ddiv余数：irem,lrem,frem,drem取负：ineg,lneg,fneg,dneg移位：ishl,lshr,iushr,lshl,lshr,lushr按位或：ior,lor按位与：iand,land按位异或：ixor,lxor类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)创建类实便：new创建新数组：newarray,anewarray,multianwarray访问类的域和类实例域：getfield,putfield,getstatic,putstatic把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore获取数组长度：arraylength检相类实例或数组属性：instanceof,checkcast操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmplfcmpg,dcmpl,dcmpg复合条件转移：tableswitch,lookupswitch无条件转移：goto,goto_w,jsr,jsr_w,ret调度对象的实便方法：invokevirtual调用由接口实现的方法：invokeinterface调用需要特殊处理的实例方法：invokespecial调用命名类中的静态方法：invokestatic方法返回：ireturn,lreturn,freturn,dreturn,areturn,return异常：athrowfinally关键字的实现使用：jsr,jsr_w,ret","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"系统开发和运行知识","slug":"系统开发和运行知识","date":"2018-01-13T14:40:00.000Z","updated":"2019-10-19T00:10:01.041Z","comments":true,"path":"2018/01/13/系统开发和运行知识/","link":"","permalink":"http://yoursite.com/2018/01/13/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. 软件工程、软件过程改进和软件开发项目管理知识 软件工程知识 软件开发生命周期各阶段的目标和任务 软件开发项目管理基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具 主要的软件开发方法（生命周期法、原型法、面向对象法、CASE） 软件开发工具与环境知识 软件过程改进知识 软件质量管理知识 软件开发过程评估、软件能力成熟评估基础知识2. 系统分析基础知识 系统分析的目的和任务 结构化分析方法（数据流图（DFD）、数据字典（DD）、实体关系图（ERD）、描述加工处理的结构化语言） 统一建模语言（UML） 系统规格说明书3. 系统设计知识 系统设计的目的和任务 结构化设计方法和工具（系统流程图、HIPO图、控制流程图） 系统总体结构设计（总体布局、设计原则、模块结构设计、数据存储设计、系统配置方案） 系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计） 系统设计说明书4. 系统实施知识 系统实施的主要任务 结构化程序设计、面向对象程序设计、可视化程序设计 程序设计风格 程序设计语言的选择 系统测试的目的、类型，系统测试方法（黑盒测试、白盒测试、灰盒测试） 测试设计和管理（错误曲线、错误排除、收敛、注入故障、测试用例设计、系统测试报告） 系统转换基础知识5. 系统运行和维护知识 系统运行管理基础知识 系统维护基础知识 系统评价基础知识6. 面向对象开发方法 面向对象开发概念（类、对象、属性、封装性、继承性、多态性、对象之间的引用） 面向对象开发方法的优越性以及有效领域 面向对象设计方法（体系结构、类的设计、用户接口设计） 面向对象实现方法（选择程序设计语言、类的实现、方法的实现、用户接口的实现、准备测试数据） 面向对象程序设计语言（如C++、Java、Visual、Bsasic、Visual C++）的基本机制 面向对象数据库、分布式对象的概念","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机系统知识","slug":"计算机系统知识","date":"2017-12-30T14:36:00.000Z","updated":"2019-10-19T00:09:45.757Z","comments":true,"path":"2017/12/30/计算机系统知识/","link":"","permalink":"http://yoursite.com/2017/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. 硬件知识1.1 计算机系统的组成、体系结构分类及特性 CPU和存储器的组成、性能和基本工作原理 常用I/O设备、通信设备的性能，以及基本工作原理 I/O接口的功能、类型和特性 I/O控制方式（中断系统、DMA、I/O处理机方式） CISC/RISC，流水线操作，多处理机，并行处理1.2 存储系统 主存-Cache存储系统的工作原理 虚拟存储器基本工作原理，多级存储体系的性能价格 RAID类型和特性1.3 安全性、可靠性与系统性能评测基础知识 诊断与容错 系统可靠性分析评价 计算机系统性能评测方式2. 软件知识2.1 操作系统知识 操作系统的内核（中断控制）、进程、线程概念 处理机管理（状态转换、共享与互斥、分时轮转、抢占、死锁） 存储管理（主存保护、动态连接分配、分段、分页、虚存） 设备管理（I/O控制、假脱机） 文件管理（文件目录、文件组织、存取方法、存取控制、恢复处理） 作业管理（作业调度、作业控制语言（JCL）、多道程序设计） 汉字处理，多媒体处理，人机界面 网络操作系统和嵌入式操作系统基础知识 操作系统的配置2.2 程序设计语言和语言处理程序的知识 汇编、编译、解释系统的基础知识和基本工作原理 程序设计语言的基本成分：数据、运算、控制和传输，过程（函数）调用 各类程序设计语言主要特点和适用情况3. 计算机网络知识 网络体系结构（网络拓扑、OSI/RM、基本的网络协议） 传输介质、传输技术、传输方法、传输控制 常用网络设备和各类通信设备 Client/Server结构、Browser/Server结构 LAN拓扑，存取控制，LAN的组网，LAN间连接，LAN-WAN连接 因特网基础知识以及应用 网络软件 网络管理 网络性能分析4. 数据库知识 数据库管理系统的功能和特征 数据库模型（概念模式、外模式、内模式） 数据模型，ER图，第一范式、第二范式、第三范式 数据操作（集合运算和关系运算） 数据库语言（SQL） 数据库的控制功能（并发控制、恢复、安全性、完整性） 数据仓库和分布式数据库基础知识5. 多媒体知识 多媒体系统基础知识，多媒体设备的性能特性，常用多媒体文件格式 简单图形的绘制，图像文件的处理方法 音频和视频信息的应用 多媒体应用开发过程6. 系统性能知识 性能指标（响应时间、吞吐量、周转时间）和性能设计 性能测试和性能评估 可靠性指标及计算、可靠性设计 可靠性测试和可靠性评估7. 计算机应用基础知识 信息管理、数据处理、辅助设计、自动控制、科学计算、人工智能等基础知识 远程通信服务基础知识 常用应用系统","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机科学基础","slug":"计算机科学基础","date":"2017-12-27T14:17:00.000Z","updated":"2019-10-19T00:09:42.314Z","comments":true,"path":"2017/12/27/计算机科学基础/","link":"","permalink":"http://yoursite.com/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 数制及其转换• 二进制、十进制和十六进制等常用制数制及其相互转换 2. 数据的表示• 数的表示（原码、反码、补码、移码表示，整数和实数的机内表示，精度和溢出）• 非数值表示（字符和汉字表示、声音表示、图像表示）• 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码） 3. 算术运算和逻辑运算• 计算机中的二进制数运算方法• 逻辑代数的基本运算和逻辑表达式的化简 4. 数学基础知识• 命题逻辑、谓词逻辑、形式逻辑的基础知识• 常用数值计算（误差、矩阵和行列式、近似求解方程、插值、数值积分）• 排列组合、概率论应用、应用统计（数据的统计分析）• 运算基本方法（预测与决策、线性规划、网络图、模拟） 5. 常用数据结构• 数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、线索树、堆）、图等的定义、存储和操作• Hash（存储地址计算，冲突处理） 6. 常用算法• 排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法• 算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Web开发入门","slug":"Web开发入门","date":"2017-04-25T09:12:00.000Z","updated":"2019-10-19T00:10:24.038Z","comments":true,"path":"2017/04/25/Web开发入门/","link":"","permalink":"http://yoursite.com/2017/04/25/Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"C/S B/S网络应用:C/S就是(客户机/服务器)的简称,桌面应用程序采用的多是这种结构.B/S就是(浏览器/服务器)的简称,特点是客户端无需安装特定的软件,只需要安装一个浏览器就可以与系统进行交互 C/S优缺点:由于C/S结构没有像B/S（下一个基本概念介绍）结构中服务器向客户端发送的数据还包含了大量的非实际交换数据，比如请求响应头，还有页面数据等等，它的==相应时间还是相对较快==的；由于C/S结构安装的客户端软件，很多的业务逻辑、算法逻辑处理都在客户端进行，这样就==减轻了服务器的压力==，这是优点，但是带来的问题也显而易见，不但==有被反编译的安全隐患==，而且不断的安装各种客户端软件，会使==客户端越来越臃肿==；在升级维护等工作上带来的麻烦也是令人不愉快，因为每发生一次升级都需要重新更新客户端的软件，这样做的后果就是在==开发上的工作量加大==，而且用户每次都要更新自己终端上的软件，这些都是令人非常头疼的问题；由于需要在客户端进行安装特定软件，因此==对操作系统有一定的限制==； Web站点、Web应用、HTTP服务器、Web应用服务器:==Web站点:==即Web Site,也被成为Web网站;比如某公司逛完就是Web站点 ==Web应用:==即Web Application,简单来说,就是通过浏览器访问的应用程序,从而为客户提供相应服务 ==Http服务器:==即Web服务器,主要功能是提供网上信息浏览服务,例如Apache、Nginx、IIS是比较常用的HTTP服务器. ==Web应用服务器:==Web应用服务器能够运行服务器上的应用程序,并将结果返回给客户端浏览器;例如Tomcat,通常Web应用服务器兼具部分Http服务器的功能. ==Servlet的概念及功能:== Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat； 可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器； Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范，例如，必须继承于javax.servlet.http.HttpServlet类；","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Java异常处理","slug":"Java异常处理","date":"2017-04-03T10:14:00.000Z","updated":"2019-10-19T00:13:16.959Z","comments":true,"path":"2017/04/03/Java异常处理/","link":"","permalink":"http://yoursite.com/2017/04/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"集合框架","slug":"集合框架","date":"2017-03-25T00:58:00.000Z","updated":"2019-10-19T00:09:37.327Z","comments":true,"path":"2017/03/25/集合框架/","link":"","permalink":"http://yoursite.com/2017/03/25/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"泛型的作用:1. 泛型的定义:泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数.这种参数类型,可以在类 接口 和方法中创建,分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。 2. 泛型的作用:引入泛型的好处是安全简单 可以将运行时类型相关错误提前到编译时错误. 3. 泛型的特点: 所有的泛型类的参数在编译时都会被擦除,虚拟机运行时没有泛型. java泛型不支持基本类型 在泛型内部,无法获得有关系泛型参数类型的信息,如果传入的类型参数为T,那么在泛型代码内部你不知道T有什么方法,属性,关于T 的一切信息都丢失了 创建泛型对象时,清指明类型. java的泛型类型不能用于new构建对象,也不能用于初始化数组. 集合接口:1.为什么要使用集合接口:如果并不知道程序运行时会需要多少对象，或者需要更复杂方式存储对象——可以使用Java集合框架 2. 集合框架组成 Collection接口是最基本的集合接口. Map接口(实现类:HasMap . TreeMap)Map是一系列键值对组成的集合,提供了key到Value的映射.同时它也没有继承Collection.在Map中保证了key和Vlaue之间的一一对应,所以它不能存在相同的key值. List接口为Collection子接口。List所代表的是有序的Collection 它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置，和数组相似，从0开始，到元素个数-1）访问元素，并检索列表中的元素 实现类: ArraryList是一个非线程安全的列表,在遍历元素效率比较高.线程不同步. LinkedList是一个双向链表,在添加和删除元素时效率比较高.线程不同步. Vector与ArrayList相似，但是Vector是同步的。所以说Vector是使用数组实现的线程安全的列表。它的操作与ArrayList几乎一样. Set是一种不包括重复元素的Collection: 它维持自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个 由于Set接口的特殊性，所有传入Set集合中的元素都必须不同 实现类: EnumSet是枚举的专用Set。所有的元素都是枚举类型 HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变 TreeSet基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法 Queue 队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作 方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。 接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除 ArrayList ArrayList是一个用数组实现的列表，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null 每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作（构建一个新的更大的数组并将之前的内容拷贝到新书组中）。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率 ArrayList的默认扩容扩展后数组大小为：(原数组长度*3)/2+1 ArrayList是一个非线程安全的列表 LinkedList 同样实现List接口的LinkedList与ArrayList不同，LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"面向接口编程","slug":"面向接口编程","date":"2017-03-23T10:27:00.000Z","updated":"2019-10-19T00:09:49.637Z","comments":true,"path":"2017/03/23/面向接口编程/","link":"","permalink":"http://yoursite.com/2017/03/23/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"什么是接口,为什么要用接口?: 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 接口(interface)是抽象方法和常量值的定义的集合。 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。 接口定义举例 123456public interface Runner &#123; int id = 1; public void start(); public void run(); public void stop();&#125; 接口的特点: 用 interface 来定义。 接口中的所有成员变量都默认是由public static final修饰的。 接口中的所有方法都默认是由public abstract修饰的。接口没有构造方法。 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口也可以继承另一个接口，使用extends关键字 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口的使用 编写接口123456public interface UsbInterface&#123; /** *USB接口提供服务 */ void service();&#125; 实现接口12345public class UDisk implements UsbInterface&#123; public void service()&#123; System.out.println(\"连接USB口,开始传输数据.\"); &#125;&#125; 使用接口12UsbInterface uDisk = new UDisk();uDisk.service();","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"深入面向对象","slug":"深入面向对象","date":"2017-03-15T01:13:00.000Z","updated":"2019-10-19T00:09:57.304Z","comments":true,"path":"2017/03/15/深入面向对象/","link":"","permalink":"http://yoursite.com/2017/03/15/%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象的三个基本特征:封装 . 继承 . 多态封装(属性 . 对象): 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象继承: 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法 一个新类可以从现有的类中派生，这个过程称为类继承，新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类） 派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要多态: 多态性是指允许不同类的对象对同一消息作出响应 多态性语言具有灵活、抽象、行为共享、代码共享的优势封装的意义: 适当的封装可以让代码更容易理解和维护，也加强了代码的安全性。包机制: 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间包的作用: 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也提供了限定了访问权限的一个控制范围，拥有包访问权限的类才能访问某个包中的类 类的访问控制符: default: 默认的（不提供访问控制符）仅可被同包的其他代码访问 public：可以被任何代码访问 protected: private: 私有的 继承的意义:继承是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的数据或新的功能,也可以用父类的功能,通过使用继承,我们能够非常方便的复用代码,大大提高开发效率 对象向上造型:所谓的向上造型就是父类的引用指向子类的对象 instanceof运算符:instanceof运算符用来判断对象是否属于某个类的实例","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java类的基本结构","slug":"Java类的基本结构","date":"2017-03-06T02:13:00.000Z","updated":"2019-10-19T00:10:08.841Z","comments":true,"path":"2017/03/06/Java类的基本结构/","link":"","permalink":"http://yoursite.com/2017/03/06/Java%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"面向对象的概念:什么是类?同时将具有相同特征的对象抽象成一种新的数据类型—-类(具有相同特征和行为的多个对象的集合) 封装的好处:一个类把属性算法(逻辑处理)封装起来,只留必要的方法(接口)让用户使用,一个类该暴露什么,不该暴露什么,由类的设计者更具需求设计决定的.private属性用户不能直接访问,如果设计者提供相应的接口方法,那么用户可以通过该接口方法访问.一个类,不直接修改属性而通过方法来修改,可以在方法里做相应的处理避免用户输入的一些非法数据而造成系统故障 什么是构造方法: 构造方法是与类同名的方法 没返回值，也不能写void 主要作用是完成新建对象的初始化工作 一般不能显式地直接调用，而是用new来调用（后面会存在使用this/super调用） 创建一个类的新对象的同时，系统自动调用该类的构造函数，为新建对象的初始化 构造方法重载: 构造方法是一种特殊的方法，它也能重载 构造函数的重载是指同一个类中存在着若干个具有不同参数列表的构造函数 this关键字:this用于表示当前对象自身的引用，可以用于访问被局部变量隐藏的成员变量，也可以将本对象作为参数传递给其他对象操作 类初始化代码块static:####static代码块的执行时机: 用Class.forName(类名)显式加载的时候（反射、JDBC时详细讲解） new或反射实例化一个类的对象时候 调用类的static方法的时候（后续详细讲解） 调用类的static变量的时候（后续详细讲解） 调用类的静态常量（后续详细讲解）的时候，是不会加载类的，即不会执行static{}语句块当访问类的静态常量时，如果编译器可以计算出常量的值，则不会加载类，否则会加载类 用Class.forName()形式的时候，也可以自己设定要不要加载类，如将Class.forName(&quot;Test&quot;)改为 Class.forName(&quot;Test&quot;,false,StaticBlockTest.class.getClassLoader())，你会发现Test没有被加载，static{}没有被执行","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java数组","slug":"Java数组","date":"2017-03-05T08:21:00.000Z","updated":"2019-10-19T00:10:13.302Z","comments":true,"path":"2017/03/05/Java数组/","link":"","permalink":"http://yoursite.com/2017/03/05/Java%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组: 数组是一组类型相同的数据的集合 数组可以存储多个数据,但类型必须相同 数组能作为数据的容器使用,把多个数据集中存储 存储在数组中的数据,都有相应的索引值,可以方便获取或修改 当需要同时保存多个类型相同的变量并进行处理时,可以考虑用数组数组的特性: Java的数组是引用类型， 数组与类、接口、枚举、注解并列，是引用类型中的一种， Java的数组长度一经确定不能改变； 数组在内存中是连续分配，所以读取速度快 实际应用中，常常无法确定变量的数量，后续我们将学习集合框架，实现可变长度的数据容器；数组的元素: 数组中存储的数据称为数组的元素(Element)， 数组本身是引用类型，但是数组中的元素可以是基本数也可以是引用类型， 也就是说，即可以有存储基本数据类型int的数组，也可以有存储引用类型String的数组，但是数组本身是引用类型 数组中的元素有索引值，索引值从0开始 也就是说，如果一个数组的长度是10，那么索引值就是0-9，也就是第一个元素的索引值是0，第二个的索引值是1，以此类准，通过索引值可以方便访问元素 数组的维数: 如果一个数组中存储数据结构如下所示，元素都是单个数据，称为一维数组，67 78 54 89 12 45 87 97 79 9 其中，67被称为第0个元素，78称为第1个元素…… 如果个数组中存储数据结构如下所示，元素是一维数组，称为二维数组，[67 78 54] [89 12] [45 87 79] [3] 数组声明:一维数组的声明:数组元素类型[] 变量名称 或数组元素类型 变量名称[]","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础","slug":"Java基础","date":"2017-03-05T05:43:00.000Z","updated":"2019-10-19T00:10:05.277Z","comments":true,"path":"2017/03/05/Java基础/","link":"","permalink":"http://yoursite.com/2017/03/05/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"为什么学习java:Java是Sun Microsystems于1995年推出的高级编程语言Java 领域的JavaSE、JavaEE技术已发展成为同C#和.NET平分天下的应用软件开发平台和技术 java语言的特点: 跨平台性;一处编写,处处运行. 面向对象(三大特征);封装.继承.多态. 健壮性;强类型机制,异常处理机制,自动垃圾回收机制 分布式; 多线程; 动态性; JVM(Java Virtual Machine)介绍:JVM称为java虚拟机;JVM可以理解为Java编译器和操作系统之间的虚拟处理器; 编译器编译的字节码只要JVM认识即可 JVM再将字节码解释成操作系统认识的机器码 只要需要运行Java程序的设备,都需要安装JVM JDK与JRE: JDK是Java开发工具包(Java Development Kit)的简称,是一个软件;如果要用Java语言编写程序,就必须在计算机上安装JDK; JRE是Java运行环境(Java Runtime Environment)的简称如果要在机器上运行Java程序,就必须要有JRE; JDK的一些常用工具: javac: 编译器,将源程序转为字节码; java: 运行编译后的java程序(.class后缀的); jar: 打包工具,将相关的类文件打包成一个文件; javadoc: 文档生成器,从源码注释中提取文档; Java项目结构:src目录：存放包和源文件JRE系统库目录：存放程序运行必须的系统库文件bin目录：存放可执行的字节码文件 注释:文本注释: 1234/*** version ycj* data 2017-03-05* / 标识符命名规则: 某一个区域中是唯一的，在不同的区域中可以使用同一名字 必须由字母、数字、下划线和$符号组成 不能以数字开头 不能使非法的字符，如：#，％……“&amp;等 不能使系统关键字 不能使空格来分隔 长度无限制 严格区分大小写 不同的标识符有一定的命名规矩，后续学习 成员变量和局部变量的区别:成员变量是作用于整个类,局部变量作用于某个方法,局部变量没有默认值,必须初始化,成员变量有默认值. 数据类型:数据类型分为基本数据类型和引用数据类型; 数据类型(8个基本数据类型):byte, short, int, long, float, double, boolean, char 引用数据类型:String, 数组, 接口, 类, 枚举, 包装类型String、StringBufferStringBuilder的区别: String类是不可变的，对象一旦被创建，就不能被修改；可以使用=直接赋值，此时使用常量池；也可以使用new创建，不使用常量池；StringBuffer是可变的，对象创建后，可以修改；必须使用new关键字；StringBuilder是不同步的，在单线程情况下使用比StringBuffer高效；必须使用new关键字； 堆,栈,常量池,方法区:基本数据类型保存在栈中,引用数据类型保存在堆中;堆:存放所有new出来的对象栈:存放基本类型的变量数据和对象的应用方法区:包含所有的class和static变量常量区:存放基本类型和字符串常量 运算符:从功能角度分，Java中的运算符可以分为算术、关系、位、逻辑运算符四类算术运算符:用来对操作数进行数学运算.关系运算符:又叫比较运算符,用来运算操作两个数的大小关系.位运算符:针对操作数的二进制位进行运算逻辑运算符:针对布尔值或返回值为布尔值的表达式进行运算","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"软件开发基础","slug":"软件开发基础","date":"2016-12-25T07:18:00.000Z","updated":"2019-10-19T00:09:53.064Z","comments":true,"path":"2016/12/25/软件开发基础/","link":"","permalink":"http://yoursite.com/2016/12/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"计算机工作的简单过程: 将程序和数据通关输入设备送入存储器(可以理解为内存) 计算机从存储器中取出程序指令送到控制器(可以理解为CPU) 控制器更具指令的含义发出相应的命令(如加法,减法),将存储单元中存放的操作数据取出送往运算器进行运算,再把运算结果送回存储器指定的单元中什么是软件: 软件=程序+文档 不同类型语言的编译与运行:==编译型==语言是先把源程序的每一条语句都编译成机器语言,并保存成二进制文件,运行时计算机可以直接以机器语言来运行此程序,速度较快;==解释型==语言在执行程序时才一条条的解释成机器语言给计算机来执行,所以运行速度会受到影响","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}]}