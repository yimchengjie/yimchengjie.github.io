{"meta":{"title":"ycjBlog","subtitle":null,"description":null,"author":"yanchengjie","url":"https://zhuyiting.xyz","root":"/"},"pages":[{"title":"书单","date":"2019-10-18T08:58:07.896Z","updated":"2019-10-18T08:58:07.896Z","comments":false,"path":"books/index.html","permalink":"https://zhuyiting.xyz/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-21T05:52:06.972Z","updated":"2019-10-21T05:52:06.972Z","comments":false,"path":"about/index.html","permalink":"https://zhuyiting.xyz/about/index.html","excerpt":"","text":"{ name: ‘yanchengjie’ age: 22, gender: ‘男’, profession: ‘programmer’, experience: ‘0年’, address: ‘浙江省杭州市’, education: ‘本科’, github: ‘https://github.com/yimchengjie&#39;, blog: ‘https://yimchengjie.github.io&#39;, email: ‘ycj996425271@live.com’, description: ‘小程序员的大厂梦’, skills: [ [‘Html’, ‘Javascript’, ‘jQuery’, ‘CSS’, ‘Vue’, ‘Node’], [‘Git’, ‘SVN’], [‘Java’,’MySql’], [‘Spring’, ‘MyBatis’, ‘SpringBoot’], [‘Redis’,’Dubbo’, ‘SpringCloud’] [‘Linux’,’Ubuntu’,’deepin’] ], devTools: [ [‘HBuilder X’, ‘Visual Studio Code’, ‘Notepad++’], [‘Chrome DevTools’ ], [‘Git’, ‘TortoiseSVN’], [‘InteliJ IDEA’,’Eclipse’], [‘Navicat’, ‘Postman’,’SSH’], ]} 博客主题来自: https://github.com/cofess/hexo-theme-pure"},{"title":"分类","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":false,"path":"categories/index.html","permalink":"https://zhuyiting.xyz/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-10-18T07:42:59.000Z","updated":"2019-10-18T07:42:59.817Z","comments":true,"path":"gallery/index.html","permalink":"https://zhuyiting.xyz/gallery/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":true,"path":"links/index.html","permalink":"https://zhuyiting.xyz/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"repository/index.html","permalink":"https://zhuyiting.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"tags/index.html","permalink":"https://zhuyiting.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"党的有关理论和习近平新时代中国特色社会主义思想","slug":"党的有关理论和习近平新时代中国特色社会主义思想","date":"2019-10-29T13:17:00.000Z","updated":"2019-11-15T05:11:22.909Z","comments":true,"path":"2019/10/29/党的有关理论和习近平新时代中国特色社会主义思想/","link":"","permalink":"https://zhuyiting.xyz/2019/10/29/%E5%85%9A%E7%9A%84%E6%9C%89%E5%85%B3%E7%90%86%E8%AE%BA%E5%92%8C%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3/","excerpt":"","text":"党的有关理论知识端正入党动机1. 正确入党动机的内涵正确的入党动机,指争取入党的内在原因是忠诚地信仰共产主义,把最终实现共产主义社会制度作为自己的最高理想,决心为了壮丽的共产主义事业奋斗终生,全心全意的为人民服务,并随时准备为党和人民的利益牺牲一切.入党,意味着要比群众多吃亏,争取入党就是要为党和人民的利益不怕吃亏.入党,意味着比群众多挑重担,多做贡献.入党,意味着比群众多做牺牲,争取入党就要有革命的自我牺牲精神. 2. 怎样端正入党动机?主要以下三个方面的内容:第一,要有为共产主义和中国特色社会主义奋斗终身的坚定信念.第二,要有全心全意为人民服务的思想.第三,要有在生产,工作,学习和社会生活中起先锋模范作用的觉悟. 党的基本理论知识1. 中国共产党性质:中国共产党是中国工人阶级的先锋队,同时是中国人民和中华民族的先锋队,是中国特色社会主义失业的领导核心,代表中国先进生产力的发展要求,代表中国先进文化的前进方向,代表中国最广大人民的根本利益. 2. 党的行动指南:是以马克思列宁主义,毛泽东思想,邓小平理论和”三个代表”重要思想作为自己的行动指南 3. 党的最高理想和最终目标:实现共产主义 4. 党的基本路线:领导和团结全国各族人民,以经济建设为中心,坚持四项基本原则,坚持改革开放,自力更生,艰苦创业,为把我国建设成为富强,民主,文明,和谐的社会主义现代化国家而奋斗. 5. 党的外交政策:坚持独立自主的和平外交政策,维护我国的独立和主权,反对霸权主义和强权政治,维护世界和平,促进人类进步. 6. 党的四项基本原则坚持社会主义道路,坚持人民民主专政,坚持中国共产党的领导,坚持马克思列宁主义毛泽东思想 7. 党的建设必须坚决实现的四项基本要求(1)坚持党的基本路线,(2)坚持解放思想,实事求是,与时俱进,(3)坚持全心全意为人民服务,(4)坚持民主集中制 8. 党的工作路线:一切为了群众,一切依靠群众,从群众中来,到群众中去,把党的正确主张变为群众的自觉行动 9. 党的最大优势:密切联系群众 10. 党执政后的最大危险:脱离群众 11. 党员享有的八项权利:(1)参加党的有关会议,阅读党的有关文件,接收党的教育和培训(2)在党的会议上和党报党刊上,参加关于党的政策问题的讨论(3)对党的工作提出建议和倡议(4)在党的会议上有根据的批评党的任何组织和任何党员,向党员负责的揭发,检举党的任何组织和任何党员违法乱纪的事实,要求处分违法乱纪的党员,要求罢免或撤换不称职的干部.(5)行使表决权,选举权,有被选举权(6)在党组织讨论决定对党员的党纪处分或作出鉴定时,本人有权参加和进行申辩,其他党员可以为他作证和辩护(7)对党的决议和政策如有不同意见,在坚决执行的前提下,可以声明保留,并且可以把自己的意见向党的上级组织直至中央提出(8)向党的上级组织直至中央给以负责的答复 12. 党员履行的八项义务:(1)认真学习马克思列宁主义,毛泽东思想,邓小平理论和”三个代表”重要思想,学习党的路线,方针,政策及决议,学习党的基本知识,学习科学,文化和业务知识,努力提高为人民服务的本领(2)贯彻执行党的基本路线和方针,政策,带头参加改革开放和社会主义现代化建设,带动群众为经济发展和社会进步艰苦奋斗,在生产,工作,学习和社会生活中起先锋模范左右(3)坚持党和人民的利益高于一切,个人利益服从党和人民的利益,吃苦在前,享受在后,克己奉公,多做贡献(4)自觉遵守党的纪律,模范遵守国家的法律法规,严格保守党和国家的秘密,执行党的决定,服从组织分配,积极完成党的任务.(5)维护党的团结和统一,对党忠诚老实,言行一致,坚决反对一切派别组织和小集团活动,反对阳奉阴违的两面派行为和一切阴谋诡计(6)切实开展批评和自我批评,勇于揭露和纠正工作中的缺点,错误,坚决痛消极腐败现象做斗争(7)密切联系群众,向群众宣传党的主张,即时同群众商量,即时向党反应群众的一件和要求,维护群众的正当利益(8)发扬社会主义新风尚,提倡共产主义道德,为了保护国家和人民的利益,在一切困难和危险的时刻挺身而出,英勇斗阵,不怕牺牲. 13. 预备党员的权利:除了没有表决权,选举权和被选举权,其他和正式党员一样 14. 党员的党龄:从预备期满转为正式党员之日算起.党员如果没有正当理由连续六个月不参加党的组织生活,或不缴纳党费,或不做党所分配的工作,就认为是自行脱党 15. 党的民主集中制的基本原则是:党员个人服从党的组织,少数服从多数,下级组织服从上级组织,全党各个组织和全体党员服从党的全国代表大会和中央委员会. 16. 党的纪律处分有五种:警告,严重警告,撤销党内职务,留党察看,开除党籍 17. 党的五个作风:思想作风,工作作风,领导作风,学风,干部生活作风 18. 两个务必:(1)务必继续地保持谦虚,谨慎,不骄,不躁的作风(2)务必继续保持艰苦奋斗的作风 19. 四个人格形象:诚实守信的人格形象,公道正派的人格形象,清正廉洁的人格形象,敬业奉献的人格形象. 20. 四个高度认同:对祖国的高度认同,对中华民族的高度认同,对中华文化的高度认同,对中国社会主义的高度认同. 21. 四大纪律:政治纪律,组织纪律,经济工作纪律,群众工作纪律. 22. 五种精神解放思想,实事求是;紧跟时代,勇于创新;艰苦奋斗,务求实效;知难而进,一往无前;淡泊名利,无私奉献. 23. 八个坚持,八个反对(1)坚持解放思想,实事求是,反对因循守旧,不思进取;(2)坚持理论联系实际,反对照抄照搬、本本主义;(3)坚持密切联系群众，反对形式主义、官僚主义;(4)坚持民主集中制，反对独断专行、软弱涣散;(5)坚持党的纪律，反对自由主义;(6)坚持艰苦奋斗，反对享乐主义;(7)坚持清正廉洁，反对以权谋私;(8)坚持任人唯贤，反对用人上的不正之风. 24. 八项要求(1)要同党中央保持高度一致，不阳奉阴违、自行其是;(2)要遵守民主集中制，不独断专行、软弱放任;(3)要依法行使权力，不滥用职权、玩忽职守;(4)要廉洁奉公，不接受任何影响公正执行公务的利益;(5)要管好配偶、子女和身边工作人员，不允许他们利用本人的影响谋取私利;(6)要公道正派用人，不任人唯亲、营私舞弊;(7)要艰苦奋斗，不奢侈浪费、贪图享受;(8)要务实为民，不弄虚作假、与民争利. 25. 科学发展观的具体内容包括:第一要义是发展,核心是以人为本,基本要求是全面协调可持续,根本方法是统筹兼顾. 发展党员的程序和手续（1）要求入党的人自愿向党组织提出入党申请；（2）党组织接到申请入党人的申请书后，应及时研究能否列为入党积极分子；（3）申请入党人被列为入党积极分子后，党组织即应落实对其培养教育和考察的措施；（4）入党积极分之经一年以上的培养教育和考察后，党组织要研究能否确定为发展对象；（5）入党积极分子被确定为发展对象后，党组织要对其进行政治审查；（6）党组织在进行政治审查的同时，要征求党内外群众对发展对象的意见；（7）党组织在接受发展对象入党前，要对其进行入党前期短期集中培训；（8）做完上述工作后，支部委员会要将发展对象的入党材料报上级党组织预审；（9）经上级党组织预审同意后，支部委员会应通知发展对象确定两名正式党员作入党介绍人；（10）入党介绍人或支部领导成员指导发展对象填写《入党志愿书》；（11）支部委员会对《入党志愿书》进行审查，认为合格后，即可召开支部大会讨论，作出决议，并报上级党组织审批；（12）上级党组织在批准申请人入党前要派人同他谈话，作进一步的了解；（13）上级党组织召开委员会，在听取谈话人的汇报和组织部门的意见后，集体讨论审批（14）被批准入党的预备党员接受党组织一年预备期的教育和考察；（15）预备党员在预备期内要面向党旗进行入党宣誓；（16）预备党员预备期满，主动向党组织提出转为正式党员的申请，党组织要及时讨论其能否转为正式党员。 习近平新时代中国特色社会主义思想八个明确第一，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国； 第二，明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕； 第三，明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信； 第四，明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化； 第五，明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家； 第六，明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队； 第七，明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体； 第八，明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。 十四个坚持第一条，坚持党对一切工作的领导； 第二条，坚持以人民为中心； 第三条，坚持全面深化改革； 第四条，坚持新发展理念； 第五条，坚持人民当家作主； 第六条，坚持全面依法治国； 第七条，坚持社会主义核心价值体系； 第八条，坚持在发展中保障和改善民生； 第九条，坚持人与自然和谐共生； 第十条，坚持总体国家安全观； 第十一条，坚持党对人民军队的绝对领导； 第十二条，坚持“一国两制”和推进祖国统一； 第十三条，坚持推动构建人类命运共同体； 第十四条，坚持全面从严治党。","categories":[{"name":"生活","slug":"生活","permalink":"https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"备忘录","slug":"备忘录","permalink":"https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"}]},{"title":"论市场化改革","slug":"论市场化改革","date":"2019-10-24T12:42:13.000Z","updated":"2019-10-29T02:32:58.652Z","comments":true,"path":"2019/10/24/论市场化改革/","link":"","permalink":"https://zhuyiting.xyz/2019/10/24/%E8%AE%BA%E5%B8%82%E5%9C%BA%E5%8C%96%E6%94%B9%E9%9D%A9/","excerpt":"","text":"当前的市场化改革是否有助于挽救我国经济下滑趋势? 应该怎么样抓住市场化改革带来的巨大机遇?最近，全球掀起了一阵降息潮，全球的经济环境普遍不太理想，全球正在经历一轮新的经济周期调整。以10年为周期的金融危机再一次来临。中美的贸易摩擦对于中国金融市场的影响冲击也是巨大的，人民币一度破7，持续的贬值导致国内资金外逃，也导致了人民币国际化的步伐放缓。1.[为什么经济不理想的时候要加息?加息为什么可以调整经济]因为经济不理想(经济衰退)是市场投资不足(市场中流动的钱少了,都存银行了),政府为了刺激市场,减少银行利息,这样本来钱存在银行的一部分人就会因为收益少了,把钱投向市场中(股票或者消费),都会促进市场健康发展,使经济复苏2.[为什么人民币破7会导致国内资金外逃,人民币破7由什么导致,为什么人民币破7会阻碍人民币国际化?]因为人民币破7是1美元兑换7块多人民币,而国际上以美元为主,本来6块多可以买到的东西,现在要多花钱才能买到,这样中国人不愿意买国外的东西(进口不利,因为变贵了).但是相反,中国更愿意卖东西了(出口有利).然后来自国外的资金,会因为人民币不值钱了(能换到的美元变少了)而减少对国内的投资(资本外逃).人民币的贬值是由于美元强势造成的(美国降息,资本都进入市场,经济强势) 2019年来，中国的经济形式总体仍延续着2018年的情况，我国经济增速下滑已是事实。由政府主导的央企在2000年后改革缓慢，各大原材料行业都亏损很大，产业的利润下滑非常严重，产能过剩，中国的供需关系面临着很大的结构性失衡，总体上低端产品产能过剩，高端产品产能不足。其次，我国低附加值、高功耗、高污染的产业比重很大；区域人口分布不合理，城镇化率低，导致发展不平衡；随着人口、土地、环境等这些红利慢慢的消失，人工成本的上涨，土地价格的升高，环境的恶化，导致中低端产业较多；我国经济的增长过多的依靠”三驾马车“，我国城乡收入差距大，行业收入差距大，居民贫富差距大。这些问题就会束缚经济的发展。1.[为什么会导致中低端产业较多]因为红利的消失会导致企业成本的增加,产品价格上涨,高端产品竞争力变弱(比如国产车和进口车一个价格, 选择国产车的人大大减少)2.[三驾马车是什么]三驾马车是投资,消费,进口; 三驾马车是用来计算GDP的三部分,是经济发展的结果,不是根本动力. 根本动力是靠企业靠市场自我的健康发展. 当前的市场化改革，正式由习近平提出的供给侧结构性改革，供给侧结构性改革，就是从提高供给质量出发，用改革的办法推进结构调整，矫正要素配置扭曲，扩大有效供给，提高供给结构对需求变化的适应性和灵活性，提高全要素生产率，更好满足广大人民群众的需要，促进经济社会持续健康发展。1.[解释一下供给侧结构性改革]供给侧结构性改革就是强调供给方(也就是企业),能够制造出物美价廉的商品,怎么改呢呢? 通过改革,减少税收,降低土地价格,给予政策福利支持等 强调供给侧改革，从生产、供给入手，调整供应结构，才能使经济健康稳固发展。提升居民消费以及当前的供给侧改革并不能完全改变经济下滑趋势，还必须打通供给以及需求，这一层中间地带，一是政府对企业的税收以及居民的社保缴费高，让企业无法生产，市场需求低。二是垄断性国企占有太多的社会资源而效率又太低，靠价格垄断生存，抬高了整个市场的生产成本，比如油价，房价。1.[为什么中间地带很重要]中间地带是商品产出到消费者买入之间的地带,是企业或者消费者,在商品之外承担的费用,比如企业的税,居民的五险一金. 企业会把这些费用加到商品的价格上或者自己承担损失, 居民手上钱少, 消费降低, 都不利于经济健康发展 供给侧结构性改革自2015年提出以后，其主要任务也在不断变化。最初的“三去一降一补”，通过关、停、并、转等方式去掉多余产能，稳定房价去房地产库存，去杠杆减少政府债务，降低企业各项成本，补充生态建设、完善产业链。1.[三去一降一补]去产能,去库存,去债务,降成本,补生态产业链 当前不仅需要优化供给，提高内需，还要解决供给与需求的中间地带，做好减税降费，优化市场生态。供给侧结构性改革是利好于我国经济发展的，在贸易战加剧，逆全球化回溯的国际背景下，我国的供给侧结构性改革要结合一带一路，深化与沿线国家的合作，强化和欧洲，拉美地区国家的科技合作，扩大开放，将中国制造带出国。 我国要吸取日本经济发展的教训，20世纪后期，日本大力发展建设，逐渐陷入了失控的建设狂奔，建设业创造了庞大的就业机会，并非来自于真正的经济增长，而是人为制造出的就业机会。这大大削弱并延缓了日本高技术产业的发展，但这种失控的建设无法停止，因为一旦停止公共建设，就会出现大量失业。更严重的是，公共建设积累的巨大负债让日本难堪重负。日本的房价泡沫也重创了日本实体工业的发展，泡沫的破灭导致了大量企业倒闭，失业率狂升。当下的日本，也还没有完全走出当年的阴影。日本经济衰退的20年，主要原因就是日本政府对经济把控出现了失误，制定了违背经济规律的政策。1.[为什么这会阻碍日本高科技产业发展?]因为大量的人口资金投入到了基础建设业,相应的高科技产业就会没钱没人2.[房价的泡沫破裂为什么影响这么大?]房价泡沫破灭, 高价买地的开发商,会破产,很多大企业也会因为投资房地产而大出血,这会让市场严重下跌,这样所有人手上的资产都贬值了,同时企业大量倒闭,失业率也会大大提高,已经买房的人失业后也还要承担巨额贷款.整个国家的经济都会受损,日本房价泡沫当时特别高,政府为了防止泡沫更高影响更恶劣,采取了主动刺破的措施.单也还是经济大衰退我国可以从日本的经济发展的教训中收益到：房地产不能长久作为支柱产业，必须防止货币超发和过度升值，在宏观调控上，政府不能过于频繁也不能过紧过松，政策引导着眼长远，统筹兼顾。面对经济寒冬，我们个人也需要重视，不要觉得离我们很遥远，面对危机，我们要留好资金，节约开销，努力工作，提升个人能力。我国的市场化改革也会带来巨大的机遇，站在风口上，猪都会飞。乱世出英雄，变革带来的巨大机遇可能产生意想不到的风云人物，不过代价也是巨大的，在改革中，抓住机会很重要，不过我们需要做好充足的准备，机会总是留给有准备的人。能力上的准备，思想上的准备，以及恰到好处的机会。在危机来临初期持有货币，在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了，但这其中随便哪一步出错，都会损失惨重，即使每一个环节都准确无误，也可能因为突如其来的不可抗力，导致整个投资计划的泡汤。比如限购限售，比如失业，比如投资企业破产。在危机时期，不要轻易触碰杠杆加大交易规模，其次要勤于学习，要对未来的风险做准备。1.[为什么在危机崩溃期买入资产，在政体调控收缩货币时期再次抛售就能获利了?]通俗点说就是在商品最便宜的时候买进。接下来商品会因为市场规律或者政府调控回升。但是政府为了控制物价（控制通货膨胀），会加息，钱流进银行，商品需求变小。在政府调控的时候，可以看成物价比较理想（高）的时候。这时候卖出。获利就很客观（差价最大的时候）2.[为什么不要触碰杠杆]触碰杠杆可以理解为贷款,因为在经济危机时期,银行出于安全考虑不可能把大量的钱借给你, 所以只能贷到很少的钱,而钱越少,承受意外的能力越低,而且贷款需要抵押,(房子或者股票,在危机时期看不到底,随时会被银行卖掉,因为银行不可能等你房子不值钱了再卖,那就失去了抵押的意义),而银行低价卖出也会导致市场供大于求,进一步下跌. 而你通过贷款买入的资产也可能会进一步下跌.很容易破产在宏观经济下滑的趋势下，要合理分配资产，综合来看2019年上半年的投资者大多以黄金、比特币为代表的避险资产，这些产品或者说是资产的价格也一直在上高，在国际范围中，各大央行实行降息政策，促进经济发展的前提下，黄金和比特币的抗通胀能力就展现出来了。但千万不能在不了解的情况下，进行投资。1.[为什么黄金,比特币是避险资产?]因为他们都有共同属性,价值不受政府调控影响(因为总量固定,且没法造假).这样不管经济怎么样,黄金比特币本来能换多少米还是能换多少米.举例:比如一块黄金本来换一代米,一百块也能换一袋米,但是经济变化,一百块只能买半袋米了,但是一快黄金还是能买一袋米.2.[为什么不了解不能投资呢]正式因为他们总量固定 ,他们会被资本炒作,比如大量买入造成供不应求,价格高了以后再高价卖出, 不了解就很可能成了韭菜,承担了这部分人造差价改革初期，商品紧缺，供不应求，是暴利的时代，后来，电子商务兴起以及产能过剩，商家开启价格战，于是进入了薄利时期，而当前，我国正在转变，产品开始个性化、定制化、高端化，提高增值空间，从而进入厚利时代。2019年下半年，各大二线城市的抢人大战也已经偃旗息鼓，但一线新一线仍然对人才有着很高的需求。这意味着，宏观上的城市化进程将会放缓，大城市的自我迭代会深度展开。其次我国股市长期以来以房地产与科技相关的驱动，目前的房价以稳为主，投资的机会在科技类企业。1.[为什么二线城市不抢人了?]因为人才需要高薪,需要好的企业,而好的企业需要政策扶持,它才愿意来,二线城市没有这样的实力,相反,一线城市企业多,对于人才的需求也大,大城市的建设需要人才.2.[为什么说投资机会在科技类企业]因为国家需要发展科技类企业来促进产业升级,政策的支持以及资金的流入,就会让科技类企业更健康的发展在我国市场化改革的背景下，勤于学习，不多弥补知识盲区，扩充个人知识领域，才能知道更多有用的信息，见多识广的人，更能规避风险，才有更大的机会抓住机遇。","categories":[{"name":"生活","slug":"生活","permalink":"https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"备忘录","slug":"备忘录","permalink":"https://zhuyiting.xyz/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"}]},{"title":"TED不念过往,不惧将来","slug":"TED不念过往,不惧将来","date":"2019-10-24T02:16:00.000Z","updated":"2019-10-24T14:19:31.012Z","comments":true,"path":"2019/10/24/TED不念过往,不惧将来/","link":"","permalink":"https://zhuyiting.xyz/2019/10/24/TED%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80,%E4%B8%8D%E6%83%A7%E5%B0%86%E6%9D%A5/","excerpt":"","text":"“These are the times” said Thomas Paine,”that try men’s souls.”“这些时间考验着人们的灵魂”Thomas Paine说.And they’re trying ours now.现在它们在考验我们.This is a fateful moment in the history of the West.这是一个西方历史的命运时刻.We’ve seen divisive elections and divided societies.我们看到了分裂的选举和分裂的社会.We’ve seen a growth of extremism in politics and religion,我们看到了一群极端分子在政治上和宗教上,all of it fueled by anxiety,uncertainty and fear,所有的这些都是被焦虑,不确定和害怕所推动,of a world that’s changing almost faster than we can bear,因为世界几乎在以比我们能够承受的更快的速度在改变,and the sure knowledge that it’s going to change faster still.并且都知道它未来还会改变的这么快I have a friend in Washington.我有一个朋友在WashingtonI asked him,what was it like being in America during the recent presidential election?我问他,在最近的总统选举期间待在美国像是什么?He said to me,”Well,it was like the man sitting on the deck of the Titanic with a glass of whiskey in his hand and he’s saying,’I know I asked for ice–,but this is ridiculous.’”他告诉我,”哇,它就像一个人坐在泰坦尼克的甲板上,手里拿着威士忌说’我知道我要了冰,但这太疯狂了’”So is there something we can do,each of us,to be able to face the future without fear?所以有没有一些事我们每个人都可以做的,可以让我们能够对未来不感到恐惧?I think there is.我觉得是有的.And one way into it is to see that perhaps the most simple way into a culture and into an age is to ask: What do people worship? 有一个方法 也许是最简单的方法 进入一个文化进入一个时代去问:人们崇拜什么?People have worshipped so many different things–the sun,the stars,the storm.人们过去崇拜很多不同的是–太阳,星型,风暴.Some people worship many gods, some one,some none.有些人崇拜很多神,有些人崇拜一个,有些人没有In the 19th and 20th centuries,people worshipped the nation,the Aryan race,the communist state.在19到20世纪,人们崇拜国家,崇拜Aryan种族,崇拜共产主义.What do we worship?那我们崇拜什么呢?I think future anthropologists will take a look at the books we read on self-help,self-realization,self-esteem.我觉得未来的人类学家会看看到我们读过的书,关于自我帮助,自我认识,自我尊重,They’ll look at the way we talk about morality as being true to oneself, the way we talk about politics as a matter of individual rights,他们会看我们谈论道德的行为当成对自己的正确,我们谈论政治的行为当成个人权利的问题.and they’ll look at this wonderful new religious ritual we have created.并且他们会看看这些很棒的我们创造的宗教利益 You know the one?你知道那是什么嘛?Called the “selfie”.我们成为”自拍”.And I think they’ll conclude that what we worship in our time is the self,the me,the I.并且我觉得他们会得出结论 那就是我们在那时候崇拜的就是自我,是我And this is great.这是很棒的It’s liberating.这是自由的It’s empowering.这是有权利的.It’s wonderful.这是极好的.But don’t forget that biologically,但是不要在生物上忘了we’re social animals.我们是社交动物We’ve spent most of our evolutionary history in small groups.我们进化历史中的很多时间都花在小小的群体中We need those face-to-face interactions,where we learn the choreography of altruism and where we create those spiritual goods like friendship and trust and loyalty and love that redeem our solitude.我们需要面对面的交流,来学习利他主义并且创造精神上的就像友谊,信任,忠诚和爱的东西以此救赎我们的孤独.When we have too much of the “I” and too little of the “we”,当我们过于关注我的, 很少关注我们时,we can find ourselves vulnerable,fearful and alone.我们会发现有多点的,会恐惧的并且孤独的自己.It was no accident that Sherry Turkle of MIT called the book she wrote on the impact of social media “Alone together”.MIT的Sherry Turkle把他写的关于社交媒体的影响命名为”一起孤单”不是一个意外.So I think the simplest way of safeguarding the future “you” is to strengthen the future “us” in three dimensions:所以我认为,最简单的保障未来的”你”的方法就是从三个方面来加深未来的”我们”the us of relationship,the us of identity and the us of responsibility.我们的关系,我们的身份和我们的责任So let me first take the us of relationship.所以,首先让我谈谈我们的关系.And here, forgive me if I get personal.在这里,原谅我如果我谈自己的事.Once upon a time,a very long time age,I was a 20-year-old undergraduate studying philosophy.从前,很长一段时间之前,我是20岁的大学生在学习哲学.I was into Nietzsche and Schopenhauer and Sartre and Camus.我沉迷于Nietzsche,Schopenhauer,Sartre和CamusI was full of ontological uncertainty and existential angst.我充满了本体论的不确定性和存在的焦虑It was terrific.那是极好的.I was self-obsessed and thoroughly unpleasant to know,我是自恋的并且感到非常厌恶,until one day I saw, across the courtyard, a girl who was everything that I wasn’t.直到有一天我看到,穿过这院子,一个女孩一切都和我不一样.She radiated sunshine.她散发着阳光.She emanated joy.她散发着快乐.I found out her name was Elaine.我找到她的名字是Elaine.We met,We talked,We married.我们见面,我们聊天,我们结婚.And 47 years,three children and eight grandchildren later,47年 有了3个小孩,8个孙子 以后I can safely say it was the best decision I ever took in my life,我可以说,那是我生命中做的最好的决定.because it’s the people not like us that make us grow.因为和我们不一样的人会让我们成长.And that is why I thik we have to do just that.这就是为什么我认为我们必须这样做.The trouble with Google filters,Facebook friends and reading the news by narrowcasting rather than broadcasting means that we’re surrounded almost entirely by people like us whose views,whose opinions,whose prejudices,even, are just like ours.谷歌过滤,脸书朋友圈以及阅读新闻通过很窄的渠道而不是广播这些麻烦意味着我们几乎完全被那些观点,想法,甚至成见和我们的一样的人包围着.And Cass Sunstein of Harvard has shown that if we surround ourselves with people with the same views as us,we get more extreme.哈弗的Cass Sunstein展示了如果我们被那些观点和我们一样的自己人包围,我们会变得极端I think we need to renew those face-to-face encounters with the people not like us.我认为我们需要重新和那些跟我们不一样的人面对面的接触.I think we need to do that in order to realize that we can disagree strongly and yet still stay friends.我认为我们需要这样做,为了我们能意识到强烈地争执也仍然可以当朋友.It’s in those face-to-face encounters that we discover that the people not like us are just people like us.在面对面的接触中我们发现那些和我们不同的人就是和我们一样的人And actually, every time we hold out the hand of friendship to somebody not like us,whose class or creed or color are different from ours,事实上,每一次,我们向那些和我们有不一样种族或者不一样信条或者不一样的肤色的人伸出友谊的手,we heal one of the fractures of our wounded world.我们治愈了我们破裂世界的一刀伤痕.That is the us of relationship.这就是我们的关系.Second is the us of identity.第二点是我们的身份.Let me give you a thought experiment.让我给你做个思维实验.Have you been to Washington?你去过Washington嘛?Have tou seen the memorials?你看过纪念碑嘛?Absolutely fascinating.绝对让人神魂颠倒.There’s the Lincoln Memorial:Gettysburg Address on one side,Second Inaugural on the other.在林肯纪念碑,一边是Gettysburg演说,另一边是Inaugural.You go to the Jefferson Memorial,screeds of text.你去Jefferson纪念碑,有一段话.Martin Luther King Memorial,more than a dozen quotes from his speeches.马丁路德金纪念碑,超过12条他演讲的引用.I didn’t realize,in America you read memorials.我不认为,你在美国会读这些纪念碑.Now go to the equivalent in London in Parliament Square and you will see that the monument to David Lloyd George contains three words:David Lloyd George.现在 一样去了伦敦的国会广场并且你会看到David Lloyd George的纪念碑上包含了三个单词:David Lloyd George.Nelson Mandela gets two.Nelson Mandela有两个Churchill gets just one:Chuichill.Churchill只有一个:ChuichillWhy the difference?为什么会有这样的差异呢I’ll tell you why the difference.我来告诉你们为什么会有这样的差异.Because America was from the outset a nation of wave after wave of immigrants,因为美国是一个从一波又一波的移民开始的国家so it had to create an identity which it did by telling a story which you learned at school, you read on memorials and you heard repeated in presidential inaugural addresses.因此,它必须创造一个形象,那个形象可以通过你学校学到的故事,你在纪念碑上读到东西和你反复在总统开幕演讲中听到的故事来讲的.Britain until recently wasn’t a nation of immigrants,不列颠直到最近也不是一个移民国家,so it could take identity for granted.所以它可以认为形象是理所当然的.The trouble is now that two tings have happened which shouldn’t have happened together.麻烦的是现在两件不应该同时发生的事发生了.The first thing is in the West we’ve stopped telling this story of who we are and why,even in America第一件事是在西方,我们停止讲述我是谁还有为什么的故事了,甚至是美国And at the same time,immigration is higher than it’s ever been before.同时,移民人口变得比以前更高了.So when you tell a story and your identity is strong,you can welcome the stranger,因此,当你们讲述一个故事并且你们形象很强的时候,你们能欢迎那些陌生人but when you stop telling the story,your identity gets weak and you fell threatened by the stranger.但是,当你们停止讲述故事,你们的形象变弱了,并且你们感到了陌生人的威胁And that’s bad.那就糟了I tell you,Jews have been scattered and dispersed and exiled for 2000 years.我告诉你们,犹太人已经被分开,被分散并且被流亡了2000多年.We never lost our identity.我们从来没有失去我们的形象.Why?Because at least once a year,on the festival of Passover,为什么? 因为么每年至少一次,在Passover节we told our story and we taught it to our children and we ate the unleavened bread of affliction and tasted the bitter herbs of slavery.我们谈论我们的故事并且我们教它给我们的孩子,并且我们吃过还没发酵的苦的面包并且吃过奴隶制的苦.So we never lost our identity.所以我们从来没有丢失我们的形象.I think collectively we’ve got to get back to telling our story,who we are,where we came from,what ideals by which we live.我认为共同的,我们必须回到的我们的故事上来说,我们是谁,我们来自哪里,我们生活的理想是什么And if that happens,we will become strong enough to welcome the stranger and say,如果发生这样的事,我们会变得强壮的足够欢迎陌生人并且说“Come and share our lives,share our stories,share our aspirations and dreams.”“过来并且分享我们的生活,分享我们的故事,分享我们的愿望和梦想”.That is the us of identity.这就是我们的形象.And finally,the us of responsibility.最后,是我们的责任.Do you know something?你知道嘛?My favorite phrase in all of politics,very American phrase,is:”We the people.”我最喜欢的一句话在所有的政治言论中,一句非常美国的话,就是”我们人”Why “we the people?”为什么是”我们人”?Because it says that we all share collective responsibility for our collective future.因为它表达了我们分享所有集体的责任为了我们集体的未来.And that’s how things really are and should be.并且那就是应该有的样子Have you noticed how magical thinking has taken over our politics?你有没有注意到多少神奇的思想占据着我们的政治?So we say, all you’ve got to do is elect this strong leader and he or she will solve all our problems for us.因此我们说,我们都要去选一个强力的领导并且他会为我们解决我们的问题.Believe me, that is magical thinking.相信我,那是幻想.And then we get the extremes:the far right,the far left,the extreme religious and extreme anti-religious,当我们变得极端以后:极右,极左,极端宗教注意或者极端反宗教,the far right dreaming of a golden age that never was,极端的右派梦想着一个从未有过的黄金时代,the far left dreaming of a utopia that never will be,极端的左派梦想着一个从未出现过的乌托邦,and the religious and anti-religious equally convinced that all it takes id God or the absence of God to save us from ourselves.宗教和反宗教同意相信上帝或者没有上帝来拯救我们.That,too,is magical thinking,这是非常神奇的想法.because the only people who will save us from ourselves is we the people,all of us together.因为可以拯救我们只有我们自己,所有的我们一起.And when we do that,and when we move from the politics of me to the politics of all of us together,并且当我们去做,当我们从我的政治中到所有的我们的政治中we rediscover those beautiful,counterintuitive truths:我们重新发现了那些美丽的,与直觉相反的事实:that a nation is strong when it cares for the weak,当一个国家关注弱者的时候它是强大的,that it becomes rich when it cares for the poor,当一个国家关心穷人的时候它是富裕的,it becomes invulnerable when it cares about the vulnerable.当一个国家开始关心那些有弱点的人的时候,它是无懈可击的.That is what makes great nations.这就是伟大的国家的形成.So here is my simple suggestion.因此,这有一个我的简单简易It might just change your life,它也许可以改变你的生活,and it might just help to begin to change the world.它也许可以帮助开始改变这个世界Do a search and replace operation one the text of your mind,做一个搜索和替换操作,一是你心中的文字,and wherever you encounter the word “self”, substitute the word “other”.并且无论在哪你遇到了单词”自己”,替换成单词”其他人”So instead of self-help,other-help;替代”自我帮助”为”他人帮助”instead of self-esteem,other-esteem.替代”自我尊重”为”他人尊重”And if you do that,you will begin to fell the power of what for me is one of the most moving sentences in all of religious literature.如果你这么做,你会开始感受到力量,这力量对我来说就是所有宗教文学中最动人的句子之一“Though I walk through the valley of the shadow of death,I will fear no evil,for you are with me.”虽然我在死亡的阴影的深渊里走,但是我不会害怕邪恶,因为你和我在一起We can face any future without fear so long as we know we will not face it alone.我们能够不害怕面对任何我们知道的我们不能独自面对的未来So for the sake of the future “you”,together let us strengthen the future “us”.为了未来的”你”,让我们一起加固未来的”我们” Thank you.","categories":[{"name":"英语","slug":"英语","permalink":"https://zhuyiting.xyz/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"TED","slug":"TED","permalink":"https://zhuyiting.xyz/tags/TED/"}]},{"title":"延期年金现值的计算","slug":"延期年金现值的计算","date":"2019-10-18T01:56:00.000Z","updated":"2019-10-29T02:32:30.230Z","comments":true,"path":"2019/10/18/延期年金现值的计算/","link":"","permalink":"https://zhuyiting.xyz/2019/10/18/%E5%BB%B6%E6%9C%9F%E5%B9%B4%E9%87%91%E7%8E%B0%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"","text":"延期年金==延期年金==又称递延年金,是指在最初若干期没有收付款项的情况下,后面若干期有等额的系列收付款项的年金.==延期年金现值计算==假定最初又m期没有收付款项,后面n期每年有等额的系列收付款项,则此延期年金的现值即为后n期年金先折现至n期期初(m期期末),再折现至第一期期初的现值. ==年金==是指定期定额的收付款项 ==现值==成本或收益的价值以今天的现金来计量时,称为现值 ==终值==是指现在某一时点上的一定量现金折合到未来的价值 延期年金的==终值==大小和延期数m无关所以延期m期之后的n期年金终值为$ F=A\\frac{(1+i)^n-1}{i} $ 普通年金的==现值==计算$ P=A\\frac{1-\\frac{1}{(1+i)^n}}{i}$ ==延期年金==的现值计算延期年金的现值与延期数m相关,m越长,现值越低. 方法一:先当成n期普通年金,求出现值P1,在将P作为第m期终值,再折现到第一期的现值P2$P1=A\\frac{1-\\frac{1}{(1+i)^n}}{i}$$P2=P1\\frac{1-\\frac{1}{(1+i)^m}}{i} $ 方法二:先计算m+n期现值,再减去m期年金现值$P=A(\\frac{1-\\frac{1}{(1+i)^m(1+i)^n}}{i}-\\frac{1-\\frac{1}{(1+i)^m}}{i}) $","categories":[{"name":"生活","slug":"生活","permalink":"https://zhuyiting.xyz/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活技巧","slug":"生活技巧","permalink":"https://zhuyiting.xyz/tags/%E7%94%9F%E6%B4%BB%E6%8A%80%E5%B7%A7/"}]},{"title":"JVM指令手册","slug":"JVM指令手册","date":"2019-07-30T07:18:00.000Z","updated":"2019-11-15T04:54:09.433Z","comments":true,"path":"2019/07/30/JVM指令手册/","link":"","permalink":"https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/","excerpt":"","text":"栈和局部变量操作将常量压入栈的指令aconst_null 将null对象引用压入栈iconst_m1 将int类型常量-1压入栈iconst_0 将int类型常量0压入栈iconst_1 将int类型常量1压入栈iconst_2 将int类型常量2压入栈iconst_3 将int类型常量3压入栈iconst_4 将int类型常量4压入栈iconst_5 将int类型常量5压入栈lconst_0 将long类型常量0压入栈lconst_1 将long类型常量1压入栈fconst_0 将float类型常量0压入栈fconst_1 将float类型常量1压入栈dconst_0 将double类型常量0压入栈dconst_1 将double类型常量1压入栈bipush 将一个8位带符号整数压入栈sipush 将16位带符号整数压入栈ldc 把常量池中的项压入栈ldc_w 把常量池中的项压入栈（使用宽索引）ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）从栈中的局部变量中装载值的指令iload 从局部变量中装载int类型值lload 从局部变量中装载long类型值fload 从局部变量中装载float类型值dload 从局部变量中装载double类型值aload 从局部变量中装载引用类型值（refernce）iload_0 从局部变量0中装载int类型值iload_1 从局部变量1中装载int类型值iload_2 从局部变量2中装载int类型值iload_3 从局部变量3中装载int类型值lload_0 从局部变量0中装载long类型值lload_1 从局部变量1中装载long类型值lload_2 从局部变量2中装载long类型值lload_3 从局部变量3中装载long类型值fload_0 从局部变量0中装载float类型值fload_1 从局部变量1中装载float类型值fload_2 从局部变量2中装载float类型值fload_3 从局部变量3中装载float类型值dload_0 从局部变量0中装载double类型值dload_1 从局部变量1中装载double类型值dload_2 从局部变量2中装载double类型值dload_3 从局部变量3中装载double类型值aload_0 从局部变量0中装载引用类型值aload_1 从局部变量1中装载引用类型值aload_2 从局部变量2中装载引用类型值aload_3 从局部变量3中装载引用类型值iaload 从数组中装载int类型值laload 从数组中装载long类型值faload 从数组中装载float类型值daload 从数组中装载double类型值aaload 从数组中装载引用类型值baload 从数组中装载byte类型或boolean类型值caload 从数组中装载char类型值saload 从数组中装载short类型值将栈中的值存入局部变量的指令istore 将int类型值存入局部变量lstore 将long类型值存入局部变量fstore 将float类型值存入局部变量dstore 将double类型值存入局部变量astore 将将引用类型或returnAddress类型值存入局部变量istore_0 将int类型值存入局部变量0istore_1 将int类型值存入局部变量1istore_2 将int类型值存入局部变量2istore_3 将int类型值存入局部变量3lstore_0 将long类型值存入局部变量0lstore_1 将long类型值存入局部变量1lstore_2 将long类型值存入局部变量2lstore_3 将long类型值存入局部变量3fstore_0 将float类型值存入局部变量0fstore_1 将float类型值存入局部变量1fstore_2 将float类型值存入局部变量2fstore_3 将float类型值存入局部变量3dstore_0 将double类型值存入局部变量0dstore_1 将double类型值存入局部变量1dstore_2 将double类型值存入局部变量2dstore_3 将double类型值存入局部变量3astore_0 将引用类型或returnAddress类型值存入局部变量0astore_1 将引用类型或returnAddress类型值存入局部变量1astore_2 将引用类型或returnAddress类型值存入局部变量2astore_3 将引用类型或returnAddress类型值存入局部变量3iastore 将int类型值存入数组中lastore 将long类型值存入数组中fastore 将float类型值存入数组中dastore 将double类型值存入数组中aastore 将引用类型值存入数组中bastore 将byte类型或者boolean类型值存入数组中castore 将char类型值存入数组中sastore 将short类型值存入数组中wide指令wide 使用附加字节扩展局部变量索引通用(无类型）栈操作nop 不做任何操作pop 弹出栈顶端一个字长的内容pop2 弹出栈顶端两个字长的内容dup 复制栈顶部一个字长内容dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2 复制栈顶部两个字长内容dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈swap 交换栈顶部两个字长内容类型转换i2l 把int类型的数据转化为long类型i2f 把int类型的数据转化为float类型i2d 把int类型的数据转化为double类型l2i 把long类型的数据转化为int类型l2f 把long类型的数据转化为float类型l2d 把long类型的数据转化为double类型f2i 把float类型的数据转化为int类型f2l 把float类型的数据转化为long类型f2d 把float类型的数据转化为double类型d2i 把double类型的数据转化为int类型d2l 把double类型的数据转化为long类型d2f 把double类型的数据转化为float类型i2b 把int类型的数据转化为byte类型i2c 把int类型的数据转化为char类型i2s 把int类型的数据转化为short类型整数运算iadd 执行int类型的加法ladd 执行long类型的加法isub 执行int类型的减法lsub 执行long类型的减法imul 执行int类型的乘法lmul 执行long类型的乘法idiv 执行int类型的除法ldiv 执行long类型的除法irem 计算int类型除法的余数lrem 计算long类型除法的余数ineg 对一个int类型值进行取反操作lneg 对一个long类型值进行取反操作iinc 把一个常量值加到一个int类型的局部变量上逻辑运算移位操作ishl 执行int类型的向左移位操作lshl 执行long类型的向左移位操作ishr 执行int类型的向右移位操作lshr 执行long类型的向右移位操作iushr 执行int类型的向右逻辑移位操作lushr 执行long类型的向右逻辑移位操作按位布尔运算iand 对int类型值进行“逻辑与”操作land 对long类型值进行“逻辑与”操作ior 对int类型值进行“逻辑或”操作lor 对long类型值进行“逻辑或”操作ixor 对int类型值进行“逻辑异或”操作lxor 对long类型值进行“逻辑异或”操作浮点运算fadd 执行float类型的加法dadd 执行double类型的加法fsub 执行float类型的减法dsub 执行double类型的减法fmul 执行float类型的乘法dmul 执行double类型的乘法fdiv 执行float类型的除法ddiv 执行double类型的除法frem 计算float类型除法的余数drem 计算double类型除法的余数fneg 将一个float类型的数值取反dneg 将一个double类型的数值取反对象和数组对象操作指令new 创建一个新对象checkcast 确定对象为所给定的类型getfield 从对象中获取字段putfield 设置对象中字段的值getstatic 从类中获取静态字段putstatic 设置类中静态字段的值instanceof 判断对象是否为给定的类型数组操作指令newarray 分配数据成员类型为基本上数据类型的新数组anewarray 分配数据成员类型为引用类型的新数组arraylength 获取数组长度multianewarray 分配新的多维数组控制流条件分支指令ifeq 如果等于0，则跳转ifne 如果不等于0，则跳转iflt 如果小于0，则跳转ifge 如果大于等于0，则跳转ifgt 如果大于0，则跳转ifle 如果小于等于0，则跳转if_icmpcq 如果两个int值相等，则跳转if_icmpne 如果两个int类型值不相等，则跳转if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转ifnull 如果等于null，则跳转ifnonnull 如果不等于null，则跳转if_acmpeq 如果两个对象引用相等，则跳转if_acmpnc 如果两个对象引用不相等，则跳转比较指令lcmp 比较long类型值fcmpl 比较float类型值（当遇到NaN时，返回-1）fcmpg 比较float类型值（当遇到NaN时，返回1）dcmpl 比较double类型值（当遇到NaN时，返回-1）dcmpg 比较double类型值（当遇到NaN时，返回1）无条件转移指令goto 无条件跳转goto_w 无条件跳转（宽索引）表跳转指令tableswitch 通过索引访问跳转表，并跳转lookupswitch 通过键值匹配访问跳转表，并执行跳转操作异常athrow 抛出异常或错误finally子句jsr 跳转到子例程jsr_w 跳转到子例程（宽索引）rct 从子例程返回方法调用与返回方法调用指令invokcvirtual 运行时按照对象的类来调用实例方法invokespecial 根据编译时类型来调用实例方法invokestatic 调用类（静态）方法invokcinterface 调用接口方法方法返回指令ireturn 从方法中返回int类型的数据lreturn 从方法中返回long类型的数据freturn 从方法中返回float类型的数据dreturn 从方法中返回double类型的数据areturn 从方法中返回引用类型的数据return 从方法中返回，返回值为void线程同步montiorenter 进入并获取对象监视器monitorexit 释放并退出对象监视器 JVM指令助记符变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_加：iadd,ladd,fadd,dadd减：isub,lsub,fsub,dsub乘：imul,lmul,fmul,dmul除：idiv,ldiv,fdiv,ddiv余数：irem,lrem,frem,drem取负：ineg,lneg,fneg,dneg移位：ishl,lshr,iushr,lshl,lshr,lushr按位或：ior,lor按位与：iand,land按位异或：ixor,lxor类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)创建类实便：new创建新数组：newarray,anewarray,multianwarray访问类的域和类实例域：getfield,putfield,getstatic,putstatic把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore获取数组长度：arraylength检相类实例或数组属性：instanceof,checkcast操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmplfcmpg,dcmpl,dcmpg复合条件转移：tableswitch,lookupswitch无条件转移：goto,goto_w,jsr,jsr_w,ret调度对象的实便方法：invokevirtual调用由接口实现的方法：invokeinterface调用需要特殊处理的实例方法：invokespecial调用命名类中的静态方法：invokestatic方法返回：ireturn,lreturn,freturn,dreturn,areturn,return异常：athrowfinally关键字的实现使用：jsr,jsr_w,ret","categories":[{"name":"JVM","slug":"JVM","permalink":"https://zhuyiting.xyz/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zhuyiting.xyz/tags/JVM/"}]},{"title":"线程池原理及应用","slug":"线程池原理及应用","date":"2019-02-15T02:31:21.000Z","updated":"2019-11-15T05:11:56.984Z","comments":true,"path":"2019/02/15/线程池原理及应用/","link":"","permalink":"https://zhuyiting.xyz/2019/02/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、为什么要使用线程池在一些需要使用线程去处理任务的业务场景中，如果每一个任务都创建一个线程去处理，任务处理完过后，把这个线程销毁，这样会产生大量的线程创建、销毁的资源开销，Java中更是如此，虚拟机将试图跟踪每一个对象。以便可以在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能降低创建和销毁对象的次数。使用线程池能够有效的控制这种线程的创建和销毁，而且能够对创建的线程进行有效的管理。 使用线程池的好处: 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会=降低系统稳定性，使用线程池可以进行统一分配、调优和监控。 线程池原理-概念 线程池管理器:用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务; 工作线程:线程池中线程,在没有任务时处于等待状态,可以循环的执行任务; 任务接口:每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入口,任务执行后的首尾工作,任务的执行状态等; 任务队列:用于存放没有处理的任务.提供一种缓存机制. 二、Java线程池相关API介绍 Executor接口主要是用来执行提交的任务。线程池会实现这个接口，并且使用exectue方法来提交一个任务。 ExecutorSevice接口ExecutorService接口是Executor接口的一个子接口，它在Executor接口的基础上增加了一些方法，用来支持对任务的终止管理以及对异步任务的支持。 AbstractExecutorService抽象类AbstractExecutorService实现了ExcutorService，并且基于模板方法模式对一些方法给出了实现。是后面提到的线程池类ThreadPoolExcutor的直接父类。 ThreadPoolExcutor类ThreadPoolExcutor通常就是我们所说的线程池类，Java的线程池就是用这个类进行创建的。在分析线程池的运行原理时，也是基于这个类来进行分析。 ScheduledExecutorService接口ScheduledExecutorService接口时ExecutorService子接口，定义了线程池基于任务调度的一些方法。 ScheduledThreadPoolExecutor类ScheduledThreadPoolExecutor集成了ThreadPoolExecutor类，并且实现了ScheduledExecutorService接口，对任务调度的功能进行了实现。 Executors类Executors可以认为是线程池的工厂类，里面提供了静态方法对线程池进行创建。 三、Java线程池的运行原理1. 线程池的参数属性介绍核心线程数corePoolSize：核心线程池数量。提交一个任务的时候，会对线程池里面的当前存活线程数量和这个corePoolSize进行比较，不同的情况下会有不同的操作。最大线程数maximumPoolSize：线程池所能创建的线程的最大数量。空闲线程的超时时间keepAliveTime：如果线程池当前的线程数大于corePoolSize，并且这些线程中是有空闲线程的，也就是说这些线程没有在执行任务，那么空闲时间超过keepAliveTime时间，这些线程也会被销毁，指代前线程代数等于corePoolsize，这时即便有空闲线程并且超时了，也不会进行线程销毁。任务队列workQueue：这是一个阻塞队列，用于存储提交的任务。线程工厂threadFactory：线程池会使用这个工厂类来创建线程，用户可以自己实现。任务的拒绝处理handler（RejectedExeutionHandler）：在线程数已经达到了最大线程数，而且任务队列也满了以后，提交的任务会使用这个handler来处理，用户也可以自己实现。默认是抛出一个异常RejectedExecutionException。 2. 线程池运行原理分析分析当用户提交一个任务使，线程池内部使如何运行的。 创建一个线程池，在还没有任务提交的时候，默认线程池里面是没有线程的。当然，可以调用prestartCoreThread方法，来预先创建一个核心线程。 线程池里面还没有线程或者线程池里面存活的线程数小于核心线程数corePoolSize时，这时对于一个新提交的任务，线程池会创建一个线程去处理提交的任务。当线程池里面存活的线程数小于等于核心线程数corePoolSize时，线程池里面的线程会一直存活着，就算空闲时间超过了keepAliveTime，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。 当线程池里面存活的线程数已经等于corePoolSize了，这时对于一个新提交的任务，会被放进任务队列workQueue排队等待执行。而之前创建的线程并不会被销毁，而是不断的去拿阻塞队列里面的任务，当任务列表为空时，线程会阻塞，直到有任务被放进任务队列，线程拿到任务后继续执行，执行完了以后继续去拿任务，这也是为什么线程池队列要使用阻塞队列。 当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列也满了，这里假设maximumPoolSize&gt;corePoolSize（如果等于的话，就直接拒绝了），这时如果再来新的任务，线程池就会继续创建新的线程来处理新任务，直到线程数达到maximumPoolSize，就不会再创建了。这些新创建的线程执行完了当前任务后，再任务队列里面还有任务的时候也不会销毁，而是去任务队列拿任务出来执行。在当前线程数大于corePoolSize过后，线程执行完当前任务，会有一个判断当前线程是否需要销毁的逻辑；如果能从任务队列中拿到任务，那么继续执行，如果拿任务时阻塞（说明队列中没有任务），那超过keepAliveTime时间就直接返回null并且销毁当前线程，直到线程池里面的线程数等于corePoolSize之后才不会进行线程销毁。 如果当前线程数达到了maximumPoolSize，并且任务队列也满了，这种情况下还有新的任务过来，那就直接采用拒绝的处理器进行执行，默认的处理器逻辑时抛出一个RejectedExcutionException异常。你也可以指定其他的处理器，或者自定义一个拒绝处理器来实现拒绝逻辑的处理（比如把任务存储起来）。JDK提供了四种拒绝策略处理类；AbortPolicy（抛出一个异常，默认的），DiscardPolicy（直接丢弃任务），DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池），CallerRunPolicy（交给线程池调用的所在线程进行处理）。 3. 线程池包含以下四个基本组成部分： 线程池管理器（ThreadPool）：用于创建并管理线程池。包含创建线程池，销毁线程池，加入新任务； 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态。能够循环的运行任务。 任务接口（Task）：每一个任务必须实现的接口，以供工作线程调度任务的运行。它主要规定了任务的入口。任务运行完成后的收尾工作，任务的运行状态等。 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 4. 常用的几种线程池以及使用场景 SingleThreadExecutor:单个线程的线程池这种线程池主要适用于请求量非常小的场景，或者离线的数据处理等，只需要一个线程就够了。在持续的请求量比较大的情况下，不要使用这种线程池，单线程处理会使队列不断变大，最终可能导致内存溢出。 FixedThreadPool：固定线程大小线程池这种线程的额corePoolSize和maximumPoolSize是相等的，keepAliveTime设置为0，队列用的是LinkedBlockingQueue无界队列。适用于流量比较稳定的情况，不会说一段时间突然有大量的流量涌入，导致LinkedBlockingQueue越来越大最后导致内存溢出。 CachedThreadPool：按需求创建线程数量线程池这种线程的corePoolSize=0，maximumPoolSize是Integer.MAX_VALUE，keepAliveTime为60秒，队列使用SynchronousQueue同步队列，这个队列可以理解为没有容量的阻塞队列，只有有别的线程来拿任务时，当前线程才能插入成功，反过来也一样。所以这种线程池任务队列时不存任务的，任务全靠创建新的线程来处理，处理完了以后线程空闲超过60秒就会被自动销毁，所以这种线程池适合有一定高峰流量的场景。但是还是要慎用，如果瞬时流量过高会导致创建的线程过多，直接导致服务所在机器的CPU负载过高，然后卡死，所以使用这种线程池必须指代最高峰时的流量也不会导致CPU负载过高。 ScheduledThreadPoolExecutor：任务调度线程池可以根据自己的需求，使用单线程调度（SingleThreadExecutor）,多线程调度（ScheduledThreadPool）。不过现在使用spring调度比较多，所以开发中比较少用。 自定义线程池（推荐使用）根据实际的一个业务场景，自己new一个ThreadPoolExecutor，参数根据业务场景需要指定合适的参数，比如核心线程数设置多少合适，最大线程数设置多少合适，任务队列设置多大的有界合适，拒绝策略也可以自定义，一般采用离线存储啥的，完全根据业务场景来定制。这样可以保证不会发生无界队列导致内存溢出，也不会导致创建的线程过多而导致机器卡死。 5. 线程池关闭 shutdown():调用后不允许提交新任务，所有调用之前提交的任务都会执行，等所有任务执行完，才会真正关闭线程池。 shutdownNow():强制关闭。返回还没有执行的task列表，然后不让等待的task执行，尝试停止正在执行的task。 线程池的使用案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/** 线程池的使用 */public class Demo &#123; /** * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况 * * @param threadPoolExecutor 传入不同的线程池，看不同的结果 * @throws Exception */ public void testCommon(ThreadPoolExecutor threadPoolExecutor) throws Exception &#123; // 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况 for (int i = 0; i &lt; 15; i++) &#123; int n = i; threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"开始执行：\" + n); Thread.sleep(3000L); System.err.println(\"执行结束:\" + n); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println(\"任务提交成功 :\" + i); &#125; // 查看线程数量，查看队列等待数量 Thread.sleep(500L); System.out.println(\"当前线程池线程数量为：\" + threadPoolExecutor.getPoolSize()); System.out.println(\"当前线程池等待的数量为：\" + threadPoolExecutor.getQueue().size()); // 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁） Thread.sleep(15000L); System.out.println(\"当前线程池线程数量为：\" + threadPoolExecutor.getPoolSize()); System.out.println(\"当前线程池等待的数量为：\" + threadPoolExecutor.getQueue().size()); &#125; /** * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest1() throws Exception &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); testCommon(threadPoolExecutor); // 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行 &#125; /** * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest2() throws Exception &#123; // 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。 // 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.err.println(\"有任务被拒绝执行了\"); &#125; &#125;); testCommon(threadPoolExecutor); // 预计结果： // 1、 5个任务直接分配线程开始执行 // 2、 3个任务进入等待队列 // 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁) // 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。 // 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程 &#125; /** * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒 * * @throws Exception */ private void threadPoolExecutorTest3() throws Exception &#123; // 和Executors.newFixedThreadPool(int nThreads)一样的 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); testCommon(threadPoolExecutor); // 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行 &#125; /** * 4、 线程池信息： * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒 * * @throws Exception */ private void threadPoolExecutorTest4() throws Exception &#123; // SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。 // 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时， // 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务， // 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。 // 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。 // 和Executors.newCachedThreadPool()一样的 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); testCommon(threadPoolExecutor); // 预计结果： // 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行 // 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0 Thread.sleep(60000L); System.out.println(\"60秒后，再看线程池中的数量：\" + threadPoolExecutor.getPoolSize()); &#125; /** * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/&gt; * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒 * * @throws Exception */ private void threadPoolExecutorTest5() throws Exception &#123; // 和Executors.newScheduledThreadPool()一样的 ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5); threadPoolExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"任务被执行，现在时间：\" + System.currentTimeMillis()); &#125; &#125;, 3000, TimeUnit.MILLISECONDS); System.out.println( \"定时任务，提交成功，时间是：\" + System.currentTimeMillis() + \", 当前线程池中线程数量：\" + threadPoolExecutor.getPoolSize()); // 预计结果：任务在3秒后被执行一次 &#125; /** * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/&gt; * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒 * * @throws Exception */ private void threadPoolExecutorTest6() throws Exception &#123; ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5); // 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。 // 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别 // 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。 // 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待） threadPoolExecutor.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"任务-1 被执行，现在时间：\" + System.currentTimeMillis()); &#125; &#125;, 2000, 1000, TimeUnit.MILLISECONDS); // 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。 // 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1） threadPoolExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"任务-2 被执行，现在时间：\" + System.currentTimeMillis()); &#125; &#125;, 2000, 1000, TimeUnit.MILLISECONDS); &#125; /** * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest7() throws Exception &#123; // 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。 // 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.err.println(\"有任务被拒绝执行了\"); &#125; &#125;); // 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况 for (int i = 0; i &lt; 15; i++) &#123; int n = i; threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"开始执行：\" + n); Thread.sleep(3000L); System.err.println(\"执行结束:\" + n); &#125; catch (InterruptedException e) &#123; System.out.println(\"异常：\" + e.getMessage()); &#125; &#125; &#125;); System.out.println(\"任务提交成功 :\" + i); &#125; // 1秒后终止线程池 Thread.sleep(1000L); threadPoolExecutor.shutdown(); // 再次提交提示失败 threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"追加一个任务\"); &#125; &#125;); // 结果分析 // 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行 // 2、调用shutdown后，不接收新的任务，等待13任务执行结束 // 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行 &#125; /** * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest8() throws Exception &#123; // 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。 // 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.err.println(\"有任务被拒绝执行了\"); &#125; &#125;); // 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况 for (int i = 0; i &lt; 15; i++) &#123; int n = i; threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"开始执行：\" + n); Thread.sleep(3000L); System.err.println(\"执行结束:\" + n); &#125; catch (InterruptedException e) &#123; System.out.println(\"异常：\" + e.getMessage()); &#125; &#125; &#125;); System.out.println(\"任务提交成功 :\" + i); &#125; // 1秒后终止线程池 Thread.sleep(1000L); List&lt;Runnable&gt; shutdownNow = threadPoolExecutor.shutdownNow(); // 再次提交提示失败 threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"追加一个任务\"); &#125; &#125;); System.out.println(\"未结束的任务有：\" + shutdownNow.size()); // 结果分析 // 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行 // 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止 // 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行 &#125; public static void main(String[] args) throws Exception &#123;// new Demo().threadPoolExecutorTest1();// new Demo().threadPoolExecutorTest2();// new Demo().threadPoolExecutorTest3();// new Demo().threadPoolExecutorTest4();// new Demo().threadPoolExecutorTest5();// new Demo().threadPoolExecutorTest6();// new Demo().threadPoolExecutorTest7(); new Demo().threadPoolExecutorTest8(); &#125;&#125;","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"线程封闭之ThreadLocal和栈封闭","slug":"线程封闭之ThreadLocal和栈封闭","date":"2019-01-29T13:25:59.000Z","updated":"2019-11-15T05:12:05.574Z","comments":true,"path":"2019/01/29/线程封闭之ThreadLocal和栈封闭/","link":"","permalink":"https://zhuyiting.xyz/2019/01/29/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/","excerpt":"","text":"线程封闭:线程不安全是因为多线程在访问共享的可变数据时,会发生数据的不一致,结果不正确. 实现好的并发是一件困难的事情, 那么如何解决呢,一个是使用同步,但是同步需要占用资源,另外一种方式,如果一个线程访问这个数据,就不会出现问题, 所以很多时候我们都想躲避并发. 避免并发最简单的方法就是线程封闭. 什么是线程封闭; 就是把对象封装到一个线程里,只有这个线程能看到此对象. 那么这个对象就算不是线程安全的也不会出现任何问题. 线程封闭的实现方式: Ad-hoc : 维护线程封闭性的职责完全由程序实现来承担,是非常脆弱的, 因为没有任何一种语言特性, 能将对象封闭到目标线程上. 栈封闭 : 简单的来说就是局部变量. 多个线程访问一个方法,此方法中的局部变量都会拷贝一份到线程栈中,. 所以局部变量是不被多个线程所共享,也就不会出现并发问题,所以能用局部变量就别用全局变量, 全局变量容易引起并发问题. ThreadLocal封闭 : 使用ThreadLocal是实现线程封闭的最好方法. ThreadLocal内部维护了一个Map, Map的key是每个线程对象,而Map的值就是我们要封闭的对象(数据) . 每个线程中的对象都对应这Map中的一个值, 也就是ThreadLocal利用Map实现了对象的线程封闭. ThreadLocalThreadLocal是Java中的一种特殊变量它是一个线程级别的变量,每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了,在并发模式下是绝对安全的变量.用法: ThreadLocal var=new ThreadLocal();会自动在每一个线程上创建一个T的副本,副本之间彼此独立,互不影响.可以再ThreadLocal中存储一些参数,以便在线程中多个方法中使用, 用来代替方法传参的做法.","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java线程通信","slug":"Java线程通信","date":"2019-01-23T02:19:49.000Z","updated":"2019-11-15T04:52:57.725Z","comments":true,"path":"2019/01/23/Java线程通信/","link":"","permalink":"https://zhuyiting.xyz/2019/01/23/Java%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"概述：线程与线程之间不是相互独立的个体，它们彼此之间需要相互通信和写作，最典型的例子就是生产者-消费者问题：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。 线程之间的通信有以下 文件共享 网络共享 共享变量 jdk提供的线程协调API 1. 文件共享线程1写入文件a.txt,线程2从a.txt中读取数据 3. 变量共享线程1写入公共变量线程2从公共变量读取数据 4. jdk提供的线程协调API多线程协作的典型场景:生产者-消费者模型 示例:线程1去买包子,没有包子,则不再执行.线程2生产出包子,通知线程1继续执行 jdk已弃用的suspend/resume 挂起和唤醒被弃用的主要原因是,容易写出死锁的代码, 在同步代码中使用,suspend挂起不会释放锁,产生死锁 suspend一定要在resumee之前执行,否则 wait/notify机制在这之前，线程间通过共享数据来实现通信，即多个线程主动地读取一个共享数据，通过同步互斥访问机制来保证线程的安全性。等待/通知机制主要由Object类中的wait()、notify()和notifyAll()三个方法来实现，这三个方法均非Thread中所申明的方法，而是Object类中申明的方法。原因是每个对象都拥有monitor（锁），所以让但却概念线程等待某个对象的锁，当然应该通过这个对象来操作，而不是当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作就会非常复杂。wait()——让当前线程释放对象锁并进入等待（阻塞）状态notify()——唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。notifyAll()——唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。 这些方法只能由同一对象锁的持有者线程调用,也就是必须写在同步块里,否则会抛出illegalMonitorStateException wait会自动解锁,但对顺序调用还是有需求.不能再notify后调用 锁对象每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度，反之，当一个线程被wait之后，就会进入阻塞队列，等待被唤醒。 park/unpark机制线程调用park则等待”许可”,unpark为指定线程提供”许可” 不要求park和unpark方法的调用顺序多次调用unpark,再调用park,线程会直接运行,但不会叠加, 连续多次调用park,只有第一次能拿到”许可”虽然没有顺序要求,但是park不会释放锁 注意: 不要使用if语句来判断,是否进入等待状态,应该在循环中检测等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒,如果不在循环条件中检查等待条件,程序就会在没有满足结束条件的情况下退出.","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"CPU多级缓存","slug":"CPU多级缓存","date":"2019-01-15T10:31:16.000Z","updated":"2019-11-15T05:12:09.767Z","comments":true,"path":"2019/01/15/CPU多级缓存/","link":"","permalink":"https://zhuyiting.xyz/2019/01/15/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"CPU多级缓存 cache带来的问题cache 给系统带来性能上飞跃的同时，也引入了新的问题“缓存一致性问题”。设想如下场景（cpu一共有两个核，core1和core2）： 以i++为例，i的初始值是0.那么在开始每个核都存储了i的值0，当第core1块做i++的时候，其缓存中的值变成了1，即使马上回写到主内存，那么在回写之后core2缓存中的i值依然是0，其执行i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是1，而不是预期中的2。 缓存一致性为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。我们介绍其中最经典的MESI协议。在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：|状态| 描述||:–:|:–:||M(Modified)| 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。||E(Exclusive)| 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。||S(Shared)| 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。||I(Invalid)| 这行数据无效| 当前状态 事件 行为 下一状态 I(Invalid) Local Read 如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E； 如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S； 如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S E/S Local Write 从内存中取数据，在Cache中修改，状态变成M； 如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存； 如果其它Cache有这份数据，则其它Cache的Cache line状态变成I M Remote Read 既然是Invalid，别的核的操作与它无关 I Remote Write 既然是Invalid，别的核的操作与它无关 I E(Exclusive) Local Read 从Cache中取数据，状态不变 E Local Write 修改Cache中的数据，状态变成M M Remote Read 数据和其它核共用，状态变成了S S Remote Write 数据被修改，本Cache line不能再使用，状态变成I I S(Shared) Local Read 从Cache中取数据，状态不变 S Local Write 修改Cache中的数据，状态变成M， 其它核共享的Cache line状态变成I M Remote Read 状态不变 S Remote Write 数据被修改，本Cache line不能再使用，状态变成I I M(Modified) Local Read 从Cache中取数据，状态不变 M Local Write 修改Cache中的数据，状态不变 M Remote Read 这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S S Remote Write 这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据， 状态变成I I 指令重排序指令重排场景:当CPU写缓存时发现缓存区块正被其他CPU占用,为了提高CPU处理性能,可能将后面的读缓存命令优先执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则之外，我们还需要确保多CPU的高速缓存中的数据与内存保持一致性，不能确保内存与CPU缓存数据一致性的指令也不能重排，内存屏障正式通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法。 内存屏障处理器提供了两个内存屏障指令用于解决以上问题 写内存屏障(Store Memory Barrier)能让写入缓存中的最新数据更新写入主内存, 让其他线程可见 读内存屏障(Load Memory Barrier)让高速缓存中的数据失效,强制重新从主内存加载数据 volatileJAVA中的volatile关键字正是使用了内存屏障。如果字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着，如果你对一个volatile字段进行写操作，你必须知道： 一旦你完成写入，任何访问这个字段的线程将会得到最新的值。 在你写入前，会保证所有之前发生的事已发生，并且任何更像过的数据值也是可见的。因为内存屏障会把之前的写入值都刷新到缓存。 注意: 内存屏障会导致不可以尽可能地高校利用CPU，另外刷新缓存亦会有开销。所以不要以为用volatile代替锁操作就一点事都没有。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://zhuyiting.xyz/tags/cache/"},{"name":"内存屏障","slug":"内存屏障","permalink":"https://zhuyiting.xyz/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"}]},{"title":"Java线程状态和线程中止","slug":"Java线程状态和线程中止","date":"2019-01-09T01:19:46.000Z","updated":"2019-11-15T05:13:30.062Z","comments":true,"path":"2019/01/09/Java线程状态和线程中止/","link":"","permalink":"https://zhuyiting.xyz/2019/01/09/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A2/","excerpt":"","text":"线程中止： 设置标记位(受限与线程中业务逻辑有循环条件)thread.setFlag(false); 使用stop()，不安全，已经被废弃thread.stop()，因为stop()方法会解除由线程获得的所有锁，当在一个线程对象上调用stop()方法时，这个线程对象所运行的线程会立即停止 使用Thread类的interrupt() 方法中断线程调用interrupt()方法只会给线程设置一个为true的终端标志，而设置之后，则根据线程当前状态进行不同的后续操作 线程的五大状态及其转换线程的五大状态分别为:创建状态（new）、就绪状态（Runnable）、运行状态（Running）、阻塞状态（Blocked）、死亡状态（Dead）。 五大状态之间的关系图： （1）新建状态：即单纯的创建一个线程创建线程有三种方式；1.集成Thread类创建线程使用集成Thread类创建线程时，首先需要创建一个类集成Thread类并覆写Thread类run()方法，在run()方法中，需要写线程要执行的任务但是调用run()方法并不是真正的启动一个线程，真正的启动线程，需要调用的时Thread类的start()方法，而start()方法会自动调用run()方法，从而启动一个线程。说明： main方法其实也是一个线程，是该进程的主线程。但是在使用多线程技术时，代码的运行结果与代码调用的顺序无关，因为线程是一个子任务，CPU以不确定的方式或者说以随机的时间来调用线程中的run()方法，所以会出现每次运行结果不同的情况。 2.实现Runnable接口创建线程Thread类的核心功能就是进行线程的启动，但一个类为了实现多线程直接取继承Thread类时出现的问题就是：单集成的局限性！所以Java中还提供了另一种实现多线程的方法：实现Runnable接口来创建多线程。注意： 启动一个线程的唯一方法就是调用Thread类的start()方法，抓住这点去建立与Thread类之间的关系。Runnable接口中只有一个抽象方法就是run()方法。那怎么使用Runnable接口去创建线程呢？（如何执行start()方法呢）第一步：定义一个类实现Runnable接口的抽象方法run()方法。 此时Thread类有一个Thread类的构造方法public Thread(Runnable target)方法，参数用于接收Runnable接口的实例化对象，所以在Runnable接口与Thread类之间就建立起了联系，从而可以调用Thread类的start()方法启动一个线程。所以 第二步：利用Thread类的public Thread(Runnable target)构造方法与Runnable接口建立关系实例化Thread类的对象；第三步：调用Thread类的start()方法启动线程。 3.实现Callable接口创建线程Runnable接口的run()方法没有返回值，而Callable接口中的call()方法有返回值，若某些线程执行完成后需要一些返回值的时候，就需要用Callable接口创建线程。再次强调：启动一个线程的唯一方法就是调用Thread类的start()方法，那么，要想通过实现Callable接口创建线程，就需要找到Callable接口与Thread类之间的关系。首先FutureTask类提供了构造方法public FutureTask(Callable callable)方法，而FutureTask类又实现了RunnableFuture接口，而RunnableFuture接口又继承了 Runnable接口，再通过public Thread(Runnable runnable)构造方法，使Callable接口与Thread类之间建立了联系。 所以使用Callable接口创建线程的步骤如下： 1234567891011121314151617181920212223242526// 1.定义一个类MyThread实现Callable接口，从而覆写call()方法class MyThread implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; return \"Callable接口创建线程\"; &#125;&#125;public static void main(String[] args) throws InterruptedException, ExecutionException &#123; //2.利用MyThread类实例化Callable接口的对象 Callable callable=new MyThread(); //3.利用FutureTask类的构造方法public FutureTask(Claaable&lt;V&gt; callable) //将Callable接口的对象传给FutureTask类 FutureTask task=new FutureTask(callable); //4.将FutureTask类的对象隐式地向上转型 //从而作为Thread类的public Thread(Runnable runnable)构造方法的参数 Thread thread=new Thread(task); //5.调用Thread类的start()方法 thread.start(); //FutureTask的get()方法用于获取FutureTask的call()方法的返回值，为了取得线程的执行结果 System.out.println(task.get());&#125; （2）就绪状态：在创建了线程之后，调用了Thread类的start()方法来启动一个线程，即表示线程进入了就绪状态！ （3）运行状态：当线程获得CPU时间，线程才从就绪状态进入到运行状态！ （4）阻塞状态：线程进入运行状态后，可能由于多种原因让线程进入阻塞状态，如：调用sleep()方法，让线程睡眠，调用wait()方法让线程等待，调用join()方法以及阻塞式IO方法 阻塞情况分为三种：（一）等待阻塞：运行中（running）的线程执行o.wait()方法，JVM会把该线程放入等待队列（waiting queue）中。（二）同步阻塞：运行中（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。（三）其他阻塞：运行中（running）的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行状态。 阻塞方法的异同： sleep、yield方法是静态方法；作用是当前执行的线程； yield方法释放了cpu的执行权，但是保留了争夺cpu的资格，这也意味着，该线程可能马上会再次执行。yield()只能使同优先级或更高优先级的线程有执行的机会。 wait释放CPU资源，同时释放锁，只有执行notify/notifyAll()时，才会唤醒处于等待的线程，然后继续往下执行，直到执行完synchronized代码块的代码火种中途再次遇到wait()。一般配合synchronized关键字使用，即，一般在synchronized同步代码块中使用wait()、notify/notifyAll方法。 sleep释放CPU资源，但不释放锁 join把调用该方法的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B （5）死亡状态：run()方法的正常退出，就是让线程进入到死亡状态，还有当一个异常未被捕获而终止了run()方法的执行也会进入到死亡状态！ 设置或获取多线程的线程名称的方法由于在一个进程中可能有多个线程，而多线程的运行状态又是不确定的，所以在多线程操作中需要有一个明确的标识符标识出当前线程对象的信息，这个信息往往通过线程的名称来描述。在Thread类中提供了一些设置或者获取线程名称的方法： 创建线程时设置线程的名称；public Thread(Runnable target,String name) 设置线程名称的普通方法；public final synchronized void setName(String name) 取得线程名称的普通方法；public final String getName()","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Vue项目搭建","slug":"Vue项目搭建","date":"2018-12-16T11:39:42.000Z","updated":"2019-11-15T04:56:12.886Z","comments":true,"path":"2018/12/16/Vue项目搭建/","link":"","permalink":"https://zhuyiting.xyz/2018/12/16/Vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Vue项目实战做一个简单的Vue前端项目,练习与巩固知识点,做一个总结 前期准备node环境github+git项目管理 项目创建 在github上创建一个仓库,作为本次项目仓库然后clone到本地 命令行工具初始化一个Vue项目前提:先安装好vue脚手架(全局), 可以使用vue命令进入项目根目录,然后执行vue init webpack初始化一个vue 尝试启动项目运行npm run dev命令,访问成功,一个vue的demo创建完成 项目结构src项目源代码结构业务开发根目录 main.js — 项目入口文件 App.vue — 项目原始根组件 router index.js — 项目路由 components — 项目中的组件 assests — 项目中的图片资源文件 config配置文件夹 index.js — 基础配置文件 dev.env.js — 开发环境 prod.env.js — 上线环境 build项目打包的webpack的配置内容一般也不需要修改 .vue文件结构.vue是一种单文件组件 12345678910111213141516171819202122232425262728&lt;!-- Vue单组件文件 --&gt;&lt;!-- 组件模板 --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 组件逻辑 --&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;!-- 组件样式 --&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 引入fastclick第三方模块引入fastclick包解决有些浏览器延迟300ms响应click事件的问题npm install fastclick --save 引入Element模板库npm i element-ui -S npm安装,这样可以和webpack更好的结合然后在main.js中导入 12345// 引入elementimport ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'// 全局使用Vue.use(ElementUI);","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"Vue的Ajax(axios)","slug":"Vue的Ajax-axios","date":"2018-11-14T03:15:38.000Z","updated":"2019-11-15T04:55:48.816Z","comments":true,"path":"2018/11/14/Vue的Ajax-axios/","link":"","permalink":"https://zhuyiting.xyz/2018/11/14/Vue%E7%9A%84Ajax-axios/","excerpt":"","text":"Vue的Ajax(axios)Vue推荐使用axios来完成ajax请求 Axios是一个基于Promise的HTTP库,可以在浏览器或者Node中使用 简单的Axios实例12345678910111213141516171819axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;);// GET 请求远程图片axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;);// 发送 GET 请求（默认的方法）axios('/user/12345'); 请求方法的别名axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 请求结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111axios(&#123; // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 //修改完后再提交 return data; &#125;], transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 // 修改完后再响应 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;\"X-Requested-With\": \"XMLHttpRequest\"&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: \"brackets\"&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: \"Fred\" &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求花费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: \"janedoe\", password: \"s00pers3cret\" &#125;, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // 默认的 &#125;, // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: \"127.0.0.1\", port: 9000, auth: : &#123; username: \"mikeymike\", password: \"rapunz3l\" &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125;) 响应结构1234567891011121314151617axios(&#123;&#125;).then(function(res)&#123; // `data` 由服务器提供的响应 console.log(response.data); // `status` HTTP 状态码 console.log(response.status); // `statusText` 来自服务器响应的 HTTP 状态信息 console.log(response.statusText); // `headers` 服务器响应的头 console.log(response.headers); // `config` 是为请求提供的配置信息 console.log(response.config); &#125;)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"Vue路由","slug":"Vue路由","date":"2018-11-02T02:51:54.000Z","updated":"2019-11-15T04:56:04.292Z","comments":true,"path":"2018/11/02/Vue路由/","link":"","permalink":"https://zhuyiting.xyz/2018/11/02/Vue%E8%B7%AF%E7%94%B1/","excerpt":"","text":"Vue路由Vue路由允许我们通过不同的URL访问不同的内容以前都是在服务端对路由进行划分,不同路由处理不同的请求现在前端的路由可以实现在不重新请求页面的情况下,改变URL展示不同的页面内容 利用Vue.js + vue.router可以实现单页应用 传统多页应用和单页应用对比多页应用 优点: 首页响应快 缺点: 页面切换慢 单页应用 优点: js动态切换页面,无需再请求html文件 缺点: 首页加载慢 Vue.routervue.router是Vue官方的路由插件路由引入的就是模板 &lt;rout-link&gt;使用&lt;rout-link&gt;标签,引入定义好的路由 &lt;router-view&gt;&lt;router-view&gt;区域用来显示路由匹配到的组件 路由的创建定义路由 1234const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;] 创建路由实例 1234const router = new VueRouter(&#123; el:\"#app\", routes:routes&#125;)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"Vue实例详解","slug":"Vue实例详解","date":"2018-10-20T02:20:51.000Z","updated":"2019-11-15T04:56:09.330Z","comments":true,"path":"2018/10/20/Vue实例详解/","link":"","permalink":"https://zhuyiting.xyz/2018/10/20/Vue%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Vue属性每一个Vue实例都拥有一些属性，比如之前的el、data、methods等还有一些其他的属性 el属性用于绑定id，指示Vue的作用范围 data属性Vue的数据属性，用来定义Vue中的数据 methods方法属性，一般的逻辑方法都写在这里 computed计算属性，定义计算属性，也是函数方法，和methods类似，但是基于它的依赖缓存，可以说computed性能更好，但不需要缓存时，可以使用methods watch监听属性，可以通过watch来响应数据的变化，每当监听的变量改变，就调用方法函数 components组件属性,用于注册组件注意:在一个Vue实例内部注册的组件,只有这个Vue的作用范围内可以使用 directives自定义指令注意:在一个Vue实例内部注册的自定义指令,只有这个Vue的作用范围内可以使用 Vue方法Vue实例内部定义了8个方法,涵盖了一个Vue的生命周期 初始化 beforeCreate() Vue实例被创建后,但为空,内部数据和方法都还没有初始化 created() 内部数据和方法初始化已经完成 beforeMount() Vue模板已经编译好,但还没有挂载到页面 mounted() 模板挂载完成 更新 beforeUpdate() 页面的数据还是旧的数据,没有同步为最新的data数据 updated() 页面的数据已经更新到最新的data数据了 销毁 beforeDestory() Vue即将销毁,但当前的数据和方法都还是可用状态 destoryed() Vue已经销毁,所有数据和方法都不可用了","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"webpack基础","slug":"webpack基础","date":"2018-10-13T06:22:50.000Z","updated":"2019-11-15T04:56:44.318Z","comments":true,"path":"2018/10/13/webpack基础/","link":"","permalink":"https://zhuyiting.xyz/2018/10/13/webpack%E5%9F%BA%E7%A1%80/","excerpt":"","text":"webpackwebpack是一个现代的JavaScript应用程序的静态模块打包器,当webpack处理应用程序时,它会递归的构建一个依赖关系,然后将模块打包成一个或多个bundlewebpack有四个核心概念:entry,output,loader,plugins entryentry(入口)之时webpack应该使用哪个模块,来作为构建内部依赖的开始123456789//单个入口语法const config=&#123; entry:\"./src/main.js\"&#125;//对象语法const config=&#123; app:\"./src/main.js\", vendors:\"./src/vendors.js\"&#125; outputoutput属性会告诉webpack在哪里输出bundle,以及如何命名,默认设置./list1234567const config=&#123; entry:\"./src/main.js\" output:&#123; filename:\"bundle.js\", path:path.resolve(_dirname,'dist') &#125;&#125; loaderloader让webpack可以处理那些非JavaScript的文件,例如开发ES6时,通过loader将ES6语法转成ES512345678910111213141516171819const config = &#123;entry: \"./src/main.js\",output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, 'dist')&#125;,module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: [ presets: [\"env\"] ] &#125; ]&#125;&#125; pluginsloader被用于转换某些类型的模块,而插件则可以做更多的事,包括打包优化,压缩,定义环境变量等等12345678910111213141516171819// 通过 npm 安装const HtmlWebpackPlugin = require('html-webpack-plugin');// 用于访问内置插件 const webpack = require('webpack'); const config = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\" &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; webpack基本配置1234567891011121314151617181920212223242526const path = require('path'); module.exports = &#123; mode: \"development\", // \"production\" | \"development\" // 选择 development 为开发模式， production 为生产模式 entry: \"./src/main.js\", output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: [ presets: [\"env\"] ] &#125; ] &#125;, plugins: [ ... ]&#125; webpack新建项目前提有node.js环境 进入项目根目录执行npm init -y创建默认package.json文件, -y表示使用默认配置 npm install webpack webpack-cli –save-dev将webpack安装到本地项目,可以看到目录中会下载一些文件 新建项目结构app存放原始项目,public存放之后生成的浏览器可用的js代码,以及一个index.html 修改index.html文件123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;!-- 之后webpack打包会生成的bundle.js --&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/html&gt; 编写Geeter.js,改文件为项目文件123456module.exports=function()&#123; var greet=document.createElement('div'); greet.textContent='Hello Webpack'; return greet; // 随便写一个&#125; 在main.js中引入1234// 引入jsconst greeter=require('./Greeter')// 查询id为root的标签,在这个标签中拼接Greeter返回的内容document.querySelector('#root').appendChild(greeter()); 打包webpack app/main.js -o public/bundle.js注意webpack要全局安装打包完,项目内就会出现bundle.js在运行index.html就ok啦 总结Webpack是一款前端的模块化打包工具,就像java可以把项目打包为jar,webpack可以将模块化的前端打包成一个jswebpack需要node.js的环境,","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://zhuyiting.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zhuyiting.xyz/tags/webpack/"},{"name":"打包管理","slug":"打包管理","permalink":"https://zhuyiting.xyz/tags/%E6%89%93%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"Vue组件基础","slug":"Vue组件基础","date":"2018-09-30T07:33:56.000Z","updated":"2019-11-15T04:56:17.221Z","comments":true,"path":"2018/09/30/Vue组件基础/","link":"","permalink":"https://zhuyiting.xyz/2018/09/30/Vue%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"组件基础1. 什么是组件组件是可重复使用的Vue实例,开发中可以把经常重复的功能封装为组件.组件可以将整个页面尽显模块化分割.组件分为全局组件和局部组件. 2. 基本实例全局组件的创建方式 使用Vue.extend来创建全局的Vue组件 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; // 使用组件,直接把组件的名字以HTML标签形式引入 //注意: HTML大小写忽略,所以驼峰命名失效,要采用 xxx-xxx来代替xxxXxx &lt;my-con1&gt;&lt;/my-con1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 注册组件Vue.component('组件名称',组件对象) Vue.component('myCon1',Vue.extend(&#123; // 使用Vue.extend创建全局组件 // 通过template属性指定组件要展示的HTML结构 template: '&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;' &#125;) ) // 创建Vue实例 var vm=new Vue(&#123;&#125;);&lt;/script&gt; 1234567891011// 定义一个名为 button-counter 的新组件//使用Vue.component函数创建组件,该函数有两个参数, 第一个是组件的名称,第二个是以对象的形式,描述一个组件//因为组件是可复用的Vue实例,所以与new Vue接收相同的选项Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;) 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;my-con3&gt;&lt;/my-con3&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;在Vue实例外部定义组件,使用template标签,这种方式有代码提示,好用,推荐&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; // 注册组件Vue.component('组件名称',组件对象) Vue.component('myCon3',&#123; // 使用Vue.extend创建全局组件 // 通过template属性指定组件要展示的HTML结构 template: '#tmp1' &#125;) // 创建Vue实例 var vm=new Vue(&#123;&#125;);&lt;/script&gt; 局部组件,在Vue实例内部的components方法内创建,只有这个Vue实例可以使用 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\"&gt; &lt;my-con&gt;&lt;/my-con&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;在Vue实例外部定义组件,使用template标签,这种方式有代码提示,好用,推荐&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; var vm=new Vue(&#123; components:&#123; myCon:&#123; template:'#tmp1' &#125; &#125; &#125;);&lt;/script&gt; 注意: 无论使用什么方式, 模板最外层只能用一个根标签包含 3. 组件复用组件的优点在于重复利用注意:复用组件内的data必须是一个函数,如果是一个对象,组件之间会相互影响(多个组件会共用一个对象),使用函-数会分别管理数据vue提供component标签来有用组件 123456789&lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;在Vue实例外部定义组件,使用template标签,这种方式有代码提示,好用,推荐&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id=\"app\"&gt;&lt;component :is=\"tmp1\"&gt;&lt;/component&gt;&lt;/div&gt; 4. 组件之间的通信组件也需要数据的通信,而vue中子组件默认无法访问父组件的数据 父子组件之propsprops是一个单向的数据流,只允许父组件向子组件传值,可以是数值、字符、布尔值、数值、对象。 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"app\"&gt; &lt;com1 v-bind:parentmsg=\"msg\"&gt;&lt;/com1&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'hello' &#125;, components:&#123; com1:&#123; template:\"#tmp1\", // 定义一个参数接收 props:['parentmsg'] &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"ES6基础","slug":"ES6基础","date":"2018-09-25T06:06:54.000Z","updated":"2019-11-15T05:12:20.931Z","comments":true,"path":"2018/09/25/ES6基础/","link":"","permalink":"https://zhuyiting.xyz/2018/09/25/ES6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"ES6基础ES6全称ECMAScript6.0 是JavaScript的下一个版本标准,但现在已经有很多浏览器支持了ES6 JavaScript只是Oracle公司注册的一个商标,它的正式名称就是ECMAScript let和constES6新增了两个重要的关键字:let和constlet声明的变量只在let所在代码块有效const声明一个只读常量,不可修改 变量的结构赋值12345678910111213141516171819//es5中对变量的赋值var data = &#123;userName: 'aaaa', password: 123456&#125;var userName = data.userNamevar password = data.passwordconsole.log(userName)console.log(password)var data1 = ['aaaa', 123456]var userName1 = data1[0]var password1 = data1[1]console.log(userName1)console.log(password1)//es6中的解构赋值const &#123;userName, password&#125; = &#123;userName: 'aaaa', password: 123456&#125;console.log(userName)console.log(password)const [userName1, password1] = ['aaaa', 123456]console.log(userName1)console.log(password1) ES6模块化ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 的模块化分为导出（export） 与导入（import）两个模块。 import命令特性 只读:可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。 单例模式 静态执行模式:不支持import的值为变量或者表达式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhuyiting.xyz/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhuyiting.xyz/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://zhuyiting.xyz/tags/ES6/"}]},{"title":"Vue基本指令","slug":"Vue基本指令","date":"2018-09-15T11:40:33.000Z","updated":"2019-11-15T04:56:01.589Z","comments":true,"path":"2018/09/15/Vue基本指令/","link":"","permalink":"https://zhuyiting.xyz/2018/09/15/Vue%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Vue基本指令1:v-cloak能够解决插值表达式闪烁问题 2:v-text和功能一样,但是没有闪烁问题可以在插值前后有内容,v-text会覆盖元素中原本的内容 3:v-html将数据已HTML格式输出 4:v-bindv-bind: 是Vue中提供的用于绑定属性的指令v-bind可以缩写为:用法: v-bind:title(需要绑定的属性) 可简写为:title(需要绑定的属性) 绑定元素设置class样式 用数组:class=&quot;[&#39;class1&#39;,&#39;class2&#39;]&quot; 三元表达式:class=&quot;[&#39;class1&#39;,&#39;class2&#39;,flag?&#39;class3&#39;:&#39;&#39;]&quot; 数组中嵌套对象:class=&quot;[&#39;class1&#39;,&#39;class2&#39;,{&#39;class3&#39;:boolean}]&quot; 直接使用对象:class=&quot;{class1:true,class2:true,class3:false}&quot;(可以在data中定义classobj:{class1:true,class2:true,class3:false}然后在属性中直接饮用:class=&quot;classobj&quot;) 5:v-onv-on:是Vue中提供的用于绑定事件的指令v-on可以缩写为@用法: v-on:click=”show”需要在Vue对象中定义show方法12345method:&#123; show:function()&#123; alert(\"hello\"); &#125;&#125; 时间修饰符 .stop:阻止冒泡; .prevent:阻止默认事件的发生; .capture:捕获冒泡,有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。 .self:将事件绑定到自身,只有自身能被触发,通常用于避免冒泡事件的影响; .once:设置事件只能触发一次,比如按钮的点击; .passive:用于对DOM的默认事件进行性能优化,比如超出最大范围的滚动条滚动; .native:把vue组件转化成一个普通的HTML标签,对普通的HTML标签是没有任何作用的; 6:v-modlev-modle:是Vue中用于数据双向绑定的指令注意: 只能运用在表单元素中 v-bind只能实现数据单向绑定,从M=&gt;V 7:v-forv-for是循环迭代指令 用法: 迭代数组123456789101112 &lt;ul&gt; &lt;li v-for=\"(item i) in list\"&gt; 索引:&#123;&#123;i&#125;&#125;----姓名:&#123;&#123;item.name&#125;&#125;----年龄:&#123;&#123;item.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; ``` 2. 迭代对象中的属性 ```html &lt;!-- 循环遍历对象的属性 --&gt; &lt;div v-for=\"(val,key,i) in list\"&gt; &#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;---&#123;&#123;i&#125;&#125; &lt;/div&gt; 迭代数字1&lt;p v-for=\"i in 10\"&gt;&#123;&#123;i&#125;&#125;&lt;/p&gt; v-for中key的使用注意(key相当于主键,是唯一的) v-for循环时,key属性只能用number或者string key在使用的时候必须使用v-bind绑定来指定key的值 8:v-ifv-if是条件渲染指令,v-if有更高的切换渲染开销.如果在运行时条件不太可能改变，则使用 v-if 较好. 用法 123&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 9:v-showv-show有更高的初始渲染开销 用法 123&lt;div v-show=\"ifShow\"&gt; show&lt;/div&gt;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"Vue概述","slug":"Vue概述","date":"2018-09-13T02:37:09.000Z","updated":"2019-11-15T04:55:59.125Z","comments":true,"path":"2018/09/13/Vue概述/","link":"","permalink":"https://zhuyiting.xyz/2018/09/13/Vue%E6%A6%82%E8%BF%B0/","excerpt":"","text":"概述什么是Vue.js Vue.js是目前最火的前端框架,React是最流行的一个前端框架(React除了开发网站,还可以开发手机APP,Vue语法也可以用于手机开发,需要借助于Weex) Vue.js是前端的主流框架之一,和Angular.js,React.js一起,并成为前端三大主流框架 Vue.js是一套构建用户界面的框架,只关注视图层,它易于上手,还便于第三方库或既有项目整合.(Vue有配套的第三方类库,可以整合起来做大型项目的开发) 前端的主要工作,负责MVC中的V层,主要工作就是制作前端页面效果. 为什么要学习前端框架 提高开发效率 提高开发效率的发展历程:原生JS-&gt;jQuery类库-&gt;前端模板引擎-&gt;Angular.js/Vue.js(能够帮助我们减少不必要的DOM操作,提高渲染效率;双向数据绑带[通过框架提供的指令,前端程序员只需要关心业务逻辑,不必关心DOM是如何渲染了]); 在Vue.js中,一个核心的概念,就是让用户不再操作DOM元素,解放了用户的双手,让程序员可以更多的关注业务逻辑 框架和库的区别 框架: 是一套完整的解决方案;对项目的侵入性较大,项目如果需要更换框架,则需要重新架构整个项目. node中的express 库: 提供某一个小功能,对项目的侵入性小,如果某个库无法完成某些需求,可以很容易的切换到其他库实现需求. 后端(Node)中的MVC与前端中的MVVM之间的区别 MVC是后端的分层开发概念 MVVM是前端视图层的概念,主要关注与视图层分层,也就是说:MVVM把前端的视图层,把每个页面分成了M,V和VM层,VM是MVVM思想的核心,因为VM层是M与V之间的调度者. M保存的是每个页面中单独的数据 V就是每个页面的HTML结构 VM是一个调度者,分割了V和M,每当V层需要获取或保存数据的时候,都需要VM做中间处理. 前端页面使用MVVM的思想,主要是为了使开发更方便,VM提供了数据的双向绑定 Vue中和MVVM之间的对应关系 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.导入Vue的包 --&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- MVVM中的V层 --&gt; &lt;!-- new的Vue实例,会控制这个元素中的内容 --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; // 2.创建一个Vue的实例 // 当我们导入包之后,在浏览器的内存中,就多了一个Vue的构造函数 // 这个vue对象就是MVVM中的调度者 // 其中的date就是MVVM中的M 数据 var vue = new Vue(&#123; el:'#app', //标书,当前我们new的这个vue实例,要控制页面上的哪个区域 data:&#123; //data属性中,存放的是el中要用到的数据 msg:\"Hello Vue.js\" //通过Vue提供的指令,很方便的就能把数据渲染到页面上,程序员不需要操作DOM元素了 &#125; &#125;) &lt;/script&gt; &lt;/html&gt;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://zhuyiting.xyz/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/tags/Vue-js/"}]},{"title":"jQuery笔记","slug":"jQuery笔记","date":"2018-08-14T01:40:22.000Z","updated":"2019-11-15T04:53:44.046Z","comments":true,"path":"2018/08/14/jQuery笔记/","link":"","permalink":"https://zhuyiting.xyz/2018/08/14/jQuery%E7%AC%94%E8%AE%B0/","excerpt":"","text":"jQuery1. 概念:jQuery是一个优秀的JavaScript库,而非JavaScript,它是轻量级的库. 2. 作用jQuery使用户能更方便的处理HTML、events、实现动画效果,并且方便的为网站提供Ajax交互, 3. 优势它的文档说明齐全,而且应用详细,同时还有很多成熟的插件可供选择 4. 核心概念write less,do more 5. 语法 jQuery入口函数1234567$(document).ready(function()&#123; // 执行代码&#125;);或者$(function()&#123; // 执行代码&#125;); 1234//对比JavaScript入口函数:window.onload = function () &#123; // 执行代码&#125; jQuery选择器 元素选择器$(&quot;p&quot;) #id选择器$(&quot;#id&quot;) .class选择器$(&quot;.class&quot;) DOM操作 捕获和设置 text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容(包含HTML标签) val() - 设置或返回表单字段的值 attr() - 获取属性 添加和删除HTML元素 append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 获取和操作CSS addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 遍历DOM树 parent() - 方法返回被选元素的直接父元素。 parents() - 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。 parentsUntil() - 方法返回介于两个给定元素之间的所有祖先元素。 children() - 方法返回被选元素的所有直接子元素。 find() - 方法返回被选元素的后代元素，一路向下直到最后一个后代。 siblings() - 方法返回被选元素的所有同胞元素。 next() - 方法返回被选元素的下一个同胞元素。 nextAll() - 方法返回被选元素的所有跟随的同胞元素。 nextUntil() - 方法返回介于两个给定参数之间的所有跟随的同胞元素。 prev() , prevAll() , prevUntil() - 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhuyiting.xyz/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhuyiting.xyz/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://zhuyiting.xyz/tags/jQuery/"}]},{"title":"HTML5基础","slug":"HTML5基础","date":"2018-08-13T01:15:32.000Z","updated":"2019-11-15T05:12:38.146Z","comments":true,"path":"2018/08/13/HTML5基础/","link":"","permalink":"https://zhuyiting.xyz/2018/08/13/HTML5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTML5基础HTML5是最新的HTML标准 HTML5新特性 在HTML5中,添加了新的HTML标签,比如&lt;article&gt;、&lt;footer&gt;、&lt;header&gt;、&lt;nav&gt;、&lt;section&gt;等 section标签:&lt;section&gt;表示文档中的一个区域.比如章节、页眉、页脚或文档中的其他部分,一般来说会包含一个标题一般来说,一个&lt;section&gt;标签应该出现在文档大纲中. article标签:&lt;article&gt;标签定义独立的内容,常用在论坛帖子,报纸文章,博客条目,用户评论等独立内容项目中. nav标签:&lt;nav&gt;标签定义导航栏链接部分,描述一个包含多个链接的区域. header标签:&lt;header&gt;标签定义文档页眉,通常是一些引导和导航信息 footer标签:&lt;footer&gt;标签定义section或document的页脚 aside标签:&lt;aside&gt;标签标示一个页与其余页面几乎无关的内容,表现为侧边栏或者嵌入内容 figure标签:&lt;figure&gt;标签规定独立的流(图片,图像,代码等) HTML视频音频在以前,想要在网页上展示视频音频通常需要使用flash这样的插件,很麻烦,而HTML5中提供了音频视频的标准接口 视频标签&lt;video&gt;video元素允许多个source子元素,可以链接不同的视频文件,浏览器自动使用第一个可使用的视频(用来引入多种格式以支持不同浏览器访问) 1234&lt;video&gt; &lt;source src=\"\" type=\"video/mp4\"&gt; &lt;source src=\"\" type=\"video/webm\"&gt;&lt;/video&gt; 视频字幕的使用在&lt;video&gt;标签中使用&lt;track&gt;元素引入字幕.vtt格式的字幕文件 1234&lt;video&gt; &lt;source src=\"\" type=\"video/mp4\"&gt; &lt;track src=\"video_ch.vtt\" srclang=\"zh\" kind=\"subtitles\" label=\"中文\" default&gt;&lt;video&gt; .vtt内容格式 123456WEBVTT 00:00:01.000 --&gt; 00:00:04.000Don&apos;t play games in class！00:00:05.000 --&gt; 00:00:09.000Study hard and make progress every day！ 音频标签&lt;audio&gt;audio标签也支持多种source子标签 1234&lt;audio&gt; &lt;source src=\"\" type=\"audio/mpeg\"&gt; &lt;source src=\"\" type=\"audio/wav\"&gt;&lt;/audio&gt; HTML5拖放拖放是HTML标准的组成部分,任何元素都能进行拖放 首先要定义元素的draggable属性为true,再加上全局处理事件函数ondragstart1&lt;img draggable=\"true\" ondragstart=\"drag(event)\" /&gt; 定义拖放数据每个drag event都有一个dataTransfer属性保存事件数据,setData()方法添加一个项目的拖拽数据 123function drag(ev)&#123; ev.dataTransfer.setData(\"Text\",ev.target.id);&#125; 定义一个放置区ondragover事件规定了在哪里放置拖动的数据,默认阻止,我们要开启 123function allowDrop(ev) &#123; ev.preventDefault();&#125; 进行放置放置被拖动数据时,会发生drop事件 12345678function drop(ev) &#123; //调用 preventDefault() 来避免浏览器对数据的默认处理 ev.preventDefault(); //通过 dataTransfer.getData(\"Text\") 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 var data = ev.dataTransfer.getData(\"Text\"); //被拖数据是被拖元素的 id (\"drag1\"),把被拖元素追加到放置元素（目标元素）中 ev.target.appendChild(document.getElementById(data));&#125; Canvas画布Canvas可以用于图形表示,图像绘制,游戏制作,,需要通过js控制来绘制 使用来操作HTML图形图标 HTML5表单 datalist元素,使用 &lt;datalist&gt; 元素来为表单小部件提供建议的、自动完成的值，并使用一些 &lt;option&gt; 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 &lt;input&gt;元素)。 123456789&lt;input type=\"text\" name=\"myColor\" id=\"myColor\" list=\"mySuggestion\"&gt; &lt;datalist id=\"mySuggestion\"&gt; &lt;option value=\"black\"&gt; &lt;option value=\"blue\"&gt; &lt;option value=\"green\"&gt; &lt;option value=\"red\"&gt; &lt;option value=\"white\"&gt; &lt;option value=\"yellow\"&gt; &lt;/datalist&gt; autocomplete属性规定表单是否应该启用自动完成功能,当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 form属性,适用所有input标签,让其可以在form域之外,但仍属于form的一部分. multiple属性规定输入域可以选择多个值,适用于以下input:email和file novalidate属性,规定在表单提交时不应该验证form域 pattern属性,指定正则表达式,用于验证 required属性规定提交时不能为空 HTML5输入类型 input-email类型,提交时自动验证 input-url类型,自动验证url域的值 input-number,允许设置最大最小值和数字间隔 input-range类型,显示为滑动条,也有最大最小值和数字间隔 input-Date Pickers时间选择器 input-search搜索域 input-color颜色选择器 Web Storage本地存储由于Cookie的限制,HTML5支持了两种Web Storage:永久性的本地存储（localStorage）和会话级别的本地存储（sessionStorage） HTML5文件上传在 HTML4 标准中文件上传控件只接受一个文件，而在新标准中，只需要设置 multiple，就支持多文件上传。按住 Ctrl 或者 Shift 即可选择多个文件。可以限制文件的上传类型使用accept属性,使用accept接受一个逗号分隔的 MIME 类型字符串。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://zhuyiting.xyz/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://zhuyiting.xyz/tags/HTML/"}]},{"title":"SpringBoot+Mybatis之动态SQL","slug":"SpringBoot-Mybatis之动态SQL","date":"2018-07-25T08:28:07.000Z","updated":"2019-11-15T04:55:22.018Z","comments":true,"path":"2018/07/25/SpringBoot-Mybatis之动态SQL/","link":"","permalink":"https://zhuyiting.xyz/2018/07/25/SpringBoot-Mybatis%E4%B9%8B%E5%8A%A8%E6%80%81SQL/","excerpt":"","text":"SpringBoot+Mybatis之动态SQL在ssm项目中,使用xml文件利用标签,可以实现复杂的动态sql语句,那在SpringBoot+Mybatis项目下,注解的方式如何实现动态sql 1. 使用&lt;script&gt;标签包裹XML方式的语句12345678910111213141516public interface UserMapper &#123; @Select(\" &lt;script&gt; SELECT * FROM myuser \" + \" &lt;where&gt; \" + \" &lt;if test='uid!=null' &gt; \" + \" uid=#&#123;uid&#125; \" + \" &lt;/if&gt; \" + \" &lt;if test='uname!=null' &gt; \" + \" and uname like CONCAT('%',#&#123;uname&#125;,'%') \" + \" &lt;/if&gt; \" + \" &lt;if test='usex!=null' &gt; \" + \" and usex=#&#123;usex&#125; \" + \" &lt;/if&gt; \" + \" &lt;/where&gt; \" + \" &lt;/script&gt; \") List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user);&#125; 这个方式我们比较熟悉,但是用字符串包裹&lt;script&gt;语句就变得很复杂, 难以维护,所以不推荐, 这样的写法和XML的写法没有什么本质区别. 2. 在Mapper中创建内部类,构建sql@SelectProvider等@XXXProvider注解允许我们指定一个类的方法来返回sql语句 123456789101112131415161718192021public interface UserMapper &#123; @SelectProvider(type = UserMapperProvider.class , method = \"userInfo\") List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user); class UserMapperProvider &#123; public String userInfo(User user) &#123; StringBuffer sql = new StringBuffer(); sql.append(\" SELECT * FROM myuser where 1=1 \"); if (user.getUid() != null) &#123; sql.append(\" AND uid=#&#123;uid&#125; \"); &#125; if (user.getUname() != null) &#123; sql.append(\" AND uname like CONCAT('%',#&#123;uname&#125;,'%') \"); &#125; if (user.getUsex() != null) &#123; sql.append(\" AND usex=#&#123;usex&#125; \"); &#125; return sql.toString(); &#125; &#125;&#125; 3. 创建内部类,使用结构化SQL方法1234567891011121314151617181920212223public interface UserMapper &#123; @SelectProvider(type = UserMapperProvider.class , method = \"userInfo\") List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user); class UserMapperProvider &#123; public String userInfo(User user) &#123; return new SQL()&#123;&#123; SELECT(\" * \"); FROM(\" myuser \"); if (user.getUid() != null) &#123; WHERE(\" uid=#&#123;uid&#125; \"); &#125; if (user.getUname() != null) &#123; WHERE(\" uname like CONCAT('%',#&#123;uname&#125;,'%') \"); &#125; if (user.getUsex() != null) &#123; WHERE(\" AND usex=#&#123;usex&#125; \"); &#125; &#125; &#125;.toString(); &#125; &#125;&#125; 总结:方法1是XML语法的注解方式实现,方法2和方法3比较相似,可读性高,易于维护, 方法2适用面可能更广,而且更加接近我们熟悉的自然sql语法, 推荐使用方法2","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zhuyiting.xyz/tags/SpringBoot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhuyiting.xyz/tags/MyBatis/"}]},{"title":"SpringBoot+MyBatis整合","slug":"SpringBoot-MyBatis整合","date":"2018-07-12T06:25:16.000Z","updated":"2019-11-15T04:55:19.367Z","comments":true,"path":"2018/07/12/SpringBoot-MyBatis整合/","link":"","permalink":"https://zhuyiting.xyz/2018/07/12/SpringBoot-MyBatis%E6%95%B4%E5%90%88/","excerpt":"","text":"SpringBoot+MyBatis整合以往我们需要用到MyBatis时,需要繁琐的xml配置,而且很容易造成spring和mybatis的jar冲突, 非常麻烦而在SpringBoot下,只需要添加mybatis的starter启动器,就能很方便的和spring整合了,无需xml配置 1. 添加mybatis的starter包12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 2. 在application.properties中添加数据源123456mybatis.type-aliases-package=com.ycj.entityspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmdemo?characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456 springboot会自动加载application.properties然后注入DateSource类中 3. 在springboot启动类上添加Mapper包的扫描注解123@SpringBootApplication@MapperScan(\"com.ycj.mapper\")public class SpringBootApplicationMain 注意:也可以在每一个mapper接口上添加@Mapper注解, 不过比较麻烦,并且容易遗漏. 推荐直接扫描包 4. 添加mapper接口,并用注解实现1234public interface UserMapper &#123; @Select(\" SELECT * FROM myuser WHERE uname Like CONCAT('%',#&#123;uname&#125;,'%') \") List&lt;Map&lt;String,Object&gt;&gt; userInfo(User user);&#125; 5. 完善代码,service层和controller层123456@ResponseBody@RequestMapping(\"/userInfo.do\")public List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user)&#123; List&lt;Map&lt;String, Object&gt;&gt; list=userService.userInfo(user); return list;&#125; 浏览器访问","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zhuyiting.xyz/tags/SpringBoot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhuyiting.xyz/tags/MyBatis/"}]},{"title":"SpringBoot入门","slug":"SpringBoot入门","date":"2018-07-03T07:55:05.000Z","updated":"2019-11-15T04:55:25.369Z","comments":true,"path":"2018/07/03/SpringBoot入门/","link":"","permalink":"https://zhuyiting.xyz/2018/07/03/SpringBoot%E5%85%A5%E9%97%A8/","excerpt":"","text":"SpringBoot简介SpringBoot是用来快速构建Spring+SpringMvc项目的框架,其设计就是为了尽可能的减少配置文件,快速开发spring应用 在使用springboot之前,我们开发一个web项目需要繁琐的配置, 还要担心jar的冲突和可行性 springboot让一切都变得简单 springboot内嵌Tomcat等web容器 提供starter简化maven配置 自动配置spring 无代码生成,无需xml配置 提供完善的项目测试 采用java类来配置 可以说 SpringBoot 是一个简便快捷强大的Spring+SpringMvc,也是目前非常主流的javaWeb技术 第一个SpringBoot采用maven项目创建springboot 新建maven项目,在pom.xml导入springboot所需包 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建springboot启动入口该启动类位于src下,且与controller,dao,service等包同级 1234567@SpringBootApplicationpublic class SpringBootApplicationMain &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootApplicationMain.class,args); &#125;&#125; 创建一个controller 123456789@Controller@RequestMapping(value = \"/user\", produces=\"application/json;charset=UTF-8\")@ResponseBodypublic class UserController &#123; @RequestMapping(\"/hello.do\") public String hello()&#123; return \"Hello SpringBoot\"; &#125;&#125; 运行启动类, 无需XML配置, 无需tomcat配置, 创建快速,一键启动4. 浏览器访问 SpringBoot项目的基础依赖关系在项目目录使用命令:mvn dependency:tree 对于SpringBoot中的starter的理解starter可以理解为启动器,它是一系列可以直接集成进springboot应用的依赖包的集合,只需要一站式的添加starter包,而不需要配置XML,和解决包依赖、包冲突的问题。 SpringBoot接口开发JSON接口开发在controller类上使用@RestController 或者在controller类的方法上加上@ResponseBody","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zhuyiting.xyz/tags/SpringBoot/"}]},{"title":"SSM框架整合","slug":"SSM框架整合","date":"2018-06-16T12:50:53.000Z","updated":"2019-11-15T05:20:38.223Z","comments":true,"path":"2018/06/16/SSM框架整合/","link":"","permalink":"https://zhuyiting.xyz/2018/06/16/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","excerpt":"","text":"SSM框架整合Spring+SpringMVC+MyBatis框架整合 1. 创建maven项目创建一个maven项目,在pom.xml文件中导入相关包基本包有: mysql连接驱动jar mybatis的jar mybatis与spring整合的jar spring相关jar springmvc的jar项目中会用到的日志记录包: log4j的jar slf4j的接口jar slf4j和log4j的整合jar项目中会用到的单元测试包: junit的jar可能会用到jsp时需要的包: servlet的jar servlet-jsp的jar jstl标签支持的jar 2. 创建项目结构 项目 pom.xml src test main java entity dao service impl controller util resources mapper mapper.xml jdbc.properties mybatis-config.xml applicationContext.xml springmvc.xml log4j.properties webapp WEB-INF web.xml index.jsp index.html 3. 配置各个框架的配置文件 配置web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\"&gt; &lt;!--&lt;display-name&gt;ssmdemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;--&gt; &lt;!-- 加载spring的ApplicationContext容器 --&gt; &lt;context-param&gt; &lt;!-- 加载src目录下的 applicationContext.xml文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring中的监听器,可以在启动项目时自动装配spring的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 加载springmvc的 DispatcherServlet (请求分发器)--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 需要加载的springmvc-servlet.xml配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理*.do的URL --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置过滤器,解决请求乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--拦截所有请求,过滤乱码--&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 配置spring监听器来创建容器,加载spring配置文件 配置springmvc分发器,加载springmvc配置文件 配置过滤器,解决乱码 applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--&amp;lt;!&amp;ndash;开启注解扫描&amp;ndash;&amp;gt; &lt;context:component-scan base-package=\"com.ycj\"/&gt; &amp;lt;!&amp;ndash;注解配置&amp;ndash;&amp;gt; &lt;context:annotation-config/&gt;--&gt; &lt;!--引入数据库properties文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;!--&amp;lt;!&amp;ndash;配置数据源&amp;ndash;&amp;gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssmdemo?characterEncoding=utf8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt;--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;pwd&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置spring整合mybatis的工厂类对象--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.ycj.entity\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--扫描Dao接口,装配mapper.xml--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.ycj.dao\"/&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;!--指定需要扫描的包,使注解生效,dao包在上面已经扫描, 不需要了--&gt; &lt;context:component-scan base-package=\"com.ycj.service\"/&gt; &lt;!--事务管理--&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--注入DataSource--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--开启事务注解扫描--&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt;&lt;/beans&gt; 配置mysql数据源 配置spring-mybatis整合工厂类对象 加载数据源 扫描实体包 扫描mapper.xml文件 配置mapper注入工厂 扫描dao层包 加载spring-mybatis整合工厂类对象 扫描有注解的包,使注解生效 开启事务管理 开启事务管理注解扫描 配置springmvc-servlet 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--配置spring创建I容器时要扫描的包--&gt; &lt;context:component-scan base-package=\"com.ycj.controller\" /&gt; &lt;!--开启注解驱动--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置Spring MVC的视图解析器 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 有时我们需要访问JSP页面,可理解为在控制器controller的返回值加前缀和后缀,变成一个可用的URL地址 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 扫描控制器包 开启注解驱动 配置视图解析器 包版本参考: 12345678910111213&lt;!--spring版本--&gt;&lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;&lt;!--mybatis版本--&gt;&lt;mybatis.version&gt;3.5.1&lt;/mybatis.version&gt;&lt;!--日志管理包--&gt;&lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;&lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;&lt;!--json版本--&gt;&lt;fastjson.version&gt;2.9.8&lt;/fastjson.version&gt;&lt;!--mysql驱动版本--&gt;&lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;&lt;!--mybatis-spring整合包版本--&gt;&lt;mybatis-spring.version&gt;1.3.2&lt;/mybatis-spring.version&gt; 4. 错误记录 错误1:tomcat报错org.apache.tomcat.util.modeler.BaseModelMBean.invoke Exception invoking method manageApp解决方案:检查maven包是否正确,clean-&gt;compile进入maven仓库删除相应包, 重新下载 错误2:java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener解决方案:项目包中存在,打开项目结构,在artifacts,将可选项添加到输出文件中,可以看到WEB-INF中多了一个lib文件,存放依赖的包. 找到原因,没有将项目中的包添加到输出war中 错误3:无法接收json数据解决方案:spring5以上版本不需要在参数前添加@RequestBody,删除注解后成功 错误4:无法返回json格式数据解决方案:配置json转换器,需要正确的包(参考spring5.1.5;fastjson2.9.8)spring5.0以上版本,只要开启注解驱动即可&lt;mvc:annotation-driven /&gt;","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhuyiting.xyz/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zhuyiting.xyz/tags/SpringMVC/"}]},{"title":"Spring之SpringMVC","slug":"Spring之SpringMVC","date":"2018-05-29T03:35:25.000Z","updated":"2019-11-15T04:55:15.871Z","comments":true,"path":"2018/05/29/Spring之SpringMVC/","link":"","permalink":"https://zhuyiting.xyz/2018/05/29/Spring%E4%B9%8BSpringMVC/","excerpt":"","text":"Spring之SpringMVCWeb应用的分层通常是MVC,对应着数据层-视图层-控制层SpringMVC就是控制层框架 SpringMVC工作流程Spring MVC 框架主要由 DispatcherServlet、处理器映射、控制器、视图解析器、视图组成 客户端请求提交到 DispatcherServlet。 由 DispatcherServlet 控制器寻找一个或多个 HandlerMapping，找到处理请求的 Controller。 DispatcherServlet 将请求提交到 Controller。 Controller 调用业务逻辑处理后返回 ModelAndView。 DispatcherServlet 寻找一个或多个 ViewResolver 视图解析器，找到 ModelAndView 指定的视图。 视图(JSP等视图层)负责将结果显示到客户端。 从宏观角度考虑，DispatcherServlet 是整个 Web 应用的控制器；从微观考虑，Controller 是单个 Http 请求处理过程中的控制器，而 ModelAndView 是 Http 请求过程中返回的模型（Model）和视图（View）。 SpringMVC的实现实例 在web.xml文件中配置部署DispatcherServlet 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;!-- 部署 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 加载springmvc-servlet.xml配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理所有URL --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 创建Controller类 123456public class LoginController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; return new ModelAndView(\"/WEB-INF/jsp/register.jsp\"); &#125;&#125; 创建springmvc-servlet.xml配置Controller的映射信息 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- LoginController控制器类，映射到\"/login\" --&gt; &lt;bean name=\"/login\" class=\"controller.LoginController\"/&gt;&lt;/beans&gt; 在配置文件中定义视图解析器(ViewResolver) 123456&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" &gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 上述视图解析器配置了前缀和后缀两个属性，因此Controller中只需要返回login,视图解析器就会自动添加前缀和后缀 通过注释实现SpringMVC传统风格的控制器不仅需要在配置文件中部署映射，而且只能编写一个处理方法，不够灵活。在基于注解的控制器类中可以编写多个处理方法，进而可以处理多个请求（动作），这就允许将相关的操作编写在同一个控制器类中，从而减少控制器类的数量，方便以后的维护。基于注解的控制器不需要在配置文件中部署映射，仅需要使用 RequestMapping 注释类型注解一个方法进行请求处理。 注释实现的Controller类 12345678910111213141516171819202122232425262728/*** “@Controller”表示 IndexController 的实例是一个控制器** @Controller相当于@Controller(@Controller) 或@Controller(value=\"@Controller\")*/@Controller@RequestMapping(value=\"/index\")public class IndexController &#123; // 处理请求的方法 @RequestMapping(value = \"/login\") public String login(HttpSession session,HttpServletRequest request)&#123; /** * login代表逻辑视图名称，需要根据Spring MVC配置 * 文件中internalResourceViewResolver的前缀和后缀找到对应的物理视图 */ session.setAttribute(\"skey\", \"session范围的值\"); session.setAttribute(\"rkey\", \"request范围的值\"); return \"login\"; &#125; @RequestMapping(\"/register\") public String register(Model model) &#123; /*在视图中可以使用EL表达式$&#123;success&#125;取出model中的值*/ // model是一个包含 Map 的 Spring 框架类型。 // 可以保存数据,然后在视图层用EL表达式提取 model.addAttribute(\"success\", \"注册成功\"); return \"register\"; &#125;&#125; 使用注释需要在配置文件开启注释扫描 12&lt;!-- 使用扫描机制扫描控制器类，控制器类都在controller包及其子包下 --&gt;&lt;context:component-scan base-package=\"controller\" /&gt; SpringMVC获取参数 把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。适用于 get 和 post 12345678910111213@RequestMapping(\"/register\")public String register(String uname,String upass,Model model) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; logger.info(\"成功\"); return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; logger.info(\"失败\"); // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过一个实体 Bean 来接收请求参数，Bean 的属性名称必须与请求参数名称相同.适用于 get 和 post1234567891011@RequestMapping(\"/login\")public String login(UserForm user, HttpSession session, Model model) &#123; if (\"zhangsan\".equals(user.getUname()) &amp;&amp; \"123456\".equals(user.getUpass())) &#123; session.setAttribute(\"u\", user); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"messageError\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 通过 HttpServletRequest 接收请求参数适用于 get 和 post 12345678910111213141516@RequestMapping(\"/register\")/*** 通过HttpServletRequest接收请求参数*/public String register(HttpServletRequest request,Model model) &#123; String uname = request.getParameter(\"uname\"); String upass = request.getParameter(\"upass\"); if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过 @PathVariable 获取 URL 中的参数,适用get123456789public String register(@PathVariable String uname,@PathVariable String upass,Model model) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过 @RequestParam 接收请求参数,适用于 get 和 post1234567891011public String register(@RequestParam String uname, @RequestParam String upass, Model model) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; logger.info(\"成功\"); return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过 @ModelAttribute 接收请求参数,适用于 get 和 post12345678910@RequestMapping(\"/register\")public String register(@ModelAttribute(\"user\") UserForm user) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 使用@ModelAttribute(\"user\")与model.addAttribute(\"user\",user)的功能相同 //register.jsp页面上可以使用EL表达式$&#123;user.uname&#125;取出ModelAttribute的uname值 return \"register\"; // 返回 register.jsp &#125;&#125; SpringMVC的转发和重定向转发是服务器行为，重定向是客户端行为。转发地址栏不变,请求数据不丢失,重定向地址栏改变,请求数据丢失 在 Spring MVC 框架中，重定向与转发的示例代码如下： 123456789101112131415@RequestMapping(\"/login\")public String login() &#123; //转发到一个请求方法（同一个控制器类可以省略/index/） return \"forward:/index/isLogin\";&#125;@RequestMapping(\"/isLogin\")public String isLogin() &#123; //重定向到一个请求方法 return \"redirect:/index/isRegister\";&#125;@RequestMapping(\"/isRegister\")public String isRegister() &#123; //转发到一个视图 return \"register\";&#125; SpringMVC的JSON数据交互Spring MVC 提供了 MappingJackson2HttpMessageConverter 实现类默认处理 JSON 格式请求响应。该实现类利用 Jackson 开源包读写 JSON 数据，将 Java 对象转换为 JSON 对象和 XML 文档，同时也可以将 JSON 对象和 XML 文档转换为 Java 对象。 在使用注解开发时需要用到两个重要的 JSON 格式转换注解，分别是 @RequestBody 和 @ResponseBody。 @RequestBody：用于将请求体中的数据绑定到方法的形参中，该注解应用在方法的形参上。把传来的JSON数据转换为响应java对象 @ResponseBody：用于直接返回 return 对象，该注解应用在方法上。表示该方法返回一个JSON格式数据","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zhuyiting.xyz/tags/SpringMVC/"}]},{"title":"Spring之事务管理","slug":"Spring之事务管理","date":"2018-05-21T11:46:10.000Z","updated":"2019-11-15T04:55:10.033Z","comments":true,"path":"2018/05/21/Spring之事务管理/","link":"","permalink":"https://zhuyiting.xyz/2018/05/21/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","excerpt":"","text":"Spring之事务管理什么是事务,就是一些列的步骤, 是一个整体,要么全都完成要么全都不完成.一个步骤失败,就要把已经完成的步骤全部回滚,回到没有运行之前.比如:银行取钱,你账户金额减少-&gt;银行ATM出钱, 要么两个都要完成,要么两个都不完成事务有四个特性: 原子性:事务是一些列步骤的组成,是一个整体,不可以分割 一致性:事务要么全部完成,要么全部不失败, 不能一部分完成一部分失败 隔离性: 持久性:一旦事务完成,结果不会受到影响,通常事务的结果会写入持久存储器 Spring的事务管理, 是基于AOP面向切面编程来实现的. Spring事务管理的三个核心接口 PlatformTransactionManager该接口是一个事务管理器,用于管理事务,提供了三个事务操作方法: TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。 void commit（TransactionStatus status）：用于提交事务。 void rollback（TransactionStatus status）：用于回滚事务。在项目中，Spring 将 xml 中配置的事务详细信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。 TransactionDefinition该接口是描述事务的对象,提供了五个事务相关信息的获取方法: String getName()：获取事务对象名称。 int getIsolationLevel()：获取事务的隔离级别。 int getPropagationBehavior()：获取事务的传播行为。 在事务管理过程中，传播行为可以控制是否需要创建事务以及如何创建事务。 int getTimeout()：获取事务的超时时间。 boolean isReadOnly()：获取事务是否只读。通常情况下，数据的查询不会改变原数据，所以不需要进行事务管理，而对于数据的增加、修改和删除等操作，必须进行事务管理。如果没有指定事务的传播行为，则 Spring3 默认的传播行为是 required。 TransactionStatus该接口是事务的状态,它描述事务在某一时间点上事务的状态信息.包含留个操作: void flush() 刷新事务 boolean hasSavepoint() 获取是否存在保存点 boolean isCompleted() 获取事务是否完成 boolean isNewTransaction() 获取是否是新事务 boolean isRollbackOnly() 获取是否回滚 void setRollbackOnly() 设置事务回滚 利用XML配置文件实现事务管理 新建Dao层接口 123456public interface AccountDao &#123; // 汇款 public void out(String outUser, int money); // 收款 public void in(String inUser, int money);&#125; 创建Dao的实现类Impl 1234567891011121314151617public class AccountDaoImpl implements AccountDao &#123; // 注入JdbcTemplate,使用SpringJDBC访问数据库 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; // 汇款的实现方法 public void out(String outUser, int money) &#123; this.jdbcTemplate.update(\"update account set money =money-?\" + \"where username =?\", money, outUser); &#125; // 收款的实现方法 public void in(String inUser, int money) &#123; this.jdbcTemplate.update(\"update account set money =money+?\" + \"where username =?\", money, inUser); &#125;&#125; 创建Service以及其实现类 123456789101112131415public interface AccountService &#123; // 转账 public void transfer(String outUser, String inUser, int money);&#125;/*-----------------------------------------------------*/public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); this.accountDao.in(inUser, money); &#125;&#125; 配置Spring的XML文件 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 配置数据源，读取properties文件信息 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\" /&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;!-- 配置dao --&gt;&lt;bean id=\"accountDao\" class=\"com.mengma.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt;&lt;/bean&gt;&lt;!-- 配置service --&gt;&lt;bean id=\"accountService\" class=\"com.mengma.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器，依赖于数据源 --&gt;&lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" rollback-for=\"Exception\" /&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" read-only=\"false\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt;&lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;!-- AspectJ表达式,代表com.mengma.service包中所有的方法 --&gt; &lt;aop:pointcut expression=\"execution(* com.mengma.service.*.*(..))\" id=\"txPointCut\" /&gt; &lt;!-- 切面：将切入点与通知整合 --&gt; &lt;aop:advisor pointcut-ref=\"txPointCut\" advice-ref=\"txAdvice\" /&gt;&lt;/aop:config&gt; 修改业务代码(模拟意外,比如断电) 123456public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); //模拟断电 int i = 1/0; this.accountDao.in(inUser, money);&#125; 测试 12345678910public class AccountTest &#123; @Test public void test() &#123; // 获得Spring容器，并操作 String xmlPath = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); AccountService accountService = (AccountService)applicationContext.getBean(\"accountService\"); accountService.transfer(\"zhangsan\", \"lisi\", 100); &#125;&#125; 利用Annotation注释方式实现事务管理省去xml中的编写通知和AOP编写 xml中添加注册驱动1&lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt; 还有要注意, 使用注释,需要在xml中开启注释处理器,指定扫描注释 在业务代码(目标事务)中添加注释@Transcational12345678910111213@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)public class AccountServiceImpl &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); // 模拟断电 int i = 1 / 0; this.accountDao.in(inUser, money); &#125;&#125;","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"}]},{"title":"Spring之JDBC支持","slug":"Spring之JDBC支持","date":"2018-05-15T02:32:03.000Z","updated":"2019-11-15T04:55:12.718Z","comments":true,"path":"2018/05/15/Spring之JDBC支持/","link":"","permalink":"https://zhuyiting.xyz/2018/05/15/Spring%E4%B9%8BJDBC%E6%94%AF%E6%8C%81/","excerpt":"","text":"Spring之JDBC支持Spring框架针对数据库开发的应用提供了JDBCTemplate类,该类是Spring对JDBC支持的核心,提供了所有对数据库操作功能的支持 DataSource主要功能是获取数据库的连接,还可以引入数据库缓冲池和分布式事务的支持,可以作为访问数据库资源的标准接口 SQLExceptionTranslator该接口负责对SQLException进行转换,通过配置,可以使JDBCTemplate在需要处理SQLException时,完成一些转译工作 Spring中JDBC的配置信息在Spring配置文件中配置 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http:/www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.dataSource.DriverManagerDataSource\"&gt; &lt;!--数据库驱动--&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;!--连接数据库的url--&gt; &lt;property name= \"url\" value=\"jdbc:mysql://localhost/spring\" /&gt; &lt;!--连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;!--连接数据库的密码--&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.jdbcTemplate\"&gt; &lt;!--默认必须使用数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--配置注入类(Dao层)--&gt; &lt;bean id=\"xxx\" class=\"xxx\"&gt; &lt;!-- 在Dao层中注入jdbcTemplate --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/&gt; &lt;/bean&gt; ...&lt;/beans&gt; 在Dao层中注入jdbcTemplate实例, 该实例提供了大量的查询和更新数据库的方法,比如query(),update()等","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"}]},{"title":"Spring之面向切面AOP","slug":"Spring之面向切面AOP","date":"2018-05-06T04:36:57.000Z","updated":"2019-11-15T04:55:01.925Z","comments":true,"path":"2018/05/06/Spring之面向切面AOP/","link":"","permalink":"https://zhuyiting.xyz/2018/05/06/Spring%E4%B9%8B%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2AOP/","excerpt":"","text":"Spring之面向切面AOPAOP 的全称是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。 AOP基本概念 Aspect(切面): 通常是一个类，里面可以定义切入点和通知 JointPoint(连接点): 程序执行过程中明确的点，即调用的方法,方法名、当前传入的参数值等等都会封装在JointPoint的实例对象中,一般作为参数代入到具体的切入方法中 Advice(通知): AOP在特定的切入点上执行增强处理，有before,after,afterReturning,afterThrowing,around Pointcut(切入点): 就是带有通知的连接点，在程序中主要体现为书写切入点表达式,定义在方法上,添加要增强的一个或一组方法,该注释描述一个可重用的切入点,可以被Adivce(通知)引用 Proxy(代理): AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类 SpringAOP应用实例 编写业务代码123456@Servicepublic class PrintService&#123; public void printStr(String str)&#123; System.out.println(str); &#125;&#125; 定义一个切面类12345678910111213141516171819@Component@Aspectpublic class PrintAspect&#123; // 添加PrintService类中的public void printStr(String str)方法 @Pointcut(\"execution(public void PrintService.printStr(String str))\") public void printCut()&#123;&#125; @After(\"printCut()\") public void printAfter(JoinPoint jp)&#123; String name = jp.getSignature().getName(); System.out.println(\"After\"+name); &#125; @Before(\"printCut()\") public void printBefore(JoinPoint jp)&#123; String name = jp.getSignature().getName(); System.out.println(\"Before\"+name); &#125;&#125; 配置代理12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd\"&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;!-- 启动aop代理 --&gt; &lt;context:component-scan base-package=\"cn.outofmemory\" /&gt; &lt;!-- 自动扫描包内的Bean --&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"}]},{"title":"Spring之容器和依赖注入","slug":"Spring之容器和依赖注入","date":"2018-05-01T07:18:44.000Z","updated":"2019-11-15T04:55:04.855Z","comments":true,"path":"2018/05/01/Spring之容器和依赖注入/","link":"","permalink":"https://zhuyiting.xyz/2018/05/01/Spring%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"Spring之容器和依赖注入Bean容器 BeanFactory是基础的容器,由 org.springframework.beans.facytory.BeanFactory 接口定义, 负责创建各种Bean创建BeanFactory实例时,需要提供Spring容器的详细配置文件applicationContext.xml ApplicationContext是BeanFactory的子接口,它相比于BeanFactory,多了国际化支持等功能,而且在项目初始化过程中,ApplicationContext会自检,避免后续使用getBean方法时抛出异常通常使用ApplicationContext来创建Spring容器 在Web项目中,Spring容器的实例化通常是由ContextLoaderListener来实现,只需要在web.xml中对其进行配置例如: 12345678910111213141516&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--spring将加载src/config目录下的applicationContext.xml文件--&gt; &lt;param-value&gt; classpath:config/applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;!-- 它在启动Web容器时，自动装配ApplicationContext的配置信息。 --&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 它实现了ServletContextListener接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。 --&gt; Bean管理 applicationContext.xml文件中&lt;bean&gt;标签对Bean进行配置 1234&lt;bean id=\"UserDao\" class=\"com.spring.dao.Impl.UserDaoImpl\" /&gt;&lt;bean id=\"UserService\" class=\"com.spring.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\" /&gt;&lt;/bean&gt; 通过注释的方式配置Bean@Component该注释用来描述Spring中的Bean,该注释是泛化概念.@Repository用于数据访问层(Dao层)的类描述为Bean@Service用于业务层(Service层)的类描述为Bean@Controller用于描述控制层(Action层)的类为Bean@Autowired用于描述Bean的依赖实例(例如Service中的属性Dao对象),当Dao只有一个实现类时,默认按照类型来匹配,当有多个实现类存在,就需要在相应的实现类上标注其名称 例如: 1234567891011@Repository(\"DaoImpl1\")public class DaoImpl1 implements Dao&#123;&#125;@Repository(\"DaoImpl2\")public class DaoImpl2 implements Dao&#123;&#125;@Servicepublic class Service&#123; @Autowired private Dao DaoImpl1; 自动装配的是DaoImpl1实现类&#125; @Resource作用和@Autowired一样,区别在于它默认装配是按照名称,如果没有匹配再按照类型 @Qualifier一般配合@Autowired使用 SpringIoC依赖注入Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。例如:在Service中注入Dao接口的实现实例 依赖注入的两种方式 属性setter注入使用setter方法注入被依赖的实例, 123456public class UserService&#123; private UserDao userDao; public void setUserDao(UserDao userDao)&#123; this.userDao=userDao; &#125;&#125; 1234&lt;bean id=\"UserDao\" class=\"com.spring.dao.Impl.UserDaoImpl\" /&gt;&lt;bean id=\"UserService\" class=\"com.spring.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\" /&gt;&lt;/bean&gt; 构造方法注入(推荐这种方法)使用带参数的构造方法注入 123456public class UserService&#123; private UserDao userDao; public UserService(UserDao userDao)&#123; this.userDao=userDao; &#125;&#125; 1234&lt;bean id=\"UserDao\" class=\"com.spring.dao.Impl.UserDaoImpl\" /&gt;&lt;bean id=\"UserService\" class=\"com.spring.service.UserService\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\" /&gt;&lt;/bean&gt;","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"}]},{"title":"Spring入门","slug":"Spring入门","date":"2018-04-29T08:55:38.000Z","updated":"2019-11-15T04:54:58.532Z","comments":true,"path":"2018/04/29/Spring入门/","link":"","permalink":"https://zhuyiting.xyz/2018/04/29/Spring%E5%85%A5%E9%97%A8/","excerpt":"","text":"Spring入门spring简介Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。 spring架构图 Spring是一个从实际项目开发经验中抽取的,可高度重用的应用框架. Spring的主要作用 springBeanFactory:所有的实例可以都可以配置到spring工厂中,新建对象时通过工厂来新建,降低了耦合性. 并且可以配置对象的作用域 Spring依赖注入(控制反转):相当于一个工厂管理对象之间的依赖关系用户只需要在spring中配置好依赖关系(在bean中配置属性的方式配置所依赖的对象)，在调用对象的时候，就不需要再管依赖关系了(不用new那些需要依赖的对象了)。比如一个对象需要另一个对象来协助完成,这时不需要主动创建所需对象,spring容器会自动创建所需要的实例,然后注入进调用者中 SpringAOP(面向切面):实现在执行过程前后执行另外的代码,进行拦截、监控等功能也就是用来定义,在方法前后要完成的什么功能spring的事务管理,就是基于AOP来实现的 总结 方便解耦,简化开发Spring就是一个工厂,可以将所有对象的创建以及依赖关系的维护都交给它 AOP编程的支持Spring提供了面向切面编程,可以方便的进行权限拦截和运行监控 方便结合其他框架Spring内部支持了和其他框架的整合,如mybatis 方便程序测试Spring支持JUnit4,可以通过注释方便的测试 降低了调用JavaEE中一些API的难度比如对JDBC等进行了封装 声明式事务的支持只需要配置就可以完成对事务的管理","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"https://zhuyiting.xyz/tags/Spring/"}]},{"title":"idea新建maven项目","slug":"idea新建maven项目","date":"2018-04-25T07:50:50.000Z","updated":"2019-11-15T04:51:04.687Z","comments":true,"path":"2018/04/25/idea新建maven项目/","link":"","permalink":"https://zhuyiting.xyz/2018/04/25/idea%E6%96%B0%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"idea新建maven项目 选择maven仓库目录File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;MavenMaven home directory:maven解压目录User settings file:配置settings.xml文件位置Local repository:本地仓库路径 新建maven项目新建project,选择maven,next 填写信息 GroupId:包名 ArtifactId:项目名 选择next,finish","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://zhuyiting.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://zhuyiting.xyz/tags/IDE/"},{"name":"MAVEN","slug":"MAVEN","permalink":"https://zhuyiting.xyz/tags/MAVEN/"}]},{"title":"Mybatis之XML映射文件","slug":"Mybatis之XML映射文件","date":"2018-04-22T09:04:03.000Z","updated":"2019-11-15T05:20:50.196Z","comments":true,"path":"2018/04/22/Mybatis之XML映射文件/","link":"","permalink":"https://zhuyiting.xyz/2018/04/22/Mybatis%E4%B9%8BXML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/","excerpt":"","text":"Mybatis之XML映射文件MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： cache – 对给定命名空间的缓存配置。 cache-ref – 对其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 sql – 可被其他语句引用的可重用语句块。这个元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中可以设置不同的值到参数占位符上。比如： 1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; CRUD语句1234567&lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"com.itheima.po.Customer\"&gt; SELECT * FROM t_customer WHERE id = #&#123;id&#125;&lt;/select&gt;&lt;insert id=\"addCustomer\" parameterType=\"com.itheima.po.Customer\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; INSERT INTO t_customer(username,jobs,phone) VALUES (#&#123;username&#125;, #&#123;jobs&#125;, #&#123;phone&#125;)&lt;/insert&gt;&lt;!-- update和delete和insert实现非常接近 --&gt; insert和update的子标签selectKey提供给你一个与数据库中自动生成主键类似的行为，同时保持了 Java 代码的简洁。 123456&lt;insert id=\"addCustomer\" parameterType=\"com.itheima.po.Customer\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"Integer\" order=\"BEFORE\"&gt; select if(max(id) is null, 1, max(id)+1) as new newId from t_customer &lt;/selectKey&gt; INSERT INTO t_customer(id,username,jobs,phone) VALUES (#&#123;id&#125;,#&#123;username&#125;, #&#123;jobs&#125;, #&#123;phone&#125;)&lt;/insert&gt; 结果映射resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 12345678910111213141516171819202122&lt;!-- 普通键值对存储 --&gt;&lt;!-- 没有显式指定 resultMap --&gt;&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 将规范的JavaBean 映射到 ResultSet --&gt;&lt;select id=\"selectUsers\" resultType=\"com.someapp.model.User\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 如果列名和属性名没有精确匹配(不规范的JavaBean)，可以在 SELECT 语句中对列使用别名 --&gt;&lt;select id=\"selectUsers\" resultType=\"com.someapp.model.User\"&gt; select user_id as \"id\", user_name as \"userName\", hashed_password as \"hashedPassword\" from some_table where id = #&#123;id&#125;&lt;/select&gt; 高级结果映射我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们不总都是这样。比如，我们如何映射下面这个语句？ 12345678910111213141516171819202122232425262728293031323334&lt;!-- 非常复杂的语句 --&gt;&lt;select id=\"selectBlogDetails\" resultMap=\"detailedBlogResultMap\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。 我们来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。 1234567891011121314151617181920212223242526272829&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=\"detailedBlogResultMap\" type=\"Blog\"&gt; &lt;constructor&gt; &lt;idArg column=\"blog_id\" javaType=\"int\"/&gt; &lt;/constructor&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt; &lt;/association&gt; &lt;collection property=\"posts\" ofType=\"Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;association property=\"author\" javaType=\"Author\"/&gt; &lt;collection property=\"comments\" ofType=\"Comment\"&gt; &lt;id property=\"id\" column=\"comment_id\"/&gt; &lt;/collection&gt; &lt;collection property=\"tags\" ofType=\"Tag\" &gt; &lt;id property=\"id\" column=\"tag_id\"/&gt; &lt;/collection&gt; &lt;discriminator javaType=\"int\" column=\"draft\"&gt; &lt;case value=\"1\" resultType=\"DraftPost\"/&gt; &lt;/discriminator&gt; &lt;/collection&gt;&lt;/resultMap&gt; 缓存默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：&lt;cache/&gt; 动态SQL如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 if动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如： 12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果 choose, when, otherwise有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where 1234567891011121314151617&lt;!-- 应对使用if时出现的语句错误 --&gt;&lt;!-- where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。 --&gt;&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。 123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt;","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhuyiting.xyz/tags/MyBatis/"}]},{"title":"Mybatis之XML配置文件","slug":"Mybatis之XML配置文件","date":"2018-04-22T07:38:49.000Z","updated":"2019-11-15T05:20:45.299Z","comments":true,"path":"2018/04/22/Mybatis之XML配置文件/","link":"","permalink":"https://zhuyiting.xyz/2018/04/22/Mybatis%E4%B9%8BXML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"XML配置文件mybatis-config.xml配置文件包含了会影响MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） properties（属性）这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。 12345//resource属性,映入java属性文件`config.properties`,也可以用url属性来指定路径&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 其中的属性就可以在整个配置文件中被用来替换需要动态配置,引用语法为${property.name}也可以在java属性文件config.properties中来配置 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。 settings（设置）一个配置完整的 settings 元素的示例如下： 1234567891011121314151617181920212223242526272829303132333435&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!-- 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!-- 是否允许单一语句返回多结果集（需要驱动支持）。 --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!-- 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;!-- 允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!-- 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 --&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;!-- 指定发现自动映射目标未知列（或者未知属性类型）的行为。 NONE: 不做任何反应 WARNING: 输出提醒日志 ('org.apache.ibatis.session.AutoMappingUnknownColumnBehavior' 的日志等级必须设置为 WARN) FAILING: 映射失败 (抛出 SqlSessionException) --&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;!-- 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 --&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;!-- 设置超时时间，它决定驱动等待数据库响应的秒数。 --&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;!-- 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 --&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;!-- 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt; &lt;!-- 指定哪个对象的方法触发一次延迟加载。 --&gt;&lt;/settings&gt; typeAliases（类型别名）类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; environments（环境配置）MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中 使用相同的 SQL 映射。有许多类似的使用场景。不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。 为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。例如 12SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 环境元素定义了如何配置环境。 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; **注意这里的关键点: 默认使用的环境 ID（比如：default=”development”）。 每个 environment 元素定义的环境 ID（比如：id=”development”）。 事务管理器的配置（比如：type=”JDBC”）。 数据源的配置（比如：type=”POOLED”）。** databaseIdProvider（数据库厂商标识）mappers（映射器）既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。 但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如： 12345678910111213141516171819202122232425&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.PostMapper\"/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt;","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhuyiting.xyz/tags/MyBatis/"}]},{"title":"Mybatis入门","slug":"Mybatis入门","date":"2018-04-21T03:20:38.000Z","updated":"2019-11-15T05:20:47.912Z","comments":true,"path":"2018/04/21/Mybatis入门/","link":"","permalink":"https://zhuyiting.xyz/2018/04/21/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"什么是MyBatisMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 Mybatis的优点: 简单小巧易于上手，方便浏览修改 SQL 语句 解除 SQL 与程序代码的耦合 提供映射标签，支持对象与数据库的 ORM 字段关系映射 提供 xml 标签，支持编写动态 SQL 安装在maven项目中,导入以下12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 配置SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。1234//引入mybatis-config.xml资源文件String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); mybatis-config.xml文件包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）简单实例:1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 要注意 XML 头部的声明，它用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。 1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; 这里到底是怎么执行的?先看看上述mybatis-config.xml文件中包含的映射(mapper)文件:BlogMapper.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，允许你使用指定的完全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句.这和使用完全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的 Mapper 类，并将已映射的 select 语句中的名字、参数和返回类型匹配成方法。 因此你就可以像上面那样很容易地调用这个对应 Mapper 接口的方法，就像下面这样： 12BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101); 用注释来映射对于像 BlogMapper 这样的映射器类来说，还有另一种方法来处理映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可被替换如下： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; 使用注解来映射简单语句会使代码显得更加简洁，然而对于稍微复杂一点的语句，Java 注解就力不从心了，并且会显得更加混乱。 因此，如果你需要完成很复杂的事情，那么最好使用 XML 来映射语句。","categories":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/categories/JavaWeb%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb框架","slug":"JavaWeb框架","permalink":"https://zhuyiting.xyz/tags/JavaWeb%E6%A1%86%E6%9E%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zhuyiting.xyz/tags/MyBatis/"}]},{"title":"Java程序运行堆栈分析","slug":"Java程序运行堆栈分析","date":"2018-04-17T03:05:34.000Z","updated":"2019-11-15T04:51:35.819Z","comments":true,"path":"2018/04/17/Java程序运行堆栈分析/","link":"","permalink":"https://zhuyiting.xyz/2018/04/17/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/","excerpt":"","text":"Java程序运行堆栈分析class文件包含JAVA程序执行的字节码,数据严格按照格式紧凑排列在class文件中的二进制流中间.java-&gt;编译-&gt;.class-&gt;JVM运行时数据区 寄存器:最快的存储区,由编译器更具需求进行分配,我们在程序中无法控制 栈:存放函数中定义的基本类型的变量数据和对象的引用(指向堆中对应对象的地址,把对象的地址赋值给栈),但对象本身不存放在栈中,而是存放在堆(new 出来的对象)或者常量池中(字符串常量对象存放在常量池中.).栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。栈内存中的数据，没有默认初始化值，需要手动设置。 堆:存放所有new出来的对象.用完之后靠垃圾回收机制不定期自动消除(当栈中没有指向当前对象时,被视为垃圾,JVM启动垃圾回收机制).堆内存中所有的实体都有内存地址值。堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。 123456Car c=new Car;c.num=5;Car c1=c;c1.color=\"green\";c.run();Car c1=c; 这句话相当于将对象复制一份出来，两个对象的内存地址值一样。所以指向同一个实体，对c1的属性修改，相当于c的属性也改了。 静态域:存放静态成员(static定义的) 常量池:存放字符串常量和基本类型常量(public static final).编译期已经创建好(直接用双引号定义的)的就存储在常量池中 123456String s1 = \"china\"; String s2 = \"china\"; String s3 = \"china\"; String ss1 = new String(\"china\"); String ss2 = new String(\"china\"); String ss3 = new String(\"china\"); s1 s2 s3 指向常量池中的同一个对象ss1 ss2 ss3 指向堆中的三个不同对象但是 ss1 ss2 ss3 创建对象前会先去常量池中查找是否存在”china” 如果不存在 则需要在常量池中先创建一个对象,然后再在队中创建常量池中该对象的拷贝对象. 这也就是有道面试题：String s = new String(“xyz”);产生几个对象？一个或两个，如果常量池中原来没有”xyz”,就是两个。 非RAM存储:硬盘等永久存储空间 java线程模型和cpu缓存模型cpu缓存模型 java线程模型 Java线程内存模型跟cpu缓存模型类似，是基于cpu缓存模型来建立的 java同步规则","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java中equals的注意事项","slug":"Java中equals的注意事项","date":"2018-04-13T02:25:33.000Z","updated":"2019-11-15T04:53:32.925Z","comments":true,"path":"2018/04/13/Java中equals的注意事项/","link":"","permalink":"https://zhuyiting.xyz/2018/04/13/Java%E4%B8%ADequals%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"Java中equals的注意事项对象的equals方法容易抛出空指针的异常,应尽量使用常量或者有确定值的对象来调用equals方法例如: 123456String str = null;if (str.equals(\"English\")) &#123; ...&#125; else &#123; ..&#125; 这样容易报空指针,应该采用以下写法 1\"English\".equals(str); 在jdk7中,有一个新的工具类java.util.Objects 更加推荐 1Objects.equals(str,\"English\");","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"maven项目构建工具","slug":"maven项目构建工具","date":"2018-04-10T00:33:00.000Z","updated":"2019-11-15T04:38:52.092Z","comments":true,"path":"2018/04/10/maven项目构建工具/","link":"","permalink":"https://zhuyiting.xyz/2018/04/10/maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1. Maven是什么?Maven是一个用于构建项目包依赖的工具它可以帮助统一维护项目中的jar包, 它把所有包都放在了仓库中,项目如果需要用到包,只需要引入jar包和对应的版本号就行了这样只需要在本地配置好一个仓库,所有的项目都可以引入,不需要再把包复制到每个项目当中了. 2.Maven的安装和配置 从官网下载最新版本的maven,下载完后,解压到本地","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://zhuyiting.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"MAVEN","slug":"MAVEN","permalink":"https://zhuyiting.xyz/tags/MAVEN/"},{"name":"包管理","slug":"包管理","permalink":"https://zhuyiting.xyz/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"GitHub使用","slug":"GitHub使用","date":"2018-04-03T09:33:00.000Z","updated":"2019-11-15T04:39:03.612Z","comments":true,"path":"2018/04/03/GitHub使用/","link":"","permalink":"https://zhuyiting.xyz/2018/04/03/GitHub%E4%BD%BF%E7%94%A8/","excerpt":"","text":"GitHub简介GitHub可以用来托管代码,也可以用来进行版本控制,它相比与其他版本控制工具的优势在于,可以非常方便的进行分支操作 1.注册账户2.新建一个仓库(repository) 3.配置GitHub公钥在Git终端输入ssh-keygen -t rsa -C &quot;email@email.com&quot;在系统用户下的/.ssh目录,找到id_rsa.pub文件,其中存放的就是秘钥. 再进入github个人设置,选择SSH and GPG keys,将id_rsa.pub文件中的内容复制进去如: 4. clone仓库使用 git clone &lt;项目链接&gt;将github仓库克隆到本地 5. 将本地项目上传到新建仓库 git init初始化项目 git add .添加文件索引 git commit -m “msg”提交到暂存区 git remote add origin git@XXXXXX添加为github仓库源点 git push -u origin master将源点作为主干推送到github","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://zhuyiting.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://zhuyiting.xyz/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://zhuyiting.xyz/tags/Git/"},{"name":"代码托管","slug":"代码托管","permalink":"https://zhuyiting.xyz/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"}]},{"title":"Git简单教程","slug":"Git简单教程","date":"2018-03-31T00:33:00.000Z","updated":"2019-11-15T04:39:01.250Z","comments":true,"path":"2018/03/31/Git简单教程/","link":"","permalink":"https://zhuyiting.xyz/2018/03/31/Git%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/","excerpt":"","text":"什么是Git?Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git在Windows的安装和配置安装包下载地址：https://gitforwindows.org/ 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 配置用户信息配置个人的用户名称和电子邮件地址： 12git config --g user.name &quot;yanchengjie&quot;git config --g user.email ycj996425271@live.com 查看配置信息要检查已有的配置信息，可以使用 git config –list 命令： 1git config --list Git的工作流程Git工作的一般流程为: 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 Git工作区、暂存区和版本库工作区：就是你在电脑里能看到的目录。暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git创建仓库Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 Git克隆仓库我们使用 git clone 从现有 Git 仓库中拷贝项目 1git clone git://github.com/XXXX/XXX Git添加文件到缓存使用命令 git add &lt;fileName&gt; Git移除缓存中的文件使用命令 git rm &lt;fileName&gt; Git将缓存区添加到仓库使用命令git commit -m &quot;备注信息&quot; Git分支管理列出分支命令:git branch(master为主分支)创建分支命令:git branch (branchName)切换分支命令:git checkout (branchNaem)删除分支命令:git branch -d (branchName)合并分支命令:git merge (branchName) Git查看提交历史使用命令 git log","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://zhuyiting.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://zhuyiting.xyz/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://zhuyiting.xyz/tags/Git/"}]},{"title":"Ajax","slug":"Ajax","date":"2018-03-05T08:25:00.000Z","updated":"2019-11-15T05:12:05.592Z","comments":true,"path":"2018/03/05/Ajax/","link":"","permalink":"https://zhuyiting.xyz/2018/03/05/Ajax/","excerpt":"","text":"AJAX1.Ajax的作用获取服务器的数据 2.Ajax的效果在不刷新整个页面的情况下,通过一个url地址获取服务器的数据,然后进行页面的局部刷新. 异布加载, 3.小结Ajax的全称: Asychronous JavaScript And XML,就是使用js代码获取服务器数据. 4.Ajax的使用Ajax简单的来说,就是一个异布的JavaScript请求,用来获取后台服务端的数据,而并不是整个界面进行跳转. 在元素js中来实现AJax主要的类就是XMLHttpRequest,它的使用一般有四个步骤; 创建XMLHttpRequest对象 准备发送网络请求 开始发送网络请求 指定回调函数 注意: 需要注意兼容处理.低版本浏览器不支持XMLHttpRequest对象,需要创建ActiveXObject对象; 指定请求方式,请求地址以及指定是否异步刷新 执行发送,POST请求方式时,数据不写在地址中,放在请求数据体中.需要发送给服务器,同时设置请求头 异步的原理是通过请求浏览器进行网络数据的请求 5. 数据格式 Xml数据格式Xml数据格式是将数据以标签的方式进行组装,必须以&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;开头,标签必须成对出现,xml是一个通用标准,任何人都知道如何解析它; 缺点:体积太大,传播慢,元数据太多,解析不方便,目前使用很少 JSON数据格式Json数据格式类似于js中的对象方式,通过key-value的形式组装,是一个通用的标准,任何人都知道如何解析它; 优点:体积小,传输快,解析方便 解析Xml数据格式获取Xml对象,在通过getElementsBtTagName获取标签内元素123456789101112var result=xhr.responseXML;var books=result.getElementsByTagName(\"booklist\")[0].getElementsByTagName(\"book\");var newHtml=document.getElementById(\"bookContariner\").innerHtml;for(var i=0;i&lt;books.length;i++)&#123; var itemBook=books[i]; var name=itemBook.getElementsByTagName(\"name\")[0].textContent; var author=itemBook.getElementsByTagName(\"author\")[0].textContent; var desc=itemBook.getElementsByTagName(\"desc\")[0].textContent; var tempHtml=\"&lt;tr&gt;&lt;td&gt;\"+name+\"&lt;/td&gt;&lt;td&gt;\"+author+\"&lt;/td&gt;&lt;td&gt;\"+desc+\"&lt;/td&gt;&lt;td&gt;\"; newHtml += tempHtml;&#125;document.getElementById(\"bookContariner\").innerHtml = newHtml; 解析Json数据格式获取Json对象,再通过对象直接获取对象的属性12345678910111213var result=xhr.responseTest;//responseTest获取的是字符串,要转换成JSON对象result=JSON.parse(result);var newHtml=document.getElementById(\"bookContariner\").innerHtml;for(var i=0;i&lt;result.length;i++)&#123; var item=result[i]; var name=item.name; var author=item.author; var desc=item.desc; var tempHtml=\"&lt;tr&gt;&lt;td&gt;\"+name+\"&lt;/td&gt;&lt;td&gt;\"+author+\"&lt;/td&gt;&lt;td&gt;\"+desc+\"&lt;/td&gt;&lt;td&gt;\"; newHtml += tempHtml;&#125;document.getElementById(\"bookContariner\").innerHtml = newHtml; 6.封装Ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function myAjax(type,url,params,callback,async)&#123; var xhr = null; if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; if(type == \"get\")&#123; if(params &amp;&amp; params!=\"\")&#123; url += \"?\" + params; &#125; &#125; xhr.open(type,url,async); if(type == \"get\")&#123; xhr.send(null); &#125;else if(type == \"post\")&#123; xhr.setRequestHeader(\"Contend-Type\",\"application/x-www-from-urlencoded\"); xhr.send(params); &#125; if(async)&#123; xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.readyState == 200)&#123; var result = null; if(dataType == \"json\")&#123; result = xhr.responseText; result = JSON.parse(result); &#125;else if(dataType == \"xml\")&#123; result = xhr.responseXML; &#125;else &#123; result = xhr.responseText; &#125; if(callback)&#123; callback(result); &#125; &#125; &#125; &#125; &#125;else&#123; if(xhr.readyState == 4)&#123; if(xhr.readyState == 200)&#123; var result = null; if(dataType == \"json\")&#123; result = xhr.responseText; result = JSON.parse(result); &#125;else if(dataType == \"xml\")&#123; result = xhr.responseXML; &#125;else &#123; result = xhr.responseText; &#125; if(callback)&#123; callback(result); &#125; &#125; &#125; &#125;&#125; 7 用jQuery实现AjaxjQuery对Ajex操作进行了封装,在jQuery中最底层的方法是$.ajax(),第二层是$.load()、$.get() 、$.post() 第三层是$.getJSON()、$.getScript() $.ajax()用法: type：指定数据提交的方式 url：提交数据的路径 cache:是否存在缓存 data：向后台发送的数据 dataType：服务器端返回的数据类型，比如：xml，text，json, html，script success：响应成功后执行的函数 error：响应失败后执行的函数123456789101112131415161718var subData=&#123; name:'张三' &#125; //提交的数据$.ajax(&#123; url : \"IndexController/getIndexImages.html\", type : \"POST\", async : true,//表示进行异步获取 data:subData,//提交的数据 dataType : 'json', contentType : 'application/x-www-form-urlencoded;charset=UTF-8', //contentType很重要 success : function(result) &#123; var obj = $.parseJSON(result); //在这里对返回的数据进行处理 &#125; error:function()&#123; //请求失败执行这个 &#125;&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zhuyiting.xyz/categories/JavaScript/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://zhuyiting.xyz/tags/Ajax/"},{"name":"异步请求","slug":"异步请求","permalink":"https://zhuyiting.xyz/tags/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"}]},{"title":"EL与JSTL表达式","slug":"EL与JSTL表达式","date":"2018-01-30T06:15:00.000Z","updated":"2019-11-15T05:12:13.495Z","comments":true,"path":"2018/01/30/EL与JSTL表达式/","link":"","permalink":"https://zhuyiting.xyz/2018/01/30/EL%E4%B8%8EJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"EL表达式:EL表达式的功能:(让JSP编写更为简单) EL是Expression Language的简称，即表达式语言； EL在JSP中使用，服务器会对其进行解析翻译，生成相应的Java代码； EL的作用是用来在JSP页面输出动态内容，可以替代JSP中的表达式元素&lt;%=%&gt; EL表达式的一般格式: ${EL表达式} 例如:${param.username} 等同于:&lt;%=request.getParameter(&quot;username&quot;)%&gt; EL表达式的内置对象:其中 2个内置对象为了方便输出请求参数： param/paramValues； 内置对象param：用来输出请求参数的值，格式为${param.请求参数名字} 内置对象paramValues：用来获取一对多的参数值，返回一个数组。 4个内置对象为了方便输出各个范围的属性： pageScope/ requestScope /sessionScope /applicationScope 获取四个范围的属性数据 检索顺序：当不指定范围时，例如，${user.pwd}，将自动从pageScope开始查找，直到applicationScope，如果没查到，则什么也不显示 2个与请求头有关的内置对象：header/headerValues 内置对象header：用来输出输出某一个请求头的值，格式为${header.请求头名字} 内置对象headerValues：如果某个请求头的值有多个，则使用headerValues返回一个数组。 2个其他内置对象：cookie/initParam 内置对象cookie：用来获取cookie的值 内置对象initParam：用来输出上下文参数; 1个特殊的内置对象pageContext 内置对象pageContext：EL中的pageContext对象可以调用PageContext类中所有符合规范的getXxx方法 使用 EL 取出内置对象的数据。 普通对象和对象属性。 服务器端：`request.setAttribute(&quot;student&quot;, student);` 在浏览器上打印出服务器端绑定的数据： 123$&#123; student &#125; &lt;!-- 相当于执行了 student.toString(); --&gt;$&#123; student.name &#125; &lt;!-- 相当于执行了 student.getName(); --&gt;$&#123; student.teacher.name &#125; &lt;!-- 相当于执行了 student.getTeacher().getName(); --&gt; 数组中的数据。 服务器端： 1234567String[] nameArray = new String[]&#123;\"Tom\", \"Lucy\", \"Lilei\"&#125;;request.setAttribute(“nameArray”,nameArray);Student[] students = new Student[3];students[0] = stu1;students[1] = stu2;students[2] = stu3;request.setAttribute(“students”,students); 在浏览器上打印出服务器端绑定的数组数据： 123456$&#123; nameArray[0] &#125; &lt;!-- Tom --&gt;$&#123; nameArray[1] &#125; &lt;!-- Lucy --&gt;$&#123; nameArray[2] &#125; &lt;!-- Lilei --&gt;$&#123; students[0].id &#125; &lt;!-- 输出第一个学生的ID --&gt;$&#123; students[1].name &#125; &lt;!-- 输出第二个学生的name --&gt;$&#123; students[2].teacher.name &#125; &lt;!-- 输出第三个学生的老师的name --&gt; List中的数据。 服务器端： 12345List&lt;Student&gt; studentList=new ArrayList&lt;Student&gt;();studentList.add(stu1);studentList.add(stu2);studentList.add(stu3);request.setAttribute(“studentList”,studentList); 在浏览器上打印出服务器端绑定的List数据： 123$&#123; studentList[0].id &#125; &lt;!-- 输出第一个学生的ID --&gt;$&#123; studentList[1].name &#125; &lt;!-- 输出第二个学生的name --&gt;$&#123; studentList[2].teacher.name &#125; &lt;!-- 输出第三个学生的老师的name --&gt; Map中的数据。 服务器端： 12345Map&lt;String, Student&gt; studentMap = new HashMap&lt;String, Student&gt;();studentMap.put(\"Tom\", stu1);studentMap.put(\"Lucy\", stu2);studentMap.put(\"Lilei\", stu3);request.setAttribute(“studentMap”,studentMap); 在浏览器上打印出服务器端绑定的Map数据： 123$&#123; studentMap.Tom.id &#125; &lt;!-- 输出第一个学生的ID --&gt;$&#123; studentMap.Lucy.name &#125; &lt;!-- 输出第二个学生的name --&gt; $&#123; studentMap.Lilei.teacher.name &#125; &lt;!-- 输出第三个学生的老师的name --&gt; EL运算符:EL中提供了多种运算符，可以对变量或常量进行运算，输出运算结果；EL中的运算符包括： 算术运算符 比较运算符 逻辑运算符 其他运算符 JSTL:JSTL是一套定义好的标签库，可以直接使用；JSTL的全称是Jsp Standard Tag Library，即JSP标准标签库；JSTL包含很多标签，根据其作用可以分为：属性相关的标签、条件分支相关的标签、迭代标签、其他标签；标签库包括标签处理器类及描述文件tld文件，JSTL也一样： 使用JSTL首先需要下载相关的jar文件并保存到工程的lib目录下；在JSP中使用taglib指令引入需要使用的标签库； forEach、set、if等是JSTL中常用的标签； JSTL标签库的使用是为类弥补html表的不足，规范自定义标签的使用而诞生的。在告别modle1模式开发应用程序后，人们开始注重软件的分层设计，不希望在jsp页面中出现java逻辑代码，同时也由于自定义标签的开发难度较大和不利于技术标准化产生了自定义标签库。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://zhuyiting.xyz/tags/JSP/"}]},{"title":"MVC模式","slug":"MVC模式","date":"2018-01-19T06:15:00.000Z","updated":"2019-11-15T04:54:31.634Z","comments":true,"path":"2018/01/19/MVC模式/","link":"","permalink":"https://zhuyiting.xyz/2018/01/19/MVC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"MVC模式基本概念MVC（Model-View-Controller）是一种软件架构设计模式，最初应用在桌面应用程序； MVC模式将软件的代码按照模型（M）、视图（V）、控制器（C）三部分组织 MVC模式构建应用的优势: 耦合性低：视图层和业务层分离，耦合性降低，可以独立修改； 重用性高：可以用不同的视图访问模型部分，实现在不同终端上访问应用； 可维护性高：视图与业务分离，降低了维护成本； MVC模式中的三个角色:在控制器和视图之间共享数据: 在控制器和视图之间，常常需要共享数据；例如从数据查出来的商品列表信息，需要从控制器发送到视图； Servlet和JSP之间共享数据一般使用请求、会话、上下文范围的属性进行； HttpServletRequest/HttpSession/ServletContext接口中都定义了存取、查询、删除属性的方法【前面已经学习过】； 使用原则：尽量用范围小的属性，即，请求范围内共享即可就用请求，以此类推；否则会造成资源浪费，降低安全性； redirect\\forward\\include几种跳转方式的功能与差异:MVC模式中，控制器和视图之间需要进行跳转，Servlet规范中，有三种跳转方式： redirect：调用响应接口的sendRedirect方法，响应重定向，相当于重新请求新的资源，当前请求对象不会到目标资源； forward: 调用请求转发器接口的forward方法，请求转发，将当前的请求、响应对象转发到目标资源；(最常用) include：调用请求转发器接口的include方法，动态包含，将目标资源的请求、响应对象包含到当前资源； forword带来的重复提交问题; 使用forward转发请求后，再次刷新当前页面，会进行重复提交； 例如：使用LoginServlet进行登录，成功后跳转到loginsuccess.jsp页面： 刷新当前页面，再次进行了登录 为了能够解决重复提交问题，关键在于：能够标志一次提交，从而识别出该提交已经处理； 步骤一：在JSP中记录一个随机数，称为令牌（token），存储在session中&lt;%session.setAttribute(&quot;token&quot;,System.nanoTime())+&quot;&quot;%&gt; 步骤二：将token值作为表单的一个隐藏域&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;)%&gt;&quot; &gt; 步骤三：在LoginServlet中获取token值，并进行判断 12345//取出存储在请求参数中的tokenString requestToken = request.getParameter(\"token\");//取出存储在session中的tokenString sessionToken = (String)request.getSession().getAttribute(\"token\");.... 步骤四：将token值从会话中删除 1request.getSession().removeAttribute(\"token\");","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"JSP扩展","slug":"JSP扩展","date":"2017-12-29T02:25:00.000Z","updated":"2019-11-15T04:53:57.262Z","comments":true,"path":"2017/12/29/JSP扩展/","link":"","permalink":"https://zhuyiting.xyz/2017/12/29/JSP%E6%89%A9%E5%B1%95/","excerpt":"","text":"JSP内置对象: 内置对象指的是服务器已经创建好的对象，可以直接使用； 9个内置对象: request response out out的类型是JspWriter out可以用来输出内容到客户端，但是程序员一般不会使用，因为直接使用&lt;%=%&gt;即可以实现输出； page page即当前类对象 page也很少使用，与this相同 pageContext 其他多数内置对象都是通过它获得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); + pageContext对象是JSP中一个非常重要的对象，是`javax.servlet.jsp.PageContext`类型的对象，指的是页面的上下文，封装了其他的内置对象，同时代表的是四大作用域【页面、请求、会话、上下文】中的页面作用域，也可以在页面上下文范围添加属性，`PageContext`中与属性相关方法如下： |方法声明|方法描述| |:---:|:---:| |void setAttribute(java.lang.String name, java.lang.Object o) |将任意类型对象设置为属性，指定一个名字；| |java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；| |void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；| + session + session是JSP中的另一个内置对象，是`HttpSession`类型的对象，可以在JSP中调用HttpSession接口中的任何方法；默认存在 + application + application是JSP中的另一个内置对象，是`ServletContext`类型的对 象，可以在JSP中调用`ServlletContext`接口中的任何方法； + exception + 内置对象exception比较特殊，默认情况下不存在；只有当JSP中使用指令指定该页面作为错误页面使用时才会翻译生成该内置对象。 + config + 在JSP中可以直接使用config对象调用ServletConfig接口中任意方法，例如，可以在web.xml中对JSP配置初始化参数，与前面学习的Servlet初始化参数相同的含义：#### 指令与动作:+ JSP可以通过指令元素而影响容器翻译生成Java类的整体结构；+ 指令的语法为：`&lt;%@ directive &#123;attr=“value”&#125;* %&gt;`；+ 其中，directive为指令名，attr指该指令对应的属性名，一个指令可能有多个属性；JSP中常用的指令有三个：page、include、taglib，前两个常用+ **page指令**作用于整个JSP页面，可以将指令放在JSP页面任何一个位置; + import属性:用来引入JSP文件需要使用的类； + 可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用import； + 值得注意的是，import是page指令中唯一一个可以在一个JSP文件中多次出现的属性，其他属性在一个JSP文件中只能出现一次； + pageEncoding属性:用来设置JSP文件的页面编码格式； + page指令的session属性：用来设置JSP页面是否生成session对象。该属性默认值为true，可以设置成false。 + session属性值设置为false后，该JSP翻译生成的类中将没有内置对象session，该JSP不参与会话。 + errorPage属性:设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面； + 访问该页面将发生数学异常，而且并没有对异常进行处理，那么将跳转到错误页面error.jsp + isErrorPage属性默认值是false，可以设置为true。在JSP的错误页面中，将isErrorPage设置为true，则该页面翻译生成的Java类中，将生成exception内置对象。在error.jsp中加入代码：`&lt;%@page isErrorPage=\"true\"%&gt;` + 上述代码将error.jsp页面设置为错误页面，所以，在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象 + 注意：即使一个页面没有设置isErrorPage=“true”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。+ **include指令**是JSP中另外一个常用指令，用来静态包含其他页面； + 在翻译期间，把包含的页面也翻译到当前页面的Java文件中，也就是Java源文件即实现“二合一”； + `&lt;%@include file=\"copyright.jsp\"%&gt;`+ **include动作标签**: + JSP规范中定义了一系列的标准动作。Web容器按照规范进行了实现，可以解析并执行标准动作； + 标准动作使用标准的XML语法。 ```jsp &lt;jsp:action_name attribute1=\"value1\" attribute2=\"value2\"&gt; &lt;/jsp:action_name&gt; ``` + 其中action_name表示标准动作的名字，attribute1和attribute2是标准动作的若干个属性； + include标准动作:`&lt;jsp:include&gt;`是动态包含，即在运行期访问被包含的页面，并将响应结果同包含页面的响应结果合并，生成最终响应。类似在Servlet中调用`RequestDispatcher`的`include`方法进行包含。+ **include标准动作和include指令的差异**; + include标准动作与include指令都是实现包含其他页面的功能; + include标准动作的属性是page，实现动态包含，发生在请求阶段； + include指令的属性是file，实现静态包含，发生在翻译阶段。+ include其他动作 + forward动作：在JSP页面中进行请求转发，如下代码所示： &lt;jsp:forward page=“loginsuccess.jsp”&gt; 1+ param动作：往往作为子动作使用，为forward和include动作传递参数，如下代码所示： &lt;jsp:forward page=”copyright.jsp”&gt; &lt;jsp:param name=”author” value=”etc”/&gt;&lt;/jsp:forward&gt; &lt;jsp:include page=”copyright.jsp”&gt; &lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt; ``` 上述代码使用param为forward和include动作传递参数，参数将被作为请求参数传递。 使用标准动作时，一定注意正确结束标准动作，如&lt;jsp:include&gt;是标准动作的开始，一定要对应结束标记，如&lt;/jsp:include&gt;。 JavaBeanJavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类，这些类遵循一定的编码规范： 必须是public类 ； 必须有一个无参的public的构造方法； 返回属性的方法为getXxxx()格式 ； 设置属性的方法为setXxx(形式参数)格式； JSP中还提供了3个与JavaBean有关的动作； useBean动作：&lt;jsp:useBean id=“” class=“” scope=“”&gt; useBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性； Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope内的一个属性，属性名为id； 其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。 setProperty 动作：&lt;jsp:setProperty name=“” property=“” param|value=“”/&gt; setProperty标准动作可以用来对JavaBean对象的属性赋值，替代调用setXxxx方法； setProperty的name属性表示JavaBean对象的id值，property表示需要调用的setXxx方法中的Xxx部分，将首字母变小写。比如需要调用setCustname方法，则property即为Custname首字母变小写，即custname； 如果setXxx方法的参数是某一个请求参数的值，则使用param属性指定请求参数名字即可； 如果setXxx方法的参数是一个常量，则使用value属性指定即可。 同时，setProperty标准动作可以对一些常见数据类型直接转换，如字符串与Integer的转换就可以自动进行； getProperty动作：&lt;jsp:getProperty name=”” property=””/&gt; getProperty标准动作用来调用JavaBean对象的getXxx方法，将其返回值在当前位置输出。 name是JavaBean对象的id值，property的值是getXxx方法中的Xxx部分，首字母变小写。假设需要调用getAddress方法显示其返回值，那么property的值就是Address的首字母变小写，即address。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://zhuyiting.xyz/tags/JSP/"}]},{"title":"Servlet上下文","slug":"JSP上下文","date":"2017-12-25T10:47:00.000Z","updated":"2019-11-15T04:54:01.257Z","comments":true,"path":"2017/12/25/JSP上下文/","link":"","permalink":"https://zhuyiting.xyz/2017/12/25/JSP%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"什么是上下文:上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个上下文对象. 当服务器启动的时候，就会为每一个应用创建一个上下文对象； 当服务器关闭的时候，上下文对象就销毁； Servlet中的ServletContext接口: 方法声明 方法描述 java.io.InputStream getResourceAsStream(java.lang.String path) 将path所代表的资源以输入流返回，可以进一步进行读操作；可以用来读取服务器端的文件； RequestDispatcher getRequestDispatcher(java.lang.String path) 返回RequestDispatcher 对象，路径是相对于上下文路径的； 上下文获取方法:Servlet规范中的多个接口中都定义了getServletContext方法获得上下文对象 上下文参数: 在web.xml中可以配置上下文参数，使用ServletContext中的getInitParameter方法可以获取该参数；【之前学习过的Servlet初始化参数，只能在当前Servlet中使用】 上下文参数存储在上下文对象，所以应用下所有组件都可以使用； 获取上下文参数： 1234&lt;context-param&gt; &lt;param-name&gt;version&lt;/param-name&gt; &lt;param-value&gt;2.0&lt;/param-value&gt;&lt;/context-param&gt; 12345//返回ServletContext对象ServletContext ctxt=this.getServletContext();//获取上下文参数String version=ctxt.getinitParameter(\"version\");System.out.println(\"上下文参数version的值:\"+version); 利用ServletContext在应用中共享数据: 方法声明 方法描述 void setAttribute(java.lang.String name, java.lang.Object o) 将任意类型对象设置为上下文属性，指定一个名字 java.lang.Object getAttribute(java.lang.String name) 通过属性的名字，获取属性的值； void removeAttribute(java.lang.String name) 通过属性的名字，删除属性； 四大作用范围:在Web应用中，有四大作用域范围 页面范围PageContext：一个Servlet或JSP文件； 请求范围ServletRequest：一次请求中可以访问多个Servlet或JSP； 访问的Servlet或JSP能够包含其他资源； 会话范围HttpSession：一次会话中可以包含多个请求； 上下文范围ServletContext：上下文包含所有会话；","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://zhuyiting.xyz/tags/JSP/"}]},{"title":"会话跟踪(前后端交互)","slug":"会话跟踪(前后端交互)","date":"2017-12-23T06:01:00.000Z","updated":"2019-11-15T05:17:53.904Z","comments":true,"path":"2017/12/23/会话跟踪(前后端交互)/","link":"","permalink":"https://zhuyiting.xyz/2017/12/23/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA(%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92)/","excerpt":"","text":"会话的概念和作用: 会话: 对于Web应用来说,会话就是浏览器与服务器之间的一次连续的通讯过程. HTTP协议是无状态的，也就是说，一次请求结束后，HTTP协议就不再记录相关信息； 而实际应用中，却常常需要记住一些状态信息； ==会话跟踪==技术就是能够跟踪客户端和服务端的交互,保存和记忆相关信息,保存请求的状态信息. 常用的四种会话跟踪技术: URL方式：需要保存的信息直接追加到URL后，例如：http://127.0.0.1:8080/chapter03/viewList?pageNo=12 隐藏域方式：可以使用表单中的隐藏域保存相关信息， 例如：&lt;input type=&quot;hidden&quot; name=“status&quot; value=“true&quot;&gt; Cookie方式：将状态信息保存到客户端，服务器能够获得相关信息进行分析，从而生成对客户端的响应；例如简化登录功能就可以使用Cookie实现； Session方式：将状态信息保存到服务器的会话对象中，通过唯一标记的ID值与客户端进行绑定使用；例如访问控制功能就可以使用Session实现； Cookie的功能和特点: Cookie是一段保存在客户端的小文本；能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪到用户的状态； Cookie包含一系列属性:如: name：cookie的名字，每个cookie都有一个名字； content：cookie的值，与名字一起作为键值对形式存在； domain：域，该cookie的域名，例如csdn.net，说明当前cookie来自csdn.net; path：路径，访问csdn.net下该路径时，当前cookie将被发送； created：cookie被创建的时间； Expired：cookie失效的时间； 最大生命时间：失效时间和创建时间的时间差，就是cookie的最大生命时间，超过该时间，cookie将失效，不再被发送到相应的域地址； 创建cookie,设置cookie属性:Servlet规范中定了Cookie类，创建该类对象就可以创建Cookie，并可以调用其中方法为Cookie设置属性； 方法声明 方法描述 Cookie(java.lang.String name, java.lang.String value) 创建Cookie对象，指定名字和对应的值； void setMaxAge(int expiry) 设置最大生命时间（秒），如果不设置，当前浏览器关闭，cookie即失效； void setValue(java.lang.String newValue) 设置Cookie的值； setDomain(java.lang.String domain) 设置cookie的域名； cookie创建好后并不能存储到客户端,要将cookie保存到客户端,必须添加到响应对象中,响应接口中定义了Cookie的方法:|方法声明|方法描述||:—:|:—:||void addCookie(Cookie cookie)|将Cookie对象保存到相应的响应对象中；| 当访问相同域名及路径时,没有超过有效时间的cookie将自动通关请求发送到网站; Servlet在请求接口中定义了获取cookie的方法:|方法声明|方法描述||:—:|:—:||Cookie[] getCookies()|获取请求中的所有Cookie对象，返回数组；| Session简介: Session是会话跟踪的另一种实现手段； Session是存储在服务器上的对象，该对象由服务器创建并维护； 服务器为客户端与服务器的每一次会话过程都创建并维护一个Session对象；每个服务器对Session的创建和维护的底层实现有所区别； session创建的时间:一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;% @page session=”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句 HttpSession session = HttpServletRequest.getSession(true);这也是JSP中隐含的 session对象的来历。 由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 session的生命周期:Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。 由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"},{"name":"Cookie","slug":"Cookie","permalink":"https://zhuyiting.xyz/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://zhuyiting.xyz/tags/Session/"}]},{"title":"JSP","slug":"JSP","date":"2017-12-15T06:37:00.000Z","updated":"2019-11-15T04:53:49.330Z","comments":true,"path":"2017/12/15/JSP/","link":"","permalink":"https://zhuyiting.xyz/2017/12/15/JSP/","excerpt":"","text":"什么是JSPJSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件。翻译和编译的过程遵守Servlet规范，因此说==JSP的本质也是Servlet==； html和jsp的表头不一样，这个是JSP的头&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。 简单说，jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。 为什么要用JSP:Servlet生成动态页面比较繁琐，使用JSP生成动态页面比较便捷，因为其中的静态内容可以使用HTML生成； JSP元素: 脚本元素可以用来包含任意Java代码,格式为：&lt;%Java代码%&gt; 服务器翻译脚本元素时，将把其中Java代码直接翻译到jspService方法中，如果语法错误，将在浏览器中提示错误； 表达式元素用来向页面输出动态内容;格式为：&lt;%=Java代码%&gt; 服务器翻译表达式元素时，将把其中Java代码部分的返回值使用out.write语句输出 模块元素指JSP中静态HTML或者XML内容 注释元素有三种情况： 格式为&lt;%--JSP注释--%&gt;；JSP的注释只有在源代码中可见，翻译时已经忽略； 在JSP中，除了使用JSP注释外，还可以使用HTML注释，&lt;!--HTML注释--&gt;，HTML注释会被返回到客户端，但是不显示到页面中； JSP中的Java代码部分，可以使用Java注释；Java注释会翻译到.java文件中，但是编译时忽略； 声明元素: 如果需要在JSP文件中定义类的成员变量或方法，可以使用声明元素，格式为&lt;%! 声明语句%&gt; 1&lt;%! private String path=\"WEB-INF\"; public void readPropertiesFile()&#123;&#125;&gt; 声明元素被翻译到Java类中，而不是_jspService方法中； 内置对象:内置对象指的是在JSP中可以直接使用的对象，不需要声明，直接使用固定的名字使用即可；例如&lt;%=request.getRemoteAddr()%&gt;中的request就是内置对象； jsp中共有9种对象 request：用户端请求，此请求会包含来自GET/Post请求的参数； response：网页传回用户端的回应。 pageContext：页面的属性是在这里管理 session：与请求有关的回话期 application ：Servlet正在执行的内容 out ：用来传递回应的输出 config ：servlet的构架部件 pagejsp网页本身 exception ：针对错误的网页。未捕捉的例外 Servlet和JSP的作用:实际应用中，Servlet是不会用来生成动态页面的，而是会用来接收来自JSP的请求，处理请求，然后调跳转到JSP页面把结果显示给客户端看； Servlet与JSP之间的跳转方式: 跳转方式一:响应重定向,响应接口中提供了该方法 void sendRedirect(java.lang.String location):响应重定向到location，相当于客户端重新请求location所在的资源； 第一个JSP页面发送请求request到Servlet,Servlet接收请求后,响应response重定向到目标JSP页面,但是请求并没有传递过来.(重定向相当于是产生一个新的请求) 跳转方式二:请求转发,RequestDispatcher接口定义了请求转发的方法 forward(ServletRequest request, ServletResponse response):将请求转发到服务器上的其他资源，包括其他的Servlet，JSP等； 要使用forward方法，需要先获得RequestDispatcher对象；请求接口(request)中提供了获得该对象的方法： RequestDispatcher getRequestDispatcher(java.lang.String path):使用path返回一个RequestDispatcher 对象 请求转发把请求对象发送到了目标JSP页面,因此目标页面可以获得上一个页面的请求对象. 请求属性的使用:如果需要在Servlet，JSP之间跳转时，同时把一些自定义的、或者通过数据库查询的、或者调用其他资源获得的数据传递到下一个资源时，就可以把这些数据设置为请求的属性即可。 请求接口中定义了一系列与属性有关的方法。|方法声明|方法描述||:——:|:—–:||void setAttribute(java.lang.String name, java.lang.Object o)|将任意类型对象设置为请求的属性，指定一个名字；||java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；||void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；|可以将数据封装进请求对象中,在前后端传递例如:后台Servlet中将数据保存进request(请求)中,跳转到前台JSP后,JSP可以用&lt;%=request.getAttribute(&quot;name&quot;)%&gt;来获取(直接输出)也可以保存为变量(前提是需要强转,因为获取的是Object类型)","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://zhuyiting.xyz/tags/JSP/"}]},{"title":"Servlet","slug":"Servlet","date":"2017-12-06T09:12:00.000Z","updated":"2019-11-15T04:54:55.569Z","comments":true,"path":"2017/12/06/Servlet/","link":"","permalink":"https://zhuyiting.xyz/2017/12/06/Servlet/","excerpt":"","text":"什么是ServletJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet的线程特性:Web应用服务器(Tomcat)将为每个客户端的连接启动一个线程来服务 第一次访问Servlet时，服务器将创建一个该Servlet类的对象，并调用doXXX方法生成响应；多个客户端访问同一个Servlet时，不再创建新的对象，而是共用同一个Servlet对象。可以说，Servlet是多线程单实例的。 Servlet请求和响应接口:通过浏览器提交给服务端的所有数据,都称为请求数据 通过服务器返回给客户端的所有数据,都称为响应数据 ServletAPI中,定义了请求和响应接口,用来封装和操作请求和响应数据 请求接口: javax.servlet.ServletRequest javax.servlet.HttpServletRequest 响应接口: javax.servlet.ServletResponse javax.servlet.HttpServletResponse Servlet类使用doXXX方法提供服务,这些方法继承于HttpServletdoXXX方法中都有两个参数,分别是请求和响应;|方法|参数|作用||:–:|:–:|:–:||void doDelete|(HttpServletRequest request,HttpServletResponse response)|用来处理一个HTTP DELETE操作,这个操作允许客户端请求从服务器上删除URL||void doGet|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP GET操作。这个操作允许客户端简单地从一个HTTP服务器“获得”资源||void doHead|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP HEAD操作。默认的情况是，这个操作会按照一个无条件的GET方法来执行||void doOptions|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP OPTION操作。这个操作自动地决定支持哪一种HTTP方法。例如，一个Servlet写了一个HttpServlet的子类并重载了doGet方法，doOption会返回下面的头： Allow:GET,HEAD,TRACE,OPTIONS||void doPost|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP POST操作。这个操作包含请求体的数据，Servlet应该按照他行事。||void doPut|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP PUT操作。这个操作类似于通过FTP发送文件。||void doTrace|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP TRACE操作。这个操作的默认执行结果是产生一个响应，这个响应包含一个反映trace请求中发送的所有头域的信息。||long getLastModified|(HttpServletRequest request)|返回这个请求实体的最后修改时间。||void service|(HttpServletRequest request, HttpServletResponse response)|这是一个Servlet的HTTP-specific方案，它分配请求到这个类的支持这个请求的其他方法。当你开发Servlet时，在多数情况下你不必重载这个方法。|也就是说：服务器会创建请求对象和响应对象传递给doXXX方法，doXXX方法中可以直接使用请求和响应对象;doXXX方法中可以使用方法参数request，response去调用请求和响应接口中的方法； 利用Servlet对客户端不同方式请求作出动态响应:客户端访问服务器端Servlet的三种方式: 直接从地址栏输入URL访问；是GET方式，调用doGet方法; 在网页中点击超级链接访问；是GET方式，调用doGet方法; 在网页中通过表单提交访问；取决form的method属性的值，默认是get，指定为post时，调用doPost方法; Servlet中获取请求参数的方法: 可以在URL后使用name=value&amp;name=value的形式传递，例如： 12&lt;a href=“TestPramServlet?page=1&amp;author=wangxh”&gt;&lt;!-- 传递两个请求参数，名字分别为page和author，值分别为1和wangxh；--&gt; 可以在使用表单提交，表单中的元素值将作为请求参数传递，元素的name是参数名字，value的值是参数的值 当客户端请求服务器端的Servlet时，请求参数都会被发送到服务器，服务器会将请求参数封装到请求对象中； Servlet初始化参数: 如果某个Servlet需要使用一些可以配置的参数，可以在web.xml进行配置，称为初始化参数； 这些参数在服务器初始化Servlet实例时被初始化到配置信息中，可以在Servlet中获取并使用； 一个Servlet可以配置多个初始化参数，所有的初始化参数只能在当前Servlet类中使用； Servlet加载启动选项: 默认情况下，只有当第一次访问Servlet时，服务器才会初始化Servlet实例； 如果需要更早实例化Servlet，可以在web.xml中进行配置，使得在启动容器的时候就能初始化Servlet实例； Servlet配置中通配符*的用法: .扩展名 ： 比如 *.do、.action 以 / 开头，同时以 /* 结尾，比如 /* 、/admin/* web.xml中首页及错误页面等其他配置信息 配置默认页面:当不指定具体访问路径时,默认访问默认页面12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 配置错误页面:当应用中出现响应错误或者异常时,可以跳转到错误页面; Servlet中获取请求头属性的方法:客户端请求服务端的Servlet,会传递给服务器一系列的HTTP请求头属性,请求接口中定义了系列方法获取请求属性","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"},{"name":"Servlet","slug":"Servlet","permalink":"https://zhuyiting.xyz/tags/Servlet/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2017-11-30T00:43:00.000Z","updated":"2019-11-15T04:51:41.080Z","comments":true,"path":"2017/11/30/Java多线程/","link":"","permalink":"https://zhuyiting.xyz/2017/11/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"Java多线程程序.进程和多任务: 程序（program） 是对数据描述与操作的代码的集合，是应用程序执行的脚本。 进程（process） 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。 多任务（multi task） 在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。 线程 线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序 一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。 如何创建多线程: 创建 java.lang.Thread 类的子类，重写该类的 run方 法 创建 java.lang.Runnable接 口的实现类，实现接口中的 run 方法(用的更多) Runnable 接口与 Thread 类之间的区别: Runnable 接口必须实现 run 方法，而 Thread 类中的run 方法是一个空方法，可以不重写 Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必须依靠 Thread 类 Runnable 接口适合于资源的共享 多线程的四种状态: 新建（New） 可执行（Runnable） 运行（Running) 阻塞（Blocking) 死亡（Dead) 状态之间的相互转化可执行&lt;—-&gt;阻塞 wait()方法: 中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。 notify()方法： 唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待 notifyall()方法： 唤醒所有由于使用这个同步方法而处于等待的线程结束等待","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://zhuyiting.xyz/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"SteamAPI","slug":"SteamAPI","date":"2017-11-25T03:30:00.000Z","updated":"2019-11-15T04:55:38.040Z","comments":true,"path":"2017/11/25/SteamAPI/","link":"","permalink":"https://zhuyiting.xyz/2017/11/25/SteamAPI/","excerpt":"","text":"Stream APIStream位于包java.util.stream .* 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 流(Stream)到底是什么呢?是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。集合讲的是数据，流讲的是计算！ 注意 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream的操作三步骤 创建Stream一个数据源（如：集合、数组），获取一个流 中间操作一个中间操作链，对数据源的数据进行处理 终止操作（终端操作）一个终止操作，执行中间操作链，并产生结果 1. 创建Stream 可以通过Collection系列集合提供的stream()或parallelStream()方法default Stream&lt; E&gt; stream() : 返回一个顺序流default Stream&lt; E&gt; parallelStream() : 返回一个并行流 通过 Arrays 中的静态方法stream()获取数组流static &lt;T&gt; Stream&lt;T&gt; stream( T[] array): 返回一个流重载形式，能够处理对应基本类型的数组：public static IntStream stream(int[] array)public static LongStream stream(long[] array)public static DoubleStream stream(double[] array) 通过Stream 类中的静态方法of()，通过显示值创建一个流。它可以接收任意数量的参数。public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流 创建无限流可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。迭代 public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f)生成 public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s) 12345678910111213141516171819202122//创建Stream@Testpublic void test1()&#123; //1.可以通过Collection 系列集合提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); //2.通过 Arrays 中的静态方法stream()获取数组流 Employee[] emps=new Employee[10]; Stream&lt;Employee&gt; stream2=Arrays.stream(emps); //3.通过Stream 类中的静态方法of() Stream&lt;String&gt; stream3=Stream.of(\"aa\",\"bb\",\"cc\"); //4.创建无限流 //迭代 Stream&lt;Integer&gt; stream4=Stream.iterate(0, (x) -&gt; x+2); stream4.limit(10).forEach(System.out::println); //生成 Stream.generate(() -&gt; Math.random()).limit(5).forEach(System.out::println);&#125; 2.中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性处理，成为“惰性求值”。 筛选与切片filter(Predicate p): 接收lambda,从流中排除某些元素distinct(): 筛选,通过流所生成元素的hashCode()和equals去除重复元素limit(long maxSize): 截断流,使元素不超过给定数量skip(long n): 跳过元素,返回一个扔掉了前n个元素的流,若流中元素不足n个,则返回一个空流,与limit(n)互补 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//中间操作List&lt;Employee&gt; employees=Arrays.asList( new Employee(\"张三\",18,9999.99), new Employee(\"李四\",58,5555.55), new Employee(\"王五\",26,3333.33), new Employee(\"赵六\",36,6666.66), new Employee(\"田七\",12,8888.88), new Employee(\"田七\",12,8888.88) ); /* 筛选与切片* filter--接收Lambda，从流中排除某些元素。* limit--截断流，使其元素不超过给定数量。* skip(n)--跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补* distinct--筛选，通过流所生成元素的 hashCode() 和 equals() 去掉重复元素*/ //内部迭代：迭代操作由 Stream API 完成@Testpublic void test1()&#123; //中间操作：不会执行任何操作 Stream&lt;Employee&gt; stream=employees.stream().filter((e) -&gt; e.getAge()&gt;35 ); //终止操作：一次性执行全部内容，即 惰性求值 stream.forEach(System.out::println);&#125;//外部迭代@Testpublic void test2()&#123; Iterator&lt;Employee&gt; it=employees.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;&#125; @Testpublic void test3()&#123;//发现“短路”只输出了两次，说明只要找到 2 个 符合条件的就不再继续迭代 employees.stream().filter((e)-&gt;&#123; System.out.println(\"短路！\"); return e.getSalary()&gt;5000; &#125;).limit(2).forEach(System.out::println);&#125; @Testpublic void test4()&#123; employees.stream().filter((e)-&gt;e.getSalary()&gt;5000).skip(2)//跳过前两个 .distinct()//去重，注意：需要Employee重写hashCode 和 equals 方法 .forEach(System.out::println);&#125; 映射 1234567891011121314151617181920212223/* 映射* map--接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。* flatMap--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流*/@Testpublic void test5()&#123; List&lt;String&gt; list=Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); list.stream() .map((str)-&gt;str.toUpperCase()) .forEach(System.out::println); System.out.println(\"------------------------\"); employees.stream().map(Employee::getName) .forEach(System.out::println); System.out.println(\"------------------------\"); Stream&lt;Character&gt; sm=list.stream() .flatMap(TestStream::filterChatacter); sm.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterChatacter(String str)&#123; List&lt;Character&gt; list=new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 排序 1234567891011121314151617/*排序* sorted()-自然排序（按照对象类实现Comparable接口的compareTo()方法 排序）* sorted(Comparator com)-定制排序（Comparator）*/@Testpublic void test7()&#123; List&lt;String&gt; list=Arrays.asList(\"ccc\",\"bbb\",\"aaa\"); list.stream().sorted().forEach(System.out::println); System.out.println(\"------------------------\"); employees.stream().sorted((e1,e2)-&gt;&#123; if(e1.getAge().equals(e2.getAge()))&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e1.getAge().compareTo(e2.getAge()); &#125; &#125;).forEach(System.out::println); &#125; 3. 终止操作终止操作会从流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。 查找与匹配 1234567891011121314151617181920212223242526272829/** 查找与匹配*/@Testpublic void test1()&#123; //allMatch-检查是否匹配所有元素 boolean b1=employees.stream().allMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b1);//false boolean b2=employees.stream().anyMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b2);//true //noneMatch-检查是否没有匹配所有元素 booleanb3=employees.stream().noneMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b3);//false //findFirst-返回第一个元素//Optional是Java8中避免空指针异常的容器类 Optional&lt;Employee&gt; op=employees.stream().sorted((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).findFirst(); System.out.println(op.get()); //findAny-返回当前流中的任意元素 Optional&lt;Employee&gt; op2=employees.parallelStream().filter((e)-&gt;e.getStatus().equals(Status.FREE)).findAny(); System.out.println(op2.get()); //count-返回流中元素的总个数 Long count=employees.stream().count(); System.out.println(count);//5 //max-返回流中最大值 Optional&lt;Employee&gt; op3=employees.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op3.get()); //min返回流中最小值 Optional&lt;Double&gt;op4=employees.stream().map(Employee::getSalary).min(Double::compare); System.out.println(op4.get());//3333.33 &#125; 归约 1234567891011121314/*归约* reduce(T identity,BinaryOperator b) / reduce(BinaryOperator b)-可以将流中元素反复结合起来，得到一个值。*/@Testpublic void test3()&#123; List&lt;Integer&gt; list=Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum=list.stream() reduce(T identity,BinaryOperator b).reduce(0, (x,y)-&gt;x+y); //0为起始值 System.out.println(sum); System.out.println(\"--------------------------\"); Optional&lt;Double&gt; op=employees.stream().map(Employee::getSalary).reduce(Double::sum); System.out.println(op.get());&#125; 收集 1234567891011121314151617181920212223242526272829303132333435/** 收集* collect-将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。*/@Testpublic void test4()&#123; List&lt;String&gt; list=employees.stream().map(Employee::getName).collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(\"----------------------------\"); Set&lt;String&gt; set=employees.stream().map(Employee::getName).collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(\"----------------------------\"); //总和 Long count=employees.stream().collect(Collectors.counting()); System.out.println(count); //平均值 Double avg=employees.stream().collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); //总和 Double sum=employees.stream().collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); //最大值 Optional&lt;Employee&gt; max=employees.stream().collect(Collectors.maxBy((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(max.get()); //最小值 Optional&lt;Double&gt; min=employees.stream().map(Employee::getSalary).collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); System.out.println(\"----------------------------\"); //分组 Map&lt;Status,List&lt;Employee&gt;&gt; map=employees.stream().collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map); //分区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map3=employees.stream().collect(Collectors.partitioningBy((e)-&gt;e.getSalary()&gt;8000)); System.out.println(map3);)","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Lambda","slug":"Lambda","date":"2017-11-18T05:40:00.000Z","updated":"2019-11-15T04:54:24.096Z","comments":true,"path":"2017/11/18/Lambda/","link":"","permalink":"https://zhuyiting.xyz/2017/11/18/Lambda/","excerpt":"","text":"函数式接口:我们把只拥有一个方法的接口称为函数式接口. 我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个 Object 已经提供的方法，比如 toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过 @FunctionalInterface 注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。 函数式接口的实现引入了一个全新的结构化函数类型.我们也称为是”箭头”类型. Java8中加入新的包：java.util.function它包含了常用的函数式接口: Predicate&lt;T&gt;: 接收T并返回boolean Consumer&lt;T&gt;: 接收T,不返回值 Function&lt;T, R&gt;: 接收T,返回R Supplier&lt;T&gt;: 提供T,不接收值 Unaryoperator&lt;T&gt;: 接收T,返回T Binary0perator&lt;T&gt;: 接收两个T,返回T Lambda表达式:lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的语法过于冗余. 下面是一些表达式: 123(int x,int y)-&gt;x+y()-&gt;42(String s)-&gt;System.out.println(s); lambda 表达式的语法由参数列表、箭头符号 -&gt; 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块： 表达式:表达式会被执行然后返回执行结果. 语句块:语句块中的语句会被依次执行,就像方法中的语句一样 return语句会把控制权交给匿名方法的调用者 break和continue只能在循环中使用 如果函数体有返回值,那么函数体内部的每一条路径都必须返回值 目标类型: 编译器负责推导lambda表达式类型,它利用lambda表达式所在上下文所期待的类型进行推导,这个被期待的类型被称为==目标类型==.lambda表达式只能出现在目标类型为函数式接口的上下文中. 当然lambda对于目标类型也是有要求的,编译器会检查lambda表达式的类型和目标类型的方法签名是否一致,当且仅当下面所有条件均满足时,lambda表达式才可以被赋给目标类型T: T是一个函数式接口 lambda表达式的参数和T的方法参数在数量和类型上一一对应 lambda表达式的返回值和T的方法返回值相兼容 lambda表达式内锁抛出的异常和T的方法throws类型相兼容 Java内置函数式接口为了免去用户每次使用Lamdba表达式时,都自行创建函数式接口,java中提供了四大核心内置函数式接口: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Consumer&lt;T&gt; :消费型接口 * void accept(T t); * * Supplier&lt;T&gt; :供给型接口 * T get(); * * Function&lt;T,R&gt; :函数型接口 * R apply(T t); * * Predicate&lt;T&gt; :断言型接口 * boolean test(T t); */ public class TestLambda3 &#123; //Consumer&lt;T&gt; 消费型接口： public void happy(double money,Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125; @Test public void test1()&#123; happy(1000,(m) -&gt;System.out.println(\"消费：\"+m+\"元\")); &#125; //Supplier&lt;T&gt; 供给型接口: //需求：产生指定个数的整数，并放入集合中 public List&lt;Integer&gt; getNumList(int num,Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n=sup.get(); list.add(n); &#125; return list; &#125; @Test public void test2()&#123; List&lt;Integer&gt; numList=getNumList(10, ()-&gt;(int)(Math.random()*100)); for (Integer num : numList) &#123; System.out.println(num); &#125; &#125; //Function&lt;T,R&gt; 函数型接口: //需求：处理字符串 public String strHandler(String str,Function&lt;String,String&gt; fun)&#123; return fun.apply(str); &#125; @Test public void test3()&#123; String newStr=strHandler(\"\\t\\t\\t 哈哈哈 \", (str)-&gt;str.trim()); System.out.println(newStr); String subStr=strHandler(\"abcdef\", (str)-&gt;str.substring(2,4)); System.out.println(subStr); &#125; //Predicate&lt;T&gt; 断言型接口： //需求：将满足条件的字符串，放入集合中 public List&lt;String&gt; filterStr(List&lt;String&gt; list,Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList=new ArrayList&lt;&gt;(); for ( String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList; &#125; @Test public void test4()&#123; List&lt;String&gt; list=Arrays.asList(\"Hello\",\"jj\",\"Lambda\",\"www\",\"ok\"); List&lt;String&gt; strList=filterStr(list, (s)-&gt;s.length()&gt;3); for (String string : strList) &#123; System.out.println(string); &#125; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Lambda","slug":"Lambda","permalink":"https://zhuyiting.xyz/tags/Lambda/"}]},{"title":"Java输入输出","slug":"Java输入输出","date":"2017-11-14T02:01:00.000Z","updated":"2019-11-15T05:13:13.187Z","comments":true,"path":"2017/11/14/Java输入输出/","link":"","permalink":"https://zhuyiting.xyz/2017/11/14/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"第1节:文件 File类型 java.io.File类的对象可以表示文件和目录，在程序中一个File类对象可以代表一个文件或目录 当创建一个File对象后，就可以利用它来对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等等 需要注意的是，File对象并不能直接对文件内容进行读/写操作，只能查看文件的属性 第2节:输出输出流 输入输出流的概念与作用 流的特点: 流是一串连续不断的数据的集合,只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的 输入流：从外存读取数据到内存，输出流：将数据从内存写到外存中 Java中输入输出流的类型 对于输入和输出流，由于传输格式的不同，又分为字节流和字符流： Java的输入输出流的继承树 Java I/O主要包括: 流式部分:IO的主体部分； 非流式部分:主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类； 其他类:文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。 字节输出流 OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的 OutputStream OutputStream是一个抽象类，提供了Java向流中以字节为单位写入数据的公开接口，大部分字节输出流都继承自OutputStream类 DataOutput DataOutput接口规定一组操作，用于直接向流中写入基本类型的数据和字符串： DataInput对基本数据类型的写入分别提供了不同的方法，方法名满足writeXXX()的规律,如writeInt()表示向流中写入一个int型数据，写入字符串的方法为writeUTF() 常见字节输出流工具的作用与使用 FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象。 创建一个文件流对象有以下方法: 方式1：12File f=new File(“d:/abc.txt”);FileOutputStream out=new FileOutputStream (f); 方式2：1FileOutputStream out=new FileOutputStream(“d:/abc.txt”); 方式3：构造函数将 FileDescriptor()对象作为其参数。12FileDescriptor() fd=new FileDescriptor();FileOutputStream f2=new FileOutputStream(fd); 方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。1FileOutputStream f=new FileOutputStream(“d:/abc.txt”,true); 字节输入流 InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法. InputStream InputStream也是一个抽象类，提供了Java中从流中以字节为单位读取数据的公开接口，大部分字节输入流都继承自InputStream类 DataInput DataInput接口规定一组操作，用于以一种与机器无关（当前操作系统等）的方式，直接在流中读取基本类型的数据和字符串： DataInput对基本数据类型的读取分别提供了不同的方法，方法名满足readXXX()的规律,如readInt()表示从流中读取一个int型数据读取字符串的方法为readUTF() 常见的字节输入流工具的作用与使用 FileInputStream类是InputStream类的子类，用来处理以文件作为数据输入源的数据流。 使用方法: 方式1：12 File fin=new File(“d:/abc.txt”);FileInputStream in=new FileInputStream(fin); 方式2：1FileInputStream in=new FileInputStream(“d: /abc.txt”; 方式3：构造函数将 FileDescriptor()对象作为其参数。12FileDescriptor() fd=new FileDescriptor();FileInputStream f2=new FileInputStream(fd); 程序对应的基本输入为键盘输入，基本输出为显示器输出。Java中，System类的in和out两个成员代表了基本输入输出的抽象 System.in:基本输入，对应InputStreamSystem.out:基本输出，对应PrintStream RandomAccessFile RandomAccessFile类可以在文件中==任何位置==查找或写入数据 RandomAccessFile==同时实现了DataInput和DataOutput接口== 磁盘文件都是可以随机访问的， 但是从网络而来的数据流却不是 ByteArrayOutpuStream/ByteArrayInputStream 一对输入输出工具为我们提供了在内存中利用byte[]进行缓冲流操作的工具 ByteArrayOutputStream提供工具将内存中以串行序列存在的流式数据以一个字节为单位进行切分，形成一个byte[]数组 而ByteArrayInputStream则正好相反，提供工具将内存中的byte[]数组中的数据进行串行序列化拼接，形成一个可供操作的流式数据 从功能上看，ByteArrayOutpuStream可以将任意数据组合转换为byte[]，而ByteArrayInputStream可以将这个数组还原，从而以流的形式读取任意数据组合 字符输出流 考虑到Java是跨平台的语言，要经常操作Unicode编码的文件，使用基于字符为读、写基本单元的字符流操作文件是有必要的,以字符为单位进行数据输出的工具继承自Writer 字符输出流的统一数据写入方法 Writer和OutputStream类似也提供了统一的往流中写入数据的方法，和OutputStream不同的是，写入数据的单位由字节变成了字符 字符输出流工具的作用与使用 FileWriter类称为文件写入流，以字符流的形式对文件进行写操作 FileWriter将逐个向文件写入字符，效率比较低下，因此一般将该类对象包装到缓冲流中进行操作 还可以使用PrintWriter对流进行包装，提供更方便的字符输出格式控制 字符输入流 以字符为单位进行数据读取的工具继承自Reader，Reader会将读取到的数据按照标准的规则转换为Java字符串对象 字符输入流的统一数据读取方法 字符输入流Reader也提供的统一读取数据的方法（和InputStream不同，实际开发时更多的调用不同Reader提供的特殊读取方法，如BufferedReader的readLine()，能够简化操作） 常见的字符输入流工具的作用与使用 FileReader类称为文件读取流，允许以字符流的形式对文件进行读操作 与FileWriter相似，该类将从文件中逐个地读取字符，效率比较低下，因此一般也将该类对象包装到缓冲流中进行操作 字节流与字符流的适配器 在某些时候虽然我们操作的是字符串，但是不得不面对数据来源是InputStream（字节输入流）的情况，在这种情况下，Java提供了将InputStream和Reader之间进行转换的工具，事实上，字节输出流和字符输出流之间也存在这种工具，称为：字节流与字符流的适配器： InputStreamReader： 字节流通向字符流的桥梁，它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集 每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节 OutputStreamWriter： 字符流通向字节流的桥梁，使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集 每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲 第3节:对象序列化Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能 对象序列化的作用 使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量 除了在持久化对象时会用到对象序列化之外，在网络中传递对象时，也会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制 序列化接口 在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化 java.io.Serializable是一个标识接口，即意味着它仅仅是为了说明类的可序列化属性，接口没有包含任何需要子类实现的抽象方法 对象序列化和反序列化 将对象的状态信息保存到流中的操作，称为序列化，可以使用Java提供的工具ObjectOutputStream. writeObject(Serializable obj)来完成 从流中读取对心状态信息的操作称为反序列化，可以使用Java提供的工具ObjectInputStream.readObject()来完成","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java核心API","slug":"Java核心API","date":"2017-11-10T02:09:00.000Z","updated":"2019-11-15T04:51:55.620Z","comments":true,"path":"2017/11/10/Java核心API/","link":"","permalink":"https://zhuyiting.xyz/2017/11/10/Java%E6%A0%B8%E5%BF%83API/","excerpt":"","text":"Object Object类是Java语言中所有类的根,所有的类都直接或间接的继承了Object类; 数组也继承了Object类; Object类中定义了equals(Object obj)方法,用来比较两个对象的虚拟地址,如果虚拟地址相同则返回true,否则返回false; Object类中的equals()方法的作用,与==相同,都是比较两个对象的虚地址 很多类覆盖了equals方法,用来比较两个对象的属性值,如果属性值相同,则认为两个对象相等,例如[String类就覆盖了equals方法,用来比较两个字符串的字符序列值] Object类中定义了hashCode方法public int hashCode()，用来返回对象的哈希码； hashCode方法主要为了配合基于哈希的集合类一起工作，例如HashSet、HashMap等； 默认情况下(即没有重新hashCode方法时)，当两个引用的虚地址相同时，hashCode返回相同的值，否则返回不同的值； 事实上，基于哈希的集合在使用hashCode的时候，基本都是和equals一起使用；先用hashCode初步比较,再用equals比较 注意:使用的时候一起使用,重写的时候也要一起重写 Object类中定义了toString方法 字符串类型是编程时最常用的类型，Object类中定义了toString方法public String toString()，可以把任意类型对象转换成字符串返回； 默认情况（没有重写Object类中的toString方法）下，返回字符串的格式为：对象类型@对象调用hashCode方法的返回值； 返回Object类中默认格式的字符串几乎没有实用意义，因此很多时候，都会重写一些实体类的toString方法，返回需要的字符串格式； Object类中定义了克隆方法clone Clone方法能够“复制”一个对象，生成一个新的引用，分配新的内存空间； 一个类必须实现Cloneable接口，才能被克隆，否则抛出异常； 克隆是生成了一个新的对象，然而，对象的属性如果有引用类型，实际上还是公用； 深克隆时，属性不仅值相同，同时又都存储在完全不同的内存中 StringString类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习 子串截取方法: String substring(int beginIndex) String substring(int beginIndex,int endIndex) 检索相关方法: int indexOf(int ch) int indexOf(int ch,int fromIndex) int indexOf(String str) int indexOf(String str,int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch,int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str,int fromIndex) char charAt(int index) 类型转换相关的方法: static String valueOf(boolen b) static String valueOf(char c) static String valueOf(char[] data) static String valueOf(char[] data,int offset,int count) static String valueOf(double d) static String valueOf(float f) static String valueOf(int i) static String valueOf(long l) static String valueOf(Object obj) 其他方法: int compareTo(String anotherString) boolean endsWith(String suffix) byte[] getBytes() byte[] getBytes(Charset charset) int length() boolean startsWith(String prefix) boolean startsWith(String prefix,int toffset) String trim() 正则表达式正则表达式就是用来描述字符串逻辑规则的工具 正则表达式本身也是个字符串，不过这些字符串是使用系列“元字符”组成； 所谓“元字符”就是预先定义的，有特殊意义的字符；例如\\d用来匹配一个数字； \\w用来匹配字母或数字或下划线或汉字等； 很多语言多对正则表达式提供了支持，例如JavaScript、Java等； 不同语言中使用正则表达式时，正则表达式的具体编写规则会有些小的差别，但是大体相同； 正大表达式在Java中的使用123456789101112131415161718192021String regex=\"^((13[0-9])|(15[0-3,5-9])|(18[0,2,3,5-9])|(17[0-8])|(147))\\\\d&#123;8&#125;$\";//检验的手机号码String string=\"15123569087\";//第一种方式//将正则表达式编译成Pattern对象Pattern pattern=Pattern.compile(regex);//使用Pattern对象为每个手机号码产生一个匹配器Matcher matcher=pattern.matcher( string);boolean flag=matcher.matches();System.out.println(flag==true?\"手机号正确\":\"手机号错误\");//第二种方式//将正则表法式编译成Pattern对象Pattern pattern2=Pattern.compile(regex);boolean flag2=pattern2.matches(regex, string);System.out.println(flag2==true?\"手机号正确\":\"手机号错误\");//第三种方式boolean flag3=string.matches(regex);System.out.println(flag3==true?\"手机号正确\":\"手机号错误\"); 对象的自然比较内部比较器: 一个类如果想【支持排序】，那么就必须实现接口Comparable&lt;T&gt;，该接口被称为对象的内部比较器； 该接口中只有一个方法；int compareTo(T o) 外部比较器: 一个类实现Comparable这个内部比较器后，该类支持排序，然而只能有一种排序逻辑，比较受限制； 可以使用外部比较器Comparator，灵活为类定义多种比较器，此时类本身不需要实现Comparable接口； Comparator接口中有两个方法int compareTo(T o1,T o2)和boolean equals(Object obj) 对象数组的排序: java.util.Arrays类是一个针对数组进行操作的工具类，其中提供了对对象数组进行排序的方法； 两个常用的对象数组排序方法如下：static void sort(Object[] a)static &lt;T&gt;void sort(T[] a,ComparaTor&lt;? super T?&gt; c) 数学APIMath类提供的数学运算方法: Math类位于java.lang包中，是一个final类，不能被继承； Math类中所有方法都是static方法，可以直接使用类名Math调用； Math中定义了大量与数学运算有关的方法，包括求绝对值、三角函数、平方根等； Math类是final类，不能被继承，所有方法都是static方法，可以直接用类名调用； Math中的round方法是四舍五入，ceil是返回大于参数且最接近参数的整数，floor是返回小于参数且最接近参数的整数； Math中的random方法返回[0.0,1.0)范围的值； Math类中还定义了很多数学计算方法； Java中的大整数API: Java中整数最大范围是long型，64位，如果需要使用超过long范围的大整数，可以使用BigInteger类； BigInteger位于java.math包中，定义了一系列的数学运算方法，调用这些方法可以进行计算，不能使用运算符计算； java.math包中还有一个类叫BigDecimal，虽然和整数无关，我们也在此一起学习； BigDecimal是用来针对浮点型进行精确运算的； BigInteger用来对超过long范围整数进行运算； BigDecimal用来对double、float类型进行精确计算； Java中的随机API Math类中的random方法可以产生随机数，然而，该方法只能生成[0.0,1.0)范围的double值；很多时候，可能需要生成不同类型不同范围的随机值； java.util包中的Random类可以用来生成不同类型的随机值，功能更为强大； Random类有两个构造方法，无参的构造方法创建对象后，每次都生成不同的随机数；有参的构造方法创建对象后，如果种子参数值一样，那么每次生成的随机数也相同； Random类功能强大，能生成int,float,double,boolean各种类型的随机数； random.nextInt生成不定范围的int随机数，而带参数的nextInt生成的随机数有范围； UUID UUID指的是通用唯一识别码，常用于分布式系统； 有多种生成UUID的策略，包括基于时间、基于名字、随机等； Java API中定义了java.util.UUID类，对UUID的生成提供了支持； DateAPI java.util.Date类表示时间，不过由于对国际化支持有限，所以JDK1.1之后推荐使用java.util.Calendar类； JDK1.1版本开始，增加Calendar类，建议使用Calendar类代替Date类； Calendar是抽象类，不能直接使用new创建对象； Calendar类中定义了获得实例的方法getInstance(),得到的实际是子类GregorianCalendar的对象!! 获得日历对象后，可以为该对象的年、月、日、时、分、秒等进行赋值： 实际编程中，往往需要对时间用不同的格式进行展示; SimpleDateFormat中定义了对时间进行格式化的方法；该类继承了抽象父类DateFormat，某些方法在父类中定义，查阅API文档时注意； 可以自定义一个模式字符串来构建SimpleDateFormat对象： 通常使用format方法进行格式化； JDK8中的新API JDK8中定义了java.time.LocalDate，用来表示日期，默认格式是yyyy-MM-dd；该类不包含时间信息；","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java异常处理","slug":"Java异常处理","date":"2017-11-03T10:14:00.000Z","updated":"2019-11-15T05:13:30.061Z","comments":true,"path":"2017/11/03/Java异常处理/","link":"","permalink":"https://zhuyiting.xyz/2017/11/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"异常处理和错误的区别:异常: 异常指的是程序运行时发生的不正常的时间;异常能够被程序处理,保证程序继续运行下去;例如除数为0,文件没有找到,输入的数字格式不对;错误: 错误程序没法处理,例如内存泄漏,发生错误后,一般虚拟机会选择终止程序运行,程序员需要修改代码才能解决相关错误; 运行时异常与非运行时异常:Exception有很多子类,这些子类又可以分为两大类;即运行时异常和非运行时异常运行时异常: 也称为非检测异常,这些异常在编译期不检测,程序中可以选择处理,也可以不处理,如果不处理运行时会中断,但编译没问题.非运行时异常: 也称为检测异常,是必须进行处理的异常,如果不处理,将发生编译期错误. 异常处理的标准流程: 抛出异常运行时异常JVM自行抛出,非运行时异常使用throw抛出 捕获异常catch语句捕获异常 如捕获成功,异常被处理,程序继续运行catch的异常类型与抛出的异常类型匹配时 如捕获失败,异常未被处理,程序中断运行catch的异常类型与抛出的异常类型不匹配 常见的异常类型 Exception: 异常层次结构的父类 ArithmeticException:算术错误情况,如以0作除数 ArrayIndexOutOfBoundsException: 数组下标越界 NullPointerException: 尝试访问null对象成员 ClassNotFoundException: 不能加载所需的类 ClassCastException:对象强制类型转换出错 NumberFormatException: 数字格式转换异常,如把”abc”转成数字了 Try-catch代码块:1234567891011try &#123; // 代码段 1 // 产生异常的代码段 2 // 代码段 3&#125; catch (异常类型1 e) &#123; // 对异常进行处理的代码段4&#125; catch (异常类型2 e) &#123; // 对异常进行处理的代码段5&#125; finally &#123; // 无论是否发生异常,代码总能执行&#125; Throw,Throws关键字 throw: 抛出异常(一般用于代码块和方法中) throws: 声明异常(一般用于方法中)1234567public void setAge(int age)throws Exception&#123; if(age&lt;=0||age&gt;100)&#123; throw new Exception(); //处理方法 try-catch &#125;else&#123; this.age=age; &#125;&#125; 自定义异常:123456public class AgeException extends Exception()&#123; public AgeException()&#123;&#125; public AgeException(String msg)&#123; super(msg); &#125;&#125; 断言:assert 5&lt;3==false “断言信息”","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java异常处理","slug":"Java异常处理","permalink":"https://zhuyiting.xyz/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"集合框架","slug":"集合框架","date":"2017-10-25T00:58:00.000Z","updated":"2019-11-15T05:11:39.701Z","comments":true,"path":"2017/10/25/集合框架/","link":"","permalink":"https://zhuyiting.xyz/2017/10/25/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"泛型的作用:1. 泛型的定义:泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数.这种参数类型,可以在类 接口 和方法中创建,分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。 2. 泛型的作用:引入泛型的好处是安全简单 可以将运行时类型相关错误提前到编译时错误. 3. 泛型的特点: 所有的泛型类的参数在编译时都会被擦除,虚拟机运行时没有泛型. java泛型不支持基本类型 在泛型内部,无法获得有关系泛型参数类型的信息,如果传入的类型参数为T,那么在泛型代码内部你不知道T有什么方法,属性,关于T 的一切信息都丢失了 创建泛型对象时,清指明类型. java的泛型类型不能用于new构建对象,也不能用于初始化数组. 集合接口:1.为什么要使用集合接口:如果并不知道程序运行时会需要多少对象，或者需要更复杂方式存储对象——可以使用Java集合框架 2. 集合框架组成 Collection接口是最基本的集合接口. Map接口(实现类:HasMap . TreeMap)Map是一系列键值对组成的集合,提供了key到Value的映射.同时它也没有继承Collection.在Map中保证了key和Vlaue之间的一一对应,所以它不能存在相同的key值. List接口为Collection子接口。List所代表的是有序的Collection 它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置，和数组相似，从0开始，到元素个数-1）访问元素，并检索列表中的元素 实现类: ArraryList是一个非线程安全的列表,在遍历元素效率比较高.线程不同步. LinkedList是一个双向链表,在添加和删除元素时效率比较高.线程不同步. Vector与ArrayList相似，但是Vector是同步的。所以说Vector是使用数组实现的线程安全的列表。它的操作与ArrayList几乎一样. Set是一种不包括重复元素的Collection: 它维持自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个 由于Set接口的特殊性，所有传入Set集合中的元素都必须不同 实现类: EnumSet是枚举的专用Set。所有的元素都是枚举类型 HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变 TreeSet基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法 Queue 队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作 方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。 接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除 ArrayList ArrayList是一个用数组实现的列表，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null 每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作（构建一个新的更大的数组并将之前的内容拷贝到新书组中）。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率 ArrayList的默认扩容扩展后数组大小为：(原数组长度*3)/2+1 ArrayList是一个非线程安全的列表 LinkedList 同样实现List接口的LinkedList与ArrayList不同，LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"Java集合容器","slug":"Java集合容器","permalink":"https://zhuyiting.xyz/tags/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"}]},{"title":"面向接口编程","slug":"面向接口编程","date":"2017-10-23T10:27:00.000Z","updated":"2019-11-15T04:48:35.329Z","comments":true,"path":"2017/10/23/面向接口编程/","link":"","permalink":"https://zhuyiting.xyz/2017/10/23/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"什么是接口,为什么要用接口?: 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 接口(interface)是抽象方法和常量值的定义的集合。 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。 接口定义举例 123456public interface Runner &#123; int id = 1; public void start(); public void run(); public void stop();&#125; 接口的特点: 用 interface 来定义。 接口中的所有成员变量都默认是由public static final修饰的。 接口中的所有方法都默认是由public abstract修饰的。接口没有构造方法。 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口也可以继承另一个接口，使用extends关键字 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口的使用 编写接口123456public interface UsbInterface&#123; /** *USB接口提供服务 */ void service();&#125; 实现接口12345public class UDisk implements UsbInterface&#123; public void service()&#123; System.out.println(\"连接USB口,开始传输数据.\"); &#125;&#125; 使用接口12UsbInterface uDisk = new UDisk();uDisk.service();","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"interface","slug":"interface","permalink":"https://zhuyiting.xyz/tags/interface/"}]},{"title":"深入面向对象","slug":"深入面向对象","date":"2017-10-15T01:13:00.000Z","updated":"2019-11-15T04:48:48.222Z","comments":true,"path":"2017/10/15/深入面向对象/","link":"","permalink":"https://zhuyiting.xyz/2017/10/15/%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象的三个基本特征:封装 . 继承 . 多态封装(属性 . 对象): 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象继承: 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法 一个新类可以从现有的类中派生，这个过程称为类继承，新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类） 派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要多态: 多态性是指允许不同类的对象对同一消息作出响应 多态性语言具有灵活、抽象、行为共享、代码共享的优势封装的意义: 适当的封装可以让代码更容易理解和维护，也加强了代码的安全性。包机制: 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间包的作用: 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也提供了限定了访问权限的一个控制范围，拥有包访问权限的类才能访问某个包中的类 类的访问控制符: default: 默认的（不提供访问控制符）仅可被同包的其他代码访问 public：可以被任何代码访问 protected: private: 私有的 继承的意义:继承是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的数据或新的功能,也可以用父类的功能,通过使用继承,我们能够非常方便的复用代码,大大提高开发效率 对象向上造型:所谓的向上造型就是父类的引用指向子类的对象 instanceof运算符:instanceof运算符用来判断对象是否属于某个类的实例","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"},{"name":"面向对象","slug":"面向对象","permalink":"https://zhuyiting.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java类的基本结构","slug":"Java类的基本结构","date":"2017-10-10T02:13:00.000Z","updated":"2019-11-15T04:52:24.822Z","comments":true,"path":"2017/10/10/Java类的基本结构/","link":"","permalink":"https://zhuyiting.xyz/2017/10/10/Java%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"面向对象的概念:什么是类?同时将具有相同特征的对象抽象成一种新的数据类型—-类(具有相同特征和行为的多个对象的集合) 封装的好处:一个类把属性算法(逻辑处理)封装起来,只留必要的方法(接口)让用户使用,一个类该暴露什么,不该暴露什么,由类的设计者更具需求设计决定的.private属性用户不能直接访问,如果设计者提供相应的接口方法,那么用户可以通过该接口方法访问.一个类,不直接修改属性而通过方法来修改,可以在方法里做相应的处理避免用户输入的一些非法数据而造成系统故障 什么是构造方法: 构造方法是与类同名的方法 没返回值，也不能写void 主要作用是完成新建对象的初始化工作 一般不能显式地直接调用，而是用new来调用（后面会存在使用this/super调用） 创建一个类的新对象的同时，系统自动调用该类的构造函数，为新建对象的初始化 构造方法重载: 构造方法是一种特殊的方法，它也能重载 构造函数的重载是指同一个类中存在着若干个具有不同参数列表的构造函数 this关键字:this用于表示当前对象自身的引用，可以用于访问被局部变量隐藏的成员变量，也可以将本对象作为参数传递给其他对象操作 类初始化代码块static:####static代码块的执行时机: 用Class.forName(类名)显式加载的时候（反射、JDBC时详细讲解） new或反射实例化一个类的对象时候 调用类的static方法的时候（后续详细讲解） 调用类的static变量的时候（后续详细讲解） 调用类的静态常量（后续详细讲解）的时候，是不会加载类的，即不会执行static{}语句块当访问类的静态常量时，如果编译器可以计算出常量的值，则不会加载类，否则会加载类 用Class.forName()形式的时候，也可以自己设定要不要加载类，如将Class.forName(&quot;Test&quot;)改为 Class.forName(&quot;Test&quot;,false,StaticBlockTest.class.getClassLoader())，你会发现Test没有被加载，static{}没有被执行","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java数组","slug":"Java数组","date":"2017-10-08T08:21:00.000Z","updated":"2019-11-15T04:52:50.841Z","comments":true,"path":"2017/10/08/Java数组/","link":"","permalink":"https://zhuyiting.xyz/2017/10/08/Java%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组: 数组是一组类型相同的数据的集合 数组可以存储多个数据,但类型必须相同 数组能作为数据的容器使用,把多个数据集中存储 存储在数组中的数据,都有相应的索引值,可以方便获取或修改 当需要同时保存多个类型相同的变量并进行处理时,可以考虑用数组数组的特性: Java的数组是引用类型， 数组与类、接口、枚举、注解并列，是引用类型中的一种， Java的数组长度一经确定不能改变； 数组在内存中是连续分配，所以读取速度快 实际应用中，常常无法确定变量的数量，后续我们将学习集合框架，实现可变长度的数据容器；数组的元素: 数组中存储的数据称为数组的元素(Element)， 数组本身是引用类型，但是数组中的元素可以是基本数也可以是引用类型， 也就是说，即可以有存储基本数据类型int的数组，也可以有存储引用类型String的数组，但是数组本身是引用类型 数组中的元素有索引值，索引值从0开始 也就是说，如果一个数组的长度是10，那么索引值就是0-9，也就是第一个元素的索引值是0，第二个的索引值是1，以此类准，通过索引值可以方便访问元素 数组的维数: 如果一个数组中存储数据结构如下所示，元素都是单个数据，称为一维数组，67 78 54 89 12 45 87 97 79 9 其中，67被称为第0个元素，78称为第1个元素…… 如果个数组中存储数据结构如下所示，元素是一维数组，称为二维数组，[67 78 54] [89 12] [45 87 79] [3] 数组声明:一维数组的声明:数组元素类型[] 变量名称 或数组元素类型 变量名称[]","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java基础","slug":"Java基础","date":"2017-10-05T05:43:00.000Z","updated":"2019-11-15T04:52:00.688Z","comments":true,"path":"2017/10/05/Java基础/","link":"","permalink":"https://zhuyiting.xyz/2017/10/05/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"为什么学习java:Java是Sun Microsystems于1995年推出的高级编程语言Java 领域的JavaSE、JavaEE技术已发展成为同C#和.NET平分天下的应用软件开发平台和技术 java语言的特点: 跨平台性;一处编写,处处运行. 面向对象(三大特征);封装.继承.多态. 健壮性;强类型机制,异常处理机制,自动垃圾回收机制 分布式; 多线程; 动态性; JVM(Java Virtual Machine)介绍:JVM称为java虚拟机;JVM可以理解为Java编译器和操作系统之间的虚拟处理器; 编译器编译的字节码只要JVM认识即可 JVM再将字节码解释成操作系统认识的机器码 只要需要运行Java程序的设备,都需要安装JVM JDK与JRE: JDK是Java开发工具包(Java Development Kit)的简称,是一个软件;如果要用Java语言编写程序,就必须在计算机上安装JDK; JRE是Java运行环境(Java Runtime Environment)的简称如果要在机器上运行Java程序,就必须要有JRE; JDK的一些常用工具: javac: 编译器,将源程序转为字节码; java: 运行编译后的java程序(.class后缀的); jar: 打包工具,将相关的类文件打包成一个文件; javadoc: 文档生成器,从源码注释中提取文档; Java项目结构:src目录：存放包和源文件JRE系统库目录：存放程序运行必须的系统库文件bin目录：存放可执行的字节码文件 注释:文本注释: 1234/*** version ycj* data 2017-03-05* / 标识符命名规则: 某一个区域中是唯一的，在不同的区域中可以使用同一名字 必须由字母、数字、下划线和$符号组成 不能以数字开头 不能使非法的字符，如：#，％……“&amp;等 不能使系统关键字 不能使空格来分隔 长度无限制 严格区分大小写 不同的标识符有一定的命名规矩，后续学习 成员变量和局部变量的区别:成员变量是作用于整个类,局部变量作用于某个方法,局部变量没有默认值,必须初始化,成员变量有默认值. 数据类型:数据类型分为基本数据类型和引用数据类型; 数据类型(8个基本数据类型):byte, short, int, long, float, double, boolean, char 引用数据类型:String, 数组, 接口, 类, 枚举, 包装类型String、StringBufferStringBuilder的区别: String类是不可变的，对象一旦被创建，就不能被修改；可以使用=直接赋值，此时使用常量池；也可以使用new创建，不使用常量池；StringBuffer是可变的，对象创建后，可以修改；必须使用new关键字；StringBuilder是不同步的，在单线程情况下使用比StringBuffer高效；必须使用new关键字； 堆,栈,常量池,方法区:基本数据类型保存在栈中,引用数据类型保存在堆中;堆:存放所有new出来的对象栈:存放基本类型的变量数据和对象的应用方法区:包含所有的class和static变量常量区:存放基本类型和字符串常量 运算符:从功能角度分，Java中的运算符可以分为算术、关系、位、逻辑运算符四类算术运算符:用来对操作数进行数学运算.关系运算符:又叫比较运算符,用来运算操作两个数的大小关系.位运算符:针对操作数的二进制位进行运算逻辑运算符:针对布尔值或返回值为布尔值的表达式进行运算","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Web开发入门","slug":"Web开发入门","date":"2017-09-30T09:12:00.000Z","updated":"2019-11-15T04:56:19.178Z","comments":true,"path":"2017/09/30/Web开发入门/","link":"","permalink":"https://zhuyiting.xyz/2017/09/30/Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"C/S B/S网络应用:C/S就是(客户机/服务器)的简称,桌面应用程序采用的多是这种结构.B/S就是(浏览器/服务器)的简称,特点是客户端无需安装特定的软件,只需要安装一个浏览器就可以与系统进行交互 C/S优缺点:由于C/S结构没有像B/S（下一个基本概念介绍）结构中服务器向客户端发送的数据还包含了大量的非实际交换数据，比如请求响应头，还有页面数据等等，它的==相应时间还是相对较快==的；由于C/S结构安装的客户端软件，很多的业务逻辑、算法逻辑处理都在客户端进行，这样就==减轻了服务器的压力==，这是优点，但是带来的问题也显而易见，不但==有被反编译的安全隐患==，而且不断的安装各种客户端软件，会使==客户端越来越臃肿==；在升级维护等工作上带来的麻烦也是令人不愉快，因为每发生一次升级都需要重新更新客户端的软件，这样做的后果就是在==开发上的工作量加大==，而且用户每次都要更新自己终端上的软件，这些都是令人非常头疼的问题；由于需要在客户端进行安装特定软件，因此==对操作系统有一定的限制==； Web站点、Web应用、HTTP服务器、Web应用服务器:==Web站点:==即Web Site,也被成为Web网站;比如某公司逛完就是Web站点 ==Web应用:==即Web Application,简单来说,就是通过浏览器访问的应用程序,从而为客户提供相应服务 ==Http服务器:==即Web服务器,主要功能是提供网上信息浏览服务,例如Apache、Nginx、IIS是比较常用的HTTP服务器. ==Web应用服务器:==Web应用服务器能够运行服务器上的应用程序,并将结果返回给客户端浏览器;例如Tomcat,通常Web应用服务器兼具部分Http服务器的功能. ==Servlet的概念及功能:== Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat； 可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器； Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范，例如，必须继承于javax.servlet.http.HttpServlet类；","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://zhuyiting.xyz/categories/Vue-js/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}]}