{"meta":{"title":"ycjBlog","subtitle":null,"description":null,"author":"yanchengjie","url":"https://zhuyiting.xyz","root":"/"},"pages":[{"title":"友情链接","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":true,"path":"links/index.html","permalink":"https://zhuyiting.xyz/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":false,"path":"categories/index.html","permalink":"https://zhuyiting.xyz/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-10-18T08:58:07.896Z","updated":"2019-10-18T08:58:07.896Z","comments":false,"path":"books/index.html","permalink":"https://zhuyiting.xyz/books/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-10-18T07:42:59.000Z","updated":"2019-10-18T07:42:59.817Z","comments":true,"path":"gallery/index.html","permalink":"https://zhuyiting.xyz/gallery/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"repository/index.html","permalink":"https://zhuyiting.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"tags/index.html","permalink":"https://zhuyiting.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM指令手册","slug":"JVM指令手册","date":"2019-07-30T07:18:00.000Z","updated":"2019-10-20T00:56:02.507Z","comments":true,"path":"2019/07/30/JVM指令手册/","link":"","permalink":"https://zhuyiting.xyz/2019/07/30/JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C/","excerpt":"","text":"栈和局部变量操作将常量压入栈的指令aconst_null 将null对象引用压入栈iconst_m1 将int类型常量-1压入栈iconst_0 将int类型常量0压入栈iconst_1 将int类型常量1压入栈iconst_2 将int类型常量2压入栈iconst_3 将int类型常量3压入栈iconst_4 将int类型常量4压入栈iconst_5 将int类型常量5压入栈lconst_0 将long类型常量0压入栈lconst_1 将long类型常量1压入栈fconst_0 将float类型常量0压入栈fconst_1 将float类型常量1压入栈dconst_0 将double类型常量0压入栈dconst_1 将double类型常量1压入栈bipush 将一个8位带符号整数压入栈sipush 将16位带符号整数压入栈ldc 把常量池中的项压入栈ldc_w 把常量池中的项压入栈（使用宽索引）ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）从栈中的局部变量中装载值的指令iload 从局部变量中装载int类型值lload 从局部变量中装载long类型值fload 从局部变量中装载float类型值dload 从局部变量中装载double类型值aload 从局部变量中装载引用类型值（refernce）iload_0 从局部变量0中装载int类型值iload_1 从局部变量1中装载int类型值iload_2 从局部变量2中装载int类型值iload_3 从局部变量3中装载int类型值lload_0 从局部变量0中装载long类型值lload_1 从局部变量1中装载long类型值lload_2 从局部变量2中装载long类型值lload_3 从局部变量3中装载long类型值fload_0 从局部变量0中装载float类型值fload_1 从局部变量1中装载float类型值fload_2 从局部变量2中装载float类型值fload_3 从局部变量3中装载float类型值dload_0 从局部变量0中装载double类型值dload_1 从局部变量1中装载double类型值dload_2 从局部变量2中装载double类型值dload_3 从局部变量3中装载double类型值aload_0 从局部变量0中装载引用类型值aload_1 从局部变量1中装载引用类型值aload_2 从局部变量2中装载引用类型值aload_3 从局部变量3中装载引用类型值iaload 从数组中装载int类型值laload 从数组中装载long类型值faload 从数组中装载float类型值daload 从数组中装载double类型值aaload 从数组中装载引用类型值baload 从数组中装载byte类型或boolean类型值caload 从数组中装载char类型值saload 从数组中装载short类型值将栈中的值存入局部变量的指令istore 将int类型值存入局部变量lstore 将long类型值存入局部变量fstore 将float类型值存入局部变量dstore 将double类型值存入局部变量astore 将将引用类型或returnAddress类型值存入局部变量istore_0 将int类型值存入局部变量0istore_1 将int类型值存入局部变量1istore_2 将int类型值存入局部变量2istore_3 将int类型值存入局部变量3lstore_0 将long类型值存入局部变量0lstore_1 将long类型值存入局部变量1lstore_2 将long类型值存入局部变量2lstore_3 将long类型值存入局部变量3fstore_0 将float类型值存入局部变量0fstore_1 将float类型值存入局部变量1fstore_2 将float类型值存入局部变量2fstore_3 将float类型值存入局部变量3dstore_0 将double类型值存入局部变量0dstore_1 将double类型值存入局部变量1dstore_2 将double类型值存入局部变量2dstore_3 将double类型值存入局部变量3astore_0 将引用类型或returnAddress类型值存入局部变量0astore_1 将引用类型或returnAddress类型值存入局部变量1astore_2 将引用类型或returnAddress类型值存入局部变量2astore_3 将引用类型或returnAddress类型值存入局部变量3iastore 将int类型值存入数组中lastore 将long类型值存入数组中fastore 将float类型值存入数组中dastore 将double类型值存入数组中aastore 将引用类型值存入数组中bastore 将byte类型或者boolean类型值存入数组中castore 将char类型值存入数组中sastore 将short类型值存入数组中wide指令wide 使用附加字节扩展局部变量索引通用(无类型）栈操作nop 不做任何操作pop 弹出栈顶端一个字长的内容pop2 弹出栈顶端两个字长的内容dup 复制栈顶部一个字长内容dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2 复制栈顶部两个字长内容dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈swap 交换栈顶部两个字长内容类型转换i2l 把int类型的数据转化为long类型i2f 把int类型的数据转化为float类型i2d 把int类型的数据转化为double类型l2i 把long类型的数据转化为int类型l2f 把long类型的数据转化为float类型l2d 把long类型的数据转化为double类型f2i 把float类型的数据转化为int类型f2l 把float类型的数据转化为long类型f2d 把float类型的数据转化为double类型d2i 把double类型的数据转化为int类型d2l 把double类型的数据转化为long类型d2f 把double类型的数据转化为float类型i2b 把int类型的数据转化为byte类型i2c 把int类型的数据转化为char类型i2s 把int类型的数据转化为short类型整数运算iadd 执行int类型的加法ladd 执行long类型的加法isub 执行int类型的减法lsub 执行long类型的减法imul 执行int类型的乘法lmul 执行long类型的乘法idiv 执行int类型的除法ldiv 执行long类型的除法irem 计算int类型除法的余数lrem 计算long类型除法的余数ineg 对一个int类型值进行取反操作lneg 对一个long类型值进行取反操作iinc 把一个常量值加到一个int类型的局部变量上逻辑运算移位操作ishl 执行int类型的向左移位操作lshl 执行long类型的向左移位操作ishr 执行int类型的向右移位操作lshr 执行long类型的向右移位操作iushr 执行int类型的向右逻辑移位操作lushr 执行long类型的向右逻辑移位操作按位布尔运算iand 对int类型值进行“逻辑与”操作land 对long类型值进行“逻辑与”操作ior 对int类型值进行“逻辑或”操作lor 对long类型值进行“逻辑或”操作ixor 对int类型值进行“逻辑异或”操作lxor 对long类型值进行“逻辑异或”操作浮点运算fadd 执行float类型的加法dadd 执行double类型的加法fsub 执行float类型的减法dsub 执行double类型的减法fmul 执行float类型的乘法dmul 执行double类型的乘法fdiv 执行float类型的除法ddiv 执行double类型的除法frem 计算float类型除法的余数drem 计算double类型除法的余数fneg 将一个float类型的数值取反dneg 将一个double类型的数值取反对象和数组对象操作指令new 创建一个新对象checkcast 确定对象为所给定的类型getfield 从对象中获取字段putfield 设置对象中字段的值getstatic 从类中获取静态字段putstatic 设置类中静态字段的值instanceof 判断对象是否为给定的类型数组操作指令newarray 分配数据成员类型为基本上数据类型的新数组anewarray 分配数据成员类型为引用类型的新数组arraylength 获取数组长度multianewarray 分配新的多维数组控制流条件分支指令ifeq 如果等于0，则跳转ifne 如果不等于0，则跳转iflt 如果小于0，则跳转ifge 如果大于等于0，则跳转ifgt 如果大于0，则跳转ifle 如果小于等于0，则跳转if_icmpcq 如果两个int值相等，则跳转if_icmpne 如果两个int类型值不相等，则跳转if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转ifnull 如果等于null，则跳转ifnonnull 如果不等于null，则跳转if_acmpeq 如果两个对象引用相等，则跳转if_acmpnc 如果两个对象引用不相等，则跳转比较指令lcmp 比较long类型值fcmpl 比较float类型值（当遇到NaN时，返回-1）fcmpg 比较float类型值（当遇到NaN时，返回1）dcmpl 比较double类型值（当遇到NaN时，返回-1）dcmpg 比较double类型值（当遇到NaN时，返回1）无条件转移指令goto 无条件跳转goto_w 无条件跳转（宽索引）表跳转指令tableswitch 通过索引访问跳转表，并跳转lookupswitch 通过键值匹配访问跳转表，并执行跳转操作异常athrow 抛出异常或错误finally子句jsr 跳转到子例程jsr_w 跳转到子例程（宽索引）rct 从子例程返回方法调用与返回方法调用指令invokcvirtual 运行时按照对象的类来调用实例方法invokespecial 根据编译时类型来调用实例方法invokestatic 调用类（静态）方法invokcinterface 调用接口方法方法返回指令ireturn 从方法中返回int类型的数据lreturn 从方法中返回long类型的数据freturn 从方法中返回float类型的数据dreturn 从方法中返回double类型的数据areturn 从方法中返回引用类型的数据return 从方法中返回，返回值为void线程同步montiorenter 进入并获取对象监视器monitorexit 释放并退出对象监视器 JVM指令助记符变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_加：iadd,ladd,fadd,dadd减：isub,lsub,fsub,dsub乘：imul,lmul,fmul,dmul除：idiv,ldiv,fdiv,ddiv余数：irem,lrem,frem,drem取负：ineg,lneg,fneg,dneg移位：ishl,lshr,iushr,lshl,lshr,lushr按位或：ior,lor按位与：iand,land按位异或：ixor,lxor类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)创建类实便：new创建新数组：newarray,anewarray,multianwarray访问类的域和类实例域：getfield,putfield,getstatic,putstatic把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore获取数组长度：arraylength检相类实例或数组属性：instanceof,checkcast操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmplfcmpg,dcmpl,dcmpg复合条件转移：tableswitch,lookupswitch无条件转移：goto,goto_w,jsr,jsr_w,ret调度对象的实便方法：invokevirtual调用由接口实现的方法：invokeinterface调用需要特殊处理的实例方法：invokespecial调用命名类中的静态方法：invokestatic方法返回：ireturn,lreturn,freturn,dreturn,areturn,return异常：athrowfinally关键字的实现使用：jsr,jsr_w,ret","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zhuyiting.xyz/tags/JVM/"}]},{"title":"系统开发和运行知识","slug":"系统开发和运行知识","date":"2018-01-13T14:40:00.000Z","updated":"2019-10-19T00:10:01.041Z","comments":true,"path":"2018/01/13/系统开发和运行知识/","link":"","permalink":"https://zhuyiting.xyz/2018/01/13/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%92%8C%E8%BF%90%E8%A1%8C%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. 软件工程、软件过程改进和软件开发项目管理知识 软件工程知识 软件开发生命周期各阶段的目标和任务 软件开发项目管理基础知识（时间管理、成本管理、质量管理、人力资源管理、风险管理等）及其常用管理工具 主要的软件开发方法（生命周期法、原型法、面向对象法、CASE） 软件开发工具与环境知识 软件过程改进知识 软件质量管理知识 软件开发过程评估、软件能力成熟评估基础知识2. 系统分析基础知识 系统分析的目的和任务 结构化分析方法（数据流图（DFD）、数据字典（DD）、实体关系图（ERD）、描述加工处理的结构化语言） 统一建模语言（UML） 系统规格说明书3. 系统设计知识 系统设计的目的和任务 结构化设计方法和工具（系统流程图、HIPO图、控制流程图） 系统总体结构设计（总体布局、设计原则、模块结构设计、数据存储设计、系统配置方案） 系统详细设计（代码设计、数据库设计、用户界面设计、处理过程设计） 系统设计说明书4. 系统实施知识 系统实施的主要任务 结构化程序设计、面向对象程序设计、可视化程序设计 程序设计风格 程序设计语言的选择 系统测试的目的、类型，系统测试方法（黑盒测试、白盒测试、灰盒测试） 测试设计和管理（错误曲线、错误排除、收敛、注入故障、测试用例设计、系统测试报告） 系统转换基础知识5. 系统运行和维护知识 系统运行管理基础知识 系统维护基础知识 系统评价基础知识6. 面向对象开发方法 面向对象开发概念（类、对象、属性、封装性、继承性、多态性、对象之间的引用） 面向对象开发方法的优越性以及有效领域 面向对象设计方法（体系结构、类的设计、用户接口设计） 面向对象实现方法（选择程序设计语言、类的实现、方法的实现、用户接口的实现、准备测试数据） 面向对象程序设计语言（如C++、Java、Visual、Bsasic、Visual C++）的基本机制 面向对象数据库、分布式对象的概念","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机系统知识","slug":"计算机系统知识","date":"2017-12-30T14:36:00.000Z","updated":"2019-10-19T00:09:45.757Z","comments":true,"path":"2017/12/30/计算机系统知识/","link":"","permalink":"https://zhuyiting.xyz/2017/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. 硬件知识1.1 计算机系统的组成、体系结构分类及特性 CPU和存储器的组成、性能和基本工作原理 常用I/O设备、通信设备的性能，以及基本工作原理 I/O接口的功能、类型和特性 I/O控制方式（中断系统、DMA、I/O处理机方式） CISC/RISC，流水线操作，多处理机，并行处理1.2 存储系统 主存-Cache存储系统的工作原理 虚拟存储器基本工作原理，多级存储体系的性能价格 RAID类型和特性1.3 安全性、可靠性与系统性能评测基础知识 诊断与容错 系统可靠性分析评价 计算机系统性能评测方式2. 软件知识2.1 操作系统知识 操作系统的内核（中断控制）、进程、线程概念 处理机管理（状态转换、共享与互斥、分时轮转、抢占、死锁） 存储管理（主存保护、动态连接分配、分段、分页、虚存） 设备管理（I/O控制、假脱机） 文件管理（文件目录、文件组织、存取方法、存取控制、恢复处理） 作业管理（作业调度、作业控制语言（JCL）、多道程序设计） 汉字处理，多媒体处理，人机界面 网络操作系统和嵌入式操作系统基础知识 操作系统的配置2.2 程序设计语言和语言处理程序的知识 汇编、编译、解释系统的基础知识和基本工作原理 程序设计语言的基本成分：数据、运算、控制和传输，过程（函数）调用 各类程序设计语言主要特点和适用情况3. 计算机网络知识 网络体系结构（网络拓扑、OSI/RM、基本的网络协议） 传输介质、传输技术、传输方法、传输控制 常用网络设备和各类通信设备 Client/Server结构、Browser/Server结构 LAN拓扑，存取控制，LAN的组网，LAN间连接，LAN-WAN连接 因特网基础知识以及应用 网络软件 网络管理 网络性能分析4. 数据库知识 数据库管理系统的功能和特征 数据库模型（概念模式、外模式、内模式） 数据模型，ER图，第一范式、第二范式、第三范式 数据操作（集合运算和关系运算） 数据库语言（SQL） 数据库的控制功能（并发控制、恢复、安全性、完整性） 数据仓库和分布式数据库基础知识5. 多媒体知识 多媒体系统基础知识，多媒体设备的性能特性，常用多媒体文件格式 简单图形的绘制，图像文件的处理方法 音频和视频信息的应用 多媒体应用开发过程6. 系统性能知识 性能指标（响应时间、吞吐量、周转时间）和性能设计 性能测试和性能评估 可靠性指标及计算、可靠性设计 可靠性测试和可靠性评估7. 计算机应用基础知识 信息管理、数据处理、辅助设计、自动控制、科学计算、人工智能等基础知识 远程通信服务基础知识 常用应用系统","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机科学基础","slug":"计算机科学基础","date":"2017-12-27T14:17:00.000Z","updated":"2019-10-20T00:44:59.637Z","comments":true,"path":"2017/12/27/计算机科学基础/","link":"","permalink":"https://zhuyiting.xyz/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 数制及其转换• 二进制、十进制和十六进制等常用制数制及其相互转换 2. 数据的表示• 数的表示（原码、反码、补码、移码表示，整数和实数的机内表示，精度和溢出）• 非数值表示（字符和汉字表示、声音表示、图像表示）• 校验方法和校验码（奇偶校验码、海明校验码、循环冗余校验码） 3. 算术运算和逻辑运算• 计算机中的二进制数运算方法• 逻辑代数的基本运算和逻辑表达式的化简 4. 数学基础知识• 命题逻辑、谓词逻辑、形式逻辑的基础知识• 常用数值计算（误差、矩阵和行列式、近似求解方程、插值、数值积分）• 排列组合、概率论应用、应用统计（数据的统计分析）• 运算基本方法（预测与决策、线性规划、网络图、模拟） 5. 常用数据结构• 数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、线索树、堆）、图等的定义、存储和操作• Hash（存储地址计算，冲突处理） 6. 常用算法• 排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法• 算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"软件开发基础","slug":"软件开发基础","date":"2017-12-25T07:18:00.000Z","updated":"2019-10-20T00:45:13.069Z","comments":true,"path":"2017/12/25/软件开发基础/","link":"","permalink":"https://zhuyiting.xyz/2017/12/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"计算机工作的简单过程: 将程序和数据通关输入设备送入存储器(可以理解为内存) 计算机从存储器中取出程序指令送到控制器(可以理解为CPU) 控制器更具指令的含义发出相应的命令(如加法,减法),将存储单元中存放的操作数据取出送往运算器进行运算,再把运算结果送回存储器指定的单元中什么是软件: 软件=程序+文档 不同类型语言的编译与运行:==编译型==语言是先把源程序的每一条语句都编译成机器语言,并保存成二进制文件,运行时计算机可以直接以机器语言来运行此程序,速度较快;==解释型==语言在执行程序时才一条条的解释成机器语言给计算机来执行,所以运行速度会受到影响","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2017-11-30T00:43:00.000Z","updated":"2019-10-20T13:59:32.466Z","comments":true,"path":"2017/11/30/Java多线程/","link":"","permalink":"https://zhuyiting.xyz/2017/11/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"Java多线程程序.进程和多任务: 程序（program） 是对数据描述与操作的代码的集合，是应用程序执行的脚本。 进程（process） 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。 多任务（multi task） 在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。 线程 线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序 一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。 如何创建多线程: 创建 java.lang.Thread 类的子类，重写该类的 run方 法 创建 java.lang.Runnable接 口的实现类，实现接口中的 run 方法(用的更多) Runnable 接口与 Thread 类之间的区别: Runnable 接口必须实现 run 方法，而 Thread 类中的run 方法是一个空方法，可以不重写 Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必须依靠 Thread 类 Runnable 接口适合于资源的共享 多线程的四种状态: 新建（New） 可执行（Runnable） 运行（Running) 阻塞（Blocking) 死亡（Dead) 状态之间的相互转化可执行&lt;—-&gt;阻塞 wait()方法: 中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。 notify()方法： 唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待 notifyall()方法： 唤醒所有由于使用这个同步方法而处于等待的线程结束等待","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"SteamAPI","slug":"SteamAPI","date":"2017-11-25T03:30:00.000Z","updated":"2019-10-20T13:58:59.770Z","comments":true,"path":"2017/11/25/SteamAPI/","link":"","permalink":"https://zhuyiting.xyz/2017/11/25/SteamAPI/","excerpt":"","text":"Stream APIStream位于包java.util.stream .* 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 流(Stream)到底是什么呢?是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。集合讲的是数据，流讲的是计算！ 注意 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream的操作三步骤 创建Stream一个数据源（如：集合、数组），获取一个流 中间操作一个中间操作链，对数据源的数据进行处理 终止操作（终端操作）一个终止操作，执行中间操作链，并产生结果 1. 创建Stream 可以通过Collection系列集合提供的stream()或parallelStream()方法default Stream&lt; E&gt; stream() : 返回一个顺序流default Stream&lt; E&gt; parallelStream() : 返回一个并行流 通过 Arrays 中的静态方法stream()获取数组流static &lt;T&gt; Stream&lt;T&gt; stream( T[] array): 返回一个流重载形式，能够处理对应基本类型的数组：public static IntStream stream(int[] array)public static LongStream stream(long[] array)public static DoubleStream stream(double[] array) 通过Stream 类中的静态方法of()，通过显示值创建一个流。它可以接收任意数量的参数。public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流 创建无限流可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。迭代 public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f)生成 public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s) 12345678910111213141516171819202122//创建Stream@Testpublic void test1()&#123; //1.可以通过Collection 系列集合提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); //2.通过 Arrays 中的静态方法stream()获取数组流 Employee[] emps=new Employee[10]; Stream&lt;Employee&gt; stream2=Arrays.stream(emps); //3.通过Stream 类中的静态方法of() Stream&lt;String&gt; stream3=Stream.of(\"aa\",\"bb\",\"cc\"); //4.创建无限流 //迭代 Stream&lt;Integer&gt; stream4=Stream.iterate(0, (x) -&gt; x+2); stream4.limit(10).forEach(System.out::println); //生成 Stream.generate(() -&gt; Math.random()).limit(5).forEach(System.out::println);&#125; 2.中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性处理，成为“惰性求值”。 筛选与切片filter(Predicate p): 接收lambda,从流中排除某些元素distinct(): 筛选,通过流所生成元素的hashCode()和equals去除重复元素limit(long maxSize): 截断流,使元素不超过给定数量skip(long n): 跳过元素,返回一个扔掉了前n个元素的流,若流中元素不足n个,则返回一个空流,与limit(n)互补 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//中间操作List&lt;Employee&gt; employees=Arrays.asList( new Employee(\"张三\",18,9999.99), new Employee(\"李四\",58,5555.55), new Employee(\"王五\",26,3333.33), new Employee(\"赵六\",36,6666.66), new Employee(\"田七\",12,8888.88), new Employee(\"田七\",12,8888.88) ); /* 筛选与切片* filter--接收Lambda，从流中排除某些元素。* limit--截断流，使其元素不超过给定数量。* skip(n)--跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补* distinct--筛选，通过流所生成元素的 hashCode() 和 equals() 去掉重复元素*/ //内部迭代：迭代操作由 Stream API 完成@Testpublic void test1()&#123; //中间操作：不会执行任何操作 Stream&lt;Employee&gt; stream=employees.stream().filter((e) -&gt; e.getAge()&gt;35 ); //终止操作：一次性执行全部内容，即 惰性求值 stream.forEach(System.out::println);&#125;//外部迭代@Testpublic void test2()&#123; Iterator&lt;Employee&gt; it=employees.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125;&#125; @Testpublic void test3()&#123;//发现“短路”只输出了两次，说明只要找到 2 个 符合条件的就不再继续迭代 employees.stream().filter((e)-&gt;&#123; System.out.println(\"短路！\"); return e.getSalary()&gt;5000; &#125;).limit(2).forEach(System.out::println);&#125; @Testpublic void test4()&#123; employees.stream().filter((e)-&gt;e.getSalary()&gt;5000).skip(2)//跳过前两个 .distinct()//去重，注意：需要Employee重写hashCode 和 equals 方法 .forEach(System.out::println);&#125; 映射 1234567891011121314151617181920212223/* 映射* map--接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。* flatMap--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流*/@Testpublic void test5()&#123; List&lt;String&gt; list=Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); list.stream() .map((str)-&gt;str.toUpperCase()) .forEach(System.out::println); System.out.println(\"------------------------\"); employees.stream().map(Employee::getName) .forEach(System.out::println); System.out.println(\"------------------------\"); Stream&lt;Character&gt; sm=list.stream() .flatMap(TestStream::filterChatacter); sm.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterChatacter(String str)&#123; List&lt;Character&gt; list=new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 排序 1234567891011121314151617/*排序* sorted()-自然排序（按照对象类实现Comparable接口的compareTo()方法 排序）* sorted(Comparator com)-定制排序（Comparator）*/@Testpublic void test7()&#123; List&lt;String&gt; list=Arrays.asList(\"ccc\",\"bbb\",\"aaa\"); list.stream().sorted().forEach(System.out::println); System.out.println(\"------------------------\"); employees.stream().sorted((e1,e2)-&gt;&#123; if(e1.getAge().equals(e2.getAge()))&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e1.getAge().compareTo(e2.getAge()); &#125; &#125;).forEach(System.out::println); &#125; 3. 终止操作终止操作会从流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。 查找与匹配 1234567891011121314151617181920212223242526272829/** 查找与匹配*/@Testpublic void test1()&#123; //allMatch-检查是否匹配所有元素 boolean b1=employees.stream().allMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b1);//false boolean b2=employees.stream().anyMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b2);//true //noneMatch-检查是否没有匹配所有元素 booleanb3=employees.stream().noneMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b3);//false //findFirst-返回第一个元素//Optional是Java8中避免空指针异常的容器类 Optional&lt;Employee&gt; op=employees.stream().sorted((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).findFirst(); System.out.println(op.get()); //findAny-返回当前流中的任意元素 Optional&lt;Employee&gt; op2=employees.parallelStream().filter((e)-&gt;e.getStatus().equals(Status.FREE)).findAny(); System.out.println(op2.get()); //count-返回流中元素的总个数 Long count=employees.stream().count(); System.out.println(count);//5 //max-返回流中最大值 Optional&lt;Employee&gt; op3=employees.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op3.get()); //min返回流中最小值 Optional&lt;Double&gt;op4=employees.stream().map(Employee::getSalary).min(Double::compare); System.out.println(op4.get());//3333.33 &#125; 归约 1234567891011121314/*归约* reduce(T identity,BinaryOperator b) / reduce(BinaryOperator b)-可以将流中元素反复结合起来，得到一个值。*/@Testpublic void test3()&#123; List&lt;Integer&gt; list=Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum=list.stream() reduce(T identity,BinaryOperator b).reduce(0, (x,y)-&gt;x+y); //0为起始值 System.out.println(sum); System.out.println(\"--------------------------\"); Optional&lt;Double&gt; op=employees.stream().map(Employee::getSalary).reduce(Double::sum); System.out.println(op.get());&#125; 收集 1234567891011121314151617181920212223242526272829303132333435/** 收集* collect-将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。*/@Testpublic void test4()&#123; List&lt;String&gt; list=employees.stream().map(Employee::getName).collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(\"----------------------------\"); Set&lt;String&gt; set=employees.stream().map(Employee::getName).collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(\"----------------------------\"); //总和 Long count=employees.stream().collect(Collectors.counting()); System.out.println(count); //平均值 Double avg=employees.stream().collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); //总和 Double sum=employees.stream().collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); //最大值 Optional&lt;Employee&gt; max=employees.stream().collect(Collectors.maxBy((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(max.get()); //最小值 Optional&lt;Double&gt; min=employees.stream().map(Employee::getSalary).collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); System.out.println(\"----------------------------\"); //分组 Map&lt;Status,List&lt;Employee&gt;&gt; map=employees.stream().collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map); //分区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map3=employees.stream().collect(Collectors.partitioningBy((e)-&gt;e.getSalary()&gt;8000)); System.out.println(map3);)","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Lambda","slug":"Lambda","date":"2017-11-18T05:40:00.000Z","updated":"2019-10-20T13:58:44.954Z","comments":true,"path":"2017/11/18/Lambda/","link":"","permalink":"https://zhuyiting.xyz/2017/11/18/Lambda/","excerpt":"","text":"函数式接口:我们把只拥有一个方法的接口称为函数式接口. 我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个 Object 已经提供的方法，比如 toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过 @FunctionalInterface 注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。 函数式接口的实现引入了一个全新的结构化函数类型.我们也称为是”箭头”类型. Java8中加入新的包：java.util.function它包含了常用的函数式接口: Predicate&lt;T&gt;: 接收T并返回boolean Consumer&lt;T&gt;: 接收T,不返回值 Function&lt;T, R&gt;: 接收T,返回R Supplier&lt;T&gt;: 提供T,不接收值 Unaryoperator&lt;T&gt;: 接收T,返回T Binary0perator&lt;T&gt;: 接收两个T,返回T Lambda表达式:lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的语法过于冗余. 下面是一些表达式: 123(int x,int y)-&gt;x+y()-&gt;42(String s)-&gt;System.out.println(s); lambda 表达式的语法由参数列表、箭头符号 -&gt; 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块： 表达式:表达式会被执行然后返回执行结果. 语句块:语句块中的语句会被依次执行,就像方法中的语句一样 return语句会把控制权交给匿名方法的调用者 break和continue只能在循环中使用 如果函数体有返回值,那么函数体内部的每一条路径都必须返回值 目标类型: 编译器负责推导lambda表达式类型,它利用lambda表达式所在上下文所期待的类型进行推导,这个被期待的类型被称为==目标类型==.lambda表达式只能出现在目标类型为函数式接口的上下文中. 当然lambda对于目标类型也是有要求的,编译器会检查lambda表达式的类型和目标类型的方法签名是否一致,当且仅当下面所有条件均满足时,lambda表达式才可以被赋给目标类型T: T是一个函数式接口 lambda表达式的参数和T的方法参数在数量和类型上一一对应 lambda表达式的返回值和T的方法返回值相兼容 lambda表达式内锁抛出的异常和T的方法throws类型相兼容 Java内置函数式接口为了免去用户每次使用Lamdba表达式时,都自行创建函数式接口,java中提供了四大核心内置函数式接口: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Consumer&lt;T&gt; :消费型接口 * void accept(T t); * * Supplier&lt;T&gt; :供给型接口 * T get(); * * Function&lt;T,R&gt; :函数型接口 * R apply(T t); * * Predicate&lt;T&gt; :断言型接口 * boolean test(T t); */ public class TestLambda3 &#123; //Consumer&lt;T&gt; 消费型接口： public void happy(double money,Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125; @Test public void test1()&#123; happy(1000,(m) -&gt;System.out.println(\"消费：\"+m+\"元\")); &#125; //Supplier&lt;T&gt; 供给型接口: //需求：产生指定个数的整数，并放入集合中 public List&lt;Integer&gt; getNumList(int num,Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n=sup.get(); list.add(n); &#125; return list; &#125; @Test public void test2()&#123; List&lt;Integer&gt; numList=getNumList(10, ()-&gt;(int)(Math.random()*100)); for (Integer num : numList) &#123; System.out.println(num); &#125; &#125; //Function&lt;T,R&gt; 函数型接口: //需求：处理字符串 public String strHandler(String str,Function&lt;String,String&gt; fun)&#123; return fun.apply(str); &#125; @Test public void test3()&#123; String newStr=strHandler(\"\\t\\t\\t 哈哈哈 \", (str)-&gt;str.trim()); System.out.println(newStr); String subStr=strHandler(\"abcdef\", (str)-&gt;str.substring(2,4)); System.out.println(subStr); &#125; //Predicate&lt;T&gt; 断言型接口： //需求：将满足条件的字符串，放入集合中 public List&lt;String&gt; filterStr(List&lt;String&gt; list,Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList=new ArrayList&lt;&gt;(); for ( String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList; &#125; @Test public void test4()&#123; List&lt;String&gt; list=Arrays.asList(\"Hello\",\"jj\",\"Lambda\",\"www\",\"ok\"); List&lt;String&gt; strList=filterStr(list, (s)-&gt;s.length()&gt;3); for (String string : strList) &#123; System.out.println(string); &#125; &#125;&#125;","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java输入输出","slug":"Java输入输出","date":"2017-11-14T02:01:00.000Z","updated":"2019-10-20T13:58:33.914Z","comments":true,"path":"2017/11/14/Java输入输出/","link":"","permalink":"https://zhuyiting.xyz/2017/11/14/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"第1节:文件 File类型 java.io.File类的对象可以表示文件和目录，在程序中一个File类对象可以代表一个文件或目录 当创建一个File对象后，就可以利用它来对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等等 需要注意的是，File对象并不能直接对文件内容进行读/写操作，只能查看文件的属性 第2节:输出输出流 输入输出流的概念与作用 流的特点: 流是一串连续不断的数据的集合,只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的 输入流：从外存读取数据到内存，输出流：将数据从内存写到外存中 Java中输入输出流的类型 对于输入和输出流，由于传输格式的不同，又分为字节流和字符流： Java的输入输出流的继承树 Java I/O主要包括: 流式部分:IO的主体部分； 非流式部分:主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类； 其他类:文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。 字节输出流 OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的 OutputStream OutputStream是一个抽象类，提供了Java向流中以字节为单位写入数据的公开接口，大部分字节输出流都继承自OutputStream类 DataOutput DataOutput接口规定一组操作，用于直接向流中写入基本类型的数据和字符串： DataInput对基本数据类型的写入分别提供了不同的方法，方法名满足writeXXX()的规律,如writeInt()表示向流中写入一个int型数据，写入字符串的方法为writeUTF() 常见字节输出流工具的作用与使用 FileOutputStream类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是File或FileDescriptor对象。 创建一个文件流对象有以下方法: 方式1：12File f=new File(“d:/abc.txt”);FileOutputStream out=new FileOutputStream (f); 方式2：1FileOutputStream out=new FileOutputStream(“d:/abc.txt”); 方式3：构造函数将 FileDescriptor()对象作为其参数。12FileDescriptor() fd=new FileDescriptor();FileOutputStream f2=new FileOutputStream(fd); 方式4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。1FileOutputStream f=new FileOutputStream(“d:/abc.txt”,true); 字节输入流 InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法. InputStream InputStream也是一个抽象类，提供了Java中从流中以字节为单位读取数据的公开接口，大部分字节输入流都继承自InputStream类 DataInput DataInput接口规定一组操作，用于以一种与机器无关（当前操作系统等）的方式，直接在流中读取基本类型的数据和字符串： DataInput对基本数据类型的读取分别提供了不同的方法，方法名满足readXXX()的规律,如readInt()表示从流中读取一个int型数据读取字符串的方法为readUTF() 常见的字节输入流工具的作用与使用 FileInputStream类是InputStream类的子类，用来处理以文件作为数据输入源的数据流。 使用方法: 方式1：12 File fin=new File(“d:/abc.txt”);FileInputStream in=new FileInputStream(fin); 方式2：1FileInputStream in=new FileInputStream(“d: /abc.txt”; 方式3：构造函数将 FileDescriptor()对象作为其参数。12FileDescriptor() fd=new FileDescriptor();FileInputStream f2=new FileInputStream(fd); 程序对应的基本输入为键盘输入，基本输出为显示器输出。Java中，System类的in和out两个成员代表了基本输入输出的抽象 System.in:基本输入，对应InputStreamSystem.out:基本输出，对应PrintStream RandomAccessFile RandomAccessFile类可以在文件中==任何位置==查找或写入数据 RandomAccessFile==同时实现了DataInput和DataOutput接口== 磁盘文件都是可以随机访问的， 但是从网络而来的数据流却不是 ByteArrayOutpuStream/ByteArrayInputStream 一对输入输出工具为我们提供了在内存中利用byte[]进行缓冲流操作的工具 ByteArrayOutputStream提供工具将内存中以串行序列存在的流式数据以一个字节为单位进行切分，形成一个byte[]数组 而ByteArrayInputStream则正好相反，提供工具将内存中的byte[]数组中的数据进行串行序列化拼接，形成一个可供操作的流式数据 从功能上看，ByteArrayOutpuStream可以将任意数据组合转换为byte[]，而ByteArrayInputStream可以将这个数组还原，从而以流的形式读取任意数据组合 字符输出流 考虑到Java是跨平台的语言，要经常操作Unicode编码的文件，使用基于字符为读、写基本单元的字符流操作文件是有必要的,以字符为单位进行数据输出的工具继承自Writer 字符输出流的统一数据写入方法 Writer和OutputStream类似也提供了统一的往流中写入数据的方法，和OutputStream不同的是，写入数据的单位由字节变成了字符 字符输出流工具的作用与使用 FileWriter类称为文件写入流，以字符流的形式对文件进行写操作 FileWriter将逐个向文件写入字符，效率比较低下，因此一般将该类对象包装到缓冲流中进行操作 还可以使用PrintWriter对流进行包装，提供更方便的字符输出格式控制 字符输入流 以字符为单位进行数据读取的工具继承自Reader，Reader会将读取到的数据按照标准的规则转换为Java字符串对象 字符输入流的统一数据读取方法 字符输入流Reader也提供的统一读取数据的方法（和InputStream不同，实际开发时更多的调用不同Reader提供的特殊读取方法，如BufferedReader的readLine()，能够简化操作） 常见的字符输入流工具的作用与使用 FileReader类称为文件读取流，允许以字符流的形式对文件进行读操作 与FileWriter相似，该类将从文件中逐个地读取字符，效率比较低下，因此一般也将该类对象包装到缓冲流中进行操作 字节流与字符流的适配器 在某些时候虽然我们操作的是字符串，但是不得不面对数据来源是InputStream（字节输入流）的情况，在这种情况下，Java提供了将InputStream和Reader之间进行转换的工具，事实上，字节输出流和字符输出流之间也存在这种工具，称为：字节流与字符流的适配器： InputStreamReader： 字节流通向字符流的桥梁，它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集 每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节 OutputStreamWriter： 字符流通向字节流的桥梁，使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集 每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲 第3节:对象序列化Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能 对象序列化的作用 使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量 除了在持久化对象时会用到对象序列化之外，在网络中传递对象时，也会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制 序列化接口 在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化 java.io.Serializable是一个标识接口，即意味着它仅仅是为了说明类的可序列化属性，接口没有包含任何需要子类实现的抽象方法 对象序列化和反序列化 将对象的状态信息保存到流中的操作，称为序列化，可以使用Java提供的工具ObjectOutputStream. writeObject(Serializable obj)来完成 从流中读取对心状态信息的操作称为反序列化，可以使用Java提供的工具ObjectInputStream.readObject()来完成","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java核心API","slug":"Java核心API","date":"2017-11-10T02:09:00.000Z","updated":"2019-10-20T13:56:26.147Z","comments":true,"path":"2017/11/10/Java核心API/","link":"","permalink":"https://zhuyiting.xyz/2017/11/10/Java%E6%A0%B8%E5%BF%83API/","excerpt":"","text":"Object Object类是Java语言中所有类的根,所有的类都直接或间接的继承了Object类; 数组也继承了Object类; Object类中定义了equals(Object obj)方法,用来比较两个对象的虚拟地址,如果虚拟地址相同则返回true,否则返回false; Object类中的equals()方法的作用,与==相同,都是比较两个对象的虚地址 很多类覆盖了equals方法,用来比较两个对象的属性值,如果属性值相同,则认为两个对象相等,例如[String类就覆盖了equals方法,用来比较两个字符串的字符序列值] Object类中定义了hashCode方法public int hashCode()，用来返回对象的哈希码； hashCode方法主要为了配合基于哈希的集合类一起工作，例如HashSet、HashMap等； 默认情况下(即没有重新hashCode方法时)，当两个引用的虚地址相同时，hashCode返回相同的值，否则返回不同的值； 事实上，基于哈希的集合在使用hashCode的时候，基本都是和equals一起使用；先用hashCode初步比较,再用equals比较 注意:使用的时候一起使用,重写的时候也要一起重写 Object类中定义了toString方法 字符串类型是编程时最常用的类型，Object类中定义了toString方法public String toString()，可以把任意类型对象转换成字符串返回； 默认情况（没有重写Object类中的toString方法）下，返回字符串的格式为：对象类型@对象调用hashCode方法的返回值； 返回Object类中默认格式的字符串几乎没有实用意义，因此很多时候，都会重写一些实体类的toString方法，返回需要的字符串格式； Object类中定义了克隆方法clone Clone方法能够“复制”一个对象，生成一个新的引用，分配新的内存空间； 一个类必须实现Cloneable接口，才能被克隆，否则抛出异常； 克隆是生成了一个新的对象，然而，对象的属性如果有引用类型，实际上还是公用； 深克隆时，属性不仅值相同，同时又都存储在完全不同的内存中 StringString类中定义了一系列字符串相关方法，可以根据API文档进行学习，练习 子串截取方法: String substring(int beginIndex) String substring(int beginIndex,int endIndex) 检索相关方法: int indexOf(int ch) int indexOf(int ch,int fromIndex) int indexOf(String str) int indexOf(String str,int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch,int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str,int fromIndex) char charAt(int index) 类型转换相关的方法: static String valueOf(boolen b) static String valueOf(char c) static String valueOf(char[] data) static String valueOf(char[] data,int offset,int count) static String valueOf(double d) static String valueOf(float f) static String valueOf(int i) static String valueOf(long l) static String valueOf(Object obj) 其他方法: int compareTo(String anotherString) boolean endsWith(String suffix) byte[] getBytes() byte[] getBytes(Charset charset) int length() boolean startsWith(String prefix) boolean startsWith(String prefix,int toffset) String trim() 正则表达式正则表达式就是用来描述字符串逻辑规则的工具 正则表达式本身也是个字符串，不过这些字符串是使用系列“元字符”组成； 所谓“元字符”就是预先定义的，有特殊意义的字符；例如\\d用来匹配一个数字； \\w用来匹配字母或数字或下划线或汉字等； 很多语言多对正则表达式提供了支持，例如JavaScript、Java等； 不同语言中使用正则表达式时，正则表达式的具体编写规则会有些小的差别，但是大体相同； 正大表达式在Java中的使用123456789101112131415161718192021String regex=\"^((13[0-9])|(15[0-3,5-9])|(18[0,2,3,5-9])|(17[0-8])|(147))\\\\d&#123;8&#125;$\";//检验的手机号码String string=\"15123569087\";//第一种方式//将正则表达式编译成Pattern对象Pattern pattern=Pattern.compile(regex);//使用Pattern对象为每个手机号码产生一个匹配器Matcher matcher=pattern.matcher( string);boolean flag=matcher.matches();System.out.println(flag==true?\"手机号正确\":\"手机号错误\");//第二种方式//将正则表法式编译成Pattern对象Pattern pattern2=Pattern.compile(regex);boolean flag2=pattern2.matches(regex, string);System.out.println(flag2==true?\"手机号正确\":\"手机号错误\");//第三种方式boolean flag3=string.matches(regex);System.out.println(flag3==true?\"手机号正确\":\"手机号错误\"); 对象的自然比较内部比较器: 一个类如果想【支持排序】，那么就必须实现接口Comparable&lt;T&gt;，该接口被称为对象的内部比较器； 该接口中只有一个方法；int compareTo(T o) 外部比较器: 一个类实现Comparable这个内部比较器后，该类支持排序，然而只能有一种排序逻辑，比较受限制； 可以使用外部比较器Comparator，灵活为类定义多种比较器，此时类本身不需要实现Comparable接口； Comparator接口中有两个方法int compareTo(T o1,T o2)和boolean equals(Object obj) 对象数组的排序: java.util.Arrays类是一个针对数组进行操作的工具类，其中提供了对对象数组进行排序的方法； 两个常用的对象数组排序方法如下：static void sort(Object[] a)static &lt;T&gt;void sort(T[] a,ComparaTor&lt;? super T?&gt; c) 数学APIMath类提供的数学运算方法: Math类位于java.lang包中，是一个final类，不能被继承； Math类中所有方法都是static方法，可以直接使用类名Math调用； Math中定义了大量与数学运算有关的方法，包括求绝对值、三角函数、平方根等； Math类是final类，不能被继承，所有方法都是static方法，可以直接用类名调用； Math中的round方法是四舍五入，ceil是返回大于参数且最接近参数的整数，floor是返回小于参数且最接近参数的整数； Math中的random方法返回[0.0,1.0)范围的值； Math类中还定义了很多数学计算方法； Java中的大整数API: Java中整数最大范围是long型，64位，如果需要使用超过long范围的大整数，可以使用BigInteger类； BigInteger位于java.math包中，定义了一系列的数学运算方法，调用这些方法可以进行计算，不能使用运算符计算； java.math包中还有一个类叫BigDecimal，虽然和整数无关，我们也在此一起学习； BigDecimal是用来针对浮点型进行精确运算的； BigInteger用来对超过long范围整数进行运算； BigDecimal用来对double、float类型进行精确计算； Java中的随机API Math类中的random方法可以产生随机数，然而，该方法只能生成[0.0,1.0)范围的double值；很多时候，可能需要生成不同类型不同范围的随机值； java.util包中的Random类可以用来生成不同类型的随机值，功能更为强大； Random类有两个构造方法，无参的构造方法创建对象后，每次都生成不同的随机数；有参的构造方法创建对象后，如果种子参数值一样，那么每次生成的随机数也相同； Random类功能强大，能生成int,float,double,boolean各种类型的随机数； random.nextInt生成不定范围的int随机数，而带参数的nextInt生成的随机数有范围； UUID UUID指的是通用唯一识别码，常用于分布式系统； 有多种生成UUID的策略，包括基于时间、基于名字、随机等； Java API中定义了java.util.UUID类，对UUID的生成提供了支持； DateAPI java.util.Date类表示时间，不过由于对国际化支持有限，所以JDK1.1之后推荐使用java.util.Calendar类； JDK1.1版本开始，增加Calendar类，建议使用Calendar类代替Date类； Calendar是抽象类，不能直接使用new创建对象； Calendar类中定义了获得实例的方法getInstance(),得到的实际是子类GregorianCalendar的对象!! 获得日历对象后，可以为该对象的年、月、日、时、分、秒等进行赋值： 实际编程中，往往需要对时间用不同的格式进行展示; SimpleDateFormat中定义了对时间进行格式化的方法；该类继承了抽象父类DateFormat，某些方法在父类中定义，查阅API文档时注意； 可以自定义一个模式字符串来构建SimpleDateFormat对象： 通常使用format方法进行格式化； JDK8中的新API JDK8中定义了java.time.LocalDate，用来表示日期，默认格式是yyyy-MM-dd；该类不包含时间信息；","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java异常处理","slug":"Java异常处理","date":"2017-11-03T10:14:00.000Z","updated":"2019-10-20T13:55:41.108Z","comments":true,"path":"2017/11/03/Java异常处理/","link":"","permalink":"https://zhuyiting.xyz/2017/11/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"异常处理和错误的区别:异常: 异常指的是程序运行时发生的不正常的时间;异常能够被程序处理,保证程序继续运行下去;例如除数为0,文件没有找到,输入的数字格式不对;错误: 错误程序没法处理,例如内存泄漏,发生错误后,一般虚拟机会选择终止程序运行,程序员需要修改代码才能解决相关错误; 运行时异常与非运行时异常:Exception有很多子类,这些子类又可以分为两大类;即运行时异常和非运行时异常运行时异常: 也称为非检测异常,这些异常在编译期不检测,程序中可以选择处理,也可以不处理,如果不处理运行时会中断,但编译没问题.非运行时异常: 也称为检测异常,是必须进行处理的异常,如果不处理,将发生编译期错误. 异常处理的标准流程: 抛出异常运行时异常JVM自行抛出,非运行时异常使用throw抛出 捕获异常catch语句捕获异常 如捕获成功,异常被处理,程序继续运行catch的异常类型与抛出的异常类型匹配时 如捕获失败,异常未被处理,程序中断运行catch的异常类型与抛出的异常类型不匹配 常见的异常类型 Exception: 异常层次结构的父类 ArithmeticException:算术错误情况,如以0作除数 ArrayIndexOutOfBoundsException: 数组下标越界 NullPointerException: 尝试访问null对象成员 ClassNotFoundException: 不能加载所需的类 ClassCastException:对象强制类型转换出错 NumberFormatException: 数字格式转换异常,如把”abc”转成数字了 Try-catch代码块:1234567891011try &#123; // 代码段 1 // 产生异常的代码段 2 // 代码段 3&#125; catch (异常类型1 e) &#123; // 对异常进行处理的代码段4&#125; catch (异常类型2 e) &#123; // 对异常进行处理的代码段5&#125; finally &#123; // 无论是否发生异常,代码总能执行&#125; Throw,Throws关键字 throw: 抛出异常(一般用于代码块和方法中) throws: 声明异常(一般用于方法中)1234567public void setAge(int age)throws Exception&#123; if(age&lt;=0||age&gt;100)&#123; throw new Exception(); //处理方法 try-catch &#125;else&#123; this.age=age; &#125;&#125; 自定义异常:123456public class AgeException extends Exception()&#123; public AgeException()&#123;&#125; public AgeException(String msg)&#123; super(msg); &#125;&#125; 断言:assert 5&lt;3==false “断言信息”","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"集合框架","slug":"集合框架","date":"2017-10-25T00:58:00.000Z","updated":"2019-10-20T13:55:20.536Z","comments":true,"path":"2017/10/25/集合框架/","link":"","permalink":"https://zhuyiting.xyz/2017/10/25/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"泛型的作用:1. 泛型的定义:泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数.这种参数类型,可以在类 接口 和方法中创建,分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。 2. 泛型的作用:引入泛型的好处是安全简单 可以将运行时类型相关错误提前到编译时错误. 3. 泛型的特点: 所有的泛型类的参数在编译时都会被擦除,虚拟机运行时没有泛型. java泛型不支持基本类型 在泛型内部,无法获得有关系泛型参数类型的信息,如果传入的类型参数为T,那么在泛型代码内部你不知道T有什么方法,属性,关于T 的一切信息都丢失了 创建泛型对象时,清指明类型. java的泛型类型不能用于new构建对象,也不能用于初始化数组. 集合接口:1.为什么要使用集合接口:如果并不知道程序运行时会需要多少对象，或者需要更复杂方式存储对象——可以使用Java集合框架 2. 集合框架组成 Collection接口是最基本的集合接口. Map接口(实现类:HasMap . TreeMap)Map是一系列键值对组成的集合,提供了key到Value的映射.同时它也没有继承Collection.在Map中保证了key和Vlaue之间的一一对应,所以它不能存在相同的key值. List接口为Collection子接口。List所代表的是有序的Collection 它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置，和数组相似，从0开始，到元素个数-1）访问元素，并检索列表中的元素 实现类: ArraryList是一个非线程安全的列表,在遍历元素效率比较高.线程不同步. LinkedList是一个双向链表,在添加和删除元素时效率比较高.线程不同步. Vector与ArrayList相似，但是Vector是同步的。所以说Vector是使用数组实现的线程安全的列表。它的操作与ArrayList几乎一样. Set是一种不包括重复元素的Collection: 它维持自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个 由于Set接口的特殊性，所有传入Set集合中的元素都必须不同 实现类: EnumSet是枚举的专用Set。所有的元素都是枚举类型 HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变 TreeSet基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法 Queue 队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作 方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。 接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除 ArrayList ArrayList是一个用数组实现的列表，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null 每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作（构建一个新的更大的数组并将之前的内容拷贝到新书组中）。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率 ArrayList的默认扩容扩展后数组大小为：(原数组长度*3)/2+1 ArrayList是一个非线程安全的列表 LinkedList 同样实现List接口的LinkedList与ArrayList不同，LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"面向接口编程","slug":"面向接口编程","date":"2017-10-23T10:27:00.000Z","updated":"2019-10-20T13:54:58.868Z","comments":true,"path":"2017/10/23/面向接口编程/","link":"","permalink":"https://zhuyiting.xyz/2017/10/23/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"什么是接口,为什么要用接口?: 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 接口(interface)是抽象方法和常量值的定义的集合。 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。 接口定义举例 123456public interface Runner &#123; int id = 1; public void start(); public void run(); public void stop();&#125; 接口的特点: 用 interface 来定义。 接口中的所有成员变量都默认是由public static final修饰的。 接口中的所有方法都默认是由public abstract修饰的。接口没有构造方法。 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口也可以继承另一个接口，使用extends关键字 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口的使用 编写接口123456public interface UsbInterface&#123; /** *USB接口提供服务 */ void service();&#125; 实现接口12345public class UDisk implements UsbInterface&#123; public void service()&#123; System.out.println(\"连接USB口,开始传输数据.\"); &#125;&#125; 使用接口12UsbInterface uDisk = new UDisk();uDisk.service();","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"深入面向对象","slug":"深入面向对象","date":"2017-10-15T01:13:00.000Z","updated":"2019-10-20T13:54:49.307Z","comments":true,"path":"2017/10/15/深入面向对象/","link":"","permalink":"https://zhuyiting.xyz/2017/10/15/%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象的三个基本特征:封装 . 继承 . 多态封装(属性 . 对象): 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象继承: 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法 一个新类可以从现有的类中派生，这个过程称为类继承，新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类） 派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要多态: 多态性是指允许不同类的对象对同一消息作出响应 多态性语言具有灵活、抽象、行为共享、代码共享的优势封装的意义: 适当的封装可以让代码更容易理解和维护，也加强了代码的安全性。包机制: 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间包的作用: 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也提供了限定了访问权限的一个控制范围，拥有包访问权限的类才能访问某个包中的类 类的访问控制符: default: 默认的（不提供访问控制符）仅可被同包的其他代码访问 public：可以被任何代码访问 protected: private: 私有的 继承的意义:继承是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的数据或新的功能,也可以用父类的功能,通过使用继承,我们能够非常方便的复用代码,大大提高开发效率 对象向上造型:所谓的向上造型就是父类的引用指向子类的对象 instanceof运算符:instanceof运算符用来判断对象是否属于某个类的实例","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java类的基本结构","slug":"Java类的基本结构","date":"2017-10-10T02:13:00.000Z","updated":"2019-10-20T13:54:37.256Z","comments":true,"path":"2017/10/10/Java类的基本结构/","link":"","permalink":"https://zhuyiting.xyz/2017/10/10/Java%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"面向对象的概念:什么是类?同时将具有相同特征的对象抽象成一种新的数据类型—-类(具有相同特征和行为的多个对象的集合) 封装的好处:一个类把属性算法(逻辑处理)封装起来,只留必要的方法(接口)让用户使用,一个类该暴露什么,不该暴露什么,由类的设计者更具需求设计决定的.private属性用户不能直接访问,如果设计者提供相应的接口方法,那么用户可以通过该接口方法访问.一个类,不直接修改属性而通过方法来修改,可以在方法里做相应的处理避免用户输入的一些非法数据而造成系统故障 什么是构造方法: 构造方法是与类同名的方法 没返回值，也不能写void 主要作用是完成新建对象的初始化工作 一般不能显式地直接调用，而是用new来调用（后面会存在使用this/super调用） 创建一个类的新对象的同时，系统自动调用该类的构造函数，为新建对象的初始化 构造方法重载: 构造方法是一种特殊的方法，它也能重载 构造函数的重载是指同一个类中存在着若干个具有不同参数列表的构造函数 this关键字:this用于表示当前对象自身的引用，可以用于访问被局部变量隐藏的成员变量，也可以将本对象作为参数传递给其他对象操作 类初始化代码块static:####static代码块的执行时机: 用Class.forName(类名)显式加载的时候（反射、JDBC时详细讲解） new或反射实例化一个类的对象时候 调用类的static方法的时候（后续详细讲解） 调用类的static变量的时候（后续详细讲解） 调用类的静态常量（后续详细讲解）的时候，是不会加载类的，即不会执行static{}语句块当访问类的静态常量时，如果编译器可以计算出常量的值，则不会加载类，否则会加载类 用Class.forName()形式的时候，也可以自己设定要不要加载类，如将Class.forName(&quot;Test&quot;)改为 Class.forName(&quot;Test&quot;,false,StaticBlockTest.class.getClassLoader())，你会发现Test没有被加载，static{}没有被执行","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java数组","slug":"Java数组","date":"2017-10-08T08:21:00.000Z","updated":"2019-10-20T13:54:22.943Z","comments":true,"path":"2017/10/08/Java数组/","link":"","permalink":"https://zhuyiting.xyz/2017/10/08/Java%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组: 数组是一组类型相同的数据的集合 数组可以存储多个数据,但类型必须相同 数组能作为数据的容器使用,把多个数据集中存储 存储在数组中的数据,都有相应的索引值,可以方便获取或修改 当需要同时保存多个类型相同的变量并进行处理时,可以考虑用数组数组的特性: Java的数组是引用类型， 数组与类、接口、枚举、注解并列，是引用类型中的一种， Java的数组长度一经确定不能改变； 数组在内存中是连续分配，所以读取速度快 实际应用中，常常无法确定变量的数量，后续我们将学习集合框架，实现可变长度的数据容器；数组的元素: 数组中存储的数据称为数组的元素(Element)， 数组本身是引用类型，但是数组中的元素可以是基本数也可以是引用类型， 也就是说，即可以有存储基本数据类型int的数组，也可以有存储引用类型String的数组，但是数组本身是引用类型 数组中的元素有索引值，索引值从0开始 也就是说，如果一个数组的长度是10，那么索引值就是0-9，也就是第一个元素的索引值是0，第二个的索引值是1，以此类准，通过索引值可以方便访问元素 数组的维数: 如果一个数组中存储数据结构如下所示，元素都是单个数据，称为一维数组，67 78 54 89 12 45 87 97 79 9 其中，67被称为第0个元素，78称为第1个元素…… 如果个数组中存储数据结构如下所示，元素是一维数组，称为二维数组，[67 78 54] [89 12] [45 87 79] [3] 数组声明:一维数组的声明:数组元素类型[] 变量名称 或数组元素类型 变量名称[]","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"Java基础","slug":"Java基础","date":"2017-10-05T05:43:00.000Z","updated":"2019-10-20T13:54:05.601Z","comments":true,"path":"2017/10/05/Java基础/","link":"","permalink":"https://zhuyiting.xyz/2017/10/05/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"为什么学习java:Java是Sun Microsystems于1995年推出的高级编程语言Java 领域的JavaSE、JavaEE技术已发展成为同C#和.NET平分天下的应用软件开发平台和技术 java语言的特点: 跨平台性;一处编写,处处运行. 面向对象(三大特征);封装.继承.多态. 健壮性;强类型机制,异常处理机制,自动垃圾回收机制 分布式; 多线程; 动态性; JVM(Java Virtual Machine)介绍:JVM称为java虚拟机;JVM可以理解为Java编译器和操作系统之间的虚拟处理器; 编译器编译的字节码只要JVM认识即可 JVM再将字节码解释成操作系统认识的机器码 只要需要运行Java程序的设备,都需要安装JVM JDK与JRE: JDK是Java开发工具包(Java Development Kit)的简称,是一个软件;如果要用Java语言编写程序,就必须在计算机上安装JDK; JRE是Java运行环境(Java Runtime Environment)的简称如果要在机器上运行Java程序,就必须要有JRE; JDK的一些常用工具: javac: 编译器,将源程序转为字节码; java: 运行编译后的java程序(.class后缀的); jar: 打包工具,将相关的类文件打包成一个文件; javadoc: 文档生成器,从源码注释中提取文档; Java项目结构:src目录：存放包和源文件JRE系统库目录：存放程序运行必须的系统库文件bin目录：存放可执行的字节码文件 注释:文本注释: 1234/*** version ycj* data 2017-03-05* / 标识符命名规则: 某一个区域中是唯一的，在不同的区域中可以使用同一名字 必须由字母、数字、下划线和$符号组成 不能以数字开头 不能使非法的字符，如：#，％……“&amp;等 不能使系统关键字 不能使空格来分隔 长度无限制 严格区分大小写 不同的标识符有一定的命名规矩，后续学习 成员变量和局部变量的区别:成员变量是作用于整个类,局部变量作用于某个方法,局部变量没有默认值,必须初始化,成员变量有默认值. 数据类型:数据类型分为基本数据类型和引用数据类型; 数据类型(8个基本数据类型):byte, short, int, long, float, double, boolean, char 引用数据类型:String, 数组, 接口, 类, 枚举, 包装类型String、StringBufferStringBuilder的区别: String类是不可变的，对象一旦被创建，就不能被修改；可以使用=直接赋值，此时使用常量池；也可以使用new创建，不使用常量池；StringBuffer是可变的，对象创建后，可以修改；必须使用new关键字；StringBuilder是不同步的，在单线程情况下使用比StringBuffer高效；必须使用new关键字； 堆,栈,常量池,方法区:基本数据类型保存在栈中,引用数据类型保存在堆中;堆:存放所有new出来的对象栈:存放基本类型的变量数据和对象的应用方法区:包含所有的class和static变量常量区:存放基本类型和字符串常量 运算符:从功能角度分，Java中的运算符可以分为算术、关系、位、逻辑运算符四类算术运算符:用来对操作数进行数学运算.关系运算符:又叫比较运算符,用来运算操作两个数的大小关系.位运算符:针对操作数的二进制位进行运算逻辑运算符:针对布尔值或返回值为布尔值的表达式进行运算","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://zhuyiting.xyz/tags/JavaSE/"}]},{"title":"EL与JSTL表达式","slug":"EL与JSTL表达式","date":"2017-06-30T06:15:00.000Z","updated":"2019-10-20T13:51:10.275Z","comments":true,"path":"2017/06/30/EL与JSTL表达式/","link":"","permalink":"https://zhuyiting.xyz/2017/06/30/EL%E4%B8%8EJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"EL表达式:EL表达式的功能:(让JSP编写更为简单) EL是Expression Language的简称，即表达式语言； EL在JSP中使用，服务器会对其进行解析翻译，生成相应的Java代码； EL的作用是用来在JSP页面输出动态内容，可以替代JSP中的表达式元素&lt;%=%&gt; EL表达式的一般格式: ${EL表达式} 例如:${param.username} 等同于:&lt;%=request.getParameter(&quot;username&quot;)%&gt; EL表达式的内置对象:其中 2个内置对象为了方便输出请求参数： param/paramValues； 内置对象param：用来输出请求参数的值，格式为${param.请求参数名字} 内置对象paramValues：用来获取一对多的参数值，返回一个数组。 4个内置对象为了方便输出各个范围的属性： pageScope/ requestScope /sessionScope /applicationScope 获取四个范围的属性数据 检索顺序：当不指定范围时，例如，${user.pwd}，将自动从pageScope开始查找，直到applicationScope，如果没查到，则什么也不显示 2个与请求头有关的内置对象：header/headerValues 内置对象header：用来输出输出某一个请求头的值，格式为${header.请求头名字} 内置对象headerValues：如果某个请求头的值有多个，则使用headerValues返回一个数组。 2个其他内置对象：cookie/initParam 内置对象cookie：用来获取cookie的值 内置对象initParam：用来输出上下文参数; 1个特殊的内置对象pageContext 内置对象pageContext：EL中的pageContext对象可以调用PageContext类中所有符合规范的getXxx方法 使用 EL 取出内置对象的数据。 普通对象和对象属性。 服务器端：`request.setAttribute(&quot;student&quot;, student);` 在浏览器上打印出服务器端绑定的数据： 123$&#123; student &#125; &lt;!-- 相当于执行了 student.toString(); --&gt;$&#123; student.name &#125; &lt;!-- 相当于执行了 student.getName(); --&gt;$&#123; student.teacher.name &#125; &lt;!-- 相当于执行了 student.getTeacher().getName(); --&gt; 数组中的数据。 服务器端： 1234567String[] nameArray = new String[]&#123;\"Tom\", \"Lucy\", \"Lilei\"&#125;;request.setAttribute(“nameArray”,nameArray);Student[] students = new Student[3];students[0] = stu1;students[1] = stu2;students[2] = stu3;request.setAttribute(“students”,students); 在浏览器上打印出服务器端绑定的数组数据： 123456$&#123; nameArray[0] &#125; &lt;!-- Tom --&gt;$&#123; nameArray[1] &#125; &lt;!-- Lucy --&gt;$&#123; nameArray[2] &#125; &lt;!-- Lilei --&gt;$&#123; students[0].id &#125; &lt;!-- 输出第一个学生的ID --&gt;$&#123; students[1].name &#125; &lt;!-- 输出第二个学生的name --&gt;$&#123; students[2].teacher.name &#125; &lt;!-- 输出第三个学生的老师的name --&gt; List中的数据。 服务器端： 12345List&lt;Student&gt; studentList=new ArrayList&lt;Student&gt;();studentList.add(stu1);studentList.add(stu2);studentList.add(stu3);request.setAttribute(“studentList”,studentList); 在浏览器上打印出服务器端绑定的List数据： 123$&#123; studentList[0].id &#125; &lt;!-- 输出第一个学生的ID --&gt;$&#123; studentList[1].name &#125; &lt;!-- 输出第二个学生的name --&gt;$&#123; studentList[2].teacher.name &#125; &lt;!-- 输出第三个学生的老师的name --&gt; Map中的数据。 服务器端： 12345Map&lt;String, Student&gt; studentMap = new HashMap&lt;String, Student&gt;();studentMap.put(\"Tom\", stu1);studentMap.put(\"Lucy\", stu2);studentMap.put(\"Lilei\", stu3);request.setAttribute(“studentMap”,studentMap); 在浏览器上打印出服务器端绑定的Map数据： 123$&#123; studentMap.Tom.id &#125; &lt;!-- 输出第一个学生的ID --&gt;$&#123; studentMap.Lucy.name &#125; &lt;!-- 输出第二个学生的name --&gt; $&#123; studentMap.Lilei.teacher.name &#125; &lt;!-- 输出第三个学生的老师的name --&gt; EL运算符:EL中提供了多种运算符，可以对变量或常量进行运算，输出运算结果；EL中的运算符包括： 算术运算符 比较运算符 逻辑运算符 其他运算符 JSTL:JSTL是一套定义好的标签库，可以直接使用；JSTL的全称是Jsp Standard Tag Library，即JSP标准标签库；JSTL包含很多标签，根据其作用可以分为：属性相关的标签、条件分支相关的标签、迭代标签、其他标签；标签库包括标签处理器类及描述文件tld文件，JSTL也一样： 使用JSTL首先需要下载相关的jar文件并保存到工程的lib目录下；在JSP中使用taglib指令引入需要使用的标签库； forEach、set、if等是JSTL中常用的标签； JSTL标签库的使用是为类弥补html表的不足，规范自定义标签的使用而诞生的。在告别modle1模式开发应用程序后，人们开始注重软件的分层设计，不希望在jsp页面中出现java逻辑代码，同时也由于自定义标签的开发难度较大和不利于技术标准化产生了自定义标签库。","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"MVC模式","slug":"MVC模式","date":"2017-06-19T06:15:00.000Z","updated":"2019-10-20T12:18:47.695Z","comments":true,"path":"2017/06/19/MVC模式/","link":"","permalink":"https://zhuyiting.xyz/2017/06/19/MVC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"MVC模式基本概念MVC（Model-View-Controller）是一种软件架构设计模式，最初应用在桌面应用程序； MVC模式将软件的代码按照模型（M）、视图（V）、控制器（C）三部分组织 MVC模式构建应用的优势: 耦合性低：视图层和业务层分离，耦合性降低，可以独立修改； 重用性高：可以用不同的视图访问模型部分，实现在不同终端上访问应用； 可维护性高：视图与业务分离，降低了维护成本； MVC模式中的三个角色:在控制器和视图之间共享数据: 在控制器和视图之间，常常需要共享数据；例如从数据查出来的商品列表信息，需要从控制器发送到视图； Servlet和JSP之间共享数据一般使用请求、会话、上下文范围的属性进行； HttpServletRequest/HttpSession/ServletContext接口中都定义了存取、查询、删除属性的方法【前面已经学习过】； 使用原则：尽量用范围小的属性，即，请求范围内共享即可就用请求，以此类推；否则会造成资源浪费，降低安全性； redirect\\forward\\include几种跳转方式的功能与差异:MVC模式中，控制器和视图之间需要进行跳转，Servlet规范中，有三种跳转方式： redirect：调用响应接口的sendRedirect方法，响应重定向，相当于重新请求新的资源，当前请求对象不会到目标资源； forward: 调用请求转发器接口的forward方法，请求转发，将当前的请求、响应对象转发到目标资源；(最常用) include：调用请求转发器接口的include方法，动态包含，将目标资源的请求、响应对象包含到当前资源； forword带来的重复提交问题; 使用forward转发请求后，再次刷新当前页面，会进行重复提交； 例如：使用LoginServlet进行登录，成功后跳转到loginsuccess.jsp页面： 刷新当前页面，再次进行了登录 为了能够解决重复提交问题，关键在于：能够标志一次提交，从而识别出该提交已经处理； 步骤一：在JSP中记录一个随机数，称为令牌（token），存储在session中&lt;%session.setAttribute(&quot;token&quot;,System.nanoTime())+&quot;&quot;%&gt; 步骤二：将token值作为表单的一个隐藏域&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;)%&gt;&quot; &gt; 步骤三：在LoginServlet中获取token值，并进行判断 12345//取出存储在请求参数中的tokenString requestToken = request.getParameter(\"token\");//取出存储在session中的tokenString sessionToken = (String)request.getSession().getAttribute(\"token\");.... 步骤四：将token值从会话中删除 1request.getSession().removeAttribute(\"token\");","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"JSP扩展","slug":"JSP扩展","date":"2017-05-29T02:25:00.000Z","updated":"2019-10-20T12:07:30.786Z","comments":true,"path":"2017/05/29/JSP扩展/","link":"","permalink":"https://zhuyiting.xyz/2017/05/29/JSP%E6%89%A9%E5%B1%95/","excerpt":"","text":"JSP内置对象: 内置对象指的是服务器已经创建好的对象，可以直接使用； 9个内置对象: request response out out的类型是JspWriter out可以用来输出内容到客户端，但是程序员一般不会使用，因为直接使用&lt;%=%&gt;即可以实现输出； page page即当前类对象 page也很少使用，与this相同 pageContext 其他多数内置对象都是通过它获得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); + pageContext对象是JSP中一个非常重要的对象，是`javax.servlet.jsp.PageContext`类型的对象，指的是页面的上下文，封装了其他的内置对象，同时代表的是四大作用域【页面、请求、会话、上下文】中的页面作用域，也可以在页面上下文范围添加属性，`PageContext`中与属性相关方法如下： |方法声明|方法描述| |:---:|:---:| |void setAttribute(java.lang.String name, java.lang.Object o) |将任意类型对象设置为属性，指定一个名字；| |java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；| |void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；| + session + session是JSP中的另一个内置对象，是`HttpSession`类型的对象，可以在JSP中调用HttpSession接口中的任何方法；默认存在 + application + application是JSP中的另一个内置对象，是`ServletContext`类型的对 象，可以在JSP中调用`ServlletContext`接口中的任何方法； + exception + 内置对象exception比较特殊，默认情况下不存在；只有当JSP中使用指令指定该页面作为错误页面使用时才会翻译生成该内置对象。 + config + 在JSP中可以直接使用config对象调用ServletConfig接口中任意方法，例如，可以在web.xml中对JSP配置初始化参数，与前面学习的Servlet初始化参数相同的含义：#### 指令与动作:+ JSP可以通过指令元素而影响容器翻译生成Java类的整体结构；+ 指令的语法为：`&lt;%@ directive &#123;attr=“value”&#125;* %&gt;`；+ 其中，directive为指令名，attr指该指令对应的属性名，一个指令可能有多个属性；JSP中常用的指令有三个：page、include、taglib，前两个常用+ **page指令**作用于整个JSP页面，可以将指令放在JSP页面任何一个位置; + import属性:用来引入JSP文件需要使用的类； + 可以使用逗号同时引入多个包，也可以在一个JSP文件中多次使用import； + 值得注意的是，import是page指令中唯一一个可以在一个JSP文件中多次出现的属性，其他属性在一个JSP文件中只能出现一次； + pageEncoding属性:用来设置JSP文件的页面编码格式； + page指令的session属性：用来设置JSP页面是否生成session对象。该属性默认值为true，可以设置成false。 + session属性值设置为false后，该JSP翻译生成的类中将没有内置对象session，该JSP不参与会话。 + errorPage属性:设置JSP页面的错误页面。当JSP中发生异常或错误却没有被处理时，容器将请求转发到错误页面； + 访问该页面将发生数学异常，而且并没有对异常进行处理，那么将跳转到错误页面error.jsp + isErrorPage属性默认值是false，可以设置为true。在JSP的错误页面中，将isErrorPage设置为true，则该页面翻译生成的Java类中，将生成exception内置对象。在error.jsp中加入代码：`&lt;%@page isErrorPage=\"true\"%&gt;` + 上述代码将error.jsp页面设置为错误页面，所以，在error.jsp翻译生成的Java类中的_jspService方法中将生成exception内置对象 + 注意：即使一个页面没有设置isErrorPage=“true”，也可以作为错误页面使用，区别在是否有内置对象exception内置对象产生。+ **include指令**是JSP中另外一个常用指令，用来静态包含其他页面； + 在翻译期间，把包含的页面也翻译到当前页面的Java文件中，也就是Java源文件即实现“二合一”； + `&lt;%@include file=\"copyright.jsp\"%&gt;`+ **include动作标签**: + JSP规范中定义了一系列的标准动作。Web容器按照规范进行了实现，可以解析并执行标准动作； + 标准动作使用标准的XML语法。 ```jsp &lt;jsp:action_name attribute1=\"value1\" attribute2=\"value2\"&gt; &lt;/jsp:action_name&gt; ``` + 其中action_name表示标准动作的名字，attribute1和attribute2是标准动作的若干个属性； + include标准动作:`&lt;jsp:include&gt;`是动态包含，即在运行期访问被包含的页面，并将响应结果同包含页面的响应结果合并，生成最终响应。类似在Servlet中调用`RequestDispatcher`的`include`方法进行包含。+ **include标准动作和include指令的差异**; + include标准动作与include指令都是实现包含其他页面的功能; + include标准动作的属性是page，实现动态包含，发生在请求阶段； + include指令的属性是file，实现静态包含，发生在翻译阶段。+ include其他动作 + forward动作：在JSP页面中进行请求转发，如下代码所示： &lt;jsp:forward page=“loginsuccess.jsp”&gt; 1+ param动作：往往作为子动作使用，为forward和include动作传递参数，如下代码所示： &lt;jsp:forward page=”copyright.jsp”&gt; &lt;jsp:param name=”author” value=”etc”/&gt;&lt;/jsp:forward&gt; &lt;jsp:include page=”copyright.jsp”&gt; &lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt; ``` 上述代码使用param为forward和include动作传递参数，参数将被作为请求参数传递。 使用标准动作时，一定注意正确结束标准动作，如&lt;jsp:include&gt;是标准动作的开始，一定要对应结束标记，如&lt;/jsp:include&gt;。 JavaBeanJavaBean是用Java语言描述的软件组件模型，实际上是一个Java SE的类，这些类遵循一定的编码规范： 必须是public类 ； 必须有一个无参的public的构造方法； 返回属性的方法为getXxxx()格式 ； 设置属性的方法为setXxx(形式参数)格式； JSP中还提供了3个与JavaBean有关的动作； useBean动作：&lt;jsp:useBean id=“” class=“” scope=“”&gt; useBean标准动作用来使用JavaBean对象，JavaBean对象是某一范围（用scope指定）的属性； Java Bean对象名字用id指定，类型用class指定。如果对应范围没有该属性，则调用class指定类的无参构造方法，创建一个该类的对象，并将该对象存储为scope内的一个属性，属性名为id； 其中scope有四种：page、request、session、application，分别为PageContext范围、HttpServletRequest范围、HttpSession范围、ServletContext范围。如果不指定scope的值，默认为page范围。 setProperty 动作：&lt;jsp:setProperty name=“” property=“” param|value=“”/&gt; setProperty标准动作可以用来对JavaBean对象的属性赋值，替代调用setXxxx方法； setProperty的name属性表示JavaBean对象的id值，property表示需要调用的setXxx方法中的Xxx部分，将首字母变小写。比如需要调用setCustname方法，则property即为Custname首字母变小写，即custname； 如果setXxx方法的参数是某一个请求参数的值，则使用param属性指定请求参数名字即可； 如果setXxx方法的参数是一个常量，则使用value属性指定即可。 同时，setProperty标准动作可以对一些常见数据类型直接转换，如字符串与Integer的转换就可以自动进行； getProperty动作：&lt;jsp:getProperty name=”” property=””/&gt; getProperty标准动作用来调用JavaBean对象的getXxx方法，将其返回值在当前位置输出。 name是JavaBean对象的id值，property的值是getXxx方法中的Xxx部分，首字母变小写。假设需要调用getAddress方法显示其返回值，那么property的值就是Address的首字母变小写，即address。","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"Servlet上下文","slug":"JSP上下文","date":"2017-05-25T10:47:00.000Z","updated":"2019-10-20T11:47:22.632Z","comments":true,"path":"2017/05/25/JSP上下文/","link":"","permalink":"https://zhuyiting.xyz/2017/05/25/JSP%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"什么是上下文:上下文ServletContext对象是用来存储全局范围信息的对象;换句话说,一个Web应用只有唯一一个上下文对象. 当服务器启动的时候，就会为每一个应用创建一个上下文对象； 当服务器关闭的时候，上下文对象就销毁； Servlet中的ServletContext接口: 方法声明 方法描述 java.io.InputStream getResourceAsStream(java.lang.String path) 将path所代表的资源以输入流返回，可以进一步进行读操作；可以用来读取服务器端的文件； RequestDispatcher getRequestDispatcher(java.lang.String path) 返回RequestDispatcher 对象，路径是相对于上下文路径的； 上下文获取方法:Servlet规范中的多个接口中都定义了getServletContext方法获得上下文对象 上下文参数: 在web.xml中可以配置上下文参数，使用ServletContext中的getInitParameter方法可以获取该参数；【之前学习过的Servlet初始化参数，只能在当前Servlet中使用】 上下文参数存储在上下文对象，所以应用下所有组件都可以使用； 获取上下文参数： 1234&lt;context-param&gt; &lt;param-name&gt;version&lt;/param-name&gt; &lt;param-value&gt;2.0&lt;/param-value&gt;&lt;/context-param&gt; 12345//返回ServletContext对象ServletContext ctxt=this.getServletContext();//获取上下文参数String version=ctxt.getinitParameter(\"version\");System.out.println(\"上下文参数version的值:\"+version); 利用ServletContext在应用中共享数据: 方法声明 方法描述 void setAttribute(java.lang.String name, java.lang.Object o) 将任意类型对象设置为上下文属性，指定一个名字 java.lang.Object getAttribute(java.lang.String name) 通过属性的名字，获取属性的值； void removeAttribute(java.lang.String name) 通过属性的名字，删除属性； 四大作用范围:在Web应用中，有四大作用域范围 页面范围PageContext：一个Servlet或JSP文件； 请求范围ServletRequest：一次请求中可以访问多个Servlet或JSP； 访问的Servlet或JSP能够包含其他资源； 会话范围HttpSession：一次会话中可以包含多个请求； 上下文范围ServletContext：上下文包含所有会话；","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"会话跟踪(前后端交互)","slug":"会话跟踪(前后端交互)","date":"2017-05-18T06:01:00.000Z","updated":"2019-10-20T11:34:45.061Z","comments":true,"path":"2017/05/18/会话跟踪(前后端交互)/","link":"","permalink":"https://zhuyiting.xyz/2017/05/18/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA(%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92)/","excerpt":"","text":"会话的概念和作用: 会话: 对于Web应用来说,会话就是浏览器与服务器之间的一次连续的通讯过程. HTTP协议是无状态的，也就是说，一次请求结束后，HTTP协议就不再记录相关信息； 而实际应用中，却常常需要记住一些状态信息； ==会话跟踪==技术就是能够跟踪客户端和服务端的交互,保存和记忆相关信息,保存请求的状态信息. 常用的四种会话跟踪技术: URL方式：需要保存的信息直接追加到URL后，例如：http://127.0.0.1:8080/chapter03/viewList?pageNo=12 隐藏域方式：可以使用表单中的隐藏域保存相关信息， 例如：&lt;input type=&quot;hidden&quot; name=“status&quot; value=“true&quot;&gt; Cookie方式：将状态信息保存到客户端，服务器能够获得相关信息进行分析，从而生成对客户端的响应；例如简化登录功能就可以使用Cookie实现； Session方式：将状态信息保存到服务器的会话对象中，通过唯一标记的ID值与客户端进行绑定使用；例如访问控制功能就可以使用Session实现； Cookie的功能和特点: Cookie是一段保存在客户端的小文本；能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪到用户的状态； Cookie包含一系列属性:如: name：cookie的名字，每个cookie都有一个名字； content：cookie的值，与名字一起作为键值对形式存在； domain：域，该cookie的域名，例如csdn.net，说明当前cookie来自csdn.net; path：路径，访问csdn.net下该路径时，当前cookie将被发送； created：cookie被创建的时间； Expired：cookie失效的时间； 最大生命时间：失效时间和创建时间的时间差，就是cookie的最大生命时间，超过该时间，cookie将失效，不再被发送到相应的域地址； 创建cookie,设置cookie属性:Servlet规范中定了Cookie类，创建该类对象就可以创建Cookie，并可以调用其中方法为Cookie设置属性； 方法声明 方法描述 Cookie(java.lang.String name, java.lang.String value) 创建Cookie对象，指定名字和对应的值； void setMaxAge(int expiry) 设置最大生命时间（秒），如果不设置，当前浏览器关闭，cookie即失效； void setValue(java.lang.String newValue) 设置Cookie的值； setDomain(java.lang.String domain) 设置cookie的域名； cookie创建好后并不能存储到客户端,要将cookie保存到客户端,必须添加到响应对象中,响应接口中定义了Cookie的方法:|方法声明|方法描述||:—:|:—:||void addCookie(Cookie cookie)|将Cookie对象保存到相应的响应对象中；| 当访问相同域名及路径时,没有超过有效时间的cookie将自动通关请求发送到网站; Servlet在请求接口中定义了获取cookie的方法:|方法声明|方法描述||:—:|:—:||Cookie[] getCookies()|获取请求中的所有Cookie对象，返回数组；| Session简介: Session是会话跟踪的另一种实现手段； Session是存储在服务器上的对象，该对象由服务器创建并维护； 服务器为客户端与服务器的每一次会话过程都创建并维护一个Session对象；每个服务器对Session的创建和维护的底层实现有所区别； session创建的时间:一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;% @page session=”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句 HttpSession session = HttpServletRequest.getSession(true);这也是JSP中隐含的 session对象的来历。 由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 session的生命周期:Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。 由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"JSP","slug":"JSP","date":"2017-05-15T06:37:00.000Z","updated":"2019-10-20T08:48:27.672Z","comments":true,"path":"2017/05/15/JSP/","link":"","permalink":"https://zhuyiting.xyz/2017/05/15/JSP/","excerpt":"","text":"什么是JSPJSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件。翻译和编译的过程遵守Servlet规范，因此说==JSP的本质也是Servlet==； html和jsp的表头不一样，这个是JSP的头&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。 简单说，jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。 为什么要用JSP:Servlet生成动态页面比较繁琐，使用JSP生成动态页面比较便捷，因为其中的静态内容可以使用HTML生成； JSP元素: 脚本元素可以用来包含任意Java代码,格式为：&lt;%Java代码%&gt; 服务器翻译脚本元素时，将把其中Java代码直接翻译到jspService方法中，如果语法错误，将在浏览器中提示错误； 表达式元素用来向页面输出动态内容;格式为：&lt;%=Java代码%&gt; 服务器翻译表达式元素时，将把其中Java代码部分的返回值使用out.write语句输出 模块元素指JSP中静态HTML或者XML内容 注释元素有三种情况： 格式为&lt;%--JSP注释--%&gt;；JSP的注释只有在源代码中可见，翻译时已经忽略； 在JSP中，除了使用JSP注释外，还可以使用HTML注释，&lt;!--HTML注释--&gt;，HTML注释会被返回到客户端，但是不显示到页面中； JSP中的Java代码部分，可以使用Java注释；Java注释会翻译到.java文件中，但是编译时忽略； 声明元素: 如果需要在JSP文件中定义类的成员变量或方法，可以使用声明元素，格式为&lt;%! 声明语句%&gt; 1&lt;%! private String path=\"WEB-INF\"; public void readPropertiesFile()&#123;&#125;&gt; 声明元素被翻译到Java类中，而不是_jspService方法中； 内置对象:内置对象指的是在JSP中可以直接使用的对象，不需要声明，直接使用固定的名字使用即可；例如&lt;%=request.getRemoteAddr()%&gt;中的request就是内置对象； jsp中共有9种对象 request：用户端请求，此请求会包含来自GET/Post请求的参数； response：网页传回用户端的回应。 pageContext：页面的属性是在这里管理 session：与请求有关的回话期 application ：Servlet正在执行的内容 out ：用来传递回应的输出 config ：servlet的构架部件 pagejsp网页本身 exception ：针对错误的网页。未捕捉的例外 Servlet和JSP的作用:实际应用中，Servlet是不会用来生成动态页面的，而是会用来接收来自JSP的请求，处理请求，然后调跳转到JSP页面把结果显示给客户端看； Servlet与JSP之间的跳转方式: 跳转方式一:响应重定向,响应接口中提供了该方法 void sendRedirect(java.lang.String location):响应重定向到location，相当于客户端重新请求location所在的资源； 第一个JSP页面发送请求request到Servlet,Servlet接收请求后,响应response重定向到目标JSP页面,但是请求并没有传递过来.(重定向相当于是产生一个新的请求) 跳转方式二:请求转发,RequestDispatcher接口定义了请求转发的方法 forward(ServletRequest request, ServletResponse response):将请求转发到服务器上的其他资源，包括其他的Servlet，JSP等； 要使用forward方法，需要先获得RequestDispatcher对象；请求接口(request)中提供了获得该对象的方法： RequestDispatcher getRequestDispatcher(java.lang.String path):使用path返回一个RequestDispatcher 对象 请求转发把请求对象发送到了目标JSP页面,因此目标页面可以获得上一个页面的请求对象. 请求属性的使用:如果需要在Servlet，JSP之间跳转时，同时把一些自定义的、或者通过数据库查询的、或者调用其他资源获得的数据传递到下一个资源时，就可以把这些数据设置为请求的属性即可。 请求接口中定义了一系列与属性有关的方法。|方法声明|方法描述||:——:|:—–:||void setAttribute(java.lang.String name, java.lang.Object o)|将任意类型对象设置为请求的属性，指定一个名字；||java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；||void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；|可以将数据封装进请求对象中,在前后端传递例如:后台Servlet中将数据保存进request(请求)中,跳转到前台JSP后,JSP可以用&lt;%=request.getAttribute(&quot;name&quot;)%&gt;来获取(直接输出)也可以保存为变量(前提是需要强转,因为获取的是Object类型)","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"Servlet","slug":"Servlet","date":"2017-05-06T09:12:00.000Z","updated":"2019-10-20T07:59:54.505Z","comments":true,"path":"2017/05/06/Servlet/","link":"","permalink":"https://zhuyiting.xyz/2017/05/06/Servlet/","excerpt":"","text":"什么是ServletJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet的线程特性:Web应用服务器(Tomcat)将为每个客户端的连接启动一个线程来服务 第一次访问Servlet时，服务器将创建一个该Servlet类的对象，并调用doXXX方法生成响应；多个客户端访问同一个Servlet时，不再创建新的对象，而是共用同一个Servlet对象。可以说，Servlet是多线程单实例的。 Servlet请求和响应接口:通过浏览器提交给服务端的所有数据,都称为请求数据 通过服务器返回给客户端的所有数据,都称为响应数据 ServletAPI中,定义了请求和响应接口,用来封装和操作请求和响应数据 请求接口: javax.servlet.ServletRequest javax.servlet.HttpServletRequest 响应接口: javax.servlet.ServletResponse javax.servlet.HttpServletResponse Servlet类使用doXXX方法提供服务,这些方法继承于HttpServletdoXXX方法中都有两个参数,分别是请求和响应;|方法|参数|作用||:–:|:–:|:–:||void doDelete|(HttpServletRequest request,HttpServletResponse response)|用来处理一个HTTP DELETE操作,这个操作允许客户端请求从服务器上删除URL||void doGet|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP GET操作。这个操作允许客户端简单地从一个HTTP服务器“获得”资源||void doHead|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP HEAD操作。默认的情况是，这个操作会按照一个无条件的GET方法来执行||void doOptions|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP OPTION操作。这个操作自动地决定支持哪一种HTTP方法。例如，一个Servlet写了一个HttpServlet的子类并重载了doGet方法，doOption会返回下面的头： Allow:GET,HEAD,TRACE,OPTIONS||void doPost|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP POST操作。这个操作包含请求体的数据，Servlet应该按照他行事。||void doPut|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP PUT操作。这个操作类似于通过FTP发送文件。||void doTrace|(HttpServletRequest request, HttpServletResponse response)|用来处理一个HTTP TRACE操作。这个操作的默认执行结果是产生一个响应，这个响应包含一个反映trace请求中发送的所有头域的信息。||long getLastModified|(HttpServletRequest request)|返回这个请求实体的最后修改时间。||void service|(HttpServletRequest request, HttpServletResponse response)|这是一个Servlet的HTTP-specific方案，它分配请求到这个类的支持这个请求的其他方法。当你开发Servlet时，在多数情况下你不必重载这个方法。|也就是说：服务器会创建请求对象和响应对象传递给doXXX方法，doXXX方法中可以直接使用请求和响应对象;doXXX方法中可以使用方法参数request，response去调用请求和响应接口中的方法； 利用Servlet对客户端不同方式请求作出动态响应:客户端访问服务器端Servlet的三种方式: 直接从地址栏输入URL访问；是GET方式，调用doGet方法; 在网页中点击超级链接访问；是GET方式，调用doGet方法; 在网页中通过表单提交访问；取决form的method属性的值，默认是get，指定为post时，调用doPost方法; Servlet中获取请求参数的方法: 可以在URL后使用name=value&amp;name=value的形式传递，例如： 12&lt;a href=“TestPramServlet?page=1&amp;author=wangxh”&gt;&lt;!-- 传递两个请求参数，名字分别为page和author，值分别为1和wangxh；--&gt; 可以在使用表单提交，表单中的元素值将作为请求参数传递，元素的name是参数名字，value的值是参数的值 当客户端请求服务器端的Servlet时，请求参数都会被发送到服务器，服务器会将请求参数封装到请求对象中； Servlet初始化参数: 如果某个Servlet需要使用一些可以配置的参数，可以在web.xml进行配置，称为初始化参数； 这些参数在服务器初始化Servlet实例时被初始化到配置信息中，可以在Servlet中获取并使用； 一个Servlet可以配置多个初始化参数，所有的初始化参数只能在当前Servlet类中使用； Servlet加载启动选项: 默认情况下，只有当第一次访问Servlet时，服务器才会初始化Servlet实例； 如果需要更早实例化Servlet，可以在web.xml中进行配置，使得在启动容器的时候就能初始化Servlet实例； Servlet配置中通配符*的用法: .扩展名 ： 比如 *.do、.action 以 / 开头，同时以 /* 结尾，比如 /* 、/admin/* web.xml中首页及错误页面等其他配置信息 配置默认页面:当不指定具体访问路径时,默认访问默认页面12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 配置错误页面:当应用中出现响应错误或者异常时,可以跳转到错误页面; Servlet中获取请求头属性的方法:客户端请求服务端的Servlet,会传递给服务器一系列的HTTP请求头属性,请求接口中定义了系列方法获取请求属性","categories":[{"name":"后端技术栈","slug":"后端技术栈","permalink":"https://zhuyiting.xyz/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhuyiting.xyz/tags/JavaEE/"}]},{"title":"Web开发入门","slug":"Web开发入门","date":"2017-04-30T09:12:00.000Z","updated":"2019-10-20T00:43:55.088Z","comments":true,"path":"2017/04/30/Web开发入门/","link":"","permalink":"https://zhuyiting.xyz/2017/04/30/Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"C/S B/S网络应用:C/S就是(客户机/服务器)的简称,桌面应用程序采用的多是这种结构.B/S就是(浏览器/服务器)的简称,特点是客户端无需安装特定的软件,只需要安装一个浏览器就可以与系统进行交互 C/S优缺点:由于C/S结构没有像B/S（下一个基本概念介绍）结构中服务器向客户端发送的数据还包含了大量的非实际交换数据，比如请求响应头，还有页面数据等等，它的==相应时间还是相对较快==的；由于C/S结构安装的客户端软件，很多的业务逻辑、算法逻辑处理都在客户端进行，这样就==减轻了服务器的压力==，这是优点，但是带来的问题也显而易见，不但==有被反编译的安全隐患==，而且不断的安装各种客户端软件，会使==客户端越来越臃肿==；在升级维护等工作上带来的麻烦也是令人不愉快，因为每发生一次升级都需要重新更新客户端的软件，这样做的后果就是在==开发上的工作量加大==，而且用户每次都要更新自己终端上的软件，这些都是令人非常头疼的问题；由于需要在客户端进行安装特定软件，因此==对操作系统有一定的限制==； Web站点、Web应用、HTTP服务器、Web应用服务器:==Web站点:==即Web Site,也被成为Web网站;比如某公司逛完就是Web站点 ==Web应用:==即Web Application,简单来说,就是通过浏览器访问的应用程序,从而为客户提供相应服务 ==Http服务器:==即Web服务器,主要功能是提供网上信息浏览服务,例如Apache、Nginx、IIS是比较常用的HTTP服务器. ==Web应用服务器:==Web应用服务器能够运行服务器上的应用程序,并将结果返回给客户端浏览器;例如Tomcat,通常Web应用服务器兼具部分Http服务器的功能. ==Servlet的概念及功能:== Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat； 可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器； Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范，例如，必须继承于javax.servlet.http.HttpServlet类；","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zhuyiting.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}]}