{"meta":{"title":"ycjBlog","subtitle":null,"description":null,"author":"yanchengjie","url":"https://yimchengjie.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-21T05:52:06.972Z","updated":"2019-10-21T05:52:06.972Z","comments":false,"path":"about/index.html","permalink":"https://yimchengjie.github.io/about/index.html","excerpt":"","text":"{ name: ‘yanchengjie’ age: 22, gender: ‘男’, profession: ‘programmer’, experience: ‘0年’, address: ‘浙江省杭州市’, education: ‘本科’, github: ‘https://github.com/yimchengjie&#39;, blog: ‘https://yimchengjie.github.io&#39;, email: ‘ycj996425271@live.com’, description: ‘小程序员的大厂梦’, skills: [ [‘Html’, ‘Javascript’, ‘jQuery’, ‘CSS’, ‘Vue’, ‘Node’], [‘Git’, ‘SVN’], [‘Java’,’MySql’], [‘Spring’, ‘MyBatis’, ‘SpringBoot’], [‘Redis’,’Dubbo’, ‘SpringCloud’] [‘Linux’,’Ubuntu’,’deepin’] ], devTools: [ [‘HBuilder X’, ‘Visual Studio Code’, ‘Notepad++’], [‘Chrome DevTools’ ], [‘Git’, ‘TortoiseSVN’], [‘InteliJ IDEA’,’Eclipse’], [‘Navicat’, ‘Postman’,’SSH’], ]} 博客主题来自: https://github.com/cofess/hexo-theme-pure"},{"title":"书单","date":"2019-10-18T08:58:07.896Z","updated":"2019-10-18T08:58:07.896Z","comments":false,"path":"books/index.html","permalink":"https://yimchengjie.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":false,"path":"categories/index.html","permalink":"https://yimchengjie.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-10-18T07:42:59.000Z","updated":"2019-10-18T07:42:59.817Z","comments":true,"path":"gallery/index.html","permalink":"https://yimchengjie.github.io/gallery/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-18T08:58:07.897Z","updated":"2019-10-18T08:58:07.897Z","comments":true,"path":"links/index.html","permalink":"https://yimchengjie.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"tags/index.html","permalink":"https://yimchengjie.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-18T08:58:07.898Z","updated":"2019-10-18T08:58:07.898Z","comments":false,"path":"repository/index.html","permalink":"https://yimchengjie.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Electron+Vue入门","slug":"Vue.js/Electron+Vue入门","date":"2020-02-07T08:24:19.000Z","updated":"2020-02-28T08:35:01.365Z","comments":true,"path":"2020/02/07/Vue.js/Electron+Vue入门/","link":"","permalink":"https://yimchengjie.github.io/2020/02/07/Vue.js/Electron+Vue%E5%85%A5%E9%97%A8/","excerpt":"","text":"Electron+Vue入门 了解ElectronElectron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 Electron使用Web页面来作为桌面应用的GUI,所以可以把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器 Electron+Vue结合使用Vue的开发环境,node.js,npm就可以进行Electron开发 使用Electron-vue框架Electron-vue是基于electron和vue结合搭建的开发脚手架","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Electron","slug":"Electron","permalink":"https://yimchengjie.github.io/tags/Electron/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"Shiro权限管理","slug":"分布式开发技术/Shiro权限管理","date":"2020-02-06T17:30:49.000Z","updated":"2020-02-27T12:27:22.503Z","comments":true,"path":"2020/02/07/分布式开发技术/Shiro权限管理/","link":"","permalink":"https://yimchengjie.github.io/2020/02/07/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"Shiro权限管理Shiro是一款强大灵活的安全框架,可以处理身份认证,授权,加密和会话管理 权限管理概念一般有用户参与的系统,都需要权限管理,权限管理实现了对用户访问系统的控制 用户认证 用户认证,即用户访问系统时,会被验证用户身份的合法性 用户授权 在用户认证通过后,系统对用户访问资源进行控制,用户拥有资源的权限时,才可以进行访问 权限管理组成 主体(账号、密码) 权限(权限名称、资源名称、资源访问地址) 角色(角色名称) 角色和权限的关系(角色id、权限id) 主体和角色的关系(主体id、角色id) 分配权限用户需要分配相应的权限才可以访问相应资源通常给用户分配资源权限需要将权限信息持久化保存,比如存到关系型数据库 然后实现访问控制 基于角色的访问控制 123if(user.hasRole(\"部门经理\"))&#123; //&#125; 基于角色的访问控制,不利于代码的维护,扩展性差,因为判断角色的条件都写死在代码中 基于资源的访问控制 1234if(user.hasPermission ('用户报表查看（权限标识符）'))&#123; //系统资源内容 //用户报表查看&#125; 资源在系统中不变,建议使用基于资源的访问控制 Shiro架构 Subject: 当前用户 SecurityManager: 管理啊所有Subject,SecurityManager是Shiro架构的核心 Realms: 用户进行权限信息的验证,可以自己实现,它封装了与数据源连接的细节,在配置Shiro的时候,必须指定至少一个Realm来实现认证/授权 Shiro认证过程 创建SecurityManager Subject提交认证 SecurityManager认证 Authenticator认证 Realm认证 123456789101112131415161718192021222324252627282930313233343536public class AuthenticationTest &#123; // 框架提供默认Realm SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); @Before public void addUser()&#123; simpleAccountRealm.addAccount(\"ycj\",\"123456\",\"admin\",\"user\"); &#125; @Test public void testAuthentication()&#123; // 1. 创建SecurityManager DefaultSecurityManager securityManager=new DefaultSecurityManager(); // 1.1 为SecurityManager设置Realm securityManager.setRealm(simpleAccountRealm); // 2. 主体提交认证请求 // 2.1 为SecurityUtils注入securityManager SecurityUtils.setSecurityManager(securityManager); // 2.2 获取当前Subject Subject subject=SecurityUtils.getSubject(); // 2.3 收集用户名和凭证 UsernamePasswordToken token = new UsernamePasswordToken(\"ycj\",\"123456\"); // 2.4 将用户名和凭证提交到SecurityManager,获取认证 subject.login(token); //判断认证状态 System.out.println(\"isAuthenticated:\" + subject.isAuthenticated()); //判断是否有以下角色权限 subject.checkRoles(\"admin\",\"user\"); //退出,取消授权 subject.logout(); System.out.println(\"isAuthenticated:\" + subject.isAuthenticated()); &#125;&#125;","categories":[{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://yimchengjie.github.io/tags/Shiro/"},{"name":"权限管理","slug":"权限管理","permalink":"https://yimchengjie.github.io/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"}]},{"title":"Docker入门篇","slug":"容器化技术/Docker入门篇","date":"2020-02-02T17:30:49.000Z","updated":"2020-02-28T08:14:25.170Z","comments":true,"path":"2020/02/03/容器化技术/Docker入门篇/","link":"","permalink":"https://yimchengjie.github.io/2020/02/03/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/Docker%E5%85%A5%E9%97%A8%E7%AF%87/","excerpt":"","text":"Docker入门篇 Docker是世界领先的软件容器平台,利用Docker可以消除协作编码时”在我的机器上可以正常工作”的问题 Docker将一整套环境打包封装成镜像,无需重复配置环境,解决了环境带来的种种问题. Docker容器间是进程隔离的,互不影响 Docker术语 镜像: 系统的环境整个打包 容器: 镜像启动后的实例 仓库: 专门存放镜像的地方 第一个Docker官方链接 安装环境: Ubuntu 16.04 更新包索引 1sudo apt-get update 安装软件包,允许在HTTPS上使用存储库 123456sudo apt-get install \\apt-transport-https \\ca-certificates \\curl \\gnupg-agent \\software-properties-common 添加Docker的官方GPC秘钥 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 通过查看指纹最后8位,以验证是否拥有带指纹的秘钥 1sudo apt-key fingerprint 0EBFCD88 设置稳定存储库 1234sudo add-apt-repository \\\"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\$(lsb_release -cs) \\stable\" 安装Docker引擎 12345&lt;!-- 先更新一遍索引包 --&gt;sudo apt-get update&lt;!-- 安装最新版本Docker引擎,Docker社区,Docker容器 --&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io 查看Docker版本 1sudo docker version 运行HelloWorld镜像 1sudo docker run hello-world 运行docker run hello-world的过程 本地找hello-world 没有,去DockerHub拉取一份hello-world镜像,并运行 配置镜像地址Docker默认的镜像地址DockerHub在国外,访问慢,这里添加阿里云的加速","categories":[{"name":"容器化技术","slug":"容器化技术","permalink":"https://yimchengjie.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://yimchengjie.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://yimchengjie.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"Selenium在爬虫中的应用","slug":"爬虫/Selenium在爬虫中的应用","date":"2020-01-30T13:30:22.000Z","updated":"2020-02-26T14:41:13.146Z","comments":true,"path":"2020/01/30/爬虫/Selenium在爬虫中的应用/","link":"","permalink":"https://yimchengjie.github.io/2020/01/30/%E7%88%AC%E8%99%AB/Selenium%E5%9C%A8%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"Selenium 在爬虫中的应用 什么是 SeleniumSelenium 是目前用的最广泛的 Web UI 自动化测试框架。核心功能是在多个浏览器上进行自动化测试支持跨平台,支持多种语言. 在 Java 中使用 Selenium在学习爬虫实践的过程中,发现很多网站使用 js 渲染,且 api 调用需要秘钥,导致无法爬取, 这时候就用到了 Selenium, 通过 Selenium 我们能得到经过浏览器渲染后产生的 HTML 文档.毕竟浏览器最终呈现的都是解析后的. 这样我们就能获得完整的 HTML 文档了 在 maven 中导入包 123456&lt;!--selenium--&gt;&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 使用浏览器调试工具 要使用 WebUI 自动化测试, 需要使用浏览器的驱动 工具系统安装的浏览器,选择对应版本的驱动 谷歌浏览器驱动下载地址 使用 WebDriver 1234567891011121314151617// 1. 得到WebDriver实例public static WebDriver initWebDriber(String diverPath) &#123; System.setProperty(\"webdriver.chrome.driver\", diverPath);// diverPath是chromedriver服务地址 WebDriver webDriver = new ChromeDriver(); return webDriver;&#125;// 2. 打开页面webDriver.get(url);// 3. 进行操作(比如登录,打开隐藏窗口等)driver.findElement(By.className(\"UG_box\"));//找到要操作的elementwebElement.click(); //使用获得的element进行点击操作// 4. 下载页面String html = webDriver.getPageSource();// 得到String格式的HTML文档 findElement/findElements详解通过findElement/findElements可以定位element,获取element进行后续操作通常使用By与之结合, By是一个类,里面封装了获取element的方法. By.id() 根据标签的id获取 By.name() 通过标签的name获取 By.tagName() 根据 标签 获取 By.className() 根据标签中类class的值获取 By.lintText() 通过页面中超链接包含的文字来定位 By.xpath() 通过Xpath语法定位 对于浏览器窗口的操作有时候不是所有操作都能用HTML定位来做,比如浏览器弹出的各种窗口 操作弹出窗口 123456// 获取弹出窗口Alert al = driver.switchTo().alert();// 选择确定按钮al.accept();// 选择取消按钮al.dismiss(); 浏览器全屏 1driver.manage().window().maximize(); 关闭浏览器窗口 123driver.quit();driver.close(); 刷新/前进/回退 123456// 刷新driver.navigate().refresh();// 前进driver.navigate().forward();// 回退driver.navigate().back(); 程序等待方式 sleep(); 强制等待,设置睡眠时间 implicitlyWait()：隐式等待，等待元素被发现、命令完成，超出了设置的时间则跑出异常 123WebDriver driver = new ChromeDriver();//设置脚本在查找元素时的最大等待时间driver.manage().timeouts().implicitlyWait(15, TimeUnit.SECONDS); WebDriverWait 123//设置等待的时长，最长10sWebDriverWait wait = new WebDriverWait(driver, 10); wait.until(ExpectedConditions.presenceOfElementLocated(By.id(\"app\"))));","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java爬虫","slug":"Java爬虫","permalink":"https://yimchengjie.github.io/tags/Java%E7%88%AC%E8%99%AB/"},{"name":"Selenium","slug":"Selenium","permalink":"https://yimchengjie.github.io/tags/Selenium/"}]},{"title":"WebMagic入门","slug":"爬虫/WebMagic入门","date":"2020-01-17T13:39:19.000Z","updated":"2020-02-26T14:41:31.399Z","comments":true,"path":"2020/01/17/爬虫/WebMagic入门/","link":"","permalink":"https://yimchengjie.github.io/2020/01/17/%E7%88%AC%E8%99%AB/WebMagic%E5%85%A5%E9%97%A8/","excerpt":"","text":"WebMagic 入门WebMagic 采用完全模块化的设计，有着强大的可扩展性,基于 HttpClient 和 Jsoup核心简单但却涵盖了爬虫的全部流程。有着丰富的页面抽取 API支持多线程分布式，支持爬取动态 js没有框架依赖 WebMagic 架构WebMagic 框架包含四个组件，PageProcessor、Scheduler、Downloader 和 Pipeline。这四大组件对应爬虫生命周期中的处理、管理、下载和持久化等功能。这四个组件都是 Spider 中的属性，爬虫框架通过 Spider 启动和管理。 Downloader: 负责从互联网上下载页面,以便后续处理.一般无需自己实现 Scheduler: 负责管理待抓取的 URL,以及一些去重工作.一般无需自己实现 PageProcessor: 负责解析页面,抽取目标信息,以及发现新 URL,需要自定义 Pipeline: 负责抽取结果的处理,包括计算,持久化等. 数据流转的对象 Request: 是对 URL 地址的一层封装,一个 Request 对象对应一个 URL 地址 Page: 代表了从 Downloader 下载到的一个页面,可能是 HTML 页面也可能是其他文本内容(XML,JSON) ResultItems: 相当于一个 MAP,保存了 PageProcessor 处理的结果,供 Pipeline 使用 简单实例环境配置maven 引入依赖 1234567891011121314151617&lt;!--webmagic--&gt;&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Demo在 WebMagic 中,实现爬虫只需要编写一个类,实现 PageProcessor 接口即可,这个类基本上包含了抓取一个网站,所需要写的所有代码 123456789101112131415161718192021222324252627282930313233343536public class TestPageProcessor implements PageProcessor &#123; // 部分一：抓取网站的相关配置，包括编码、抓取间隔、重试次数等 private Site site = Site.me().setRetryTimes(3).setSleepTime(1000); @Override // process是定制爬虫逻辑的核心接口，在这里编写抽取逻辑 public void process(Page page) &#123; // 部分二：定义如何抽取页面信息，并保存下来 page.putField(\"author\", page.getUrl().regex(\"https://github\\\\.com/(\\\\w+)/.*\").toString()); page.putField(\"name\", page.getHtml().xpath(\"//h1[@class='entry-title public']/strong/a/text()\").toString()); if (page.getResultItems().get(\"name\") == null) &#123; //skip this page page.setSkip(true); &#125; page.putField(\"readme\", page.getHtml().xpath(\"//div[@id='readme']/tidyText()\")); // 部分三：从页面发现后续的url地址来抓取 page.addTargetRequests(page.getHtml().links().regex(\"(https://github\\\\.com/[\\\\w\\\\-]+/[\\\\w\\\\-]+)\").all()); &#125; @Override public Site getSite() &#123; return site; &#125; public static void main(String[] args) &#123; Spider.create(new TestPageProcessor()) //从\"https://github.com/code4craft\"开始抓 .addUrl(\"https://github.com/code4craft\") //开启5个线程抓取 .thread(5) //启动爬虫 .run(); &#125;&#125; 注解模式开发123456789101112131415161718192021222324252627@TargetUrl(\"https://github.com/\\\\w+/\\\\w+\") //要抓取的目标url// 在TargetUrl页面得到的URL,只要符合TargetUrl的格式,也会被下载// TargetUrl还支持定义sourceRegion，这个参数是一个XPath表达式，指定了这个URL从哪里得到——不在sourceRegion的URL不会被抽取。@HelpUrl(\"https://github.com/\\\\w+\") // 为了访问目标url需要访问的url/* 对于博客页，HelpUrl是列表页，TargetUrl是文章页。 对于论坛，HelpUrl是帖子列表，TargetUrl是帖子详情。 对于电商网站，HelpUrl是分类列表，TargetUrl是商品详情。 */public class GithubRepo &#123; //@ExtractBy注解主要作用于字段，它表示“使用这个抽取规则，将抽取到的结果保存到这个字段中”。 @ExtractBy(value = \"//h1[@class='entry-title public']/strong/a/text()\", notNull = true) private String name; @ExtractByUrl(\"https://github\\\\.com/(\\\\w+)/.*\") private String author; @ExtractBy(\"//div[@id='readme']/tidyText()\") private String readme; public static void main(String[] args) &#123; OOSpider.create(Site.me().setSleepTime(1000) , new ConsolePageModelPipeline(), GithubRepo.class) .addUrl(\"https://github.com/code4craft\").thread(5).run(); &#125;&#125; 一个完整流程 编写爬虫 12345678910111213@TargetUrl(\"https://github.com/\\\\w+/\\\\w+\")@HelpUrl(\"https://github.com/\\\\w+\")public class GithubRepo &#123; @ExtractBy(value = \"//h1[@class='entry-title public']/strong/a/text()\", notNull = true) private String name; @ExtractByUrl(\"https://github\\\\.com/(\\\\w+)/.*\") private String author; @ExtractBy(\"//div[@id='readme']/tidyText()\") private String readme;&#125; 启动 123456public static void main(String[] args) &#123; // OOSpider是入口, 参数分别为, 请求参数, 结果处理链, 爬虫类 OOSpider.create(Site.me().setSleepTime(1000) , new ConsolePageModelPipeline(), GithubRepo.class) .addUrl(\"https://github.com/code4craft\").thread(5).run();&#125;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java爬虫","slug":"Java爬虫","permalink":"https://yimchengjie.github.io/tags/Java%E7%88%AC%E8%99%AB/"},{"name":"WebMagic","slug":"WebMagic","permalink":"https://yimchengjie.github.io/tags/WebMagic/"}]},{"title":"时间复杂度和空间复杂度","slug":"算法与数据结构/时间复杂度和空间复杂度","date":"2020-01-14T08:44:37.000Z","updated":"2020-02-21T17:59:20.180Z","comments":true,"path":"2020/01/14/算法与数据结构/时间复杂度和空间复杂度/","link":"","permalink":"https://yimchengjie.github.io/2020/01/14/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度和空间复杂度算法的时间复杂度和空间复杂度是用来描述算法优劣的两个指标 时间复杂度算法的时间复杂度反应了算法执行时间随输入规模增长而增长的量级,通常的时间复杂度指的是最坏时间复杂度 时间复杂度预估步骤 找出基准语句,即算法中执行次数最多的那条语句 计算基本语句的执行次数的数量级 用O()表示算法的时间性能,括号内为基准语句执行次数的数量级 预估时间复杂度的具体实例注: 只计算时间复杂度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 时间复杂度 O(1)if (n &gt; 10) &#123; System.out.println(\"n &gt; 10\");&#125; else if (n &gt; 5) &#123; // 2 System.out.println(\"n &gt; 5\");&#125; else &#123; System.out.println(\"n &lt;= 5\"); &#125;// 时间复杂度 O(n)for (int i = 0; i &lt; n; i++) &#123; // 循环内语句最大执行次数: n System.out.println(\"test\");&#125;// 时间复杂度 O(n)for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 15; j++) &#123; // 内层循环内语句最大执行次数: 15*n System.out.println(\"test\"); &#125;&#125;// 时间复杂度 O(n^2)for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; // 内层循环内语句最大执行次数: n^2 System.out.println(\"test\"); &#125;&#125;// 时间复杂度 O(logn)// java中整形数值相除当x&lt;y时x/y=0while ((n = n / 2) &gt; 0) &#123; // 循环内语句最大执行次数: n除几次2=1 -&gt; log2(n) System.out.println(\"test\");&#125;// 时间复杂度 O(logn)while ((n = n / 5) &gt; 0) &#123; // 循环内语句最大执行次数: n除几次5=1 -&gt; log5(n) System.out.println(\"test\");&#125;// 时间复杂度 O(nlogn)for (int i = 1; i &lt; n; i = i * 2) &#123; // 外层循环执行次数: log2(n) for (int j = 0; j &lt; n; j++) &#123; // 单独内层循环语句执行次数为: n // 基准语句最大执行次数为: n*log2(n) System.out.println(\"test\"); &#125;&#125;空间复杂度算法的空间复杂度是算法在运行时间内临时占用的内存空间的大小,但一般的程序只要满足占用空间小于可用空间即可. 所以尝尝牺牲空间复杂度来满足时间复杂度","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://yimchengjie.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"时间复杂度","slug":"时间复杂度","permalink":"https://yimchengjie.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"空间复杂度","slug":"空间复杂度","permalink":"https://yimchengjie.github.io/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"Jsoup技术入门","slug":"爬虫/Jsoup技术入门","date":"2020-01-03T14:11:13.000Z","updated":"2020-02-21T17:58:47.637Z","comments":true,"path":"2020/01/03/爬虫/Jsoup技术入门/","link":"","permalink":"https://yimchengjie.github.io/2020/01/03/%E7%88%AC%E8%99%AB/Jsoup%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/","excerpt":"","text":"Jsoup技术入门在使用Jsoup之前,解析响应通常使用字符串和正则表达式来获取目标数据, 但是正则表达式还是相对麻烦. Jsoup是一款Java的HTML解析器,可以直接解析某个URL地址,HTML内容. Jsoup提供了丰富的API,可以向前端一样通过DOM等操作方法获取目标数据 简单实例虽然Jsoup也可以直接通过URL抓取内容, 但不用来做爬虫,因为开发中往往需要使用多线程,连接池等技术, Jsoup的支持并不好, 所以Jsoup通常依赖解析数据 解析URL12345678@Testpublic void testUrl() throws IOException &#123; // Jsoup解析URL地址 Document document = Jsoup.parse(new URL(\"https://www.baidu.com\"),3000); // 使用标签选择器获取标题 String title = document.getElementsByTag(\"title\").first().text(); System.out.println(title);&#125; 解析String12345678@Testpublic void testString()&#123; // 封装好的HttpClient爬虫 String html=SpiderFirst.getSpider(\"https://www.baidu.com\"); Document document = Jsoup.parse(html); String title = document.getElementsByTag(\"title\").first().text(); System.out.println(title);&#125; 解析File123456@Testpublic void testfile() throws IOException &#123; Document document = Jsoup.parse(new File(\"C:\\\\Users\\\\yanchengjie\\\\Desktop\\\\baidu.html\"),\"utf8\"); String title = document.getElementsByTag(\"title\").first().text(); System.out.println(title);&#125; DOM操作12345678910111213141516171819202122@Testpublic void testDOM() &#123; // 封装好的HttpClient爬虫 String html = SpiderFirst.getSpider(\"http://www.itcast.cn/\"); Document document = Jsoup.parse(html); Element element = document.getElementById(\"webim\"); System.out.println(element.toString()); // 获取id值 String id = element.id(); String id_ = element.attr(\"id\"); System.out.println(id + \" \" + id_); // 获取className String className = element.child(0).className(); String className_ = element.child(0).attr(\"class\"); System.out.println(className+\" \"+className_); // 获取所有元素 Attributes attrs = element.child(0).child(0).child(0).attributes(); System.out.println(attrs.toString()); // 获取文本内容 String text = element.child(0).child(0).child(0).text(); System.out.println(text);&#125; 选择器操作12345678910111213141516171819202122232425262728293031323334@Testpublic void testSelector()&#123; // 封装好的HttpClient爬虫 String html = SpiderFirst.getSpider(\"http://www.itcast.cn/\"); Document document = Jsoup.parse(html); // 使用标签选择器 Elements elements = document.select(\"span\"); for(Element element: elements)&#123; System.out.println(element.text()); &#125; // 使用id选择器 Element element = document.select(\"#webim\").first(); System.out.println(element.toString()); // 使用类选择器 Elements elements1 = document.select(\".a_default\"); for(Element element1: elements1)&#123; System.out.println(element1.text()); &#125; // 元素选择器 Elements elements2 = document.select(\"[class=slogan]\"); for(Element element2: elements2)&#123; System.out.println(element2.toString()); &#125; // 组合选择器 Elements elements3 = document.select(\"img.slogan\"); for(Element element3: elements3)&#123; System.out.println(element3.toString()); &#125; Elements elements4 = document.select(\".box_hd &gt; h2\"); for(Element element4: elements4)&#123; System.out.println(element4.toString()); &#125;&#125;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java爬虫","slug":"Java爬虫","permalink":"https://yimchengjie.github.io/tags/Java%E7%88%AC%E8%99%AB/"},{"name":"Jsoup","slug":"Jsoup","permalink":"https://yimchengjie.github.io/tags/Jsoup/"}]},{"title":"NoSQL之MongoDB","slug":"数据库/NoSQL之MongoDB","date":"2020-01-03T09:21:16.000Z","updated":"2020-02-26T14:54:20.170Z","comments":true,"path":"2020/01/03/数据库/NoSQL之MongoDB/","link":"","permalink":"https://yimchengjie.github.io/2020/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL%E4%B9%8BMongoDB/","excerpt":"","text":"NoSQL 之 MongoDB MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 安装 MongoDB以 Ubuntu 为例 sudo apt install mongodb–安装命令 systemctl status mongodb–检查服务 概念解析 SQL 术语 MongoDB 术语 说明 database database 数据库 table collection 表/集合 row document 记录行/文档 column field 字段/域 index index 索引 table joins - 连表查询/MongoDB 不支持 primary key primary key 主键,MongoDB 自动将_id 字段设置为主键 MongoDB Java在 Java 中使用 MongoDB 直接使用 Spring Data MongoDB 添加 spring-boot-starter-data-mongodb 包 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 配置 application.properties 12345# user:用户名,# mongo1.example.com:host地址,# 27017:端口号# test:数据库名spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:27017/test 使用 MongoTemplate MongoTemplate 提供了增删改查的方法 123456789101112131415@SpringBootTestclass SpiderApplicationTests &#123; @Autowired private MongoTemplate mongoTemplate; @Test void contextLoads() &#123; MongoCollection mongoCollection = mongoTemplate.getCollection(\"weibo\"); String index=mongoCollection.createIndex(new Document().append(\"text\", 1)); Long count=mongoCollection.countDocuments(); mongoTemplate.createCollection(\"\"); System.out.println(index+\" \"+count); &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yimchengjie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://yimchengjie.github.io/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://yimchengjie.github.io/tags/MongoDB/"}]},{"title":"HttpClient技术入门","slug":"爬虫/HttpClient技术入门","date":"2019-12-30T12:05:53.000Z","updated":"2020-02-21T17:58:15.697Z","comments":true,"path":"2019/12/30/爬虫/HttpClient技术入门/","link":"","permalink":"https://yimchengjie.github.io/2019/12/30/%E7%88%AC%E8%99%AB/HttpClient%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/","excerpt":"","text":"HttpClient技术入门网络爬虫通常都是使用Http协议访问互联网,所以HttpClient这个同样是Http协议的客户端技术就被运用到了爬虫技术中只需要在maven引入HttpClient就可以使用 简单示例1234567891011121314151617181920212223242526public static void main(String[] args) &#123; // 1.创建HttpClient对象(Default默认设置的) CloseableHttpClient httpClient = HttpClients.createDefault(); // 2.创建请求对象,需要Url参数 HttpGet httpGet = new HttpGet(\"https://www.baidu.com\"); // 3.发起请求,接收响应 CloseableHttpResponse httpResponse = null; try &#123; httpResponse = httpClient.execute(httpGet); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 4.解析请求,获取数据 // 4.1 判断状态码 if (httpResponse.getStatusLine().getStatusCode() == 200)&#123; // 4.2 获取主体数据 HttpEntity httpEntity = httpResponse.getEntity(); try &#123; // 4.3 数据转码 String context = EntityUtils.toString(httpEntity,\"utf-8\"); System.out.println(context); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用步骤1. 构建HTTP请求12345678910111213// 方法一HttpGet httpGet = new HttpGet(\"https://www.baidu.com\");// 方法二URI uri = new URIBuilder().setScheme(\"http\") .setHost(\"https://www.baidu.com\") .setPath(\"/s\") .setParameter(\"ie\",\"utf-8\") .setParameter(\"f\",\"8\") .setParameter(\"rsv_bp\",\"1\") .setParameter(\"tn\",\"80035161_2_dg\") .build();HttpGet httpGet = new HttpGet(uri); 2. 添加消息头123456HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_OK,\"OK\");response.addHeader(\"Set-Cookie\",\"c1=a; path=/; domain=localhost\");response.addHeader(\"Set-Cookie\",\"c2=b; path=\\\"/\\\", c3=c; domain=\\\"localhost\\\"\");Header h1 = response.getFirstHeader(\"Set-Cookie\");Header h2 = response.getLastHeader(\"Set-Cookie\");Header[] hs = response.getHeaders(\"Set-Cookie\"); 3. 生成HTTP实体123456789101112// 1. String类型的实体StringEntity myEntity = new StringEntity(\"important message\",ContentType.create(\"text/plain\",\"UTF-8\"));// 2. File类型实体File file = new File(\"onefile.txt\");FileEntity entity = new FileEntity(file,contentType.create(\"text/plain\",\"UTF-8\"));// 3. 表单实体List&lt;NameValuePair&gt; formparam = new ArrayList&lt;NameValuePair&gt;();formparam.add(new BasicNameValuePair(\"param1\",\"value1\"));formparam.add(new BasicNameValuePair(\"param2\",\"value2\"));UrlEncodeFormEntity entity = new UrlEncodedFormEntity(formparam,Consts.UTF_8); 4. 配置请求信息12345678// 配置请求信息RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(1000) // 创建连接的最长时间 .setConnectionRequestTimeout(500) // 设置获取连接的最长时间 .setSocketTimeout(10*1000) // 设置数据传输的最长时间 .build();// 添加配置对象httpGet.setConfig(requestConfig); 连接池的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void main(String[] args) &#123; // 1. 创建连接池管理器 PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager(); // 2. 使用连接池管理器发起请求 doGet(poolingHttpClientConnectionManager,\"https://www.baidu.com/s\",\"wt\",\"httpclient\");&#125;private static String doGet(PoolingHttpClientConnectionManager poolingHttpClientConnectionManager,String url,String...param) &#123; // 从连接池中获取HttpClient CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(poolingHttpClientConnectionManager).build(); // 2.1 创建URI对象(带参的URL) URIBuilder uriBuilder; HttpGet httpGet = null; try &#123; uriBuilder = new URIBuilder(url); for (int i=0;(i+1)&lt;param.length;i+=2) uriBuilder.setParameter(param[i],param[i+1]); httpGet = new HttpGet(uriBuilder.build()); &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; // 3.发起请求,接收响应 CloseableHttpResponse httpResponse = null; try &#123; httpResponse = httpClient.execute(httpGet); // 4.解析请求,获取数据 // 4.1 判断状态码 if (httpResponse.getStatusLine().getStatusCode() == 200)&#123; // 4.2 获取主体数据 HttpEntity httpEntity = httpResponse.getEntity(); // 4.3 数据转码 String context = EntityUtils.toString(httpEntity,\"utf-8\"); System.out.println(context); return context; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; // 关闭资源 try &#123; httpResponse.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; /* 交给连接池管理, 不用关闭 try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;*/ &#125; return null;&#125;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java爬虫","slug":"Java爬虫","permalink":"https://yimchengjie.github.io/tags/Java%E7%88%AC%E8%99%AB/"},{"name":"HttpClient","slug":"HttpClient","permalink":"https://yimchengjie.github.io/tags/HttpClient/"}]},{"title":"初探Java爬虫","slug":"爬虫/初探Java爬虫","date":"2019-12-27T13:09:53.000Z","updated":"2020-02-21T17:58:58.259Z","comments":true,"path":"2019/12/27/爬虫/初探Java爬虫/","link":"","permalink":"https://yimchengjie.github.io/2019/12/27/%E7%88%AC%E8%99%AB/%E5%88%9D%E6%8E%A2Java%E7%88%AC%E8%99%AB/","excerpt":"","text":"初探Java爬虫既然学的是Java,那就用Java来学爬虫. Demo1234567891011121314151617181920212223242526272829public class spiderDemo &#123; public static void main(String[] args) &#123; // 爬取的目标url String url = \"https://www.baidu.com\"; // 空字符串,用于后续接收内容 StringBuffer result = new StringBuffer(); BufferedReader in = null; try&#123; // 将字符串url转换成URL类型 URL readUrl = new URL(url); // 进行链接初始化 URLConnection connection = readUrl.openConnection(); // 开始连接 connection.connect(); // 创建一个输入流来读取响应内容 in = new BufferedReader(new InputStreamReader(connection.getInputStream())); // 创建读取临时变量(读取缓存) String tempStr = \"\"; while ((tempStr = in.readLine())!=null)&#123; result.append(tempStr); &#125; System.out.println(result); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; System.out.println(\"爬取结束\"); &#125; &#125;&#125; 程序运行结果 可以看到, 上述程序连接到URL,然后读取了响应, 也就是baidu首页的源码 那么如何获取更细的内容呢. 正则表达式的应用1234567891011121314151617181920public static void main(String[] args) &#123; SpiderDemo spiderDemo = new SpiderDemo(); // 爬取的目标url String url = \"https://www.baidu.com\"; // 将爬取功能封装 String result = spiderDemo.spiderMan(url); // 定义样式模板,匹配&lt;img&gt;标签 String patternStr = \"&lt;img.*src\\\\s*=\\\\s*(.*?)[^&gt;]*?&gt;\"; // 要匹配的目标字符串 String targetStr = result; // 将样式模板字符串转型 Pattern pattern = Pattern.compile(patternStr); // 定义匹配对象进行匹配 Matcher matcher = pattern.matcher(targetStr); // 如果匹配成功 while (matcher.find())&#123; System.out.println(\"匹配成功\"); System.out.println(matcher.group()); &#125; &#125; 正则表达式是爬虫获取精确内容的重要基础","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java爬虫","slug":"Java爬虫","permalink":"https://yimchengjie.github.io/tags/Java%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫入门","slug":"爬虫/爬虫入门","date":"2019-12-10T16:12:45.000Z","updated":"2020-02-20T14:39:40.700Z","comments":true,"path":"2019/12/11/爬虫/爬虫入门/","link":"","permalink":"https://yimchengjie.github.io/2019/12/11/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/","excerpt":"","text":"爬虫入门爬虫是什么爬虫即网络爬虫,其作用是自动爬取互联网数据的程序.数据是互联网的石油,没有数据时,爬虫就能发挥重要作用.搜索引擎也可以看成是一个爬虫,它网络了互联网上的内容. 爬虫的基本流程 分析网站,得到目标url 根据url,发起请求,获取HTML源码 从HTML源码中提取数据 提取源码中的目标数据,并持久化保存 提取源码中的新Url地址,重复第2步操作 爬虫结束,所有目标url提取完毕,并且目标数据保存完成 实现爬虫的基本步骤 建立连接,爬取数据 建立正则表达式规范 使用正则匹配目标数据 Url的组成 scheme:协议(http,https,ftp) host:服务器地址 port:服务器端口 path:访问的资源路径 query-string:参数 常见请求状态码200:请求成功301:永久重定向302:临时重定向400:客户端错误401:未授权403:服务器拒绝访问404:找不到页面405:请求方式错误408:请求超时500:服务器错误503:服务不可用","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yimchengjie.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"SpringCloud入门","slug":"分布式开发技术/SpringCloud入门","date":"2019-11-25T11:30:49.000Z","updated":"2020-02-26T17:58:04.286Z","comments":true,"path":"2019/11/25/分布式开发技术/SpringCloud入门/","link":"","permalink":"https://yimchengjie.github.io/2019/11/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/SpringCloud%E5%85%A5%E9%97%A8/","excerpt":"","text":"SpringCloud入门SpringCloud是一套用于分布式/微服务的框架 分布式简单的来说,就是将业务拆分,并部署到不同的服务器上 分布式系统面临的问题就叫CAP,即数据一致性,可用性,容错率 SpringCloud的基础功能 服务治理: SpringCloud Eureka 客户端负载均衡: SpringCloud Ribbon 服务容错保护: SpringCloud Hystrix 声明式服务调用: SpringCloud Feign API网关服务: SpringCloud ZuuI 分布式配置中心: SpringCloud Config SpringCloud Eureka分布式/微服务的系统,由于不同模块在物理层面被分开,运行在不同的服务器. 那么模块与模块之间的调用,或者说通讯(信息交互), 就需要用到远程调用远程调用就会有很多的地址配置, 比如IP地址, 一旦IP地址发生改变, 维护就变得很麻烦 服务治理框架就是围绕着服务注册和服务发现机制来完成对微服务应用实例的自动化管理工具 系统服务器将自己的id和IP注册到Eureka服务上, 这样系统间调用就只需要通过id, 而IP则由Eureka维护 我们把提供Eureka的服务器称为Eureka服务端, 那些将服务注册到Eureka服务端的的服务器成为Eureka客户端 1. Eureka Server的配置Eureka Server可以看成是Zookeeper 12register-with-eureka: false #false表示不向注册中心注册自己。fetch-registry: false #false表示自己就是注册中心，不需要去检索服务 2. Eureka Client的配置Eureka Client分为服务提供者和服务消费者, 也可以既是提供者也是消费者 12345eureka: client: register-with-eureka: false # 当前微服务不注册到eureka中(消费端) 如果是服务端就改为true service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 3. Eureka的治理机制 服务提供者 服务注册: 启动时发送请求将自己注册到Eureka Server上 服务续约: 在注册完服务后,服务提供者会维护一个心跳来告诉Eureka Server服务状态可用 服务下线: 当服务不可用时,会触发下线请求,通知Eureka Server 服务消费者 获取服务: 启动消费者时, 它会发生请求给Eureka Server, 获取上面注册的服务清单 服务调用: 消费者获取服务清单以后,通过服务名调用具体的服务实例.在进行服务调用的时候,会优先访问同处于一个地区的服务提供方(同一服务多台服务器集群的情况) Eureka Server 失效剔除: 默认每隔一段时间将当前注册的服务清单中没有续约的服务剔除 自我保护: Eureka Server在运行期间,会统计心跳失效的比例,如果一段时间内的心跳成功比例过低,,Eureka Server会将这个提供者的信息保存起来 4. RestTemplate提交REST请求RestTemplate是SpringCloud封装的工具类,实现获取具体服务实例的IP 1234567891011121314151617// 传统的方式，直接显示写死IP是不好的！//private static final String REST_URL_PREFIX = \"http://localhost:8001\";// 服务实例名, 这里只是名字,不是IPprivate static final String REST_URL_PREFIX = \"http://MICROSERVICECLOUD-DEPT\";/** * 使用 使用restTemplate访问restful接口非常的简单 * (url, requestMap, ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。 */@Autowiredprivate RestTemplate restTemplate;@RequestMapping(value = \"/consumer/dept/add\")public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class);&#125; SpringCloud Ribbon为了实现服务的高可用, 往往会使用集群的方式部署一个服务,而如何让集群合理分摊请求,就涉及到负载均衡 Ribbon是SpringCloud支持的客户端的负载均衡 通常的负载均衡都在服务端,比如Nginx 所谓的客户端负载均衡,就是由获取了服务清单的消费者,来进行负载均衡算法的分配 Ribbon的配置Ribbon是支持负载均衡,默认的负载均衡策略是采用轮询的方式,也可以自定义 1234567891011@Configurationpublic class MySelfRule&#123; @Bean public IRule myRule() &#123; //return new RandomRule();// Ribbon默认是轮询，自定义为随机 //return new RoundRobinRule();// Ribbon默认是轮询，自定义为随机 return new RandomRule_ZY();// 自定义为每台机器5次 &#125;&#125; 自定义的方式很简单,继承AbstractLoadBalancerRule,重写public Server choose(ILoadBalancer lb, Object key)即可 SpringCloud HystrixHystrix是SpringCloud的容错机制 虽然实现了服务注册和发现,以及集群负载均衡 但是,如果有一个请求,需要调用多个服务,而有一个服务出现了问题,比如网络延迟,那会导致这个请求不可用, 如果是高并发式的请求, 那所有的请求都会延迟甚至不可用,进一步,请求的堆积,导致负载均衡饱和,集群资源耗尽,服务器瘫痪, 这就是”雪崩“ Hystrix为了防止这一系列问题,实现了断路器、线程隔离等一些系列保护机制 断路器 Fallback(失败快速返回):当某个服务节点出现故障(类似电器短路), 断路器的故障监控就会发现他(类似保险丝),向调用方返回一个错误响应,而不是长久等待.这样就不会因为请求时间过长而占用资源,防止了进一步恶化 线程隔离 为每个依赖服务设立单独的线程池,固定线程数量, 当请求过多(每个请求都会创建线程),线程池饱和就会拒绝请求. 这样就阻断了雪崩 Hystrix仪表盘Hystrix仪表盘用于实时监控Hystrix的各项指标信息, 帮助我们发现存在的问题,从而采取相应措施 SpringCloud FeignFeign整合了Eurake和Hystrix, 使开发更加便捷 此外,还提供了声明式服务调用 声明式服务调用使用声明式服务调用可以实现使用HTTP请求远程服务能与调用本地方法一样的简单遍历 123456789101112131415// value ---&gt;指定调用哪个服务// fallbackFactory---&gt;熔断器的降级提示@FeignClient(value = \"MICROSERVICECLOUD-DEPT\", fallbackFactory = DeptClientServiceFallbackFactory.class)public interface DeptClientService &#123; // 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！ @RequestMapping(value = \"/dept/get/&#123;id&#125;\", method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\", method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept);&#125; 123456789101112131415161718192021222324252627/** * Feign中使用断路器 * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来) */@Component // 不要忘记添加，不要忘记添加public class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt; &#123; @Override public DeptClientService create(Throwable throwable) &#123; return new DeptClientService() &#123; @Override public Dept get(long id) &#123; return new Dept().setDeptno(id).setDname(\"该ID：\" + id + \"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭\") .setDb_source(\"no this database in MySQL\"); &#125; @Override public List&lt;Dept&gt; list() &#123; return null; &#125; @Override public boolean add(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; SpringCloud Zuul由于服务的增多,路由规则和实例维护都需要外部负载均衡(nigix)来做而且为了保证所有服务的安全性,每一层都要设立验证 Zuul网关可以解决上述问题 如何解决上述问题 Zuul通过与Eureka结合,将自身注册到Eureka,同时获得了所有注册服务的清单.外层的请求,都要经过Zuul,这就使维护服务实例的任务交给了服务治理框架自己完成 在Zuul网关上进行统一调用验证服务,实现对微服务接口的拦截和校验 Zuul是整个系统对外暴露的唯一接口,解决的是外部请求调用的问题,Ribbo和Fegin虽然也有负载均衡的功能,但解决的是内部各个服务之间的调用问题 Zuul和Nginx并不冲突,可以同时使用 SpringCloud Config随着业务的扩展,服务越来越多, 每个服务都要存在配置文件, 而配置文件往往是修改频繁的地方. Config可以解决分布式系统配置的管理问题,它包含Client和Server两部分 Config将所有的配置文件存放到统一的位置管理(Server端),其他的服务(Client)通过接口获取自己的配置 Config通常用Git来做Server端 Config实现了实时配置管理,结合 SpringCloud Bus,可以实现服务动态刷新配置(不需要重启)","categories":[{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://yimchengjie.github.io/tags/SpringCloud/"}]},{"title":"JPA-SpringData入门","slug":"Java开发框架/JPA-SpringData入门","date":"2019-11-12T13:30:45.000Z","updated":"2020-02-21T11:28:00.921Z","comments":true,"path":"2019/11/12/Java开发框架/JPA-SpringData入门/","link":"","permalink":"https://yimchengjie.github.io/2019/11/12/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/JPA-SpringData%E5%85%A5%E9%97%A8/","excerpt":"","text":"JPA-SpringData入门SpringData JPA是基于Spring的ORM框架,采用JPA规范,底层采用了Hibernate,而Hibernate也是基于JPA规范开发的它提供了增删改查等在内的功能,且易于扩展 组成 Repository: 标识接口,表明任何继承它的类都是仓库接口类,方便Spring自动扫描 CrudRepository: 继承了Repository, 实现了CRUD的方法 PagingAndSortingRepository: 继承了CrudRepository,实现了一组分页排序相关的方法 JpaRepository: 继承PagingAndSortingRepository,实现了一组JPA规范的方法 JpaSpecificationExecutor: 不属于Repository体系, 它实现了一组JPA规范的查询相关的方法 根据功能,可以看到Repository系列组成的模块, 相当于以前的Mapper层(或者Dao层)且提供了基础的增删改查,无需手写, 相比Mybatis方便很多 JpaRepositoryJpaRepository继承了PagingAndSortingRepository,间接也继承了CrudRepository所以JpaRepository的功能是非常全面的,一般数据访问层的接口实现这个接口它的定义如下 123456789public interface JpaRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt; &#123; List&lt;T&gt; findAll();//查询所有对象，不排序 List&lt;T&gt; findAll(Sort sort);//查询所有对象，并排序 &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; entities);//批量保存 void flush();//强制缓存与数据库同步 T saveAndFlush(T entity);//保存并强制同步 void deleteInBatch(Iterable&lt;T&gt; entities);//批量删除 void deleteAllInBatch();//删除所有&#125; 如何执行SQLJPA规范下有HQL,JPQL语句, 一般在复杂查询时使用, 但是如果能直接写SQL还是更好的(更熟悉,更可读) JPA下如何执行SQL语句呢 利用if语句合理拼接SQL createNativeQuery()方法可以创建要执行自然SQL语句查询Query query=entityManager.createNativeQuery(sql.toString) query.getSingleResult()方法执行","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"JPA","slug":"JPA","permalink":"https://yimchengjie.github.io/tags/JPA/"}]},{"title":"享元模式","slug":"设计模式/享元模式","date":"2019-11-08T12:58:21.000Z","updated":"2020-01-07T13:37:32.997Z","comments":true,"path":"2019/11/08/设计模式/享元模式/","link":"","permalink":"https://yimchengjie.github.io/2019/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"享元模式属于结构型模式 又叫共享模式, 共享系统对象 为什么使用享元模式解决重复对象的内存浪费的问题 常用场景为数据库连接池 使用享元模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface Pool &#123; void connect();&#125;public class PoolObj implements Pool&#123; private String db; public PoolObj(String db) &#123; this.db = db; &#125; @Override public void connect() &#123; System.out.println(\"连接 \"+db); &#125;&#125;public class PoolFactory &#123; private HashMap&lt;String,Pool&gt; pools=new HashMap&lt;&gt;(); public Pool getPool(String db)&#123; if (pools.get(db)!=null)&#123; return pools.get(db); &#125;else&#123; Pool pool=new PoolObj(db); pools.put(db,pool); return pool; &#125; &#125; public void printMapCount()&#123; System.out.println(pools.size()); &#125;&#125;@Testpublic void testFlyWeight()&#123; PoolFactory poolFactory=new PoolFactory(); Pool pool1=poolFactory.getPool(\"mysql\"); Pool pool2=poolFactory.getPool(\"oracle\"); pool1.connect(); pool2.connect(); Pool pool3=poolFactory.getPool(\"mysql\"); Pool pool4=poolFactory.getPool(\"oracle\"); pool3.connect(); pool4.connect(); poolFactory.printMapCount();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"外观模式","slug":"设计模式/外观模式","date":"2019-10-30T12:31:05.000Z","updated":"2020-01-07T13:37:21.551Z","comments":true,"path":"2019/10/30/设计模式/外观模式/","link":"","permalink":"https://yimchengjie.github.io/2019/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"外观模式属于结构型模式 外观模式其实就是将一段代码中不变的部分提炼出来,做成一个接口暴露给用户 为什么使用外观模式降低访问复杂系统的内部子系统时的复杂度,减少系统相互依赖。提高灵活性.提高安全性 使用外观模式1234567891011121314151617181920212223242526272829303132333435// 将一些列方法封装成接口暴露给用户public class Facade &#123; private DeviceA deviceA=new DeviceA(); private DeviceB deviceB=new DeviceB(); private DeviceC deviceC=new DeviceC(); public void methed()&#123; deviceA.method(); deviceB.method(); deviceC.method(); &#125;&#125;public class DeviceA &#123; public void method()&#123; System.out.println(\"执行DeviceA的方法\"); &#125;&#125;public class DeviceB &#123; public void method()&#123; System.out.println(\"执行DeviceB的方法\"); &#125;&#125;public class DeviceC &#123; public void method()&#123; System.out.println(\"执行DeviceC的方法\"); &#125;&#125;//测试@Testpublic void testFacade() &#123; Facade facade = new Facade(); facade.methed();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"MySQL数据库之索引","slug":"数据库/MySQL数据库之索引","date":"2019-10-28T11:21:16.000Z","updated":"2020-01-07T12:27:49.440Z","comments":true,"path":"2019/10/28/数据库/MySQL数据库之索引/","link":"","permalink":"https://yimchengjie.github.io/2019/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%B4%A2%E5%BC%95/","excerpt":"","text":"MySQL数据库之索引MySQL索引的简历对于MySQL的高效运行至关重要,索引可以大大提高MySQL检索速度 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。所以建立索引会占用磁盘空间的索引文件。 对表中数据增删改时,索引也要进行相应维护 索引的使用 在创建表的时候创建索引 1234567CREATE TABLE book( id INT NOT NULL PRIMARY KEY, name VARCHAR(50) NOT NULL, author VARCHAR(20) NOT NULL, info VARCHAR(255) NULL, INDEX(author)); CREATE INDEX直接创建索引 12CREATE INDEX index_name ON table_name (column_list)CREATE UNIQUE INDEX index_name ON table_name (column_list) 删除索引 123drop index index_name on table_name ;alter table table_name drop index index_name ;alter table table_name drop primary key ; 组合索引和前缀索引 12-- 使用column_list1(4)建立column_list1的前4位的索引ALTER TABLE table_name ADD INDEX index_name (column_list1(4),column_list2,column_list3); 使用注意不走索引的情况 索引列参与到计算式 索引列参与到函数运算 正则表达式匹配 条件中带or like ‘%XX%’ where中有不等号 注意: like’XXX%’ 走索引 索引虽然大大提高了查询速度, 但是降低了更新速度; 索引技巧 只要列中有NULL值, 索引就无效 使用短索引,对长字段建索引时使用前缀建立 ORDER BY中的列不会使用索引 使用like语句走索引要用’XXX%’ 不要在列上运算 索引要建立在经常进行select操作的字段上 索引要建立在值相对唯一的字段上","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yimchengjie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://yimchengjie.github.io/tags/MySQL/"}]},{"title":"MySQL数据库之事务","slug":"数据库/MySQL数据库之事务","date":"2019-10-22T10:23:20.000Z","updated":"2020-02-26T14:54:06.548Z","comments":true,"path":"2019/10/22/数据库/MySQL数据库之事务/","link":"","permalink":"https://yimchengjie.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"MySQL数据库之事务MySQL事务主要用于处理操作量大的一系列操作;比如在人员管理系统中,删除一个人员的同时还要删除人员的基本资料,也要删除一些其他相关的信息,这样的数据库操作就叫事务. MySQL事务处理的两种方式 用BEGIN(开始一个事务),ROLLBACK(事务回滚),COMMIT(事务确认)实现 用SET来改变MySQL的自动提交模式 实现事务管理12345678910111213141516171819202122232425262728293031// 模拟一次转账@Testpublic void test1() &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = DBUtils.getConnection(); //这里关闭自动事务提交, 相当于开启事务 begin ,并且需要手动提交 conn.setAutoCommit(false); //用户A转出100 ps = conn.prepareStatement(\"update account set money=money-100 where name='A'\"); ps.executeUpdate(); //模拟异常 int i = 10/0; //用户B转入100 ps = conn.prepareStatement(\"update account set money=money+100 where name='B'\"); ps.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; try &#123; //事务回滚 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; DBUtils.close(conn, ps, null); &#125;&#125; Mybatis中的事务管理Mybatis的事务在环境配置中, 环境配置传入SqlSessionFactory工厂 1234&lt;environment&gt; &lt;!-- 使用JDBC开启事务 --&gt; &lt;transactionManager type=\"jdbc\"/&gt;&lt;/environment&gt; 开启事务后,Mybatis会创建一个TransactionFactory 事务工厂Mybatis中Transaction(事务)是由TransactionFactory(事务工厂)创建的 事务由Connection实例管理 Spring+Mybatis实现事务管理使用Managed事务管理,Mybatis对事务的创建提交回滚没有实现,是交给容器来实现的 12345678910111213&lt;!-- Mybatis配置 --&gt;&lt;environment&gt; &lt;!-- Mybatis中开启Managed事务管理 --&gt; &lt;transactionManager type=\"managed\"/&gt;&lt;/environment&gt;```html&lt;!-- Spring配置 --&gt;&lt;tx:annotation-driven /&gt;&lt;bean id=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 12//SpringBoot开启事务@EnableTransactionManagement //开始事务 抽离出事务Service,使用@Transational注解事务方法 1234567891011121314@Servicepublic class TransationalService &#123; @Autowired Service service @Transactional(rollbackFor = Exception.class) public void transationMethod() &#123; // 调用其他增删改查, 组成一个事务 service.select(); service.update(); service.delete(); &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://yimchengjie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://yimchengjie.github.io/tags/MySQL/"}]},{"title":"组合模式","slug":"设计模式/组合模式","date":"2019-10-15T08:53:46.000Z","updated":"2020-01-05T03:06:23.672Z","comments":true,"path":"2019/10/15/设计模式/组合模式/","link":"","permalink":"https://yimchengjie.github.io/2019/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"组合模式属于结构型模式 组合模式又叫部分整体模式,它创建了对象组的树形结构, 将对象组成树状结构来表示整体的层次关系 为什么使用组合模式组合模式能够使用户对单个对象和组合对象的访问具有一致性 有时候功能的扩展对象可能是包含关系, 而不是继承关系, 需要使用组合模式 使用组合模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 组织, 大学 学院 部门都继承组织public abstract class Origanization &#123; public Origanization(String name, String info) &#123; this.name = name; this.info = info; &#125; private String name; private String info; public void add(Origanization origanization)&#123; System.out.println(\"添加: \"+origanization.name); &#125; public void remove(Origanization origanization)&#123; System.out.println(\"移除: \"+origanization.name); &#125; public abstract void print(); @Override public String toString() &#123; return \"Origanization&#123;\" + \"name='\" + name + '\\'' + \", info='\" + info + '\\'' + '&#125;'; &#125;&#125;// 大学public class University extends Origanization&#123; // 管理学院 List&lt;Origanization&gt; list=new ArrayList&lt;&gt;(); @Override public void add(Origanization origanization) &#123; list.add(origanization); &#125; @Override public void remove(Origanization origanization) &#123; list.remove(origanization); &#125; public University(String name, String info) &#123; super(name, info); &#125; // 输出包含的学院 @Override public void print() &#123; System.out.println(\"----\"+this+\"----\"); for(Origanization origanization: list)&#123; origanization.print(); &#125; &#125;&#125;// 学院public class College extends Origanization&#123; //管理部门 List&lt;Origanization&gt; list=new ArrayList&lt;&gt;(); @Override public void add(Origanization origanization) &#123; list.add(origanization); &#125; @Override public void remove(Origanization origanization) &#123; list.remove(origanization); &#125; public College(String name, String info) &#123; super(name, info); &#125; @Override public void print() &#123; System.out.println(\"--\"+this+\"--\"); for(Origanization origanization: list)&#123; origanization.print(); &#125; &#125;&#125;// 部门 叶子节点public class Department extends Origanization&#123; public Department(String name, String info) &#123; super(name, info); &#125; @Override public void print() &#123; System.out.println(this); &#125;&#125;// 测试@Testpublic void testComposite()&#123; Origanization university = new University(\"浙江大学\",\"大学\"); Origanization college1 = new College(\"计算机学院\",\"学院\"); Origanization college2 = new College(\"国际学院\",\"学院\"); university.add(college1); university.add(college2); Origanization department1 = new Department(\"信息工程\",\"部门\"); Origanization department2 = new Department(\"软件工程\",\"部门\"); college1.add(department1); college1.add(department2); Origanization department3 = new Department(\"国际英语\",\"部门\"); Origanization department4 = new Department(\"商务英语\",\"部门\"); college2.add(department3); college2.add(department4); university.print();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰者模式","slug":"设计模式/装饰者模式","date":"2019-10-08T07:11:25.000Z","updated":"2020-01-05T02:13:28.028Z","comments":true,"path":"2019/10/08/设计模式/装饰者模式/","link":"","permalink":"https://yimchengjie.github.io/2019/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰者模式属于结构型模式 装饰者模式动态的给一个对象添加一些额外的职责 为什么使用装饰者模式通常使用继承类来扩展功能, 如果功能种类很多, 会造成类爆炸(类的数量很多);不方便管理使用装饰者模式, 可以让用户决定动态的加入扩展功能; 使用装饰者模式装饰者模式有Component(主体), (装饰部分),ConcreteComponent(具体的主体);装饰者和具体的主体都要继承主体;装饰者内维护一个主体,并将主体进行装饰. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 主体 饮品public abstract class Drink &#123; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; private double price = 0.0d; private String info; // 计算饮品价格 public abstract double cost();&#125;// 主体的实现 咖啡public class Coffee extends Drink &#123; public Coffee() &#123; setInfo(\"咖啡\"); setPrice(18d); &#125; @Override public double cost() &#123; return getPrice(); &#125;&#125;// 主体的实现 奶茶public class MilkTea extends Drink &#123; public MilkTea() &#123; setInfo(\"奶茶\"); setPrice(15d); &#125; @Override public double cost() &#123; return getPrice(); &#125;&#125;// 装饰者public class Decorator extends Drink &#123; private Drink drink; @Override public String getInfo() &#123; return super.getInfo()+\" \"+drink.getInfo(); &#125; @Override public double cost() &#123; return super.getPrice()+drink.cost(); &#125; public Decorator(Drink drink)&#123; this.drink=drink; &#125;&#125;// 装饰者的实现 加奶盖public class MilkCap extends Decorator &#123; public MilkCap(Drink drink) &#123; super(drink); setInfo(\"加奶盖\"); setPrice(6d); &#125;&#125;// 装饰者的实现 加芝士public class Cheese extends Decorator &#123; public Cheese(Drink drink) &#123; super(drink); setInfo(\"加芝士\"); setPrice(5d); &#125;&#125;// 测试@Testpublic void testDecorator()&#123; // 点一份咖啡 Drink coffee=new Coffee(); System.out.println(coffee.getInfo()+coffee.cost()); // 加一份奶盖 Drink coffee1=new MilkCap(coffee); System.out.println(coffee1.getInfo()+coffee1.cost()); // 加一份芝士 Drink coffee2=new Cheese(coffee1); System.out.println(coffee2.getInfo()+coffee2.cost()); System.out.println(\"===============================\"); // 点一份奶茶 Drink milkTea=new MilkTea(); System.out.println(milkTea.getInfo()+milkTea.cost()); // 加一份芝士 Drink milkTea1=new Cheese(milkTea); System.out.println(milkTea1.getInfo()+milkTea1.cost()); // 加一份奶盖 Drink milkTea2=new MilkCap(milkTea1); System.out.println(milkTea2.getInfo()+milkTea2.cost());&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"设计模式/桥接模式","date":"2019-09-29T02:23:41.000Z","updated":"2020-01-05T01:23:03.131Z","comments":true,"path":"2019/09/29/设计模式/桥接模式/","link":"","permalink":"https://yimchengjie.github.io/2019/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"桥接模式属于结构型模式 桥接模式将抽象和实现分离开来,各自独立,但能动态的结合; 为什么使用桥接模式桥接模式基于类的最小设计原则, 通过使用封装、聚合及继承，让不同的类承担不同的职责；将事物的抽象和实现分离， 从而保持各部分的独立性功能的扩展性； 使用桥接模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 抽象事物 消息public abstract class AbstractMessage &#123; public AbstractMessage(MessageImplementor messageImplementor) &#123; this.messageImplementor = messageImplementor; &#125; private MessageImplementor messageImplementor; public void sendMessage(String message, String toUser)&#123; this.messageImplementor.send(message,toUser); &#125;&#125;// 抽象的子类, 默认消息public class DefaultMessage extends AbstractMessage &#123; public DefaultMessage(MessageImplementor messageImplementor) &#123; super(messageImplementor); &#125; @Override public void sendMessage(String message, String toUser) &#123; super.sendMessage(message, toUser); &#125;&#125;// 抽象的子类, 加急消息public class UrgencyMessage extends AbstractMessage &#123; @Override public void sendMessage(String message, String toUser) &#123; super.sendMessage(\"加急\"+message, toUser); &#125; public UrgencyMessage(MessageImplementor messageImplementor) &#123; super(messageImplementor); &#125;&#125;// 抽象的子类, 特快消息public class ExpressMessage extends AbstractMessage &#123; public ExpressMessage(MessageImplementor messageImplementor) &#123; super(messageImplementor); &#125; @Override public void sendMessage(String message, String toUser) &#123; super.sendMessage(\"特快\"+message, toUser); &#125;&#125;// 行为接口public interface MessageImplementor &#123; void send(String message,String toUser);&#125;// 行为的实现, 用邮件发public class MessageMail implements MessageImplementor &#123; @Override public void send(String message, String toUser) &#123; System.out.println(\"用邮件给 \"+toUser+\" 发送: \"+message); &#125;&#125;// 行为的实现, 用微信发public class MessageWeChat implements MessageImplementor &#123; @Override public void send(String message, String toUser) &#123; System.out.println(\"用微信给 \"+toUser+\" 发送: \"+message); &#125;&#125;//测试@Testpublic void testBridging()&#123; AbstractMessage message1=new DefaultMessage(new MessageMail()); AbstractMessage message2=new DefaultMessage(new MessageWeChat()); AbstractMessage message3=new UrgencyMessage(new MessageMail()); AbstractMessage message4=new UrgencyMessage(new MessageWeChat()); AbstractMessage message5=new ExpressMessage(new MessageMail()); AbstractMessage message6=new ExpressMessage(new MessageWeChat()); message1.sendMessage(\"在吗\",\"小明\"); message2.sendMessage(\"在吗\",\"小明\"); message3.sendMessage(\"在吗\",\"小明\"); message4.sendMessage(\"在吗\",\"小明\"); message5.sendMessage(\"在吗\",\"小明\"); message6.sendMessage(\"在吗\",\"小明\");&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"设计模式/适配器模式","date":"2019-09-21T04:51:31.000Z","updated":"2020-01-04T09:13:11.365Z","comments":true,"path":"2019/09/21/设计模式/适配器模式/","link":"","permalink":"https://yimchengjie.github.io/2019/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"适配器模式属于结构型模式 适配器模式将两个不兼容的类通过适配器能够做到兼容;用户调用适配器转化后的接口方法, 适配器再调用被适配者的接口方法;用户只要关心适配器暴露的接口方法 为什么使用适配器模式现实中,存在很多的适配器, 比如电源适配器; 让原本不能直接兼容的两个对象, 通过适配器进行兼容 使用适配器模式1234567891011121314151617181920212223242526272829// 被适配者, 比如插座 交流220Vpublic class Adaptee &#123; public int output()&#123; return 220; &#125;&#125;// 适配器 电源适配器 转化成低压直流电public class Adapter &#123; void input(Adaptee adaptee)&#123; System.out.println(\"输入电压: \"+adaptee.output()); &#125; int output()&#123; System.out.println(\"输出电压: \"+5); return 5; &#125;&#125;// 使用者 需要充电的电池public class Battery &#123; public void charging(Adapter adapter)&#123; if (adapter.output()==5)&#123; System.out.println(\"充电\"); &#125;else&#123; System.out.println(\"不适配\"); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"设计模式/建造者模式","date":"2019-09-14T08:34:15.000Z","updated":"2020-01-04T08:04:52.635Z","comments":true,"path":"2019/09/14/设计模式/建造者模式/","link":"","permalink":"https://yimchengjie.github.io/2019/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式属于创建者模式 建造者模式将一个复杂对象的构建和对象分离,实现解耦;比如一辆汽车的创建,需要一整套过程和很多的部件,建造者模式实现了将部件和过程分离 为什么使用建造者模式是为了将创建一个复杂对象的过程与它的属性解耦 使用建造者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 产品public class Product &#123; @Override public String toString() &#123; return \"Product&#123;\" + \"wheel='\" + wheel + '\\'' + \", engine='\" + engine + '\\'' + \", chassis='\" + chassis + '\\'' + '&#125;'; &#125; // 模拟汽车 轮子 发动机 底盘 private String wheel; private String engine; private String chassis; public String getWheel() &#123; return wheel;&#125; public void setWheel(String wheel) &#123;this.wheel = wheel; &#125; public String getEngine() &#123; return engine;&#125; public void setEngine(String engine) &#123; this.engine = engine;&#125; public String getChassis() &#123; return chassis; &#125; public void setChassis(String chassis) &#123; this.chassis = chassis; &#125;&#125;// 抽象建造者public interface Builder &#123; // 创建组件A void buildPartA(); // 创建组件B void buildPartB(); // 创建组件C void buildPartC(); Product getResult();&#125;// 建造者的具体实现public class ConcreteBuilder implements Builder &#123; private Product product; public ConcreteBuilder() &#123; this.product = new Product(); &#125; @Override public void buildPartA() &#123;product.setWheel(new String(\"米其林轮胎\")); &#125; @Override public void buildPartB() &#123;product.setEngine(new String(\"三菱发动机\")); &#125; @Override public void buildPartC() &#123;product.setChassis(new String(\"宝马底盘\")); &#125; @Override public Product getResult() &#123;return product; &#125;&#125;// 指挥者// 客户端直接利用指挥者创建对象, 给指挥者传入一个建造者实例public class Diector &#123; private Builder builder; public void setBuilder(Builder builder) &#123; this.builder = builder; &#125; public Diector(Builder builder)&#123; this.builder=builder; &#125; public Product construct()&#123; builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"设计模式/原型模式","date":"2019-08-27T14:09:01.000Z","updated":"2020-01-04T03:05:48.529Z","comments":true,"path":"2019/08/27/设计模式/原型模式/","link":"","permalink":"https://yimchengjie.github.io/2019/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式属于创建者模式 原型对象负责创建需要用到的对象, 使用者直接拷贝原型,作为创建的对象 注意, 是拷贝, 不是引用; 核心点是object对象的clone方法 为什么要使用原型模式 使用原型模式拷贝对象, 可以获得对象的运行状态, 不会产生一个初始全新对象 拷贝的效率比创建的效率更高 一个对象有多个访问者的时候,可以考虑用原型模式 对于一个创建过程很复杂的类来说, 可以使用原型模式 使用原型模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//原型类// 实现拷贝需要继承Cloneable接口public class Sheep implements Cloneable, Serializable &#123; @Override public String toString() &#123; return \"Sheep&#123;\" + \"name='\" + name + '\\'' + \", master=\" + master + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Master getMaster() &#123; return master; &#125; public void setMaster(Master master) &#123; this.master = master; &#125; private String name; private Master master; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; // 把引用的对象也进行拷贝 // 这种方法要把所有要拷贝的类都继承Cloneable,并且当有多层引用关系时, 代码会很复杂 // 不推荐 public Object deepCloneAbandon() throws CloneNotSupportedException &#123; Sheep clone=(Sheep) super.clone(); clone.master=(Master) this.master.clone(); return clone; &#125; // 用流的方法实现深拷贝, 推荐使用 public Object deepClone() throws CloneNotSupportedException &#123; ByteArrayOutputStream byteArrayOutputStream = null; ObjectOutputStream objectOutputStream = null; ByteArrayInputStream byteArrayInputStream = null; ObjectInputStream objectInputStream = null; try &#123; byteArrayOutputStream = new ByteArrayOutputStream(); objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); objectInputStream = new ObjectInputStream(byteArrayInputStream); return objectInputStream.readObject(); &#125; catch (IOException iOException) &#123; iOException.printStackTrace(); return null; &#125; catch (ClassNotFoundException classNotFoundException) &#123; classNotFoundException.printStackTrace(); return null; &#125; finally &#123; try &#123; byteArrayOutputStream.close(); objectOutputStream.close(); byteArrayInputStream.close(); objectInputStream.close(); &#125; catch (IOException iOException) &#123; iOException.printStackTrace(); &#125; &#125; &#125;&#125;//测试@Testpublic void testPrototype() throws CloneNotSupportedException &#123; Sheep sheep = new Sheep(); sheep.setName(\"喜洋洋\"); sheep.setMaster(new Master(\"村长\")); Sheep copysheep = (Sheep) sheep.clone(); // hashCode不同,说明不是复制引用而是拷贝对象 // 拷贝对象中的属性为引用类型的时候, 拷贝的引用地址 // 所以默认的clone方法是浅拷贝的方法 System.out.println(sheep.hashCode() + \" \" + sheep.toString()); System.out.println(copysheep.hashCode() + \" \" + copysheep.toString()); // 人工再拷贝实现深拷贝 System.out.println(\"人工再拷贝实现深拷贝\"); Sheep deepCopySheepAbandon = (Sheep) sheep.deepCloneAbandon(); System.out.println(deepCopySheepAbandon.hashCode() + \" \" + deepCopySheepAbandon.toString()); // 用流深拷贝 System.out.println(\"用流深拷贝\"); Sheep deepCopySheep = (Sheep) sheep.deepClone(); System.out.println(deepCopySheep.hashCode() + \" \" + deepCopySheep.toString());&#125; Spring中应用bean的scope属性可以指定为prototype原型模式, 每次创建bean时都是clone创建; 注意(缺点)在实现深度克隆时, 代码复杂需要给每个类写克隆方法, 对于已有不支持clone的类,工作量大,而且违背了开闭原则","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"RabbitMQ入门","slug":"消息中间件/RabbitMQ入门","date":"2019-08-25T13:55:17.000Z","updated":"2020-01-24T07:48:12.168Z","comments":true,"path":"2019/08/25/消息中间件/RabbitMQ入门/","link":"","permalink":"https://yimchengjie.github.io/2019/08/25/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E5%85%A5%E9%97%A8/","excerpt":"","text":"RabbitMQ入门RabbitMQ是一个开源的机遇AMQP协议的实现,服务端用Erlang语言编写,支持多种客户端,用于在分布式系统中存储转发消息 AMQP协议RabbitMQ的安装 官网安装rabbitmq,注意需要安装erlang对应的版本 安装完,可以直接启动服务systemctl start rabbitmq-server Web管理平台 开启插件rabbitmq-plugins enable rabbitmq_management 创建新用户,配置权限 rabbitmqctl add_user admin admin 分配操作权限 rabbitmqctl set_user_tags admin administrator 分配资源权限 rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 开启防火墙 java中的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * 简单队列生产者 * 使用RabbitMQ的默认交换器发送消息 */public class Producer &#123; public static void main(String[] args) &#123; // 1、创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); // 2、设置连接属性 factory.setHost(\"192.168.100.242\"); factory.setPort(5672); factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); Connection connection = null; Channel channel = null; try &#123; // 3、从连接工厂获取连接 connection = factory.newConnection(\"生产者\"); // 4、从链接中创建通道 channel = connection.createChannel(); /** * 5、声明（创建）队列 * 如果队列不存在，才会创建 * RabbitMQ 不允许声明两个队列名相同，属性不同的队列，否则会报错 * * queueDeclare参数说明： * @param queue 队列名称 * @param durable 队列是否持久化 * @param exclusive 是否排他，即是否为私有的，如果为true,会对当前队列加锁，其它通道不能访问，并且在连接关闭时会自动删除，不受持久化和自动删除的属性控制 * @param autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除 * @param arguments 队列参数，设置队列的有效期、消息最大长度、队列中所有消息的生命周期等等 */ channel.queueDeclare(\"queue1\", false, false, false, null); // 消息内容 String message = \"Hello World!\"; // 6、发送消息 channel.basicPublish(\"\", \"queue1\", null, message.getBytes()); System.out.println(\"消息已发送！\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; // 7、关闭通道 if (channel != null &amp;&amp; channel.isOpen()) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; &#125; // 8、关闭连接 if (connection != null &amp;&amp; connection.isOpen()) &#123; try &#123; connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;/** * 简单队列消费者 */public class Consumer &#123; public static void main(String[] args) &#123; // 1、创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); // 2、设置连接属性 factory.setHost(\"192.168.100.242\"); factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); Connection connection = null; Channel channel = null; try &#123; // 3、从连接工厂获取连接 connection = factory.newConnection(\"消费者\"); // 4、从链接中创建通道 channel = connection.createChannel(); /** * 5、声明（创建）队列 * 如果队列不存在，才会创建 * RabbitMQ 不允许声明两个队列名相同，属性不同的队列，否则会报错 * * queueDeclare参数说明： * @param queue 队列名称 * @param durable 队列是否持久化 * @param exclusive 是否排他，即是否为私有的，如果为true,会对当前队列加锁，其它通道不能访问， * 并且在连接关闭时会自动删除，不受持久化和自动删除的属性控制。 * 一般在队列和交换器绑定时使用 * @param autoDelete 是否自动删除，当最后一个消费者断开连接之后是否自动删除 * @param arguments 队列参数，设置队列的有效期、消息最大长度、队列中所有消息的生命周期等等 */ channel.queueDeclare(\"queue1\", false, false, false, null); // 6、定义收到消息后的回调 DeliverCallback callback = new DeliverCallback() &#123; public void handle(String consumerTag, Delivery message) throws IOException &#123; System.out.println(\"收到消息：\" + new String(message.getBody(), \"UTF-8\")); &#125; &#125;; // 7、监听队列 channel.basicConsume(\"queue1\", true, callback, new CancelCallback() &#123; public void handle(String consumerTag) throws IOException &#123; &#125; &#125;); System.out.println(\"开始接收消息\"); System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; // 8、关闭通道 if (channel != null &amp;&amp; channel.isOpen()) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; &#125; // 9、关闭连接 if (connection != null &amp;&amp; connection.isOpen()) &#123; try &#123; connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"RabbitMQ入门","slug":"RabbitMQ入门","permalink":"https://yimchengjie.github.io/tags/RabbitMQ%E5%85%A5%E9%97%A8/"}]},{"title":"工厂模式","slug":"设计模式/工厂模式","date":"2019-08-18T12:31:20.000Z","updated":"2020-01-03T07:48:47.734Z","comments":true,"path":"2019/08/18/设计模式/工厂模式/","link":"","permalink":"https://yimchengjie.github.io/2019/08/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂模式属于创建型模式 专门定义一个类来负责创建一个接口的一系列实现类的实例;即负责创建一些列有公共父类或者实现接口的对象 为什么使用工厂模式 使用工厂模式, 将创建实例和使用实例进行分离, 更便于后期的维护和扩展;实现了解耦 工厂模式可以减少重复代码, 创建实例的代码只要重复调用工厂模式中的创建方法就行了 简单工厂模式简单工厂模式又叫静态工厂方法模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//父类public abstract class Animal &#123; private String kindName; public String getKindName() &#123; return kindName; &#125; public void setKindName(String kindName) &#123; this.kindName = kindName; &#125; public void breathe()&#123; System.out.println(\"呼吸中...\"); &#125; public abstract void eat();&#125;//子类dogpublic class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗啃骨头...\"); &#125;&#125;//子类catpublic class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼...\"); &#125;&#125;//工厂类public class AnimalFactory &#123; public static Animal getAnimal(String name)&#123; if (name==\"dog\"||name==\"Dog\")&#123; Animal dog=new Dog(); dog.setKindName(\"dog\"); return dog; &#125;else if (name==\"cat\"||name==\"Cat\") &#123; Animal cat = new Cat(); cat.setKindName(\"dog\"); return cat; &#125;else&#123; System.out.println(\"出错\"); return null; &#125; &#125;&#125; 抽象工厂模式当简单工厂模式要创建的对象非常多, 或者工厂类有它自己的实现类了,代码量也会增多, 不易维护.上述代码的例子下, AnimalFactory有了继承它的DogFactory, CatFactory创建的对象变成ChinaDog ChinaCat EnglishDog EnglishCat..怎么办呢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 使用者public class Zoo &#123; AbstractAnimalFactory abstractAnimalFactory=null; public void setAnimal(String country,String kind)&#123; if (kind==\"dog\")&#123; abstractAnimalFactory=new DogFactoryAbstract(); &#125;else if (kind==\"cat\")&#123; abstractAnimalFactory=new CatFactoryAbstract(); &#125;else&#123; System.out.println(\"工厂错误\"); &#125; abstractAnimalFactory.createAnimal(country); &#125;&#125;// 抽象工厂public abstract class AbstractAnimalFactory &#123; public abstract Animal createAnimal(String name);&#125;// 子类实现工厂public class CatFactoryAbstract extends AbstractAnimalFactory &#123; @Override public Animal createAnimal(String country) &#123; if (country == \"chinese\") &#123; return new ChineseCat(); &#125; else if (country == \"english\") &#123; return new EnglishCat(); &#125; else &#123; System.out.println(\"错误\"); return null; &#125; &#125;&#125;public class DogFactoryAbstract extends AbstractAnimalFactory &#123; @Override public Animal createAnimal(String country) &#123; if (country == \"chinese\") &#123; return new ChineseDog(); &#125; else if (country == \"english\") &#123; return new EnglishDog(); &#125; else &#123; System.out.println(\"错误\"); return null; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"设计模式/单例模式","date":"2019-08-10T10:55:45.000Z","updated":"2020-01-03T04:50:38.264Z","comments":true,"path":"2019/08/10/设计模式/单例模式/","link":"","permalink":"https://yimchengjie.github.io/2019/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式属于创建型模式 单例模式,就是采取一定的方法保证在整个系统中,对于某个类,只存在一个实例对象. 为什么使用单例模式 使用单例模式,对于那些经常使用的实例, 可以减少创建对象的开销 实例化减少,可能减少虚拟机垃圾回收的压力 使用单例模式的几种方法静态方法12345678910111213141516public class Singleton &#123; //静态变量 private static Singleton instance; //私有化构造器, 防止外部进行new private Singleton()&#123;&#125; //synchronized保证线程安全性, 但是会影响效率,存在实例时也要进行同步, 这是不必要的 public static synchronized Singleton getInstance()&#123; if (instance!=null)&#123; return instance; &#125;else&#123; return instance=new Singleton(); &#125; &#125;&#125; 双重检查在静态方法保证线程安全的基础上,提高了系统效率 1234567891011121314151617public class DoubleCheck &#123; // 保证可见性,一但有实例时,所有线程都会知道 private static volatile DoubleCheck instance; private DoubleCheck()&#123;&#125; private static DoubleCheck getInstance()&#123; if (instance==null)&#123; synchronized (DoubleCheck.class)&#123; if (instance==null)&#123; return instance=new DoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类比较推荐的方法 1234567891011121314public class StaticInnerClass &#123; private StaticInnerClass() &#123; &#125; // 类装载时,静态内部类不会被加载, 保证了懒加载 // 静态内部类装载时, JVM提供了线程安全, 保证了线程安全 // 类的静态属性,只在类装载时被加载,保证了单例 private static class StaticInnerClassIntance &#123; private static final StaticInnerClass INTANCE = new StaticInnerClass(); &#125; public static StaticInnerClass getInstance() &#123; return StaticInnerClassIntance.INTANCE; &#125;&#125; 枚举方法1234567public enum EnumSingleton &#123; INSTACNE; public static EnumSingleton getIntance()&#123; return INSTACNE; &#125;&#125; 枚举方法是最好的一种,也是官方推荐的一种, 它完美的解决了懒加载, 线程安全, 单例等问题 而且他不会被反射影响, 上面几种方法都可以通过反射的方式, 破坏单例, 而枚举类型是无法通过反射创建实例的","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"6大设计原则","slug":"设计模式/6大设计原则","date":"2019-08-10T04:45:11.000Z","updated":"2020-01-05T01:26:14.409Z","comments":true,"path":"2019/08/10/设计模式/6大设计原则/","link":"","permalink":"https://yimchengjie.github.io/2019/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"6大设计原则1. 单一职责原则SRP(Single Responsiblity Principle) 核心定义:一个接口或者一个类或者一个方法,只负责一件事; 就像流水线生产,分工合作, 每个人只负责一件事情, 一个人不能负责太多事情, 否则效率低下,而且可能会出问题 在java程序中, 特别要注意接口的设计, 要遵循单一职责原则, 定义所有实现类通用的职责, 不能把实现类特有的职责放在接口上,否则所有实现类都会受到影响; 但要注意, 要根据业务合理划分责任, 过于细分,会导致类的数量非常庞大, 而且需要相互的耦合, 造成不必要的负责度 2. 里式替换原则LSP(Liskov Substitution Principle) 核心定义:子类应该是可以替换父类,并且在所有使用父类的地方都能够换成子类; 在java中,子类必须完全实现父类的方法;父类出现的地方换成子类,程序依然能正常运行;子类可以在父类基础上增加新的行为. 3. 依赖倒置原则DIP(Dependence Inversion Principle) 核心定义:就是面向接口(或抽象类)编程,各个模块之间不能直接进行依赖, 要通过接口的方式,使各个模块相互独立 在java中,每个类都尽量继承一个接口;依赖的变量尽量使用接口而不是实现类(比如service依赖dao层,在service接口定义中,只是用dao接口而不是dao实现类);如果基类是抽象类或类,且实现了一些方法,那么尽量不要覆写基类的方法; 4. 接口隔离原则ISP(Interface Segregation Principle) 核心定义:接口的方法要少,类之间的关系要建立在最小接口上;这个单一职责要区分开, 单一职责讲的是类的业务功能单一 在java中体现为接口的拆分,接口方法尽量定义的少,不要定义没意义的接口 5. 开放封闭原则OCP(Open Close Principle) 核心定义:一个模块的扩展性方面应该是开放的, 而在更改性方面应该是封闭的 一个网络模块, 原来只有服务端功能,现在要加入客户端功能,那么在不需要修改服务端代码的前提下, 就能扩展客户端, 这样就是前后端分离,在设计之初, 将服务端和客户端分开 6. 迪米特法则LOD(Law Of Demter) 核心定义:一个类应该对自己需要耦合或者调用的类保持最少的了解,也就是低耦合,高内聚 类与类之间不能有过多的耦合,在系统设计时,不要让一个类依赖太多其他的类, 尽量减少依赖关系 设计模式概览1. 创建型模式用于描述”怎样创建对象”,它的主要特点是”将对象的创建与使用分离” 有单例,原型,工厂方法,抽象工厂,建造者 5种创造型模式 2. 结构型模式用于描述”如何将对象按某种布局组成更大的结构” 有代理,适配器,桥接,装饰者,外观,享元,组合 7种结构型模式 3. 行为型模式用于描述”类或对象之间怎么相互协作共同完成单个对象无法单独完成的任务,以及怎么样分配职责” 有模板方法,策略,命令,责任链,状态,观察者,中介者,迭代器,访问者,备忘录,解释器 11种行为型模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ActiveMQ支持的协议","slug":"消息中间件/ActiveMQ支持的协议","date":"2019-07-30T11:40:31.000Z","updated":"2019-12-31T09:13:13.890Z","comments":true,"path":"2019/07/30/消息中间件/ActiveMQ支持的协议/","link":"","permalink":"https://yimchengjie.github.io/2019/07/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E6%94%AF%E6%8C%81%E7%9A%84%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"ActiveMQ支持的协议ActiveMQ支持多种协议传输和传输方式,允许客户端使用多种协议连接. ActiveMQ支持的协议: AUTO、OpenWire、AMQP、Stomp、MQTT等在${ACTIVE_HOME}/conf/activemq.xml中, 通过配置&lt;transportConnectors&gt;就可以使用多种传输方式(==注意配置文件中可能会用到转义字符串, 比如&amp;要用&amp;来表示==) ActiveMQ支持的基础传输方式有: VM、TCP、SSL、UDP、Peer、Multicast、HTTP(S)等 由于TCP的稳定性, 它也是ActiveMQ中最常用的一种传输方式. 在默认的设置中, TCP连接的端口为61616 OpenWire协议OpenWire协议是Apache的一种跨语言的协议,允许从不同的语言和平台访问ActiveMQ默认就是使用这种协议, 功能很全面 OpenWire支持TCP、SSL、NIO、UDP、VM等传输方式，但URL只配置传输方式时，默认就是使用OpenWire协议 MQTT协议全称Message Queuing Telemetry Transport，即消息队列遥测传输，由IBM开发， 已成为物联网通信的标准 它结构简单，相比其他的协议更加轻量级 发布-订阅模型MQTT协议使用发布-订阅模型提供者发布消息到主题topic上, 只要订阅了这个topic的消费者,都能收到这条消息 消费者无法收到启动前topic上的消息 MQTT中的服务质量(QoS)服务质量(QoS)级别 是一种关于发送者和接受者之间信息传递的保证协议 MQTT支持三种QoS至多一次(0)客户端只发布一次消息到服务器至少一次(1)客户端发送消息,直到服务器返回成功只有一次(2)在(1)的前提下, 客户端继续发送, 客户端查看是否存在, 有就删除 QoS是的在不可靠的网络下进行通信变得更加简单,因为即使是在非常不可靠的网络下,协议也可以掌控是否需要重发消息, 并保证消息到达 ActiveMQ中使用MQTT协议123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//发布者public class MqttProducer &#123; private static int qos = 1; private static String broker = \"tcp://activemq.tony.com:1883\"; private static String userName = \"admin\"; private static String passWord = \"admin\"; private static MqttClient connect(String clientId, String userName,String password) throws MqttException &#123; MemoryPersistence persistence = new MemoryPersistence(); MqttConnectOptions connOpts = new MqttConnectOptions(); connOpts.setCleanSession(true); connOpts.setUserName(userName); connOpts.setPassword(password.toCharArray()); connOpts.setConnectionTimeout(10); connOpts.setKeepAliveInterval(20); // connOpts.setServerURIs(uris); //这个是mqtt客户端实现的负载均衡和容错 // String[] uris = &#123;\"tcp://10.100.124.206:1883\",\"tcp://10.100.124.207:1883\"&#125;; MqttClient mqttClient = new MqttClient(broker, clientId, persistence); mqttClient.setCallback(new PushCallback(\"test\")); mqttClient.connect(connOpts); return mqttClient; &#125; private static void pub(MqttClient sampleClient, String msg, String topic) throws Exception &#123; MqttMessage message = new MqttMessage(msg.getBytes()); message.setQos(qos); message.setRetained(false); sampleClient.publish(topic, message); &#125; private static void publish(String str, String clientId, String topic) throws Exception &#123; MqttClient mqttClient = connect(clientId, userName, passWord); if (mqttClient != null) &#123; pub(mqttClient, str, topic); System.out.println(\"pub--&gt;\" + str); &#125; if (mqttClient != null) &#123; mqttClient.disconnect(); &#125; &#125; public static void main(String[] args) throws Exception &#123; publish(\"message content\", \"producer-client-id-0\", \"x/y/z\"); &#125;&#125;class PushCallback implements MqttCallback &#123; private String threadId; public PushCallback(String threadId) &#123; this.threadId = threadId; &#125; public void connectionLost(Throwable cause) &#123; cause.printStackTrace(); &#125; public void deliveryComplete(IMqttDeliveryToken token) &#123; System.out.println(\"服务器是否正确接收---------\" + token.isComplete()); &#125; public void messageArrived(String topic, MqttMessage message) throws Exception &#123; String msg = new String(message.getPayload()); System.out.println(threadId + \" \" + msg); &#125;&#125;//消费者public class MqttConsumer &#123; private static int qos = 2; private static String broker = \"tcp://activemq.tony.com:1883\"; private static String userName = \"admin\"; private static String passWord = \"admin\"; private static MqttClient connect(String clientId) throws MqttException &#123; MemoryPersistence persistence = new MemoryPersistence(); MqttConnectOptions connOpts = new MqttConnectOptions(); connOpts.setCleanSession(false); connOpts.setUserName(userName); connOpts.setPassword(passWord.toCharArray()); connOpts.setConnectionTimeout(10); connOpts.setKeepAliveInterval(20); MqttClient mqttClient = new MqttClient(broker, clientId, persistence); mqttClient.connect(connOpts); return mqttClient; &#125; public static void sub(MqttClient mqttClient, String topic) throws MqttException &#123; int[] Qos = &#123;qos&#125;; String[] topics = &#123;topic&#125;; mqttClient.subscribe(topics, Qos, new IMqttMessageListener[]&#123;(s, mqttMessage) -&gt; &#123; System.out.println(\"收到新消息\" + s + \" &gt; \" + mqttMessage.toString()); &#125;&#125;); &#125; private static void runsub(String clientId, String topic) throws MqttException &#123; MqttClient mqttClient = connect(clientId); if (mqttClient != null) &#123; sub(mqttClient, topic); &#125; &#125; public static void main(String[] args) throws MqttException &#123; runsub(\"consumer-client-id-1\", \"x/y/z\"); &#125;&#125; AUTO协议AUTO自动检测协议,可以自动检测ActiveMQ支持的所有协议, 允许使用各种协议的客户端,使用同一个传输 Stomp协议可以使用webSocket传输协议","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://yimchengjie.github.io/tags/ActiveMQ/"}]},{"title":"深入理解SpringAOP","slug":"Java开发框架/深入理解SpringAOP","date":"2019-07-21T13:30:45.000Z","updated":"2020-02-21T10:55:40.632Z","comments":true,"path":"2019/07/21/Java开发框架/深入理解SpringAOP/","link":"","permalink":"https://yimchengjie.github.io/2019/07/21/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringAOP/","excerpt":"","text":"深入理解 SpringAOPAOP 是指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式 SpringAOP 的底层其实就是动态代理 Spring 是如何使用动态代理的 将业务组件和切面组件添加到容器中, 创建对象的时候, 根据切入点表达式拦截的类, 加入通知,生成代理对象. 如果目标对象有实现接口就用 JDK 代理, 反之就用 CGLIB 代理. SpringAOP 注解驱动原理IoC容器启动中,创建了哪些和AOP有关的组件? 这些组件什么时候工作? 工作内容是什么? 1. 实现入口@EnableAspectJAutoProxy主要工作: @Import(AspectJAutoProxyRegistrar.class)给容器导入 AspectJAutoProxyRegistrar 组件(切面自动代理注册器) 利用 AspectJAutoProxyRegistrar 给容器中注册一个切面相关的 beanAnnotationAwareAspectJAutoProxyCreator(支持注解的 AspectJ 自动代理创建器) 1234567891011121314/* *代码跟进演示 *///出发点@EnableAspectJAutoProxy//跟进@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)//点进AspectJAutoProxyRegistrarAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);//点进registerAspectJAnnotationAutoProxyCreatorIfNecessary方法return registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)null);//点进registerAspectJAnnotationAutoProxyCreatorIfNecessaryreturn registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);//点进AnnotationAwareAspectJAutoProxyCreator 2. AnnotationAwareAspectJAutoProxyCreator 创建过程 主要关注的是它继承了BeanFactoryAware和BeanPostProcessor接口, 所以它的创建是在BeanFactory进行初始化,注册BeanPostProcessor阶段(也就是BeanFactoryPostProcessor注册完成之后) registerBeanPostProcessors(beanFactory);注册 BeanPostProcessor 来处理拦截 bean 的创建(在bean创建前后执行)； 先获取 IOC 容器已经定义的需要创建对象的所有 BeanPostProcessor 注册 BeanPostProcessor,实际上就是创建 BeanPostProcessor 对象，保存在容器中；创建 internalAutoProxyCreator 的 BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 创建 Bean 的实例 populateBean；给 bean 的各种属性赋值 initializeBean invokeAwareMethods()：处理 Aware 接口的方法回调 applyBeanPostProcessorsBeforeInitialization();应用后置处理器的 postProcessBeforeInitialization(); invokeInitMethods()；执行自定义的初始化方法 applyBeanPostProcessorsAfterInitialization()；执行后置处理器的 postProcessAfterInitialization(); BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–》aspectJAdvisorsBuilder 把 BeanPostProcessor 注册到 BeanFactory 中；beanFactory.addBeanPostProcessor(postProcessor); 3. 起作用阶段BeanPostProcessor是在bean实例化前后起作用的, 所以它的执行是在beanFactroy对bean实例化的阶段进行 finishBeanFactoryInitialization(beanFactory);实例化所有单例 bean 遍历所有Bean,依次创建对象,使用getBean(beanName);方法 创建bean 先看看容器中是否存在bean,如果存在直接使用,没有再创建 创建bean; resolveBeforeInstantiation解析,如果能返回一个代理对象则直接用,不能继续 createBean 拿到所有BeanPostProcessor并执行postProcessBeforeInstantiation doCreateBean真正的创建bean 创建完,执行 4. AnnotationAwareAspectJAutoProxyCreator的作用postProcessBeforeInstantiation每一个bean创建之前,调用postProcessBeforeInstantiation 前提: 容器加载了@AspectJ注解的类,并加载了信息,再匹配切入点表达式与哪些类、方法匹配 判断当前的bean是否在advisedBeans中(里面保存了所有需要增强的bean) 判断当前bean是否Advice、Pointcut、Advisor、AopInfrastructureBean、被@Aspect注解的类型 或者是设置了跳过自动代理 是否配置了跳过通知 postProcessAfterInitialization前提：bean实例化完成 获取bean的所有通知器 找到当前bean所匹配的通知器 对通知器进行优先级排序 将通知器存入adviseBeans 如果当前的bean需要注入切面,创建bean的代理对象(jdk代理或者cglib代理) 向容器返回增强后的代理对象 代理对象如何工作容器中保存了基础组件的代理对象 拦截器拦截目标方法的执行 根据ProxyFactory对象获取将要执行的目标方法的增强器链 以任务栏的形式执行通知和目标方法 总结 @EnableAspectJAutoProxy 开启AOP功能会在容器启动阶段注册一个组件 AnnotationAwareAspectJAutoProxyCreator 容器开始创建 容器注册后置处理器;AnnotationAwareAspectJAutoProxyCreator 继承了后置处理器接口. 被创建并注册进容器 容器开始创建bean; 创建业务逻辑bean;和切面bean AnnotationAwareAspectJAutoProxyCreator拦截组件创建,如果有已代理对象,直接返回 组件创建 AnnotationAwareAspectJAutoProxyCreator执行postProcessBeforeInstantiation,给需要增强bean创建代理对象获取目标对象以及advisor(增强器,切面的通知方法) 创建代理 执行目标方法 CglibAopProxy.intercept();拦截 执行通知任务链和目标方法","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringIoC详解","slug":"Java开发框架/SpringIoC详解","date":"2019-07-10T08:30:45.000Z","updated":"2020-02-21T10:56:26.020Z","comments":true,"path":"2019/07/10/Java开发框架/SpringIoC详解/","link":"","permalink":"https://yimchengjie.github.io/2019/07/10/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/SpringIoC%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"SpringIoC详解容器对于SpringIoC来说,最重要的就是容器了,容器管理这所有的Bean,控制这Bean的依赖注入 BeanFactory早期基础容器, 可以理解成一个HashMap,key是BeanName,value是Bean实例. ApplicationContext应用上下午,高级容器,相比BeanFactory功能全面很多 BeanDefinitionBean对象在Spring中是以BeanDefinition来描述的 Bean的解析主要就是对配置文件或者配置类的解析 SpringIoC注解驱动初始化过程SpringIoC的初始化过程也是ApplicationContext容器的初始化过程 入口:AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); 调用AnnotationConfigApplicationContext构造函数 12345678public AnnotationConfigApplicationContext(Class... annotatedClasses) &#123; // 1. 先执行父类构造方法,再执行本类无参构造方法 this(); // 2. 注册带注解的类 this.register(annotatedClasses); // 3. 更新容器 this.refresh();&#125; this(); 默认先调用父类无参构造函数,构建初始对象DefaultListableBeanFactory,最基础的BeanFactory 12345public GenericApplicationContext() &#123; this.customClassLoader = false; this.refreshed = new AtomicBoolean(); this.beanFactory = new DefaultListableBeanFactory(); &#125; 再调用当前类this();创建读取器和扫描器 123456public AnnotationConfigApplicationContext() &#123; //BeanDefinition解析器; 用来解析带注解的bean this.reader = new AnnotatedBeanDefinitionReader(this); //ClassPath下的BeanDefinition的扫描器(用来扫描类) this.scanner = new ClassPathBeanDefinitionScanner(this); &#125; 创建注解模式下的BeanDefinition解析器AnnotatedBeanDefinitionReader 123456789101112public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) &#123; // BeanName产生器 this.beanNameGenerator = new AnnotationBeanNameGenerator(); // 作用域元数据解析器 this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(); Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); Assert.notNull(environment, \"Environment must not be null\"); this.registry = registry; // @Conditionl条件表达式鉴别器 this.conditionEvaluator = new ConditionEvaluator(registry, environment, (ResourceLoader)null); AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; 跟进AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source) &#123; DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) &#123; if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123; beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); &#125; if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123; beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); &#125; &#125; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet(4); RootBeanDefinition def; if (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\")) &#123; // 注册主配置类的后置处理器 def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalConfigurationAnnotationProcessor\")); &#125; if (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\")) &#123; // 注册处理@Autowired注解的后置处理器 def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalAutowiredAnnotationProcessor\")); &#125; if (!registry.containsBeanDefinition(\"org.springframework.context.annotation.internalRequiredAnnotationProcessor\")) &#123; // 注册处理@Required注解的后置处理器 def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalRequiredAnnotationProcessor\")); &#125; if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(\"org.springframework.context.annotation.internalCommonAnnotationProcessor\")) &#123; // 注册处理JSR规范注解的后置处理器 def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalCommonAnnotationProcessor\")); &#125; //注册处理jpa的后置处理器 if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(\"org.springframework.context.annotation.internalPersistenceAnnotationProcessor\")) &#123; def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(\"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\", AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException var6) &#123; throw new IllegalStateException(\"Cannot load optional framework class: org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\", var6); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.annotation.internalPersistenceAnnotationProcessor\")); &#125; //注册处理事件监听方法的处理器 if (!registry.containsBeanDefinition(\"org.springframework.context.event.internalEventListenerProcessor\")) &#123; def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.event.internalEventListenerProcessor\")); &#125; //注册事件监听工厂 if (!registry.containsBeanDefinition(\"org.springframework.context.event.internalEventListenerFactory\")) &#123; def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, \"org.springframework.context.event.internalEventListenerFactory\")); &#125; //完成spring自身的后置处理器注册 //到这一步, BeanDefinitionMap中已经保存了一些spring自带的后置处理器的定义信息了 return beanDefs; &#125; 创建ClassPath下的BeanDefinition的扫描器ClassPathBeanDefinitionScanner 1234567891011121314151617public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) &#123; this.beanDefinitionDefaults = new BeanDefinitionDefaults(); this.beanNameGenerator = new AnnotationBeanNameGenerator(); this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(); this.includeAnnotationConfig = true; Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); //设置加载BeanDefinition的注册器 this.registry = registry; //是否使用默认的过滤规则 if (useDefaultFilters) &#123; this.registerDefaultFilters(); &#125; //设置环境 this.setEnvironment(environment); //设置资源加载器 this.setResourceLoader(resourceLoader); &#125; 跟进this.registerDefaultFilters(); 123456789101112131415161718protected void registerDefaultFilters() &#123; // 向includeFilters中添加所有@Component注解的类(其他的一些Bean注解也都有@Component) this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try &#123; this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(\"javax.annotation.ManagedBean\", cl), false)); this.logger.debug(\"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning\"); &#125; catch (ClassNotFoundException var4) &#123; &#125; try &#123; this.includeFilters.add(new AnnotationTypeFil ter(ClassUtils.forName(\"javax.inject.Named\", cl), false)); this.logger.debug(\"JSR-330 'javax.inject.Named' annotation found and supported for component scanning\"); &#125; catch (ClassNotFoundException var3) &#123; &#125; &#125; 注册Bean配置类register(annotatedClasses) 123456789101112131415161718192021222324252627282930313233343536373839public void registerBean(Class&lt;?&gt; annotatedClass, String name, Class... qualifiers) &#123; // 将Bean配置信息转换成AnnotatedGenericBeanDefinition 注解通用BeanDefinition AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass); // 判断@Conditionl条件是否有跳过注册的 if (!this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123; // 解析@Scope作用域, 没有则默认Singleton ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd); // 将作用域信息添加到BeanDefinition abd.setScope(scopeMetadata.getScopeName()); // 设置beanName String beanName = name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry); AnnotationConfigUtils.processCommonDefinitionAnnotations(abd); // 解析@Qualifier if (qualifiers != null) &#123; Class[] var7 = qualifiers; int var8 = qualifiers.length; for(int var9 = 0; var9 &lt; var8; ++var9) &#123; Class&lt;? extends Annotation&gt; qualifier = var7[var9]; // 如果有@Primary注解,向BeanDefinition中写入首选bean if (Primary.class == qualifier) &#123; abd.setPrimary(true); // 如果有@Lazy注解, 设置懒加载 &#125; else if (Lazy.class == qualifier) &#123; abd.setLazyInit(true); &#125; else &#123; abd.addQualifier(new AutowireCandidateQualifier(qualifier)); &#125; &#125; &#125; // 封装一个BeanName和BeanDefinition之间的映射关系 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); // 创建代理对象 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); // 按BeanName将BeanDefinition注册到容器中 BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; refresh(); IoC容器启动的核心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public void refresh() throws BeansException, IllegalStateException &#123; synchronized(this.startupShutdownMonitor) &#123; // 1. 刷新上下文之前的准备工作 this.prepareRefresh(); // 2. 获取初始化BeanFactory ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); // 3. 对BeanFactory进行属性填充 this.prepareBeanFactory(beanFactory); try &#123; // 4. 模板方法，注册自己添加的BeanPostFactoryProcessor this.postProcessBeanFactory(beanFactory); // 5. 执行BeanFactory后置处理器 this.invokeBeanFactoryPostProcessors(beanFactory); // 6. 注册Bean后置注册器 this.registerBeanPostProcessors(beanFactory); // 7. 初始化国际化资源处理器 this.initMessageSource(); // 8. 初始化应用事件多播器 this.initApplicationEventMulticaster(); // 9. 模板方法，调用某些特殊的bean的初始化，springboot中在这个地方启动tomcat this.onRefresh(); // 10. 注册监听器到多播器上 this.registerListeners(); // 11. 实例化所有非懒加载的单例Bean this.finishBeanFactoryInitialization(beanFactory); // 12. 初始化容器生命周期事件处理器，并发布容器的生命周期事件 this.finishRefresh(); &#125; catch (BeansException var9) &#123; if (this.logger.isWarnEnabled()) &#123; this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9); &#125; this.destroyBeans(); this.cancelRefresh(var9); throw var9; &#125; finally &#123; this.resetCommonCaches(); &#125; &#125; &#125;/** 对代码进行进一步跟进,看看每一步中都做了什么*//* 1. prepareRefresh() 1. this.startupDate = System.currentTimeMillis();设置启动时间 2. initPropertySources();自定义属性设置 3. getEnvironment().validateRequiredProperties();检验属性的合法性 4. earlyApplicationEvents = new LinkedHashSet();创建早期应用事件集合 2. beanFactory = this.obtainFreshBeanFactory(); 1. this.beanFactory.setSerializationId(this.getId());设置BeanFactoryID 3. prepareBeanFactory(beanFactory); 1. addBeanPostProcessor(new ApplicationContextAwareProcessor(this));添加一个ApplicationContextAwareProcessor 2. ignoreDependencyInterface(XXX.class); 设置忽略注入的接口实现类 3. registerResolvableDependency(XXX.class,beanFactory); 注册可解析的注入的组件 4. 添加编译时的AOP组件 5. 注册环境组件,系统属性组件,系统环境组件 4. postProcessBeanFactory(beanFactory); 1. 子类重写这个方法,在BeanFactory准备完成创建之前做最后的步骤 5. invokeBeanFactoryPostProcessors(beanFactory); 1. 执行BeanDefinitionRegistryPostProcessor 1. 获取所有BeanDefinitionRegistryPostProcessor 2. 先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor 3. 再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor 4. 最后执行其他的BeanDefinitionRegistryPostProcessor 2. 执行BeanFactoryPostProcessor 1. 获取所有BeanFactoryPostProcessor 2. 先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor 3. 再执行实现了Ordered顺序接口的BeanFactoryPostProcessor 4. 最后执行其他的BeanFactoryPostProcessor 6. registerBeanPostProcessors(beanFactory); 1. 获取所有的BeanPostProcessor 2. 先BeanPostProcessor 3. 注册MergedBeanDefinitionPostProcessor 4. 最后创建一个ApplicationListenerDetector;检查是ApplicationListener的bean 7. initMessageSource(); 1. 获取BeanFactory 2. 判断容器中是否有MessageSource的组件 3. 如果有则取用, 没有则创建DelegatingMessageSource 4. 将国际化组件祖册到容器 8. initApplicationEventMulticaster(); 1. 获取BeanFactory 2. 判断容器是否有ApplicationEventMulticaster 3. 如果有取用, 没有则创建SimpleApplicationEventMulticaster 4. 将ApplicationEventMulticaster组件添加到BeanFactory 9. onRefresh(); 1. 留给子类,子类重写这个方法, 在容器刷新时可以自定义一些逻辑 10. registerListeners(); 1. 获取容器中的ApplicationListener 2. 将所有ApplicationListener添加到ApplicationEventMulticaster 3. 派发早期事件earlyApplicationEvents 11. finishBeanFactoryInitialization(beanFactory); 1. preInstantiateSingletons;初始化剩下的所有单实例Bean 1. 获取容器中的单例beanName 2. 如果beanName对应的bean不是抽象不是懒加载不是多实例的 3. getBean(beanName); 4. doGetBean(beanName); 5. 标记要创建bean了,保证线程安全 6. getMergedLocalBeanDefinition(beanName);获得BeanDefinition 7. getDependsOn();获取依赖 8. 递归getBean;创建所依赖Bean 9. 将获取的依赖bean注册到denpendsOn集合 10. createBean(beanName, ex1, args);创建bean 11. doCreateBean(beanName, mbdToUse, args); 1. createBeanInstance(beanName, mbd, args); 2. 调用前置处理器 3. 属性赋值 4. 执行初始化 5. 执行后置处理器 6. 注册bean销毁方法 7. 添加到单例bean集合 12. finishRefresh(); 1. 初始化生命周期有关后置处理器 2. 执行容器刷新完成事件 3. 将ApplicationContext注册到视图中*/ 总结大致流程 Spring容器在启动时,会先加载有关Bean定义信息的配置文件或者配置类(xml注册bean/注解注册bean) BeanDefinitionReader将配置文件或者配置类解析成BeanDefinition,并存入容器中BeanDefinitionRegistry Spring容器扫描BeanDefinitionRegistry中的所有BeanDefinition,使用BeanFactoryPostProcessor对它们进行加工, 主要是依赖处理和属性赋值 实例化Bean时,封装Bean然后完成对Bean的属性设置工作 利用Bean后置处理器,对完成的Bean进行加工 重要组件 Resourcexml、properties资源文件的抽象 ResourceLoader资源的加载, 解析xml、properties返回Resource BeanDefinition保存了从配置文件中读取到的bean的各种信息,一个bean对应一个BeanDefinition有beanClass、scope、lazyInit等属性 BeanDefinitionReader定义读取组件，从Resource资源中读取出BeanDefinition BeanDefinitionRegistryBeanFactory的实现类需要实现这个接口，所以所有BeanFactory都有注册BeanDefinition的功能其内部维护了一个Map，可以将BeanDefinition和beanName的对应关系添加进去 Enviroment环境，保存了程序运行的环境参数（JDK版本，jre等等） BeanFactoryPostProcessor接口BeanFactory后置处理器, 扩展切口, 允许它的实现类在容器初始化前后进行相应操作典型的有PropertyPlaceholderConfigurer,占位符配置处理器 Aware接口对于实现了XXXXAware的bean,spring会注入相应的XXXX, 通过重写setXXXX的方法 BeanPostProcessor接口允许实现它的bean,在实例化前后做相应操作,在最前最后位置 InitializingBean接口允许实现它的bean,在实例化前后做相应操作, 在处理器before之后和after之前 DisposableBean接口允许实现它的bean,在摧毁前后做相应操作 FactoryBean接口允许实现它的bean,在beanFactory.getBean()获取该bean时, 会调用这个bean中重写的方法getObject,而不是直接返回该bean工厂模式的体现","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"代理模式","slug":"设计模式/代理模式","date":"2019-07-02T11:35:45.000Z","updated":"2020-01-03T04:51:06.771Z","comments":true,"path":"2019/07/02/设计模式/代理模式/","link":"","permalink":"https://yimchengjie.github.io/2019/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式(Proxy)属于结构型模式 Proxy-代理模式是指为其他对象提供一种代理,来控制对这个对象的访问 即对A对象进行代理后, 本来A对象的功能交给代理B来做; 代理就是原实例前后添加一层处理. 为什么使用代理模式 授权机制: 不同级别的用户对于同一对象的访问权限是不同的, 要用代理实现对不同用户的访问权限的控制 某个客户端不能直接操作一个对象, 但又要和那个对象互动, 也要通过代理实现间接互动 代理类为委托类预处理消息,过滤消息,把消息传递给委托类, 以及事后对返回结果的处理等. 3种代理模式1. 静态代理实现步骤 12345678910111213141516171819202122232425262728293031323334353637// 第一步:创建服务类接口public interface UserService&#123; void login();&#125;// 第二步:实现服务接口public class UserServiceImpl implements UserService&#123; @Override public void login()&#123; System.out.println(\"登录\"); &#125;&#125;// 第三步:创建代理类public class UserServiceProxy implements UserService&#123; private UserService userService; public UserService(final UserService userService)&#123; this.userService=userService; &#125; @Override public void login()&#123; System.out.println(\"准备登录\"); userService.login(); System.out.println(\"登录完成\"); &#125;&#125;// 第四步:测试运行public class ProxyTest&#123; public static void main(String[] args)&#123; UserService userService=new UserServiceImpl(); UserServiceProxy userServiceProxy=new UserServiceProxy(userService); userServiceProxy.login(); &#125;&#125; 静态代理可以做到符合开闭原则的对目标对象进行功能扩展, 但是工作量大, 要给每个对象创建代理类, 而且不易管理, 接口发生改变, 代理类也要改变 2. JDK动态代理动态代理中, 不需要手动创建代理类了, 只要编写一个动态处理器就OK了 实现步骤 12345678910111213141516171819202122232425// 第一步:编写动态代理public class DynamicProxyHandler implements InvocationHandler&#123; private Object object; public DynamicProxyHandler(final Object object)&#123; this.object=object; &#125; @Override public Object invoke(Object proxy,Method method,Object[] agrs)throws Throwable&#123; System.out.println(\"准备\"); Object result=method.invoke(Object,args); System.out.println(\"完成\"); return result; &#125;&#125;// 第二步:编写测试类public class DynamicProxyTest&#123; public static void main(String[] args)&#123; UserService userService=new UserServiceImpl(); UserService userServiceProxy=(UserService)Proxy.newProxyInstnce(UserService.class.getClassLoader(),new Class[]&#123;UserService.class&#125;,new DynamicProxyHandler(userService)); userServiceProxy.login(); &#125;&#125; 3. CGLIB代理JDK实现动态代理需要实现类通过接口定义业务的方法, 对于没有接口的类就不能实现代理.这就需要CGLIB了 实现步骤 123456789101112131415161718192021222324252627282930// 第一步:创建CGLIB代理类public class CglibProxy implements MethodInterceptor&#123; private Object target; public Object getInstance(final Object target)&#123; this.target=target; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(This.target.getClass()); enhancer.setCallback(this); return enhancer.create(); &#125; public Object intercept(Object object, Method method, Object[] args,MeyhodProxy methodProxy)throws Throwable&#123; System.out.println(\"准备\"); Object result=method.invoke(object,args); System.out.println(\"结束\"); return result &#125;&#125;// 第二步:创建测试类public class CglibDynamicProxyTest&#123; public static void main(String[] args)&#123; UserService userService=new UserServiceImpl(); CglibProxy cglibProxy=new CglibProxy(); UserService userServiceProxy=(UserService)cglibProxy.getInstance(userService1;) userServiceProxy.login(); &#125;&#125; CGLIB代理比JDK代理的性能更高,但是CGLIB比JDK创建代理的耗时要更高,所以单例对象CGLIB更合适, 反之JDK更合适.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://yimchengjie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"ActiveMQ入门","slug":"消息中间件/ActiveMQ入门","date":"2019-06-30T14:10:45.000Z","updated":"2020-02-26T14:57:03.430Z","comments":true,"path":"2019/06/30/消息中间件/ActiveMQ入门/","link":"","permalink":"https://yimchengjie.github.io/2019/06/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ%E5%85%A5%E9%97%A8/","excerpt":"","text":"ActiveMQ入门ActiveMQ是Apache出品, 是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现尽管JMS已经出台很久, 但在J2EE中仍然扮演者重要角色 ActiveMQ特性 支持多种编程语言 支持多种传输协议 支持多种持久化方式(文件系统/数据库) ActiveMQ的安装 从官网下载ActiveMQ 利用Xftp将文件传到服务器 解压到/var目录下 修改文件名为activemq ActiveMQ启动在activemq文件下使用命令./bin/activemq start 后台启动ActiveMQ 但最好是将ActiveMQ作为一个服务来启动,这样可以使activemq在系统启动时自动启动 创建ActiveMQ服务 使用vim创建一个服务文件vi /usr/lib/systemd/system/activemq.service 输入内容 123456789101112131415161718[Unit]Description=ActiveMQ serviceAfter=network.target[Service]Type=forkingExecStart=/var/activemq/bin/activemq startExecStop=/var/activemq/bin/activemq stopUser=rootGroup=rootRestart=alwaysRestartSec=9StandardOutput=syslogStandardError=syslogSyslogIdentifier=activemq[Install]WantedBy=multi-user.target 修改/var/activemq/bin/env文件 将JAVA_HOME的注释删除,然后填入系统jdk的安装路径 启动ActiveMQ服务 使用systemctl start activemq来启动服务 查看服务状态 使用命令systemctl status activemq 设置开机自动启动 ln -s /usr/lib/systemd/system/activemq.service/etc/systemd/system/multi-user.target.wants/activemq.service systemctl enable activemq 在防火墙添加ActiveMQ的Web管理端口和通讯端口 1234#Web管理端口默认为8161,通讯端口默认为61616ufw allow 8161ufw allow 61616# 部分服务器需要在对应的服务提供商管理页面修改出入站规则 浏览器访问http://服务IP:8161/admin进入管理平台账户默认:admin密码默认:admin Web管理平台配置ActiveMQ的Web管理平台是基于jetty运行,因此在/var/activemq/conf目录可以查看jetty的配置文件 在/var/activemq/conf/jetty.xml文件中,可以进行修改端口,密码等内容 使用ActiveMQ在Java中使用 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.15.8&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * 简单生产者 */public class Producer &#123; public static void main(String[] args) &#123; new ProducerThread(\"tcp://119.3.218.159:61616\", \"queue1\").start(); &#125; static class ProducerThread extends Thread &#123; String brokerUrl; String destinationUrl; // brokerUrl中间件url地址, destinationUrl队列url public ProducerThread(String brokerUrl, String destinationUrl) &#123; this.brokerUrl = brokerUrl; this.destinationUrl = destinationUrl; &#125; @Override public void run() &#123; ActiveMQConnectionFactory connectionFactory; Connection conn; Session session; try &#123; // 1、创建连接工厂 connectionFactory = new ActiveMQConnectionFactory(brokerUrl); // 2、创建连接对象md conn = connectionFactory.createConnection(); conn.start(); // 3、创建会话 session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4、创建点对点发送的目标 Destination destination = session.createQueue(destinationUrl); // 5、创建生产者消息 MessageProducer producer = session.createProducer(destination); // 设置生产者的模式，有两种可选 持久化 / 不持久化 producer.setDeliveryMode(DeliveryMode.PERSISTENT); // 6、创建一条文本消息 String text = \"Hello world!\"; TextMessage message = session.createTextMessage(text); for (int i = 0; i &lt; 1; i++) &#123; // 7、发送消息 producer.send(message); &#125; // 8、 关闭连接 session.close(); conn.close(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * 简单消费者 */// http://activemq.apache.org/consumer-features.htmlpublic class Consumer &#123; public static void main(String[] args) &#123; new ConsumerThread(\"tcp://119.3.218.159:61616\", \"queue1\").start(); new ConsumerThread(\"tcp://119.3.218.159:61616\", \"queue1\").start(); &#125; static class ConsumerThread extends Thread &#123; String brokerUrl; String destinationUrl; public ConsumerThread(String brokerUrl, String destinationUrl) &#123; this.brokerUrl = brokerUrl; this.destinationUrl = destinationUrl; &#125; @Override public void run() &#123; ActiveMQConnectionFactory connectionFactory; Connection conn; Session session; MessageConsumer consumer; try &#123; // brokerURL http://activemq.apache.org/connection-configuration-uri.html // 1、创建连接工厂 connectionFactory = new ActiveMQConnectionFactory(this.brokerUrl); // 2、创建连接对象 conn = connectionFactory.createConnection(); conn.start(); // 一定要启动 // 3、创建会话（可以创建一个或者多个session） session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE); // 4、创建点对点接收的目标，queue - 点对点 Destination destination = session.createQueue(destinationUrl); // 5、创建消费者消息 http://activemq.apache.org/destination-options.html consumer = session.createConsumer(destination); // 6、接收消息(没有消息就持续等待) Message message = consumer.receive(); if (message instanceof TextMessage) &#123; System.out.println(\"收到文本消息：\" + ((TextMessage) message).getText()); &#125; else &#123; System.out.println(message); &#125; consumer.close(); session.close(); conn.close(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 在Spring中使用 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-broker&lt;/artifactId&gt; &lt;version&gt;5.15.8&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;geronimo-jms_1.1_spec&lt;/groupId&gt; &lt;artifactId&gt;org.apache.geronimo.specs&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; web控制台activemq支持web控制台http://host:8161/admin 默认账号admin,密码admin 持久化ActiveMQ的消息持久化机制有JDBC，AMQ,KahaDB和LevelDB，无论使用哪种持久化，消息的存储逻辑都是一致的 Queue(消息队列)类型的持久化机制 Topic(消息订阅)类型的持久化机制 持久化机制 JDBC: 存入数据库,方便管理,性能低 AMQ: 基于文件的存储方式,写入速度快,且易于恢复,但是建索引时间长 KahaDB: 默认方式,相比AMQ恢复更快,并且占用数据量更少 LevelDB: 谷歌开发的持久化高性能类库.","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://yimchengjie.github.io/tags/ActiveMQ/"}]},{"title":"分布式消息中间件","slug":"消息中间件/分布式消息中间件","date":"2019-06-27T13:36:45.000Z","updated":"2020-01-07T07:40:32.705Z","comments":true,"path":"2019/06/27/消息中间件/分布式消息中间件/","link":"","permalink":"https://yimchengjie.github.io/2019/06/27/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"分布式消息中间件生产者(客户端)–发送消息–&gt;消息中间件–分发消息–&gt;消费者(服务器) 什么是消息中间件 利用高效可靠的消息传递机制进行平台无关的数据交互; 把用户消息暂存到消息中间件, 消息中间件在把消息分发到对应分布式模块 基于数据通信来集成分布式系统 分布式系统之间完全通过数据来连接,后台系统之间不需要接口调用 通过提供消息传递和消息队列模型, 它可以在分布式环境下扩展进程间的通信 跨系统跨进程通信 消息中间件的应用场景跨系统数据传递、高并发流量削峰填谷、数据异步处理、系统解耦…等等 常用的消息中间件ActiveMQ、RabbitMQ、Kafka、RocketMQ 消息中间件的核心设计消息中间件的本质一种具备接收请求、保存数据、发送数据等功能的网络应用；和一般网络应用的区别是它主要负责数据的接收和传递，所以性能一般高于普通程序 消息中间件的5大核心组成1. 协议计算机之间通信共同遵循的一组约定协议三要素: 语法 语义 时序 消息中间件常用的协议: OpenWire、AMQP、MQTT、Kafka、OpenMessage(由国内发起) 2. 持久化机制简单来说就是将数据存入磁盘,而不是在内存中,不会因为服务器宕机而丢失数据,能够让数据永久保存就叫持久化 常用持久化方式就是文件系统 3. 消息分发机制为什么要有消息分发策略 消息要被特定的系统接收到, 其他的系统不需要接收 试错机制:后台出错,需要重新发送消息 要解决的问题: 消息传递是推还是拉 是主动分发还是轮询分发 有无重发功能 4. 高可用设计指服务可用性,保持能够使用的状态, 避免服务中断.消息中间件可以使用集群部署, 来达到高可用 分布式消息中间件实现方式: Master-Slave主从共享数据服务器共用同一份数据 Master-Slave主从同步部署方式主服务器同步数据到所有服务器 Broker-Cluster多主集群同步所有服务器都可以进行同步数据 Broker-Cluster多主集群转发只同步数据信息,不同步数据内容, 服务器将请求转发给存有消息内容的服务器 Master-Slave与Broker-Cluster结合分区同步数据 5. 高可靠设计消息传输可靠:通过协议保证系统数据解析的正确性消息存储可靠:通过持久化保证存储消息的可靠性","categories":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://yimchengjie.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"JDK内置命令工具","slug":"Java系统调优/内存爆炸CPU100%问题分析","date":"2019-06-27T13:36:45.000Z","updated":"2019-12-22T06:45:07.428Z","comments":true,"path":"2019/06/27/Java系统调优/内存爆炸CPU100%问题分析/","link":"","permalink":"https://yimchengjie.github.io/2019/06/27/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8CPU100%25%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/","excerpt":"","text":"内存爆炸和CPU100%问题分析当线上的系统突然请求缓慢, CPU100%, 内存占用巨大, 当JVM出现问题时,应该如何排查问题呢 问题排查 登录服务器, 使用top命令查看系统资源使用情况一般出问题时java程序的占用是最高的 找到CPU或者内存占用高的java进程PID, 使用命令top -Hp 进程ID, 查询该进程中线程的运行情况 使用printf &quot;%x\\n&quot; 线程ID查看线程PID的16进制形式 因为在java日志中记录的PID是16进制的形式 jstack 进程ID &gt; ./threadDump.log 打印JVM堆栈信息到文件threadDump.log中在该堆栈信息文件中,找到第3步的线程, 查看具体信息 使用jstat -gcutil 进程号 统计间隔时间 统计次数查看GC的变化情况, 当发现FGC的值一直增大时, 继续使用jmap -heap 进程ID 查看进程堆内存的情况, 特别是老年代的使用情况.老年代内存占用达到阈值时就会触发Full GC jmap -dump:format=b,file=filename 进程ID ,导出Java进程下内存堆到文件中, 再把内存镜像dump文件传到本地, 利用工具进行分析可以使用jhat、VisualVM等工具分析dump文件 原因分析Full GC次数过多 jstat命令发现GC次数很多,并且不断增加 分析dump文件,查看具体对象的内存占用情况如果内存占用情况不多, 说明代码中频繁使用了System.gc() 代码中消耗CPU的操作太多比如复杂的算法,递归的循环等,甚至是代码BUG 锁的使用不正确, 造成死锁分析JVM堆栈信息,看是否有死锁deadlock 不定期的接口耗时现象这主要是因为不定期的高并发带来的问题, 要通过压测工具不断加大访问力度, 发现某个接口某个位置响应缓慢, 再查看堆栈日志, 发现大量线程被阻塞在同一位置, 就能查到我们哪个业务代码出了问题","categories":[{"name":"Java系统调优","slug":"Java系统调优","permalink":"https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yimchengjie.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://yimchengjie.github.io/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://yimchengjie.github.io/tags/JDK/"}]},{"title":"JDK内置命令工具","slug":"Java系统调优/JDK内置命令工具","date":"2019-06-18T06:56:05.000Z","updated":"2019-12-19T11:09:06.563Z","comments":true,"path":"2019/06/18/Java系统调优/JDK内置命令工具/","link":"","permalink":"https://yimchengjie.github.io/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JDK%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/","excerpt":"","text":"JDK内置命令工具javap命令java反编译工具, 主要用于根据Java字节码文件反汇编为Java源代码文件. jps命令显示当前所有java进程pid的命令 jstat命令监视Java虚拟机统计信息 jcmd命令可以替代jps工具查看本地的jvm信息 jinfo命令可以查看运行中的jvm的全部参数, 还可以设置部分参数 jhat分析java堆的命令,可以将堆中的对象以html的形式展现出来,支持对象查询语言SQL jmap打印出java进程内存中对象的情况,或者将JVM中的堆,以二进制输出成文本 jstack用于打印出给定的java进程ID或core file或远程调试服务的堆栈信息, 如果在64位机器, 需要指定选项-J-d64 Jconsole可视化的监视管理控制台 JvisualVM可视化的JVM监控工具","categories":[{"name":"Java系统调优","slug":"Java系统调优","permalink":"https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yimchengjie.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://yimchengjie.github.io/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://yimchengjie.github.io/tags/JDK/"}]},{"title":"JVM参数以及调优","slug":"Java系统调优/JVM参数以及调优","date":"2019-06-18T06:56:05.000Z","updated":"2020-02-26T15:32:15.116Z","comments":true,"path":"2019/06/18/Java系统调优/JVM参数以及调优/","link":"","permalink":"https://yimchengjie.github.io/2019/06/18/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%B0%83%E4%BC%98/","excerpt":"","text":"JVM参数以及调优JVM调优基本概念 堆大小调整 垃圾收集器调整 JIT编译器 大多数调优选项都与调整堆大小和根据情况选择最合适的垃圾收集器有关. 调优的主要目标响应性: 应用程序或系统对请求的数据进行响应的速度, 对于响应性要求高的程序,重点是在短时间内做出回应, 不接受长暂停. 吞吐量: 侧重于在特定时间段内最大化应用程序的工作量. 高暂停是可接受的. 系统瓶颈核心还是在应用代码, 一般情况下无需过多调优, JVM本身在不断优化. GC调优思路 分析场景 确定目标内存占用、低延时、吞吐量 收集日志通过参数配置收集GC日志; 通过JVM分析GC状态看GC状态 分析日志使用工具辅助分析日志, 查看GC次数, GC时间 调整参数切换垃圾收集器或者调整垃圾收集器参数","categories":[{"name":"Java系统调优","slug":"Java系统调优","permalink":"https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yimchengjie.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://yimchengjie.github.io/tags/Java/"}]},{"title":"JVM垃圾回收机制","slug":"Java系统调优/JVM垃圾回收机制","date":"2019-06-10T09:23:11.000Z","updated":"2019-12-19T08:46:04.819Z","comments":true,"path":"2019/06/10/Java系统调优/JVM垃圾回收机制/","link":"","permalink":"https://yimchengjie.github.io/2019/06/10/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"JVM垃圾回收机制自动垃圾收集自动垃圾收集是查看堆内存,识别正在使用哪些对象以及哪些对象未被删除以及删除未使用对象的过程 正在使用的对象是指,程序的某些部分仍然维护指向该对象的指针未使用的对象是指,程序的任何部分都不再引用的对象,因此需要回收未引用对象的内存 自动垃圾收集机制也是java非常重要的一大特性 如何确定内存需要被回收第一步,称为标记.这是垃圾收集器识别哪些内存正在使用而哪些不在使用的 可达性分析算法就是将对象及其引用关系看做一个图,选定活动的对象作为GC Roots;然后跟踪引用链,如果一个对象和GC Roots之间没有连通性,也就是不存在引用,那么可以认为是可回收对象. 可以用作GC Root的对象 虚拟机栈中正在引用的对象 本地方法栈中正在引用的对象 静态属性引用的对象 方法区常量引用的对象 引用类型 强引用:最常见的普通对象引用,只要还有强引用指向一个对象,就不会回收(new出来的对象) 软引用:JVM认为内存不足,才会去试图回收软引用指向的对象.(缓存场景) 弱引用:虽然是引用,但随时可能被回收掉 虚引用:不能通过它访问对象. 通常是在GC时做一些操作 可达性级别 强可达:一个对象可以有一个或多个线程可以通过各种引用访问 软可达:只能通过软引用才能访问 弱引用:只能通过弱引用访问 幻象可达:不存在其他引用,并且finalize过了,只有虚引用指向它 不可达:意味着可以被GC了 怎么清楚垃圾第二步, 定义如何清除垃圾 垃圾收集算法标记-清除(mark-sweep)算法首先标识出所有要回收的对象,然后清除,标记-清除算法效率优先,有内存碎片化问题,不适合特别大的堆;分代收集算法基本基于标记-清除算法的思路改进. 复制(Copying)算法划分两块同等大小的区域,收集时将活着的对象复制到另一块区域. 拷贝过程中将对象顺序放置,就可以避免内存碎片化. 复制+预留内存, 有一定的资源浪费. 标记-整理(mark-compact)类似于标记-清除,但是为了避免内存碎片化,会在清理过程中将对象移动,已确保对象占用连续的内存空间. 分代收集算法当前商业虚拟机常用的算法,根据对象存活周期的不同,将内存划分为几块,一般是把堆划分为新生代和老年代,这样就可以根据各个年代的特点采用最适合的收集算发.在新生代中,每次垃圾收集都有大量对象死去,少量存活,就用复制算法,只需要付出少量存活对象的复制成本就可以完成收集,而老年代中因为对象存活率高,没有额外的空间对它进行分配担保,必须使用标记-清除或者标记-整理算法来回收,不需要大量的移动对象. 新对象会被分配到新生代(Eden),如果超过-XX:+PretenureSizeThreshold:设置的大对象直接进入老年代的阈值, 直接存放到老年代 垃圾收集器串行收集器Serial-Serial GC -XX:UseSerialGC单个线程来执行所有垃圾收集工作,适合单处理器机器,Glient模式下JVM的默认选项 -Serial Old -XX:UseSeriaOldlGCSerial的老年代版本,可以在老年代使用, 它采用了标记-整理(Mark-Compact)算法,区别于新生代的复制算法 并行收集器Parallel-Parallel GC -XX:+UseParallelGC-Parallel Old GC -XX:+UseParallelGCserver模式JVM的默认GC选择,整体算法和Serial类似,区别是新生代和老年代GC都是并行进行;可以设置GC时间或吞吐量等,可以自动进行适应性调整Eden,Survivor大小和MaxTenuringThreshold的值. 也称为吞吐量优先的GC: 吞吐量=用户代码运行时间/(用户代码运行时间+GC时间) -XX:ParallelGCThreads: 设置用于垃圾回收的线程数. 通常和CPU数相等-XX:MaxGCPauseMills: 设置最大垃圾收集停顿时间. 值是大于0的整数.-XX:GCTimeRatio: 设置吞吐量大小,它的值是一个0-100之间的整数.-XX:+UseAdaptiveSizePolicy: 打开自适应GC策略. 以达到在堆大小,吞吐量和停顿时间之间的平衡点 -ParNew GC -XX:+UseParNewGC新生代GC的实现, 它实际是Serial GC的多线程版本. 可以控制线程数量, 参数: -XX:ParallelGCThreads最常见的场景是配合老年代的CMS GC工作. 参数: -XX:+UseConcMarkSweepGC 并发收集器CMS(Concurrent Mark Sweep)-CMS GC -XX:+UseConcMarkSweepGC专用老年代,基于标记-清除算法,设计目标是尽量减少停顿时间.但会占用更多的CPU资源,并和用户线程争抢 -G1 -XX:+UseG1GC针对大堆内存设计的收集器,兼顾吞吐量和停顿时间, JDK9后为默认选项, 目标是替代GMC;G1将堆分为多个固定大小, 堆之间是复制算法, 但整体上可以理解为标记-整理算法,可以有效避免内存碎片化.","categories":[{"name":"Java系统调优","slug":"Java系统调优","permalink":"https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yimchengjie.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://yimchengjie.github.io/tags/Java/"}]},{"title":"类加载机制","slug":"Java系统调优/类加载机制","date":"2019-06-03T02:53:51.000Z","updated":"2019-12-19T08:19:01.020Z","comments":true,"path":"2019/06/03/Java系统调优/类加载机制/","link":"","permalink":"https://yimchengjie.github.io/2019/06/03/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"类生命周期1. 加载:读取二进制内容2. 验证:验证class文件格式规范、语义分析、引用验证、字节码验证3. 准备:分配内存、设置类static修饰的变量初始值4. 解析:类、接口、字段、类方法等解析5. 初始化:为静态变量赋值；执行静态代码块6. 使用:创建实例对象7. 卸载:从JVM方法区中卸载 类加载器类加载器负责装入类,搜索各个位置的类资源.一个Java程序运行,至少有三个类加载器实例,负责不同类的加载 Bootstrap Loader 核心类库加载器,由C语言实现,加载JDK核心类库 Extension Class Loader 拓展类库加载器,加载JDK拓展包 application class loader 用户应用程序加载器,加载classpath路径下的包 类不会重复加载类的唯一性:同一个类加载器,类名一样,代表同一个类. 双亲委托机制某一个类加载器想要去加载一个类,并不会立刻去加载,而是委托给父亲,如果父亲上面还有父亲,则继续向上委托,最终到达核心类库加载器,如果核心类库无法记载,再向下一个个委托.即,有父类交给父类加载,没父类了开始加载,无法加载向下委托,全都不能加载则失败 通过双亲委派机制 建立类的层级关系可以避免类的重复加载,当父亲已经加载该类时,就没必要再加载一次了. 优先加载核心类库, 这样防止用户恶意的同名类,因为永远是核心的类先被加载.","categories":[{"name":"Java系统调优","slug":"Java系统调优","permalink":"https://yimchengjie.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yimchengjie.github.io/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://yimchengjie.github.io/tags/Java/"}]},{"title":"Dubbo+Zookeeper+SpringBoot整合","slug":"分布式开发技术/Dubbo+Zookeeper+SpringBoot整合","date":"2019-05-23T16:15:49.000Z","updated":"2020-02-26T14:40:22.071Z","comments":true,"path":"2019/05/24/分布式开发技术/Dubbo+Zookeeper+SpringBoot整合/","link":"","permalink":"https://yimchengjie.github.io/2019/05/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Dubbo+Zookeeper+SpringBoot%E6%95%B4%E5%90%88/","excerpt":"","text":"Dubbo+Zookeeper+SpringBoot整合 Dubbo作为一款非常高性能轻便的RPC框架,往往搭配着Zookeeper作为服务注册发现中心来使用SpringBoot在Java开发中也越来越主流,开发非常便利如何整合Dubbo+Zookeeper+SpringBoot进行分布式开发呢? 整合步骤1. 创建项目新建一个maven工程dubbo_demo,然后在工程下, 创建三个模块,provider,consumer,common(通用接口jar) 在父pom中导入需要的包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.ycj&lt;/groupId&gt; &lt;artifactId&gt;DubboDemo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;consumer&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.42.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ZooKeeper client --&gt; &lt;!-- https://mvnrepository.com/artifact/com.101tec/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; common的pom.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;com.ycj&lt;/groupId&gt; &lt;artifactId&gt;DubboDemo&lt;/artifactId&gt; &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ycj.dubboDemo&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/project&gt; provider和consumer只需导入common即可 12345&lt;dependency&gt; &lt;groupId&gt;com.ycj.dubboDemo&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 2. 编写接口 123public interface DemoService &#123; public String getDemoString();&#125; 3. 编写提供者 12345678910// DemoService的实现类// 这里的@Service是Dubbo的Service,不是spring的@Servicepublic class ProviderService implements DemoService &#123; @Override public String getDemoString() &#123; return \"ProviderService\"; &#125;&#125; 1234567891011// 启动类, 注意加载配置@SpringBootApplication@ImportResource(locations = &#123;\"classpath:provider.xml\"&#125;)@EnableDubbopublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; dubbo提供者配置,注意资源地址http://code.alibabatech.com/,Apache的我试了一下不可用(当前pom配置情况下) 12345678910111213&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;dubbo:application name=\"demo-provider\"/&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20890\"/&gt; &lt;bean id=\"demoService\" class=\"com.ycj.dubboDemo.provider.service.ProviderService\"/&gt; &lt;dubbo:service interface=\"com.ycj.dubboDemo.common.service.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; 4. 编写消费者 123456789101112// 调用类@Controllerpublic class consumer &#123; @Autowired public DemoService demoService; @RequestMapping(\"/test\") @ResponseBody public String test()&#123; return demoService.getDemoString(); &#125;&#125; 123456789// 启动类,注意加载配置@SpringBootApplication@ImportResource(locations = &#123;\"classpath:consumer.xml\"&#125;)@EnableDubbopublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; dubbo消费者配置 1234567891011&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;dubbo:application name=\"demo-consumer\"/&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.ycj.dubboDemo.common.service.DemoService\"/&gt;&lt;/beans&gt; 5. 启动Zookeeper 6. 启动提供者 7. 启动消费者 8. 访问成功","categories":[{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://yimchengjie.github.io/tags/Dubbo/"},{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}]},{"title":"初识Dubbo","slug":"分布式开发技术/初识Dubbo","date":"2019-05-22T08:15:49.000Z","updated":"2020-02-26T14:39:55.934Z","comments":true,"path":"2019/05/22/分布式开发技术/初识Dubbo/","link":"","permalink":"https://yimchengjie.github.io/2019/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%88%9D%E8%AF%86Dubbo/","excerpt":"","text":"初识Dubbo 随着互联网的发展,网站应用的规模不断扩大,常规的垂直应用架构以及无法应对(应用拆分的越来越细,模块之间的交互在所难免), 分布式服务架构以及流动计算架构势在必行 分布式服务架构: 将应用的核心业务抽取出来,作为独立的服务,逐渐形成稳定的服务中心,使前端应用能更快速的响应多变的市场需求. 此时,用于提高业务复用以及整合的分布式服务框架(RPC)就成了关键 流动计算架构: 当服务越来越多, 部分小服务就会有资源浪费的问题,此时需要增加一个调度中心基于访问压力实时管理集群容量,提高集群利用率,此时, 用于提高机器利用率的资源调度和治理中心(SOA)是关键 Dubbo是阿里巴巴开源的一款高性能、轻量级的开源JavaRPC框架 它体统了三大核心能力：面向接口的远程方法调用、智能容错和负载均衡、以及服务自动注册和发现 Dubbo架构 节点角色节点|角色说明-|-Provider|暴露服务提供方Consumer|调用远程服务的服务消费方Registry|服务注册与发现的注册中心Monitor|统计服务的调用次数和调用时间的监控中心Container|服务运行容器 Container负责启动,加载,运行Provider Provider在启动时,向Registry注册自己提供的服务 Consumer在启动时,向Registry订阅自己所需的服务 Registry返回Provider提供的地址列表给Consumer,一旦列表有变更,Registry将基于长连接(TCP)推送变更数据给Consumer Consumer,从Provider提供的地址列表中,基于软负载均衡算法,选取一台服务器进行调用,如果调用失败,再选另一台调用 Comsumer和Provider,在内存中累计调用次数和调用时间,定时每分钟发送一次统计数据到Monitor Dubbo快速启动Dubbo采用全Spring的配置方式,透明化接入应用,对应用没有任何API侵入,只需要用Spring加载Dubbo的配置即可 服务提供者 定义服务接口 123public interface DemoService &#123; String sayHello(String name);&#125; 在服务提供方实现接口 12345public class DemoServiceImpl implements DemoService &#123; public String sayHello(String name) &#123; return \"Hello \" + name; &#125;&#125; 在Spring配置(provider.xml)中声明暴露服务 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"hello-world-app\" /&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"multicast://224.5.6.7:1234\" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=\"org.apache.dubbo.demo.DemoService\" ref=\"demoService\" /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=\"demoService\" class=\"org.apache.dubbo.demo.provider.DemoServiceImpl\" /&gt;&lt;/beans&gt; 加载Spring配置文件 12345678public class Provider &#123; // 程序启动入口 public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"http://10.20.160.198/wiki/display/dubbo/provider.xml\"&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 服务消费者 通过Spring配置引用远程服务 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"consumer-of-helloworld-app\" /&gt; &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=\"multicast://224.5.6.7:1234\" /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" interface=\"org.apache.dubbo.demo.DemoService\" /&gt;&lt;/beans&gt; 加载Spring配置,并调用远程服务 123456789public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"http://10.20.160.198/wiki/display/dubbo/consumer.xml\"&#125;); context.start(); DemoService demoService = (DemoService)context.getBean(\"demoService\"); // 获取远程服务代理 String hello = demoService.sayHello(\"world\"); // 执行远程方法 System.out.println( hello ); // 显示调用结果 &#125;&#125;","categories":[{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://yimchengjie.github.io/tags/Dubbo/"},{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}]},{"title":"Zookeeper知识点","slug":"分布式开发技术/Zookeeper知识点","date":"2019-05-20T12:57:49.000Z","updated":"2020-02-22T17:02:57.008Z","comments":true,"path":"2019/05/20/分布式开发技术/Zookeeper知识点/","link":"","permalink":"https://yimchengjie.github.io/2019/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/Zookeeper%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"Zookeeper知识点Zookeeper主要用于分布式系统, 实现统一配置管理,统一命名服务,分布式锁和集群管理 简单来说, zookeeper=文件系统+监听通知机制 Zookeeper数据结构Zookeeper维护了一个类似于文件系统的树形数据结构 文件系统树形结构有很多节点,称为znode.我们可以自由的增加删除节点 每一个znode节点,都是可以存储数据的 监听机制客户端注册监听某些节点, 当节点发生改变(数据改变,被删除,子节点增加删除)时,zookeeper就会通知监听节点的客户端 统一配置管理一个分布式系统,多个模块部署在多台设备,如果我们改变程序的配置文件,就需要修改多台设备上的配置, 非常麻烦, 现在把所有配置文件放在zookeeper中,保存在某一个节点,然后与之相关的模块都进行监听,一单配置修改,每个模块都能收到zookeeper的通知,然后获取最新配置信息.比如:一个系统有三个模块ABC,对应三个配置文件,A.yml、B.yml、C.yml,三份配置文件中有一部分信息是相同的, 那么我们要改一个配置就需要修改三个模块的配置信息.并且很可能需要重启服务.现在我们把A.yml、B.yml、C.yml中相同的部分抽取出来,作为公共配置D.yml然后把D.yml存放在Zookeeper的一个节点中,ABC对其监听,一旦发生改变,就可以马上响应了 统一命名服务统一命名服务相当于键值对,系统通过zookeeper节点的名字,拿到同一个数据, 比如ip地址 分布式锁分布式系统必然会有同步的问题,那么如何实现分布式锁呢 系统在获取zookeeper节点的数据时会创建一个临时节点, 这个临时节点会有一个起始最小值(比如,node_001,node_002,node_003这样的顺序创建),系统通过判断自己创建的是不是最小的节点,如果是最小的节点,就能拿到节点的数据. 如果不是就监听比自己小一个的节点(比如,node_001先获取节点数据,node_002想要获取时发现自己不是最小的,于是它会监听node_001, 一旦node_001获取到后,临时节点删除,node_002就能获取节点数据了) 集群状态和分布式锁类似, 通过创建临时节点.ABC通过监听Node1,都临时创建一个节点, 一旦某一个系统挂了, 它创建的临时节点就会删除,那么其他监听Node1的系统,发现Node1有一个子节点挂了,就能判断出集群的状态了. Zookeeper安装使用安装到系统目录,解压 修改zookeeper/conf下的zoo_sample.cfg为zoo.cfg, 在该文件中,可以修改启动端口等参数,默认端口为2181 进入zookeeper/bin,启动zkServer.sh或者zkServer.cmd 看到这个消息就说明启动成功了","categories":[{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"分布式开发技术","slug":"分布式开发技术","permalink":"https://yimchengjie.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://yimchengjie.github.io/tags/Zookeeper/"}]},{"title":"Redis入门","slug":"缓存中间件/Redis入门","date":"2019-05-12T06:32:23.000Z","updated":"2020-02-26T14:38:40.498Z","comments":true,"path":"2019/05/12/缓存中间件/Redis入门/","link":"","permalink":"https://yimchengjie.github.io/2019/05/12/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Redis 入门Redis 是一套缓存中间件,是基于内存的数据库,采用 key-value 的形式存储数据,底层由 C 语言开发 以前的数据库读写,需要到硬盘中读取数据,速度相比内存是慢很多的.Redis 直接存储在内存中,读取速度快,而且 Redis 实现了分布式缓存 Redis 安装与配置下载安装 12$sudo apt-get update$sudo apt-get install redis-server 启动服务(默认配置) 1redis-server 打开 Redis 1redis-cli redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 Redis 数据类型Redis 支持物种数据类型:string(字符串),hash(哈希表),list(列表),set(集合)及 zset(sorted set 有序集合) String(字符串)string 是 redis 最基本的类型,string 类型是二进制安全的,这意味着 redis 的 string 可以包含任何数据. 最大能存储 512MB hash(哈希表)redis 的 hash 是一个键值对集合, 在 redis 中的关系是 key 对应 value,value 中又是键值对 Set(集合)redis 中的 set 是 String 类型的无序集合,且没有重复值 zset(有序结合)zeset 也是 String 类型的集合,也没有重复值 但它有序 Java 使用 RedisRedis 在 Web 开发中往往用作缓存,存储需要高速读写的数据 Java 使用 Redis 需要用到驱动包 jedis.jar 连接 redis 服务器 123456public static void main(String[] args)&#123; Jedis jedis = new Jedis(\"000.000.000.000\", 6379, 100000); jedis.set(\"test\",\"test\"); jedis.get(\"test\"); jedis.close();&#125;","categories":[{"name":"缓存中间件","slug":"缓存中间件","permalink":"https://yimchengjie.github.io/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"缓存中间件","slug":"缓存中间件","permalink":"https://yimchengjie.github.io/tags/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"Redis","permalink":"https://yimchengjie.github.io/tags/Redis/"}]},{"title":"Netty网络编程框架","slug":"网络编程/Netty网络编程框架","date":"2019-05-07T12:59:55.000Z","updated":"2020-02-26T14:54:50.649Z","comments":true,"path":"2019/05/07/网络编程/Netty网络编程框架/","link":"","permalink":"https://yimchengjie.github.io/2019/05/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Netty 网络编程框架Netty 是一个高性能、高可扩展性的异步事件驱动的网络应用程序框架，它极大的简化了 TCP 和 UDP 客户端和服务器开发等网络编程 Netty 支持 BIO、NIO，支持各种协议 Reactor 线程模型Reactor 模型也叫 Dispatcher 模式,服务器接收多路请求,并同步反派给请求对应的线程 Netty 线程模型Netty 线程模型基于主从 Reactor 线程模型,有多个 Reactor Netty 模块组件 Bootstrap 引导: 一个 Netty 应用通常由一个 Bootstrap 开始,主要作用是配置整个 Netty 程序,串联各个组件,Netty 中 Bootstrap 类是客户端程序的启动引导类,ServerBootstrap 是服务端启动引导类 Future ChannelFuture: 可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。 Channel: 网络通信通道,发送接收数据 Selector: 实现 I/O 多路复用,一个 Selector 线程可以监听多个线程的 Channel 事件 NioEventLoop: 类似线程池,维护了一个线程和任务队列,支持异步提交执行,线程启动时,会调用 run()方法,执行 IO 任务和非 IO 任务 NioEventLoopGroup: 用于管理 eventLoop 的生命周期,可以理解为大线程池,内部维护了一组小线程池 ChannelHandler: 处理 IO 事件或者拦截 IO 操作,并转发到 ChannelPipeline(业务处理链)中Handler 可以被共享,但是要注意防止共享变量,比如解码器是不能被共享的耗时的业务不要放在 Handler,要单独交给指定的线程池中 ChannelHandlerContext: 保存 Channel 相关的上下文信息,每一个 ChannelHandlerContext 关联一个 ChannelHandler ChannelPipline: 责任链,业务处理链,保存了 ChannelHandler 的 List,用于处理或拦截 Channel 的入站事件或者出站操作. netty 服务端处理用户请求流程图解","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Netty","slug":"Netty","permalink":"https://yimchengjie.github.io/tags/Netty/"}]},{"title":"NIO网络编程","slug":"网络编程/NIO网络编程","date":"2019-04-30T14:19:55.000Z","updated":"2020-02-26T14:55:03.133Z","comments":true,"path":"2019/04/30/网络编程/NIO网络编程/","link":"","permalink":"https://yimchengjie.github.io/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"NIO 网络编程非阻塞 IO NIO 是 Java 提供的替代 BIO 的相关 API NIO 三大核心组件Buffr 缓冲区Channel 通道Selector 选择器 Buffer 缓冲区Java 提供 Buffer API, 可以让我们更轻松的使用内存块 使用 Buffer 对象,对数据进行写入和读取 将数据写入缓冲区 调用 buffer.flip(),转换为读取模式 缓冲区读取数据 调用 buffer.clear()或 buffer.compact() 清楚缓冲区 Buffer 的三个属性capacity 容量: 缓冲区内存块大小position 位置: 写入或读取时的位置limit 限制: 限制每次读取或者写入的大小 12345678910111213141516171819202122232425262728293031323334353637383940public class BufferDemo &#123; public static void main(String[] args) &#123; // 构建一个byte字节缓冲区，容量是4 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(4); // 默认写入模式，查看三个重要的指标 System.out.println(String.format(\"初始化：capacity容量：%s, position位置：%s, limit限制：%s\", byteBuffer.capacity(), byteBuffer.position(), byteBuffer.limit())); // 写入2字节的数据 byteBuffer.put((byte) 1); byteBuffer.put((byte) 2); byteBuffer.put((byte) 3); // 再看数据 System.out.println(String.format(\"写入3字节后，capacity容量：%s, position位置：%s, limit限制：%s\", byteBuffer.capacity(), byteBuffer.position(), byteBuffer.limit())); // 转换为读取模式(不调用flip方法，也是可以读取数据的，但是position记录读取的位置不对) System.out.println(\"#######开始读取\"); byteBuffer.flip(); byte a = byteBuffer.get(); System.out.println(a); byte b = byteBuffer.get(); System.out.println(b); System.out.println(String.format(\"读取2字节数据后，capacity容量：%s, position位置：%s, limit限制：%s\", byteBuffer.capacity(), byteBuffer.position(), byteBuffer.limit())); // 继续写入3字节，此时读模式下，limit=3，position=2.继续写入只能覆盖写入一条数据 // clear()方法清除整个缓冲区。compact()方法仅清除已阅读的数据。转为写入模式 byteBuffer.compact(); // buffer : 1 , 3 byteBuffer.put((byte) 3); byteBuffer.put((byte) 4); byteBuffer.put((byte) 5); System.out.println(String.format(\"最终的情况，capacity容量：%s, position位置：%s, limit限制：%s\", byteBuffer.capacity(), byteBuffer.position(), byteBuffer.limit())); // rewind() 重置position为0 // mark() 标记position的位置 // reset() 重置position为上次mark()标记的位置 &#125;&#125; Buffer 可以直接获取直接内存ByteBuffer directByteBuffer=ByteBuffer.allocateDirect(n);内部有一个回收对象, 可以进行垃圾回收, 否则 JVM 的垃圾回收无法管理堆外内存 否则使用 JVM 堆内存,写入时用堆内存会复制一份数据到堆外内存 Channel 通道通道从 ByteBuffer 中读取数据或者写入数据 Channel 四种实现类型1. FileChannel: 用于文件的数据读写。 1234567891011121314151617// 创建FileChannel通道RandomAccessFile aFile = new RandomAccessFile(\"test.txt\"，\"rw\");FileChannel inChannel = aFile.getChannel();// 读取数据ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf);// 写入数据String newData = \"New String to write to file...\" + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining())&#123; channel.write(buf);&#125;// 关闭channel.close(); 2. DatagramChannel: 用于 UDP 的数据读写。3. SocketChannel: 用于 TCP 的数据读写。4. ServerSocketChannel: 监听 TCP 链接请求，每个请求会创建会一个 SocketChannel。 123456789ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));serverSocketChannel.configureBlocking(false);while(true)&#123; SocketChannel socketChannel = serverSocketChannel.accept(); if(socketChannel != null)&#123; //do something with socketChannel... &#125;&#125; Selector 选择器可以检查一个或多个 NIO 通道,实现单个线程管理多个通道,从而管理多个网络连接 比如:当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务,不会阻塞 一个通道继承了 SelectableChannel,那么他就可以被 Selector 复用 一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通道和选择器之间的关系，使用注册的方式完成。SelectableChannel 可以被注册到 Selector 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。 使用 Channel.register（Selector sel，int ops）方法, 将通道注册到选择器上,这里的操作指的是当前通道已经准备就绪,能够进行的操作类型int ops 包括 可读 : SelectionKey.OP_READ 可写 : SelectionKey.OP_WRITE 连接 : SelectionKey.OP_CONNECT 接收 : SelectionKey.OP_ACCEPT selector.select(); 查找准备就绪的通道 Selector 使用流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//创建选择器Selector selector = Selector.open();//创建通道ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//设置非租塞serverSocketChannel.configureBlocking(false);//绑定连接serverSocketChannel.bind(new InetSocketAddress(SystemConfig.SOCKET_SERVER_PORT));//将通道注册到选择器,并指定为可接收serverSocketChannel.register(selector，SelectionKey.OP_ACCEPT);// 采用轮询的方式，查询获取“准备就绪”的注册过的操作while (selector.select() &gt; 0)&#123; // 获取当前选择器中所有注册的选择键（“已经准备就绪的操作”） Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().iterator(); while (selectedKeys.hasNext()) &#123; // 获取“准备就绪”的事件 SelectionKey selectedKey = selectedKeys.next(); // 判断key是具体的什么事件 if (selectedKey.isAcceptable()) &#123; // 若接受的事件是“接收就绪” 操作,就获取客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 切换为非阻塞模式 socketChannel.configureBlocking(false); // 将该通道注册到selector选择器上,并指定为可读 socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (selectedKey.isReadable()) &#123; // 获取该选择器上的“读就绪”状态的通道 SocketChannel socketChannel = (SocketChannel) selectedKey.channel(); // 读取数据 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int length = 0; while ((length = socketChannel.read(byteBuffer)) != -1)&#123; byteBuffer.flip(); System.out.println(new String(byteBuffer.array(), 0, length)); byteBuffer.clear(); &#125; socketChannel.close(); &#125; // 移除选择键 selectedKeys.remove(); &#125;&#125;// 关闭连接serverSocketChannel.close();&#125; 注意:要注册到选择器, 通道必须是非租塞的 Reactor 模式基于 Java NIO, 在此基础, 抽象出来两个组件–Reactor 和 Handler Reactor: 负责响应 IO 事件,当检测到新的时间, 发送给相应的 Handler Handler: 执行处理","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"BIO网络编程","slug":"网络编程/BIO网络编程","date":"2019-04-30T11:29:55.000Z","updated":"2020-02-26T14:54:45.570Z","comments":true,"path":"2019/04/30/网络编程/BIO网络编程/","link":"","permalink":"https://yimchengjie.github.io/2019/04/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/BIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"BIO 网络编程同步阻塞网络编程 阻塞 IO 的含义阻塞 IO: 资源不可用时,IO 请求一直阻塞,直到有数据或者阻塞超时非阻塞 IO: 资源不可用时,IO 请求离开返回,返回数据标识资源不可用阻塞非阻塞描述请求,即如何获取数据 同步 IO: 应用阻塞在发送或者接受数据的状态,直到数据成功传输或者返回失败异步 IO: 应用发送或接受数据后立刻返回,实际处理是异步执行同步异步描述响应,即如何拿数据 Java 中的ServerSocket 类的 accept 方法和 InputStream 类的 read 方法,都是阻塞 API 1234567891011121314151617181920212223242526272829303132333435363738394041// 服务端// 初始化服务端SocketServerSocket serverSocket = new ServerSocket(8080);System.out.println(\"服务器启动成功\");while (!serverSocket.isClosed()) &#123; Socket request = serverSocket.accept();// 阻塞 System.out.println(\"收到新连接 : \" + request.toString()); try &#123; // 接收数据、打印 InputStream inputStream = request.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, \"utf-8\")); String msg; while ((msg = reader.readLine()) != null) &#123; // 没有数据，阻塞 if (msg.length() == 0) &#123; break; &#125; System.out.println(msg); &#125; System.out.println(\"收到数据,来自：\"+ request.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; request.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;serverSocket.close();// 客户端Socket s = new Socket(\"localhost\", 8080);OutputStream out = s.getOutputStream();Scanner scanner = new Scanner(System.in);System.out.println(\"请输入：\");String msg = scanner.nextLine();out.write(msg.getBytes(charset)); // 阻塞，写完成scanner.close();s.close();","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"网络协议","slug":"网络编程/网络协议","date":"2019-04-27T05:25:11.000Z","updated":"2020-02-26T14:54:35.625Z","comments":true,"path":"2019/04/27/网络编程/网络协议/","link":"","permalink":"https://yimchengjie.github.io/2019/04/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"OSI 网络七层模型物理层: 使原始的数据比特流能在物理介质上传输数据链路层: 封装成帧、透明传输、差错检测。网络层: 路由选择、流量控制（IP 协议） 传输层： 提供可靠的端口到端口的数据传输服务（TCP/UDP 协议） 会话层: 建立、管理、终止进程之间的会话和数据交换表示层: 数据格式转换，加密解密，压缩解压等应用层: 为用户的应用进程提供网络服务 TCP 协议TCP 提供面向连接、可靠、有序、字节流传输服务。应用程序在使用 TCP 之前，必须先建立 TCP 连接。 TCO 三次握手在正式发送数据之前，做的检验机制通过以后就成功建立了 TCP 连接，然后开始传输数据 TCP 四次挥手在断开连接之前，做的确认机制 TCP 三次握手和四次挥手，都是为了让连接的可靠性更高 UDP 协议UDP 提供无连接、不可靠、数据报尽力传输服务。 比如语言视频聊天， 日志上报等， 会用到 Http 协议一个 http 请求包含四个部分 请求行: 请求类型,资源路径,以及 http 版本 请求头部: 用来说明服务器要使用的附加信息 空行: 请求头和数据主体之间必须有换行,作为分隔标记 主体: 即请求数据 一个 http 响应数据包含 状态行: HTTP 版本、状态码、状态消息 响应报头部: 用来说明服务器要使用的附加信息 空行: 头部和数据之间的换行 响应正文: 即响应数据 HTTP 协议响应状态码 1XX: 临时响应握手成功,TCP 建立 2XX: 成功表示已成功处理了请求 3XX: 重定向表示要完成请求,需要进一步操作 4XX: 请求错误请求可能出错 5XX: 服务器错误服务器内部出错 WebSocket 协议WebSocket 是基于 TCP 的一种新的网络协议它实现了服务器和客户端全双工通信 支持多客服端,多语言,多服务器","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://yimchengjie.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://yimchengjie.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"并发工具类","slug":"Java并发编程/并发工具类","date":"2019-04-19T10:17:31.000Z","updated":"2020-02-26T15:13:12.258Z","comments":true,"path":"2019/04/19/Java并发编程/并发工具类/","link":"","permalink":"https://yimchengjie.github.io/2019/04/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"并发工具类FutureFuture 可以实现异步执行,并且收集结果, 可以在其他线程中获取线程的返回结果Future 是一个接口,FutureTask 是它的实现类 FutureTask 解读 FutureTask 类实现了 Runable 接口 所以要想执行 FutureTask 类,需要利用它构造 Thead 类 FutureTask 的构造函数需要一个 Callable 接口, 来定义操作,Callable 相比 Runable 多了返回值 Callable 中的 call 方法,最终会在 Runable 接口的 run 方法中执行 多个 FutureTask 执行流程 CountDownLatch倒计数器,实现异步执行它可以用来记录线程池中任务完成的情况 定义任务数量 每次任务完成,任务数减 1,减 1 操作是同步操作 await 方法,等待计数器归 0,当任务数清零后,任务全部完成 CyclicBarrier线程栅栏,功能和 CountDownLatch 类似,但是 CyclicBarrier 对象可以重复执行多次 类似于线程池,提供了启动方法,用来指定任务数, 只有任务达到启动数量,才开启任务 Fork/Join 框架Fork/Join 是一个用来切分任务和合并结果的框架专为可以递归分解成小块的工作而设计的Fork/Join 将任务分配给线程池中的工作线程,充分利用资源,提高性能 适合数据处理,结果汇总,统计等场景 ForkJoinPool 本质是一个线程池,它的默认的线程数量是 CPU 的核心数量","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"并发工具类","slug":"并发工具类","permalink":"https://yimchengjie.github.io/tags/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"并发容器类","slug":"Java并发编程/并发容器类","date":"2019-04-11T14:17:53.000Z","updated":"2020-02-26T15:14:15.851Z","comments":true,"path":"2019/04/11/Java并发编程/并发容器类/","link":"","permalink":"https://yimchengjie.github.io/2019/04/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E7%B1%BB/","excerpt":"","text":"并发容器类(一)HashMap 源码分析非线程安全容器类 1. 存储结构HashMap 是依据哈希表（数组和链表的结合）实现的内部使用 Node 类型的数组，即一个数组，数组的元素是链表 每一个 Node 都存储着四个字段，如下： 从 next 字段我们可以看出 Node 是一个链表.即数组中的每一个位置存储一个链表的头结点,HashMap 使用链表法来解决冲突,同一个链表中存放着 hash(key)%len( 元素 key 的哈希值和数组长度取模运算) 结果相同的元素 2. 拉链法的工作原理拉链法: 就是把具有相同哈希值的关键字值放在同一个单链表中比如 12345678// 新建一个默认大小16的HashMapHashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();// 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的下标 115%16=3。那么插入到数组下标为3的位置map.put(\"K1\", \"V1\");// 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。那么插入到数组下标为6的位置map.put(\"K2\", \"V2\");// 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，数组下标6的位置,即插在 &lt;K2,V2&gt; 前面。map.put(\"K3\", \"V3\"); 3. JDK1.7 和 JDK1.8 中 HashMap 的区别单链表数组结构的缺陷JDK1.7 采用的是单链表数组的结构,这样的结构,在查找的时候是分为两步的; 先计算要查找的元素的键key所对应的 hashCode,然后除留语法得到链表头所在数组的位置 然后从这个头结点,按顺序查找比对. 所以,单链表数组结构的查询算法的时间复杂度与链表的长度成正比,和数组的长度无关. 单链表数组的扩容机制因为查询的时间复杂度与链表长度成正比, 所以需要尽量让链表保持较短这就引入了扩容机制,扩大数组的长度,从而减少了链表的长度. 但是扩容机制成本非常大, 因为它需要新建一个长数组,然后把之前的每个节点都重新计算 hash 值,再复制到新数组中,构成新的链表数组 扩容机制的新数组长度为旧数组的两倍， 这就保证了旧数组中的节点所在位置 index 在新数组中，要么还是 index，要么就是 index+oldTable.lenth() JDK1.8 的红黑树由于扩容机制的成本太大，所以 JDK1.8 中引入了红黑树的数据结构，它是一种自平衡二叉树，它不要求平衡二叉树那样的绝对平衡，但是每次添加操作，都能保证只做三次旋转，就能达到自平衡二叉树的要求，而平衡二叉树插入新节点的旋转次数却不可预知。 红黑树保证了用少量的算力换取相对的平衡。 在 JDK1.8 中设计了每个链表长度都有阈值，超过阈值后，链表就会转换成红黑树。以降低时间复杂度和减少扩容次数。 头插法和尾插法JDK1.7 采用头插法，但是由于每次插入操作之前,都会遍历一遍链表,已判断是更新还是插入,所以头插法并没有提高插入效率 ,其次可能是考虑到新插入的元素更可能被先使用，所以使用头插法，让先头插法让新插入的元素更容易的被查找到 JDK1.8 开始采用尾插法 是因为 JDK1.7 中的扩容机制，是从表头开始复制到新数组,这就和原来的旧的链表相反了, 由于头插法, 后插入的数据本来应该在表头,可是复制到新数组中成了链表的尾结点. 这使得新插先用的想法成为了伪命题. 头插法在并发情况下,容易造成循环链 HashMap 在 JDK1.8 中的简单流程 (二)HashTable一个 synchronized 的 HashMap,只是在 HasMap 上加了 synchronized 关键字,它是遗留类,现在不推荐使用,因为全程都是重量级锁它不允许记录的键或者值为空 (三)ConcurrentHashMap 源码分析ConcurrentHashMap 支持线程安全，并且 ConcurrentHashMap 的效率会比 HashTable 更高，因为它引入了分段锁。 ConcurrentHashMap存储结构在 JDK1.7 中Segment&lt;K,V&gt;[]Segment&lt;K,V&gt;对象中含有HashEntry&lt;K,V&gt;[]table 数组每一个 Segment 都是一把锁结构如图: 在 JDK1.8 中结构和 HashMap 类似,但操作的时候,产生 Hash 冲突时,对于当前的桶的头结点加锁.没有 Hash 冲突时采用 CAS 机制来操作数组 hash 冲突的几率是小的,JDK1.8 的设计,减少了加锁次数和加锁范围, 只有 hash 冲突时加锁,且只加在一个桶 (四)ArrayListArrayList存储结构ArrayList 是基于数组实现的,默认的大小是 10, 它继承了 RandomAccess 接口, 意味着支持随机访问 自动扩容size 属性记录了保存的元素数量,当容量不够时就会扩容新的数组长度是 oldCapacity+(oldCapacity&gt;&gt;1),也就是原来的 1.5 倍 扩容时会把所有元素复制到新数组,代价很高, 所以最好能在一开始就知道要存的量,并在初始化的时候指定大小 modCount 标记位ArrayList 有一个 modCount 标记位, 用来记录修改移除添加的操作的次数, 当利用迭代器对它进行遍历操作时, 会拷贝一个 expectModCount, 用来判断是否有修改操作, 当 ArrayList 被修改(修改,添加,移除),modCount 和 expectModCount 不一致, 就会抛出异常 (五)CopyOnWriteArrayListArrayList 的并发版本,由 J.U.C 包提供,采取读写分离的思想 添加数据的时候执行加锁,然后(拷贝原数组, 添加元素, 再替换),保证这些操作的线程安全 但这样做有两个问题: 占用内存, 因为会复制一份完整的数组 读取会有时间滞后性, 其他线程进入读操作,读到的是旧数组的内容. 要替换操作完成, 才能读到 (六)Vector同步关键字版本的 ArrayList,遗留容器 (七)HashSet基于 HashMap 实现 Set 与 List 的区别是,Set 元素不能重复, 这也叫就是 HashMap 的一个特性 HashSet存储结构内部有一个 HashMap (八)CopyOnWriteArraySet基于 CopyOnWriteArrayList基本原理就是添加时先进行比对操作,没有重复值才插入 (九)PriorityQueue采用数组结构, 引入完全二叉树概念 所以是有序队列 (十)LinkedList双链表结构 前指针数据类型后指针","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java集合容器","slug":"Java集合容器","permalink":"https://yimchengjie.github.io/tags/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"AQS抽象队列同步器详解","slug":"Java并发编程/AQS抽象队列同步器详解","date":"2019-03-25T14:17:53.000Z","updated":"2020-02-26T15:26:52.255Z","comments":true,"path":"2019/03/25/Java并发编程/AQS抽象队列同步器详解/","link":"","permalink":"https://yimchengjie.github.io/2019/03/25/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"AQS 抽象队列同步器详解同步锁的本质是什么同步的方法:独享-单个排队窗口,共享-多个排队窗口抢锁的方法:不公平-插队抢,公平-先来后到排队没抢到锁怎么办:反复询问窗口是否有空(CAS 自旋),等待叫号(阻塞等待)唤醒阻塞线程:全部通知,通知下一个(叫号器) 什么是 AQSAQS 全称 AbstractQueuedSynchronizer 被认为是 J.U.C 的核心，和 CAS 共同撑起了整个 J.U.C 包（java.util.concurrent）J.U.C 中的大多数同步器都是基于 AQS 来构建的. 抽象队列同步器 AQS，用于解决的就是多线程并发访问控制问题，在传统的多线程编程中，如果有多个线程需要访问同一个变量，就需要使用 sychronized 来为临界值区加锁，但是这种方法即不优雅，也不高效，更重要的是，不能实现更细粒度的控制，这时候 AQS 提供了一种简洁优雅的机制来实现线程安全:管理同步状态、阻塞/唤醒线程、管理等待队列 本质上来说，AQS 是构建（包括锁在内）大部分同步组件的基本基础框架，它实现了对资源的占用,释放;线程的等待唤醒,等相关接口的实现。 比如 ReentrantLock、CountDownLatch、CyclicBarrier 等同步起， 其实都是通过内部类实现了 AQS 框架暴露的 API，以此实现各类同步器功能，这些同步器的主要区别其实就是对同步状态（synchronion state）的定义不同。 AQS 的作用AQS 框架， 分裂了构建同步器时的一系列关注点，它的额所有操作都围绕着资源——同步状态（synchronization state）来展开，并且解决了如下问题 资源时可以被同时访问？ 还是在同一时间只能被一个线程访问（共享/独占功能） 访问资源的线程如何进行并发管理？（等待队列） 如果线程等不及资源了，如何从等待队列退出（超时/中断） 这相当于时模板方法设计模式， AQS 作为父类 定义好框架和内部操作细节， 具体的实现则由子类来操作 AQS 框架将剩下的一个问题留给用户：什么是资源？ 如何定义资源是否可以被访问？ 以下则是具体同步器 综上所述：AQS 提供了一套模板框架：由于并发的存在，需要考虑的情况很多，因此能否以一种相对简单的方法来完成这两个目标就非常重要， 因为对于用户（AQS 框架的使用者），很多时候并不关心内部复杂的细节。而 AQS 其实就是利用模板方法来实现这一点，AQS 中大多数方法都是 final 或者 private 的。AQS 通过暴露以下 API 来让用户自己解决上面提到的“什么是资源？ 如何定义资源是否可以被访问？”的问题。AQS 支持中断、超时：使用了 AQS 框架的同步器，都支持下面的操作：阻塞和非阻塞（例如 tryLock）同步；可选的超时设置，让调用者可以放弃等待；可中断的阻塞操作。 AQS 支持独占模式和共享模式：AQS 框架内部通过一个内部类 ConditionObject，实现了 Condition 接口，以此来为子类提供条件等待的功能。 AQS 原理简述AQS 所有操作都围绕着资源——同步状态（synchronization state）来展开，围绕着资源，衍生出三个基本问题： 同步状态（synchronization state）的管理 阻塞/唤醒线程的操作 线程等待队列的管理 AQS 内部主体属性state:同步状态位,锁的数量,加锁+1,释放-1owner:资源拥有者node:锁的等待者方法acquire,acquireShared:定义了资源争用逻辑,如果没拿到,进入等待队列tryAcquire,tryAcquireShared:实际占用资源的操作, 需要具体使用者来实现release,releaseShared:定义了释放资源的逻辑,释放之后,通知队列进行争抢tryRelease,tryReleaseShared:实际执行资源释放的操作,由具体使用者来实现 AQS 实现一把简单的独享锁流程图","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Java锁","slug":"Java锁","permalink":"https://yimchengjie.github.io/tags/Java%E9%94%81/"},{"name":"AQS","slug":"AQS","permalink":"https://yimchengjie.github.io/tags/AQS/"}]},{"title":"Lock锁","slug":"Java并发编程/Lock锁","date":"2019-03-17T10:17:53.000Z","updated":"2020-02-26T15:31:52.424Z","comments":true,"path":"2019/03/17/Java并发编程/Lock锁/","link":"","permalink":"https://yimchengjie.github.io/2019/03/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Lock%E9%94%81/","excerpt":"","text":"LockLock 是一个锁的接口， 提供获取锁和解锁的方法（lock，trylock，unlock）是一种用代码实现的锁注意:当 Lock 没有指向 unlock 释放锁的时候,即为可重入锁,其他线程在锁没有释放的时候还是无法获取锁,即使没有线程在使用锁, 但还是有一个线程在占用锁ReentrantLock是 Lock 接口的一个实现类， 它实现了 Lock 中的方法， 但是使用 Lock 的时候必须注意它不会像 synchronized 执行完后或者抛出异常后自动释放锁， 而是需要你主动释放锁， 所以我们必须在使用 Lock 时加上 try{}catch{}finally{}块，并且在 finally 中释放占用的锁资源。 使用 Lock 和 synchronized 最大的区别就是当使用 synchroniized 时一个线程抢占资源，其他线程必须等待，而使用 Lock，一个线程抢占到锁资源，其他的线程可以不等待或者设置等待时间， 实在抢不到可以去做其他的业务逻辑 ReadWriteLock 读写锁它可以实现读写锁， 当读取的时候线程会获得 read 锁， 其他线程也可以获取 read 锁，同时并发的去读取，但是写程序运行获取到 write 锁时， 其他线程是不能进行操作的，因为 write 是排它锁，而上面介绍的两种 Lock 和 synchronized 不管是 read 还是 write 没有抢到锁的线程都会被阻塞或者中断，ReadWriteLock 也是个接口，里面定义了两种方法 readLock()和 writeLock()，他的一个实现类是 ReentrantReadWriteLock 是 ReadWriteLock 的实现类注意读锁被占用的时候,写锁不能被占用 小记:Lock 比内置锁更具灵活性,可以设置方法不去等待锁,做其他的逻辑操作. 它具备和内置锁同样的内存语义","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Java锁","slug":"Java锁","permalink":"https://yimchengjie.github.io/tags/Java%E9%94%81/"}]},{"title":"Java锁与synchronized","slug":"Java并发编程/Java锁与synchronized","date":"2019-03-15T06:04:30.000Z","updated":"2020-02-26T15:28:32.763Z","comments":true,"path":"2019/03/15/Java并发编程/Java锁与synchronized/","link":"","permalink":"https://yimchengjie.github.io/2019/03/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E9%94%81%E4%B8%8Esynchronized/","excerpt":"","text":"Java 锁与 synchronizedJava 内置锁 synchronized 是一把互斥锁, 这意味这同时只有一个线程能够进入锁 锁的概念 自旋锁: 为了不放弃 CPU 执行事件,循环的使用 CAS 技术对数据尝试进行更新,直到成功,本质上是乐观锁的一种实现 悲观锁: 假定会发生并发冲突,同步所有对数据的相关的操作,从读数据就开始上锁 乐观锁: 假定没有冲突,在修改数据时如果发现数据和之前不一致,则读最新数据,再重试修改 独享锁(写): 给资源加上写锁,只有一个线程可以修改,其他线程排队 共享锁(读): 给资源加上读锁,其他线程只能加读锁,不能加写锁 可重入锁、不可重入锁: 线程拿到锁后可以、不可以重用锁资源 公平锁、不公平锁: 争抢锁的顺序,如先来后到则是公平锁 注意:不同的锁应对不同的场景,没有优劣之分,只有最适合场景的锁. 同步关键字 synchronizedJava 内置锁 synchronized同步关键字 synchronized 属于悲观锁属于最基本的线程通信机制，基于对象监视器实现的。Java 中的每个对象都与一个监视器相关联，一个线程可以锁定或解锁监视器，一次只有一个线程可以锁定监视器特性：synchronized 是一个可重入、独享、悲观锁 synchronized 用于同步方法和代码块，执行完后自动释放锁 锁的范围:修饰类或静态方法,类锁, 同步的内容是 class 对象和静态方法 修饰非静态方法或者 this,对象锁,同步的内容是单个对象资源 synchronized 原理理解 Java 对象头与 Monitor对象在内存中，有一块对象头区域，它是实现 synchronized 的基础， 对象头区域有两个部分：第一部分(markword)，存放hashCode 值、锁状态、GC 标志等信息第二部分，存放类型指针，指向类元数据，表名该对象属于哪个类 第一部分除了锁状态，Java6 还新增了轻量级锁和偏向锁。synchronized 属于重量级锁 锁状态对象头中的锁状态，存放这锁的信息 有一个线程 ID是标记线程对象的线程中也有一个锁记录,来标记到锁 有一个锁状态位标记当前锁的状态01:unlocked(未锁定)00:轻量级锁10:重量级锁11:要被 GC 回收线程可以通过 CAS 机制来修改锁的状态位 有一个偏向锁锁状态位偏向锁锁状态位只有一位0/1: 开启或者关闭 有一个锁监视器标志位锁监视器标志位中指针指向Monitor 对象（锁监视器）的起始地址每个对象都有一个Monitor 对象（锁监视器）与其关联 Monitor 对象（锁监视器）Monitor 对象（锁监视器）中有一个指针，指向持有它的线程(_owner)Monitor 对象还拥有两个队列， 一个是线程排队队列(_EntryList)，一个是线程阻塞队列(_WaitList)。 当持有它的对象释放它的时候，指针会重制，指向等待队列中的下一个线程， 当线程执行 wait 时,它会进入阻塞队列_WaitList,唤醒后,进入排队队列_EntryList synchronized 就是通过这种方法来实现锁的， 这也是为什么 Java 中任意对象都可以是锁的原因。监视器跟对象共同的生命周期,但是在没有开启重量级锁之前,监视器是空对象,_owner 在开启重量级锁后才会指向线程 偏向锁、轻量级锁、自旋锁、锁消除偏向锁偏向锁就是，当一个线程获得了锁，就会进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁(本质可以理解为单线程情况无锁)(因为当只有一个线程反复操作锁的时候,不应该反复加锁, 这是额外的消耗,是需要尽量降低的) 当一个线程来获取锁,并不会第一时间修改锁状态位,而是先修改偏向锁的标志位,偏向锁默认为 1 即开启状态,还有一个线程标记,指向获取偏向锁的线程,线程要获取偏向锁,修改线程标记指向自己, 操作成功即得到锁,第二次再来访问锁时,比较当前的线程标记是否是自己,如果是,就直接访问. 但如果是第二个线程想要来获取锁,发现线程标记不是自己,就会锁升级到轻量级锁,升级后,偏向锁改为 0,即关闭偏向锁 但是对于锁竞争比较激烈的场合，偏向锁就失效了，当每次申请锁的线程都是不相同的,每个线程都获得了偏向锁,就没有了偏向锁的效果了 偏向锁失败后，会升级为轻量级锁 轻量级锁当一个线程进入锁,有线程来争抢锁时,偏向锁升级为轻量级锁来争抢的线程会进入自旋,即循坏等待锁被释放,即自旋锁 轻量级锁所适应的场景是线程交替执行同步块的场合 如果存在同一时间多个线程访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 重量级锁重量级锁即 synchronized 实现的锁, 启用锁监视器 Monitor 对象线程自旋次数增加后升级到重量级锁, 停止自旋, 监视器启动, 监视器中的_owner 属性指向当前占有锁的线程, 锁升级是单向的,即从低到高,从轻到重,锁的等级是通过对象中的锁信息里的状态位来标识,而多线程争抢锁,就会改变这个状态位 锁消除锁消除即消除不必要的锁,或者缩小锁的范围","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Java锁","slug":"Java锁","permalink":"https://yimchengjie.github.io/tags/Java%E9%94%81/"}]},{"title":"使用volatile解决可见性问题及阻止指令重排序","slug":"Java并发编程/使用volatile解决可见性问题及阻止指令重排序","date":"2019-03-03T14:52:41.000Z","updated":"2020-02-26T15:14:27.764Z","comments":true,"path":"2019/03/03/Java并发编程/使用volatile解决可见性问题及阻止指令重排序/","link":"","permalink":"https://yimchengjie.github.io/2019/03/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BD%BF%E7%94%A8volatile%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E9%98%BB%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/","excerpt":"","text":"volatile 解决可见性问题volatile 关键字的作用之一，是系统每次使用被它修饰过的变量时都时直接从内存中提取，而不是从缓存 Cache 中提取，同时对于该变量的更改会马上刷新回主存，使得各个线程取出的值相同，这里的 Cache 可以理解为线程的工作内存。volatile 可以解决可见性问题，但无法解决原子性问题（synchronized 或其他的加锁，也能保证内存的可见性，但实现方式略有不同，volatile 的使用成本更低，因为它不会引起线程上下文的切换和调度。） volatile 原理对于 volatile 修饰的变量的写操作会有一行以 lock 作为前缀的汇编代码。这个指令在多核处理器下会引发两件事， 将当前处理器缓存行的数据写回到主内存； 这个写回内存的操作会使其他在 CPU 里缓存了该内存地址的数据无效(禁用缓存)lock 前缀的指令会锁住系统总线或者缓存，目的就是保证在同一时间只有一个 CPU 可以修改数据。 volatile 解决指令重排序问题volatile 的另外一个作用就是阻止指令重排序JVM 会在不改变数据依赖的前提下对指令进行任意排序以提高程序性能。如果不存在数据依赖性，处理器也可以改变语句对应机器指令的执行顺序； volatile 通过插入内存屏障来实现阻止指令重排序 happens-before 原则：它保证了程序的有序性，它规定如果两个操作的执行顺序无法从 happens-before 原则中推出来，那么它们就不能保证有序性，可以随意进行重排序： 总结: volatile 可以保证可见性和有序性,但不能保证原子性.","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"volatile","slug":"volatile","permalink":"https://yimchengjie.github.io/tags/volatile/"}]},{"title":"了解原子性CAS操作","slug":"Java并发编程/了解原子性CAS操作","date":"2019-03-03T06:13:07.000Z","updated":"2020-02-26T15:14:23.871Z","comments":true,"path":"2019/03/03/Java并发编程/了解原子性CAS操作/","link":"","permalink":"https://yimchengjie.github.io/2019/03/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%80%A7CAS%E6%93%8D%E4%BD%9C/","excerpt":"","text":"CAS 操作Atomic 相关的类采用 CAS 操作来实现原子性 CAS 操作依赖底层硬件的 CAS 指令,CAS 指令有两个步骤:冲突检测和更新操作,但是这两个步骤合起来成为 一个原子性操作 CAS 指令需要 3 个操作数,:内存位置(V),旧的预期值(A),新值(B).CAS 指令执行时,首先比较内存位置 V 处的值和 A 的值是否相等(冲突检测),如果相等,就用新值 B 覆盖 A(更新操作),否则,就什么都不做,所以一般循环执行 CAS 操作,直到成功为止. Unsafe 类里面的 compareAndSwapXXX 方法最后都会变成与硬件相关的 CAS 指令. 从 Unsafe 这个类名就可以看出, 作者不希望我们随便使用,因为这是不安全的,为什么不安全:因为这个类可以直接操作内存;还有其他的一些底层操作, 比如将线程挂起,就是调用了 Unsafe 类的 park 方法","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"原子性","slug":"原子性","permalink":"https://yimchengjie.github.io/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"}]},{"title":"Java并发编程基础","slug":"Java并发编程/Java并发编程基础","date":"2019-02-23T05:48:00.000Z","updated":"2020-02-26T15:28:01.785Z","comments":true,"path":"2019/02/23/Java并发编程/Java并发编程基础/","link":"","permalink":"https://yimchengjie.github.io/2019/02/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java 并发编程研究的是什么解决三个问题并发编程最先要解决的就是性能问题， 而引入多线程的概念带来了新的问题，即安全问题和活跃问题 1. 线程安全问题2. 活跃问题死锁、活锁、饥饿 3. 性能问题线程安全线程安全就是线程同步的意思，当一个线程对一个线程安全的方法或者语句进行访问的时候，其他的线程不能在对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问。 多个线程同时运行时，这些线程可能会同时运行一个方法，如果每次运行的结果和单个线程运行的结果时一样的，而且其他的变量的值也和预期一样，就是线程安全的。线程安全的问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而没有写操作，一般来说，这个全局变量时线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能会影响线程安全。 并发编程中的三大特性(重要概念)1. 原子性:Java 内存模型保证了 read，load，usee，assign，store，write，lock，unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load，store，read 和 write 操作可以不具备原子性。 原子性是指该操作是不可再分的.不论是多核还是单核,具有原子性的量,同一时刻只能有一个线程来对它进行操作.竞态条件是指通过一个可能失效的观测结果来决定下一步的动作,比如 A 拿到数据 n,将要执行++操作, 而 B 在 A 拿到数据后操作前, 做了一次 n=n+1, 那么在 A 对 n 完成+1 并写回 n 以后, B 对 n 的操作就失效了.原子操作是一个步骤,也可以是多个步骤,但是其顺序是不可以被打乱的,也不可以被切割而只执行其中的一部分(不可中断性)将操作视为一个整体,资源在该次操作中保持一致,这就是原子性的核心特征.原子操作是不会被线程调度机制打断的操作;这种操作一旦开始,就一直运行到结束,中间不会有任何 context switch(切换到另一个线程). 2. 可见性：可见性： 可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立刻看到。 CPU 从主存中读取数据的效率相对不高，现在主流的计算机中都会设有几级缓存，每个线程读取共享变量时，都会将该变量加载进其对应 CPU 的高速缓存中，修改变量后，CPU 会立刻更新缓存，但并不一定会立即将其写回主存（写进主存的时间不可预期），此时其他线程（尤其时不再同一 CPU 上执行的线程）访问该变量时，从主存中读到的就是酒数据，而非第一个线程更新后的数据。 这点实在操作系统或者说时硬件层面的机制，所以很多应用开发人员经常会忽略。 可见性就是要让一个 CPU 核心对数据的修改，对其他 CPU 核心立即可见。volatile 关键词修饰的变量是指 CPU 从缓存读取数据时，其他 CPU 可见,然后都会从内存中读取数据 3. 有序性：有序性: 是指在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序时因为发生了指令重排序。在 java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。volatile 关键字通过添加内存屏障的方式来禁止指令重排序，即重排序时不能把后面的指令放到内存屏障之前。也可以用 synchronized 来保证有序性， 它保证每个时刻只有一个线程可以执行同步代码，相当于是让线程顺序执行同步代码。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"内存模型","slug":"内存模型","permalink":"https://yimchengjie.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]},{"title":"JVM内存模型与内存区域","slug":"Java并发编程/JVM内存模型与内存区域","date":"2019-02-19T05:38:15.000Z","updated":"2020-02-26T15:30:15.585Z","comments":true,"path":"2019/02/19/Java并发编程/JVM内存模型与内存区域/","link":"","permalink":"https://yimchengjie.github.io/2019/02/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"JVM 内存模型 1.类装载子系统把 .class 文件装载运行时数据区（内存模型） 2.执行引擎去数据区执行字节码文件 JVM 内存区域1. 堆(共享)堆就是被所有线程共享的一块内存区域.这块内存区域的唯一目的就是存放内存实例.几乎所有对象实例都在这里分配内存.但不是所有对象都保存在堆中，如果 java 在必要的时候，可以把对象分配到栈中，从而自动销毁对象，那必然能减少一些垃圾回收的开销，同时提高执行效率。逃逸分析：它并不是直接优化代码的手段，而是为其他优化手段提高依据的分析技术，逃逸分析的主要作用就是分析对象的作用域。当一个对象在方法中被定义后，他可能被外部方法引用，例如作为调用参数传到其他方法，这种行为叫做方法逃逸。甚至该对象可能被外部线程访问到，例如赋值被类变量或可以在其他线程中访问的实例变量，称为线程逃逸，通过逃逸分析，把不逃逸的对象找出，并在栈中分配内存，那他就可以随着方法桢出栈而销毁。这样大量的对象就不需要存放在堆中，垃圾收集系统的压力也会变小很多。 线程共享的 Java 堆中可能还会为每个线程划分线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）,但存放的依旧是对象实例.对象被 new 出来的时候会同时生成一个对象头信息,其中有一个类指针,指向方法区中的类元信息对象创建的五种方式: new 关键字(调用了构造方法) User user=new User(); 利用反射机制(调用了构造方法) User user=User.class.newInstance(); 利用 Constructor 类的 newInstance()(调用了构造方法) Constructor&lt;User&gt; constructor=User.class.getConstructor(); User user=constructor.newInstance(); 使用 clone 方法(没有调用了构造方法) User user2=user1.clone(); 反序列化(没有调用了构造方法) ObjectInputStream in=new ObjectInputStream(new FileInputStream(&quot;user.obj&quot;)); User user=(User) in.readObject(); 对象创建的过程大致如下： 虚拟机遇到 new 指令，到常量池定位到到这个类的符号引用， 检查符号引用代表的类是否被加载、解析、初始化过，如果没有，那必须先执行相应的类加载过程 虚拟机为对象分配内存 虚拟机将分配到的内存空间都初始化为 0 值 虚拟机对对象进行必要的设置 执行方法，成员变量进行初始化新建出来的对象,存放在 Eden,当 Eden 存满,会触发 JVM 的 minor gc 命令,会把 Eden 中没有引用的对象清理掉, 这些对象被转移到 Survivor 取,并且每经历一次 minor gc 对象的分代年龄就会+1,当分代年龄达到 15,就会存放到老年代中,当老年代中的对象存满时,会执行 full gc,如果还是不能清理出内存空间,就会产生内存溢出 2. 栈（线程栈/虚拟机栈）(私有)虚拟机栈符合栈数据结构的特征，先进后出（主方法进站子方法再进栈，先执行子方法，子方法执行完出栈，最后主方法再出栈）。栈是线程私有的，每个线程有对应的独立栈区，它的生命周期与线程相同。栈是描述 Java 方法执行的内存模型，每个方法在执行的同时都会创建这个方法对应的栈帧，用于存储方法内部局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行完的过程就对应着一个栈桢在栈中入栈到出栈的过程。 栈帧内存模型： 局部变量表：存放了编译期可知的各种基本数据类型、以及对象变量和其对象的地址(指向堆中), 内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部空间是完全确定的. 操作数栈：存放操作数,遇到运算符取数据 动态链接：存放线程中每个方法的指令码的内存地址 方法出口：方法执行完要返回到父方法(线程)中的哪一条指令 3. 本地方法栈本地方法栈也是线程私有的,用于存放系统本地的方法,一般用于 java 访问系统中的 c 语言写的方法. 4. 方法区（元空间）(共享)方法区存放在系统内存中,不在 jvm 虚拟机的内存中.方法区存放常量,静态变量以及类元信息(类的方法,类的属性)运行时常量池是方法区的一部分,《Java 虚拟机规范》对于方法区的管理是最宽松的，这个区域可以不用实现垃圾回收，对于内存策略，方法区的大小可以是固定的也可以是可扩展的，不同的虚拟机对于方法区有不同的实现，HotSpot 虚拟机在 Java 8 之前，方法区仅仅是逻辑上的空间，物理上位于堆中的永久代中。Java 8 中 HotSpot 虚拟机移除了堆中的永久代，使用本地内存存储类元信息，称为元空间 5. 程序计数器(私有)程序计数器是线程私有的。存放线程正在执行或者将要执行的 JVM 指令存放的对应地址。 6.直接内存直接内存并不是虚拟机运行时数据区的一部分,也不是虚拟机规范中定义的内存区域,但也被频繁使用. JVM 内存间交互操作Java 内存模型中定义了 8 个操作来完成主内存和工作内存的交互操作. read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://yimchengjie.github.io/tags/JVM/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"线程池原理及应用","slug":"Java并发编程/线程池原理及应用","date":"2019-02-15T02:31:21.000Z","updated":"2020-02-26T15:26:25.339Z","comments":true,"path":"2019/02/15/Java并发编程/线程池原理及应用/","link":"","permalink":"https://yimchengjie.github.io/2019/02/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、为什么要使用线程池在一些需要使用线程去处理任务的业务场景中，如果每一个任务都创建一个线程去处理，任务处理完过后，把这个线程销毁，这样会产生大量的线程创建、销毁的资源开销，Java 中更是如此，虚拟机将试图跟踪每一个对象。以便可以在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能降低创建和销毁对象的次数。使用线程池能够有效的控制这种线程的创建和销毁，而且能够对创建的线程进行有效的管理。 使用线程池的好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会=降低系统稳定性，使用线程池可以进行统一分配、调优和监控。 线程池原理-概念 线程池管理器:用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务; 工作线程:线程池中线程,在没有任务时处于等待状态,可以循环的执行任务; 任务接口:每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入口,任务执行后的首尾工作,任务的执行状态等; 任务接口通常就是 Runable 接口,所以提交任务时,只要提交一个 Runable 的实现类就可以了 任务队列:用于存放没有处理的任务.提供一种缓存机制. 二、Java 线程池相关 API 介绍 Executor 接口主要是用来执行提交的任务。线程池会实现这个接口，并且使用 exectue 方法来提交一个任务。 ExecutorSevice 接口ExecutorService 接口是 Executor 接口的一个子接口，它在 Executor 接口的基础上增加了一些方法，用来支持对任务的终止管理以及对异步任务的支持。 AbstractExecutorService 抽象类AbstractExecutorService 实现了 ExcutorService，并且基于模板方法模式对一些方法给出了实现。是后面提到的线程池类 ThreadPoolExcutor 的直接父类。 ThreadPoolExcutor 类ThreadPoolExcutor 通常就是我们所说的线程池类，Java 的线程池就是用这个类进行创建的。在分析线程池的运行原理时，也是基于这个类来进行分析。 ScheduledExecutorService 接口ScheduledExecutorService 接口时 ExecutorService 子接口，定义了线程池基于任务调度的一些方法。 ScheduledThreadPoolExecutor 类ScheduledThreadPoolExecutor 集成了 ThreadPoolExecutor 类，并且实现了 ScheduledExecutorService 接口，对任务调度的功能进行了实现。 Executors 类Executors 可以认为是线程池的工厂类，里面提供了静态方法对线程池进行创建。 三、Java 线程池的运行原理1. 线程池的参数属性介绍核心线程数 corePoolSize：核心线程池数量。提交一个任务的时候，会对线程池里面的当前存活线程数量和这个 corePoolSize 进行比较，不同的情况下会有不同的操作。最大线程数 maximumPoolSize：线程池所能创建的线程的最大数量。空闲线程的超时时间 keepAliveTime：如果线程池当前的线程数大于 corePoolSize，并且这些线程中是有空闲线程的，也就是说这些线程没有在执行任务，那么空闲时间超过 keepAliveTime 时间，这些线程也会被销毁，指代前线程代数等于 corePoolsize，这时即便有空闲线程并且超时了，也不会进行线程销毁。任务队列 workQueue：这是一个阻塞队列，用于存储提交的任务。线程工厂 threadFactory：线程池会使用这个工厂类来创建线程，用户可以自己实现。任务的拒绝处理 handler（RejectedExeutionHandler）：在线程数已经达到了最大线程数，而且任务队列也满了以后，提交的任务会使用这个 handler 来处理，用户也可以自己实现。默认是抛出一个异常 RejectedExecutionException。 2. 线程池运行原理分析分析当用户提交一个任务时，线程池内部使如何运行的。 创建一个线程池，在还没有任务提交的时候，默认线程池里面是没有线程的。当然，可以调用 prestartCoreThread 方法，来预先创建一个核心线程。 线程池里面还没有线程或者线程池里面存活的线程数小于核心线程数 corePoolSize 时，这时对于一个新提交的任务，线程池会创建一个线程去处理提交的任务。当线程池里面存活的线程数小于等于核心线程数 corePoolSize 时，线程池里面的线程会一直存活着，就算空闲时间超过了 keepAliveTime，线程也不会被销毁，而是一直阻塞在那里一直等待任务队列的任务来执行。 当线程池里面存活的线程数已经等于 corePoolSize 了，这时对于一个新提交的任务，会被放进任务队列 workQueue 排队等待执行。而之前创建的线程并不会被销毁，而是不断的去拿阻塞队列里面的任务，当任务列表为空时，线程会阻塞，直到有任务被放进任务队列，线程拿到任务后继续执行，执行完了以后继续去拿任务，这也是为什么线程池队列要使用阻塞队列。 当线程池里面存活的线程数已经等于 corePoolSize 了，并且任务队列也满了，这里假设 maximumPoolSize&gt;corePoolSize（如果等于的话，就直接拒绝了），这时如果再来新的任务，线程池就会继续创建新的线程来处理新任务，直到线程数达到 maximumPoolSize，就不会再创建了。这些新创建的线程执行完了当前任务后，再任务队列里面还有任务的时候也不会销毁，而是去任务队列拿任务出来执行。在当前线程数大于 corePoolSize 过后，线程执行完当前任务，会有一个判断当前线程是否需要销毁的逻辑；如果能从任务队列中拿到任务，那么继续执行，如果拿任务时阻塞（说明队列中没有任务），那超过 keepAliveTime 时间就直接返回 null 并且销毁当前线程，直到线程池里面的线程数等于 corePoolSize 之后才不会进行线程销毁。 如果当前线程数达到了 maximumPoolSize，并且任务队列也满了，这种情况下还有新的任务过来，那就直接采用拒绝的处理器进行执行，默认的处理器逻辑时抛出一个 RejectedExcutionException 异常。你也可以指定其他的处理器，或者自定义一个拒绝处理器来实现拒绝逻辑的处理（比如把任务存储起来）。JDK 提供了四种拒绝策略处理类；AbortPolicy（抛出一个异常，默认的），DiscardPolicy（直接丢弃任务），DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池），CallerRunPolicy（交给线程池调用的所在线程进行处理）。 3. 线程池包含以下四个基本组成部分： 线程池管理器（ThreadPool）：用于创建并管理线程池。包含创建线程池，销毁线程池，加入新任务； 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态。能够循环的运行任务。 任务接口（Task）：每一个任务必须实现的接口，以供工作线程调度任务的运行。它主要规定了任务的入口。任务运行完成后的收尾工作，任务的运行状态等。 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 4. 常用的几种线程池以及使用场景 SingleThreadExecutor:单个线程的线程池这种线程池主要适用于请求量非常小的场景，或者离线的数据处理等，只需要一个线程就够了。在持续的请求量比较大的情况下，不要使用这种线程池，单线程处理会使队列不断变大，最终可能导致内存溢出。 FixedThreadPool：固定线程大小线程池这种线程的额 corePoolSize 和 maximumPoolSize 是相等的，keepAliveTime 设置为 0，队列用的是 LinkedBlockingQueue 无界队列。适用于流量比较稳定的情况，不会说一段时间突然有大量的流量涌入，导致 LinkedBlockingQueue 越来越大最后导致内存溢出。 CachedThreadPool：按需求创建线程数量线程池这种线程的 corePoolSize=0，maximumPoolSize 是 Integer.MAX_VALUE，keepAliveTime 为 60 秒，队列使用 SynchronousQueue 同步队列，这个队列可以理解为没有容量的阻塞队列，只有有别的线程来拿任务时，当前线程才能插入成功，反过来也一样。所以这种线程池任务队列时不存任务的，任务全靠创建新的线程来处理，处理完了以后线程空闲超过 60 秒就会被自动销毁，所以这种线程池适合有一定高峰流量的场景。但是还是要慎用，如果瞬时流量过高会导致创建的线程过多，直接导致服务所在机器的 CPU 负载过高，然后卡死，所以使用这种线程池必须指代最高峰时的流量也不会导致 CPU 负载过高。 ScheduledThreadPoolExecutor：任务调度线程池可以根据自己的需求，使用单线程调度（SingleThreadExecutor）,多线程调度（ScheduledThreadPool）。不过现在使用 spring 调度比较多，所以开发中比较少用。 自定义线程池（推荐使用）根据实际的一个业务场景，自己 new 一个 ThreadPoolExecutor，参数根据业务场景需要指定合适的参数，比如核心线程数设置多少合适，最大线程数设置多少合适，任务队列设置多大的有界合适，拒绝策略也可以自定义，一般采用离线存储啥的，完全根据业务场景来定制。这样可以保证不会发生无界队列导致内存溢出，也不会导致创建的线程过多而导致机器卡死。 5. 线程池关闭 shutdown():调用后不允许提交新任务，所有调用之前提交的任务都会执行，等所有任务执行完，才会真正关闭线程池。 shutdownNow():强制关闭。返回还没有执行的 task 列表，然后不让等待的 task 执行，尝试停止正在执行的 task。 线程池的使用案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/** 线程池的使用 */public class Demo &#123; /** * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况 * * @param threadPoolExecutor 传入不同的线程池，看不同的结果 * @throws Exception */ public void testCommon(ThreadPoolExecutor threadPoolExecutor) throws Exception &#123; // 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况 for (int i = 0; i &lt; 15; i++) &#123; int n = i; threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"开始执行：\" + n); Thread.sleep(3000L); System.err.println(\"执行结束:\" + n); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println(\"任务提交成功 :\" + i); &#125; // 查看线程数量，查看队列等待数量 Thread.sleep(500L); System.out.println(\"当前线程池线程数量为：\" + threadPoolExecutor.getPoolSize()); System.out.println(\"当前线程池等待的数量为：\" + threadPoolExecutor.getQueue().size()); // 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁） Thread.sleep(15000L); System.out.println(\"当前线程池线程数量为：\" + threadPoolExecutor.getPoolSize()); System.out.println(\"当前线程池等待的数量为：\" + threadPoolExecutor.getQueue().size()); &#125; /** * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest1() throws Exception &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); testCommon(threadPoolExecutor); // 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行 &#125; /** * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest2() throws Exception &#123; // 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。 // 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.err.println(\"有任务被拒绝执行了\"); &#125; &#125;); testCommon(threadPoolExecutor); // 预计结果： // 1、 5个任务直接分配线程开始执行 // 2、 3个任务进入等待队列 // 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁) // 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。 // 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程 &#125; /** * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒 * * @throws Exception */ private void threadPoolExecutorTest3() throws Exception &#123; // 和Executors.newFixedThreadPool(int nThreads)一样的 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); testCommon(threadPoolExecutor); // 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行 &#125; /** * 4、 线程池信息： * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒 * * @throws Exception */ private void threadPoolExecutorTest4() throws Exception &#123; // SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。 // 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时， // 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务， // 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。 // 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。 // 和Executors.newCachedThreadPool()一样的 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); testCommon(threadPoolExecutor); // 预计结果： // 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行 // 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0 Thread.sleep(60000L); System.out.println(\"60秒后，再看线程池中的数量：\" + threadPoolExecutor.getPoolSize()); &#125; /** * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/&gt; * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒 * * @throws Exception */ private void threadPoolExecutorTest5() throws Exception &#123; // 和Executors.newScheduledThreadPool()一样的 ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5); threadPoolExecutor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"任务被执行，现在时间：\" + System.currentTimeMillis()); &#125; &#125;, 3000, TimeUnit.MILLISECONDS); System.out.println( \"定时任务，提交成功，时间是：\" + System.currentTimeMillis() + \", 当前线程池中线程数量：\" + threadPoolExecutor.getPoolSize()); // 预计结果：任务在3秒后被执行一次 &#125; /** * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/&gt; * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒 * * @throws Exception */ private void threadPoolExecutorTest6() throws Exception &#123; ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5); // 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。 // 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别 // 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。 // 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待） threadPoolExecutor.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"任务-1 被执行，现在时间：\" + System.currentTimeMillis()); &#125; &#125;, 2000, 1000, TimeUnit.MILLISECONDS); // 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。 // 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1） threadPoolExecutor.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"任务-2 被执行，现在时间：\" + System.currentTimeMillis()); &#125; &#125;, 2000, 1000, TimeUnit.MILLISECONDS); &#125; /** * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest7() throws Exception &#123; // 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。 // 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.err.println(\"有任务被拒绝执行了\"); &#125; &#125;); // 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况 for (int i = 0; i &lt; 15; i++) &#123; int n = i; threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"开始执行：\" + n); Thread.sleep(3000L); System.err.println(\"执行结束:\" + n); &#125; catch (InterruptedException e) &#123; System.out.println(\"异常：\" + e.getMessage()); &#125; &#125; &#125;); System.out.println(\"任务提交成功 :\" + i); &#125; // 1秒后终止线程池 Thread.sleep(1000L); threadPoolExecutor.shutdown(); // 再次提交提示失败 threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"追加一个任务\"); &#125; &#125;); // 结果分析 // 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行 // 2、调用shutdown后，不接收新的任务，等待13任务执行结束 // 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行 &#125; /** * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的 * * @throws Exception */ private void threadPoolExecutorTest8() throws Exception &#123; // 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。 // 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.err.println(\"有任务被拒绝执行了\"); &#125; &#125;); // 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况 for (int i = 0; i &lt; 15; i++) &#123; int n = i; threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"开始执行：\" + n); Thread.sleep(3000L); System.err.println(\"执行结束:\" + n); &#125; catch (InterruptedException e) &#123; System.out.println(\"异常：\" + e.getMessage()); &#125; &#125; &#125;); System.out.println(\"任务提交成功 :\" + i); &#125; // 1秒后终止线程池 Thread.sleep(1000L); List&lt;Runnable&gt; shutdownNow = threadPoolExecutor.shutdownNow(); // 再次提交提示失败 threadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"追加一个任务\"); &#125; &#125;); System.out.println(\"未结束的任务有：\" + shutdownNow.size()); // 结果分析 // 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行 // 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止 // 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行 &#125; public static void main(String[] args) throws Exception &#123;// new Demo().threadPoolExecutorTest1();// new Demo().threadPoolExecutorTest2();// new Demo().threadPoolExecutorTest3();// new Demo().threadPoolExecutorTest4();// new Demo().threadPoolExecutorTest5();// new Demo().threadPoolExecutorTest6();// new Demo().threadPoolExecutorTest7(); new Demo().threadPoolExecutorTest8(); &#125;&#125;","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"线程封闭之ThreadLocal和栈封闭","slug":"Java并发编程/线程封闭之ThreadLocal和栈封闭","date":"2019-01-29T13:25:59.000Z","updated":"2020-02-26T15:26:46.768Z","comments":true,"path":"2019/01/29/Java并发编程/线程封闭之ThreadLocal和栈封闭/","link":"","permalink":"https://yimchengjie.github.io/2019/01/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%E4%B9%8BThreadLocal%E5%92%8C%E6%A0%88%E5%B0%81%E9%97%AD/","excerpt":"","text":"线程封闭线程不安全是因为多线程在访问共享的可变数据时,会发生数据的不一致,结果不正确. 实现好的并发是一件困难的事情, 那么如何解决呢,一个是使用同步,但是同步需要占用资源,另外一种方式,如果一个线程访问这个数据,就不会出现问题, 所以很多时候我们都想躲避并发. 避免并发最简单的方法就是线程封闭. 什么是线程封闭; 就是把对象封装到一个线程里,只有这个线程能看到此对象. 那么这个对象就算不是线程安全的也不会出现任何问题. 线程封闭的实现方式 Ad-hoc : 维护线程封闭性的职责完全由程序实现来承担,是非常脆弱的, 因为没有任何一种语言特性, 能将对象封闭到目标线程上. 栈封闭 : 简单的来说就是局部变量. 多个线程访问一个方法,此方法中的局部变量都会拷贝一份到线程栈中,. 所以局部变量是不被多个线程所共享,也就不会出现并发问题,所以能用局部变量就别用全局变量, 全局变量容易引起并发问题. ThreadLocal 封闭 : 使用ThreadLocal 是实现线程封闭的最好方法. ThreadLocal 内部维护了一个 Map, Map 的 key 是每个线程对象,而 Map 的值就是我们要封闭的对象(数据) . 每个线程中的对象都对应这 Map 中的一个值, 也就是 ThreadLocal 利用 Map 实现了对象的线程封闭. ThreadLocalThreadLocal 是 Java 中的一种特殊变量它是一个线程级别的变量,每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了,在并发模式下是绝对安全的变量.用法: ThreadLocal&lt;T&gt; var=new ThreadLocal&lt;T&gt;();会自动在每一个线程上创建一个 T 的副本,副本之间彼此独立,互不影响.可以再 ThreadLocal 中存储一些参数,以便在线程中多个方法中使用, 用来代替方法传参的做法.","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java线程通信","slug":"Java并发编程/Java线程通信","date":"2019-01-23T02:19:49.000Z","updated":"2020-02-26T15:28:46.467Z","comments":true,"path":"2019/01/23/Java并发编程/Java线程通信/","link":"","permalink":"https://yimchengjie.github.io/2019/01/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"概述线程与线程之间不是相互独立的个体，它们彼此之间需要相互通信和写作，最典型的例子就是生产者-消费者问题：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。 线程之间的通信有以下 文件共享 网络共享 共享变量 jdk 提供的线程协调 API 1. 文件共享线程 1 写入文件 a.txt,线程 2 从 a.txt 中读取数据 3. 变量共享线程 1 写入公共变量线程 2 从公共变量读取数据 4. jdk 提供的线程协调 API多线程协作的典型场景:生产者-消费者模型 示例:线程 1 去买包子,没有包子,则不再执行.线程 2 生产出包子,通知线程 1 继续执行 jdk 已弃用的 suspend/resume 挂起和唤醒被弃用的主要原因是,容易写出死锁的代码, 在同步代码中使用,suspend 挂起不会释放锁,产生死锁 suspend 一定要在 resumee 之前执行,否则 wait/notify 机制在这之前，线程间通过共享数据来实现通信，即多个线程主动地读取一个共享数据，通过同步互斥访问机制来保证线程的安全性。等待/通知机制主要由 Object 类中的 wait()、notify()和 notifyAll()三个方法来实现，这三个方法均非 Thread 中所申明的方法，而是 Object 类中申明的方法。原因是每个对象都拥有 monitor（锁），所以让但却概念线程等待某个对象的锁，当然应该通过这个对象来操作，而不是当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作就会非常复杂。wait()——让当前线程释放对象锁并进入等待（阻塞）状态notify()——唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到 CPU 的执行。notifyAll()——唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到 CPU 的执行。 这些方法只能由同一对象锁的持有者线程调用,也就是必须写在同步块里,否则会抛出 illegalMonitorStateException wait 会自动解锁,但对顺序调用还是有需求.不能再 notify 后调用 锁对象每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待 CPU 的调度，反之，当一个线程被 wait 之后，就会进入阻塞队列，等待被唤醒。 park/unpark 机制线程调用 park 则等待”许可”,unpark 为指定线程提供”许可” 不要求 park 和 unpark 方法的调用顺序多次调用 unpark,再调用 park,线程会直接运行,但不会叠加, 连续多次调用 park,只有第一次能拿到”许可”虽然没有顺序要求,但是 park 不会释放锁 注意: 不要使用 if 语句来判断,是否进入等待状态,应该在循环中检测等待条件, 原因是处于等待状态的线程可能会收到错误警报和伪唤醒,如果不在循环条件中检查等待条件,程序就会在没有满足结束条件的情况下退出.","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"CPU多级缓存","slug":"Java并发编程/CPU多级缓存","date":"2019-01-15T10:31:16.000Z","updated":"2020-02-26T15:26:56.666Z","comments":true,"path":"2019/01/15/Java并发编程/CPU多级缓存/","link":"","permalink":"https://yimchengjie.github.io/2019/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"CPU 多级缓存 cache 带来的问题cache 给系统带来性能上飞跃的同时，也引入了新的问题“缓存一致性问题”。设想如下场景（cpu 一共有两个核，core1 和 core2）： 以 i++为例，i 的初始值是 0.那么在开始每个核都存储了 i 的值 0，当第 core1 块做 i++的时候，其缓存中的值变成了 1，即使马上回写到主内存，那么在回写之后 core2 缓存中的 i 值依然是 0，其执行 i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是 1，而不是预期中的 2。 缓存一致性为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有 MSI，MESI，MOSI 等。我们介绍其中最经典的 MESI 协议。在 MESI 协议中，每个 cache line 有 4 个状态，可用 2 个 bit 表示，它们分别是：|状态| 描述||:–:|:–:||M(Modified)| 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中。||E(Exclusive)| 这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中。||S(Shared)| 这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中。||I(Invalid)| 这行数据无效| 当前状态 事件 行为 下一状态 I(Invalid) Local Read 如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E； 如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S； 如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S E/S Local Write 从内存中取数据，在Cache中修改，状态变成M； 如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存； 如果其它Cache有这份数据，则其它Cache的Cache line状态变成I M Remote Read 既然是Invalid，别的核的操作与它无关 I Remote Write 既然是Invalid，别的核的操作与它无关 I E(Exclusive) Local Read 从Cache中取数据，状态不变 E Local Write 修改Cache中的数据，状态变成M M Remote Read 数据和其它核共用，状态变成了S S Remote Write 数据被修改，本Cache line不能再使用，状态变成I I S(Shared) Local Read 从Cache中取数据，状态不变 S Local Write 修改Cache中的数据，状态变成M， 其它核共享的Cache line状态变成I M Remote Read 状态不变 S Remote Write 数据被修改，本Cache line不能再使用，状态变成I I M(Modified) Local Read 从Cache中取数据，状态不变 M Local Write 修改Cache中的数据，状态不变 M Remote Read 这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S S Remote Write 这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据， 状态变成I I 指令重排序指令重排场景:当 CPU 写缓存时发现缓存区块正被其他 CPU 占用,为了提高 CPU 处理性能,可能将后面的读缓存命令优先执行，那么问题来了，那些指令不是在所有场景下都能进行重排，除了本身的一些规则之外，我们还需要确保多 CPU 的高速缓存中的数据与内存保持一致性，不能确保内存与 CPU 缓存数据一致性的指令也不能重排，内存屏障正式通过阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化而提出的一种解决办法。 内存屏障处理器提供了两个内存屏障指令用于解决以上问题 写内存屏障(Store Memory Barrier)能让写入缓存中的最新数据更新写入主内存, 让其他线程可见 读内存屏障(Load Memory Barrier)让高速缓存中的数据失效,强制重新从主内存加载数据 volatileJAVA 中的 volatile 关键字正是使用了内存屏障。如果字段是 volatile，java 内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着，如果你对一个 volatile 字段进行写操作，你必须知道： 一旦你完成写入，任何访问这个字段的线程将会得到最新的值。 在你写入前，会保证所有之前发生的事已发生，并且任何更像过的数据值也是可见的。因为内存屏障会把之前的写入值都刷新到缓存。 注意: 内存屏障会导致不可以尽可能地高校利用 CPU，另外刷新缓存亦会有开销。所以不要以为用 volatile 代替锁操作就一点事都没有。","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://yimchengjie.github.io/tags/cache/"},{"name":"内存屏障","slug":"内存屏障","permalink":"https://yimchengjie.github.io/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"}]},{"title":"Java线程状态和线程中止","slug":"Java并发编程/Java线程状态和线程中止","date":"2019-01-09T01:19:46.000Z","updated":"2020-02-26T15:29:39.288Z","comments":true,"path":"2019/01/09/Java并发编程/Java线程状态和线程中止/","link":"","permalink":"https://yimchengjie.github.io/2019/01/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A2/","excerpt":"","text":"线程中止 设置标记位(受限与线程中业务逻辑有循环条件)thread.setFlag(false); 使用 stop()，不安全，已经被废弃thread.stop()，因为 stop()方法会解除由线程获得的所有锁，当在一个线程对象上调用 stop()方法时，这个线程对象所运行的线程会立即停止 使用 Thread 类的 interrupt() 方法中断线程调用 interrupt()方法只会给线程设置一个为 true 的终端标志，而设置之后，则根据线程当前状态进行不同的后续操作 线程的五大状态及其转换线程的五大状态分别为:创建状态（new）、就绪状态（Runnable）、运行状态（Running）、阻塞状态（Blocked）、死亡状态（Dead）。 五大状态之间的关系图： （1）新建状态：即单纯的创建一个线程创建线程有三种方式；1.集成 Thread 类创建线程使用集成 Thread 类创建线程时，首先需要创建一个类集成 Thread 类并覆写 Thread 类run()方法，在 run()方法中，需要写线程要执行的任务但是调用 run()方法并不是真正的启动一个线程，真正的启动线程，需要调用的时 Thread 类的 start()方法，而 start()方法会自动调用 run()方法，从而启动一个线程。说明： main 方法其实也是一个线程，是该进程的主线程。但是在使用多线程技术时，代码的运行结果与代码调用的顺序无关，因为线程是一个子任务，CPU 以不确定的方式或者说以随机的时间来调用线程中的 run()方法，所以会出现每次运行结果不同的情况。 2.实现 Runnable 接口创建线程Thread 类的核心功能就是进行线程的启动，但一个类为了实现多线程直接取继承 Thread 类时出现的问题就是：单集成的局限性！所以 Java 中还提供了另一种实现多线程的方法：实现 Runnable 接口来创建多线程。注意： 启动一个线程的唯一方法就是调用 Thread 类的 start()方法，抓住这点去建立与 Thread 类之间的关系。Runnable 接口中只有一个抽象方法就是 run()方法。那怎么使用 Runnable 接口去创建线程呢？（如何执行 start()方法呢）第一步：定义一个类实现 Runnable 接口的抽象方法 run()方法。 此时 Thread 类有一个 Thread 类的构造方法 public Thread(Runnable target)方法，参数用于接收 Runnable 接口的实例化对象，所以在 Runnable 接口与 Thread 类之间就建立起了联系，从而可以调用 Thread 类的 start()方法启动一个线程。所以第二步：利用 Thread 类的 public Thread(Runnable target)构造方法与 Runnable 接口建立关系实例化 Thread 类的对象；第三步：调用 Thread 类的 start()方法启动线程。 3.实现 Callable 接口创建线程Runnable 接口的 run()方法没有返回值，而 Callable 接口中的 call()方法有返回值，若某些线程执行完成后需要一些返回值的时候，就需要用 Callable 接口创建线程。再次强调：启动一个线程的唯一方法就是调用 Thread 类的 start()方法，那么，要想通过实现 Callable 接口创建线程，就需要找到 Callable 接口与 Thread 类之间的关系。首先 FutureTask 类提供了构造方法 public FutureTask(Callable&lt;V&gt; callable)方法，而 FutureTask 类又实现了 RunnableFuture 接口，而 RunnableFuture 接口又继承了 Runnable 接口，再通过 public Thread(Runnable runnable)构造方法，使 Callable 接口与Thread 类之间建立了联系。 所以使用 Callable 接口创建线程的步骤如下： 1234567891011121314151617181920212223242526// 1.定义一个类MyThread实现Callable接口，从而覆写call()方法class MyThread implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; return \"Callable接口创建线程\"; &#125;&#125;public static void main(String[] args) throws InterruptedException,ExecutionException &#123; //2.利用MyThread类实例化Callable接口的对象 Callable callable=new MyThread(); //3.利用FutureTask类的构造方法public FutureTask(Claaable&lt;V&gt;callable) //将Callable接口的对象传给FutureTask类 FutureTask task=new FutureTask(callable); //4.将FutureTask类的对象隐式地向上转型 //从而作为Thread类的public Thread(Runnable runnable)构造方法的参数 Thread thread=new Thread(task); //5.调用Thread类的start()方法 thread.start(); //FutureTask的get()方法用于获取FutureTask的call()方法的返回值，为了取得线程的执行结果 System.out.println(task.get());&#125; （2）就绪状态在创建了线程之后，调用了 Thread 类的 start()方法来启动一个线程，即表示线程进入了就绪状态！ （3）运行状态当线程获得 CPU 时间，线程才从就绪状态进入到运行状态！ （4）阻塞状态线程进入运行状态后，可能由于多种原因让线程进入阻塞状态，如：调用 sleep()方法，让线程睡眠，调用 wait()方法让线程等待，调用 join()方法以及阻塞式 IO 方法 阻塞情况分为三种：（一）等待阻塞：运行中（running）的线程执行 o.wait()方法，JVM 会把该线程放入等待队列（waiting queue）中。（二）同步阻塞：运行中（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池（lock pool）中。（三）其他阻塞：运行中（running）的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行状态。 阻塞方法的异同： sleep、yield 方法是静态方法；作用是当前执行的线程； yield 方法释放了 cpu 的执行权，但是保留了争夺 cpu 的资格，这也意味着，该线程可能马上会再次执行。yield()只能使同优先级或更高优先级的线程有执行的机会。 wait 释放 CPU 资源，同时释放锁，只有执行 notify/notifyAll()时，才会唤醒处于等待的线程，然后继续往下执行，直到执行完 synchronized 代码块的代码火种中途再次遇到 wait()。一般配合 synchronized 关键字使用，即，一般在 synchronized 同步代码块中使用 wait()、notify/notifyAll 方法。 sleep 释放 CPU 资源，但不释放锁 join 把调用该方法的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程 B 中调用了线程 A 的 join()方法，直到线程 A 执行完毕后，才会继续执行线程 B （5）死亡状态run()方法的正常退出，就是让线程进入到死亡状态，还有当一个异常未被捕获而终止了 run()方法的执行也会进入到死亡状态！ 设置或获取多线程的线程名称的方法由于在一个进程中可能有多个线程，而多线程的运行状态又是不确定的，所以在多线程操作中需要有一个明确的标识符标识出当前线程对象的信息，这个信息往往通过线程的名称来描述。在Thread 类中提供了一些设置或者获取线程名称的方法： 创建线程时设置线程的名称；public Thread(Runnable target,String name) 设置线程名称的普通方法；public final synchronized void setName(String name) 取得线程名称的普通方法；public final String getName()","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Vue项目搭建","slug":"Vue.js/Vue项目搭建","date":"2018-12-16T11:39:42.000Z","updated":"2019-11-15T04:56:12.886Z","comments":true,"path":"2018/12/16/Vue.js/Vue项目搭建/","link":"","permalink":"https://yimchengjie.github.io/2018/12/16/Vue.js/Vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Vue项目实战做一个简单的Vue前端项目,练习与巩固知识点,做一个总结 前期准备node环境github+git项目管理 项目创建 在github上创建一个仓库,作为本次项目仓库然后clone到本地 命令行工具初始化一个Vue项目前提:先安装好vue脚手架(全局), 可以使用vue命令进入项目根目录,然后执行vue init webpack初始化一个vue 尝试启动项目运行npm run dev命令,访问成功,一个vue的demo创建完成 项目结构src项目源代码结构业务开发根目录 main.js — 项目入口文件 App.vue — 项目原始根组件 router index.js — 项目路由 components — 项目中的组件 assests — 项目中的图片资源文件 config配置文件夹 index.js — 基础配置文件 dev.env.js — 开发环境 prod.env.js — 上线环境 build项目打包的webpack的配置内容一般也不需要修改 .vue文件结构.vue是一种单文件组件 12345678910111213141516171819202122232425262728&lt;!-- Vue单组件文件 --&gt;&lt;!-- 组件模板 --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 组件逻辑 --&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;!-- 组件样式 --&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 引入fastclick第三方模块引入fastclick包解决有些浏览器延迟300ms响应click事件的问题npm install fastclick --save 引入Element模板库npm i element-ui -S npm安装,这样可以和webpack更好的结合然后在main.js中导入 12345// 引入elementimport ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'// 全局使用Vue.use(ElementUI);","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"Vue的Ajax(axios)","slug":"Vue.js/Vue的Ajax-axios","date":"2018-11-14T03:15:38.000Z","updated":"2020-02-24T12:39:15.922Z","comments":true,"path":"2018/11/14/Vue.js/Vue的Ajax-axios/","link":"","permalink":"https://yimchengjie.github.io/2018/11/14/Vue.js/Vue%E7%9A%84Ajax-axios/","excerpt":"","text":"Vue 的 Ajax(axios)Vue 推荐使用 axios 来完成 ajax 请求 Axios 是一个基于 Promise 的 HTTP 库,可以在浏览器或者 Node 中使用 简单的 Axios 实例123456789101112131415161718axios(&#123; method: \"post\", url: \"/user/12345\", data: &#123; firstName: \"Fred\", lastName: \"Flintstone\" &#125;&#125;);// GET 请求远程图片axios(&#123; method: \"get\", url: \"http://bit.ly/2mTM3nY\", responseType: \"stream\"&#125;).then(function(response) &#123; response.data.pipe(fs.createWriteStream(\"ada_lovelace.jpg\"));&#125;);// 发送 GET 请求（默认的方法）axios(\"/user/12345\"); 请求方法的别名axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 请求结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111axios(&#123; // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 //修改完后再提交 return data; &#125;], transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 // 修改完后再响应 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;\"X-Requested-With\": \"XMLHttpRequest\"&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: \"brackets\"&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: \"Fred\" &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求花费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: \"janedoe\", password: \"s00pers3cret\" &#125;, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // 默认的 &#125;, // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: \"127.0.0.1\", port: 9000, auth: : &#123; username: \"mikeymike\", password: \"rapunz3l\" &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125;) 响应结构12345678910111213141516axios(&#123;&#125;).then(function(res) &#123; // `data` 由服务器提供的响应 console.log(response.data); // `status` HTTP 状态码 console.log(response.status); // `statusText` 来自服务器响应的 HTTP 状态信息 console.log(response.statusText); // `headers` 服务器响应的头 console.log(response.headers); // `config` 是为请求提供的配置信息 console.log(response.config);&#125;);","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"Vue路由","slug":"Vue.js/Vue路由","date":"2018-11-02T02:51:54.000Z","updated":"2019-11-15T04:56:04.292Z","comments":true,"path":"2018/11/02/Vue.js/Vue路由/","link":"","permalink":"https://yimchengjie.github.io/2018/11/02/Vue.js/Vue%E8%B7%AF%E7%94%B1/","excerpt":"","text":"Vue路由Vue路由允许我们通过不同的URL访问不同的内容以前都是在服务端对路由进行划分,不同路由处理不同的请求现在前端的路由可以实现在不重新请求页面的情况下,改变URL展示不同的页面内容 利用Vue.js + vue.router可以实现单页应用 传统多页应用和单页应用对比多页应用 优点: 首页响应快 缺点: 页面切换慢 单页应用 优点: js动态切换页面,无需再请求html文件 缺点: 首页加载慢 Vue.routervue.router是Vue官方的路由插件路由引入的就是模板 &lt;rout-link&gt;使用&lt;rout-link&gt;标签,引入定义好的路由 &lt;router-view&gt;&lt;router-view&gt;区域用来显示路由匹配到的组件 路由的创建定义路由 1234const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;] 创建路由实例 1234const router = new VueRouter(&#123; el:\"#app\", routes:routes&#125;)","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"Vue实例详解","slug":"Vue.js/Vue实例详解","date":"2018-10-20T02:20:51.000Z","updated":"2019-11-15T04:56:09.330Z","comments":true,"path":"2018/10/20/Vue.js/Vue实例详解/","link":"","permalink":"https://yimchengjie.github.io/2018/10/20/Vue.js/Vue%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Vue属性每一个Vue实例都拥有一些属性，比如之前的el、data、methods等还有一些其他的属性 el属性用于绑定id，指示Vue的作用范围 data属性Vue的数据属性，用来定义Vue中的数据 methods方法属性，一般的逻辑方法都写在这里 computed计算属性，定义计算属性，也是函数方法，和methods类似，但是基于它的依赖缓存，可以说computed性能更好，但不需要缓存时，可以使用methods watch监听属性，可以通过watch来响应数据的变化，每当监听的变量改变，就调用方法函数 components组件属性,用于注册组件注意:在一个Vue实例内部注册的组件,只有这个Vue的作用范围内可以使用 directives自定义指令注意:在一个Vue实例内部注册的自定义指令,只有这个Vue的作用范围内可以使用 Vue方法Vue实例内部定义了8个方法,涵盖了一个Vue的生命周期 初始化 beforeCreate() Vue实例被创建后,但为空,内部数据和方法都还没有初始化 created() 内部数据和方法初始化已经完成 beforeMount() Vue模板已经编译好,但还没有挂载到页面 mounted() 模板挂载完成 更新 beforeUpdate() 页面的数据还是旧的数据,没有同步为最新的data数据 updated() 页面的数据已经更新到最新的data数据了 销毁 beforeDestory() Vue即将销毁,但当前的数据和方法都还是可用状态 destoryed() Vue已经销毁,所有数据和方法都不可用了","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"webpack基础","slug":"前端基础/webpack基础","date":"2018-10-13T06:22:50.000Z","updated":"2020-02-26T14:52:58.599Z","comments":true,"path":"2018/10/13/前端基础/webpack基础/","link":"","permalink":"https://yimchengjie.github.io/2018/10/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/webpack%E5%9F%BA%E7%A1%80/","excerpt":"","text":"webpackwebpack 是一个现代的 JavaScript 应用程序的静态模块打包器,当 webpack 处理应用程序时,它会递归的构建一个依赖关系,然后将模块打包成一个或多个 bundlewebpack 有四个核心概念:entry,output,loader,plugins entryentry(入口)之时 webpack 应该使用哪个模块,来作为构建内部依赖的开始 123456789//单个入口语法const config = &#123; entry: \"./src/main.js\"&#125;;//对象语法const config = &#123; app: \"./src/main.js\", vendors: \"./src/vendors.js\"&#125;; outputoutput 属性会告诉 webpack 在哪里输出 bundle,以及如何命名,默认设置./list 1234567const config=&#123; entry:\"./src/main.js\" output:&#123; filename:\"bundle.js\", path:path.resolve(_dirname,'dist') &#125;&#125; loaderloader 让 webpack 可以处理那些非 JavaScript 的文件,例如开发 ES6 时,通过 loader 将 ES6 语法转成 ES5 1234567891011121314151617const config = &#123; entry: \"./src/main.js\", output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: [(presets: [\"env\"])] &#125; ] &#125;&#125;; pluginsloader 被用于转换某些类型的模块,而插件则可以做更多的事,包括打包优化,压缩,定义环境变量等等 1234567891011121314151617// 通过 npm 安装const HtmlWebpackPlugin = require(\"html-webpack-plugin\");// 用于访问内置插件const webpack = require(\"webpack\");const config = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\" &#125; ] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;)]&#125;; webpack 基本配置1234567891011121314151617181920212223242526const path = require('path');module.exports = &#123; mode: \"development\", // \"production\" | \"development\" // 选择 development 为开发模式， production 为生产模式 entry: \"./src/main.js\", output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\", options: [ presets: [\"env\"] ] &#125; ] &#125;, plugins: [ ... ]&#125; webpack 新建项目前提有 node.js 环境 进入项目根目录执行 npm init -y创建默认 package.json 文件, -y 表示使用默认配置 npm install webpack webpack-cli –save-dev将 webpack 安装到本地项目,可以看到目录中会下载一些文件 新建项目结构app 存放原始项目,public 存放之后生成的浏览器可用的 js 代码,以及一个 index.html 修改 index.html 文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;!-- 之后webpack打包会生成的bundle.js --&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/html&gt; 编写 Geeter.js,改文件为项目文件 123456module.exports = function() &#123; var greet = document.createElement(\"div\"); greet.textContent = \"Hello Webpack\"; return greet; // 随便写一个&#125;; 在 main.js 中引入 1234// 引入jsconst greeter = require(\"./Greeter\");// 查询id为root的标签,在这个标签中拼接Greeter返回的内容document.querySelector(\"#root\").appendChild(greeter()); 打包 webpack app/main.js -o public/bundle.js注意 webpack 要全局安装打包完,项目内就会出现 bundle.js在运行 index.html 就 ok 啦 总结Webpack 是一款前端的模块化打包工具,就像 java 可以把项目打包为 jar,webpack 可以将模块化的前端打包成一个 jswebpack 需要 node.js 的环境,","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://yimchengjie.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://yimchengjie.github.io/tags/webpack/"},{"name":"打包管理","slug":"打包管理","permalink":"https://yimchengjie.github.io/tags/%E6%89%93%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"Vue组件基础","slug":"Vue.js/Vue组件基础","date":"2018-09-30T07:33:56.000Z","updated":"2020-02-26T16:04:52.321Z","comments":true,"path":"2018/09/30/Vue.js/Vue组件基础/","link":"","permalink":"https://yimchengjie.github.io/2018/09/30/Vue.js/Vue%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"组件基础1. 什么是组件组件是可重复使用的 Vue 实例,开发中可以把经常重复的功能封装为组件.组件可以将整个页面尽显模块化分割.组件分为全局组件和局部组件. 2. 基本实例全局组件的创建方式 使用 Vue.extend 来创建全局的 Vue 组件 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\"&gt; // 使用组件,直接把组件的名字以HTML标签形式引入 //注意: HTML大小写忽略,所以驼峰命名失效,要采用 xxx-xxx来代替xxxXxx &lt;my-con1&gt;&lt;/my-con1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 注册组件Vue.component('组件名称',组件对象) Vue.component( \"myCon1\", Vue.extend(&#123; // 使用Vue.extend创建全局组件 // 通过template属性指定组件要展示的HTML结构 template: \"&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;\" &#125;) ); // 创建Vue实例 var vm = new Vue(&#123;&#125;);&lt;/script&gt; // 定义一个名为 button-counter 的新组件 //使用Vue.component函数创建组件,该函数有两个参数, 第一个是组件的名称,第二个是以对象的形式,描述一个组件 //因为组件是可复用的Vue实例,所以与new Vue接收相同的选项 Vue.component(\"button-counter\", { data: function() { return { count: 0 }; }, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me {{ count }} times.&lt;/button&gt;' }); &lt;!--￼1--&gt; 局部组件,在 Vue 实例内部的 components 方法内创建,只有这个 Vue 实例可以使用 12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;my-con&gt;&lt;/my-con&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt; 在Vue实例外部定义组件,使用template标签,这种方式有代码提示,好用,推荐 &lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; components: &#123; myCon: &#123; template: \"#tmp1\" &#125; &#125; &#125;);&lt;/script&gt; 注意: 无论使用什么方式, 模板最外层只能用一个根标签包含 3. 组件复用组件的优点在于重复利用注意:复用组件内的 data 必须是一个函数,如果是一个对象,组件之间会相互影响(多个组件会共用一个对象),使用函-数会分别管理数据vue 提供 component 标签来有用组件 123456789&lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;在Vue实例外部定义组件,使用template标签,这种方式有代码提示,好用,推荐&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;div id=\"app\"&gt; &lt;component :is=\"tmp1\"&gt;&lt;/component&gt;&lt;/div&gt; 4. 组件之间的通信组件也需要数据的通信,而 vue 中子组件默认无法访问父组件的数据 父子组件之 propsprops 是一个单向的数据流,只允许父组件向子组件传值,可以是数值、字符、布尔值、数值、对象。 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"app\"&gt; &lt;com1 v-bind:parentmsg=\"msg\"&gt;&lt;/com1&gt; &lt;/div&gt; &lt;template id=\"tmp1\"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: \"#app\", data: &#123; msg: \"hello\" &#125;, components: &#123; com1: &#123; template: \"#tmp1\", // 定义一个参数接收 props: [\"parentmsg\"] &#125; &#125; &#125;);&lt;/script&gt;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"ES6基础","slug":"前端基础/ES6基础","date":"2018-09-25T06:06:54.000Z","updated":"2020-02-26T14:51:36.171Z","comments":true,"path":"2018/09/25/前端基础/ES6基础/","link":"","permalink":"https://yimchengjie.github.io/2018/09/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/ES6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"ES6 基础ES6 全称 ECMAScript6.0 是 JavaScript 的下一个版本标准,但现在已经有很多浏览器支持了 ES6 JavaScript 只是 Oracle 公司注册的一个商标,它的正式名称就是 ECMAScript 关键字let和constES6 新增了两个重要的关键字:let和constlet声明的变量只在 let 所在代码块有效const声明一个只读常量,不可修改 变量的结构赋值12345678910111213141516171819//es5中对变量的赋值var data = &#123; userName: \"aaaa\", password: 123456 &#125;;var userName = data.userName;var password = data.password;console.log(userName);console.log(password);var data1 = [\"aaaa\", 123456];var userName1 = data1[0];var password1 = data1[1];console.log(userName1);console.log(password1);//es6中的解构赋值const &#123; userName, password &#125; = &#123; userName: \"aaaa\", password: 123456 &#125;;console.log(userName);console.log(password);const [userName1, password1] = [\"aaaa\", 123456];console.log(userName1);console.log(password1); ES6 模块化ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 的模块化分为导出（export） 与导入（import）两个模块。 import 命令特性 只读:可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。 单例模式 静态执行模式:不支持 import 的值为变量或者表达式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yimchengjie.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yimchengjie.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://yimchengjie.github.io/tags/ES6/"}]},{"title":"Vue基本指令","slug":"Vue.js/Vue基本指令","date":"2018-09-15T11:40:33.000Z","updated":"2020-02-26T15:52:06.686Z","comments":true,"path":"2018/09/15/Vue.js/Vue基本指令/","link":"","permalink":"https://yimchengjie.github.io/2018/09/15/Vue.js/Vue%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Vue 基本指令1:v-cloak能够解决插值表达式闪烁问题 2:v-text和功能一样,但是没有闪烁问题可以在插值前后有内容,v-text 会覆盖元素中原本的内容 3:v-html将数据已 HTML 格式输出 4:v-bindv-bind: 是 Vue 中提供的用于绑定属性的指令v-bind 可以缩写为:用法: v-bind:title(需要绑定的属性) 可简写为:title(需要绑定的属性) 绑定元素设置 class 样式 用数组:class=&quot;[&#39;class1&#39;,&#39;class2&#39;]&quot; 三元表达式:class=&quot;[&#39;class1&#39;,&#39;class2&#39;,flag?&#39;class3&#39;:&#39;&#39;]&quot; 数组中嵌套对象:class=&quot;[&#39;class1&#39;,&#39;class2&#39;,{&#39;class3&#39;:boolean}]&quot; 直接使用对象:class=&quot;{class1:true,class2:true,class3:false}&quot;(可以在 data 中定义classobj:{class1:true,class2:true,class3:false}然后在属性中直接饮用:class=&quot;classobj&quot;) 5:v-onv-on:是 Vue 中提供的用于绑定事件的指令v-on 可以缩写为@用法: v-on:click=”show”需要在 Vue 对象中定义 show 方法 12345method:&#123; show:function()&#123; alert(\"hello\"); &#125;&#125; 时间修饰符 .stop:阻止冒泡; .prevent:阻止默认事件的发生; .capture:捕获冒泡,有该修饰符的 dom 元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。 .self:将事件绑定到自身,只有自身能被触发,通常用于避免冒泡事件的影响; .once:设置事件只能触发一次,比如按钮的点击; .passive:用于对 DOM 的默认事件进行性能优化,比如超出最大范围的滚动条滚动; .native:把 vue 组件转化成一个普通的 HTML 标签,对普通的 HTML 标签是没有任何作用的; 6:v-modlev-modle:是 Vue 中用于数据双向绑定的指令注意: 只能运用在表单元素中 v-bind 只能实现数据单向绑定,从 M=&gt;V 7:v-forv-for 是循环迭代指令 用法: 迭代数组 12345&lt;ul&gt; &lt;li v-for=\"(item i) in list\"&gt; 索引:&#123;&#123;i&#125;&#125;----姓名:&#123;&#123;item.name&#125;&#125;----年龄:&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象的属性 --&gt;&lt;div v-for=\"(val,key,i) in list\"&gt; &#123;&#123;val&#125;&#125;---&#123;&#123;key&#125;&#125;---&#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 1&lt;p v-for=\"i in 10\"&gt;&#123;&#123;i&#125;&#125;&lt;/p&gt; v-for 中 key 的使用注意(key 相当于主键,是唯一的) v-for 循环时,key 属性只能用 number 或者 string key 在使用的时候必须使用 v-bind 绑定来指定 key 的值 8:v-ifv-if 是条件渲染指令,v-if 有更高的切换渲染开销.如果在运行时条件不太可能改变，则使用 v-if 较好. 用法 123&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 9:v-showv-show 有更高的初始渲染开销 用法 1&lt;div v-show=\"ifShow\"&gt;show&lt;/div&gt;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"Vue概述","slug":"Vue.js/Vue概述","date":"2018-09-13T02:37:09.000Z","updated":"2020-02-26T15:50:46.122Z","comments":true,"path":"2018/09/13/Vue.js/Vue概述/","link":"","permalink":"https://yimchengjie.github.io/2018/09/13/Vue.js/Vue%E6%A6%82%E8%BF%B0/","excerpt":"","text":"概述什么是 Vue.js Vue.js 是目前最火的前端框架,React 是最流行的一个前端框架(React 除了开发网站,还可以开发手机 APP,Vue 语法也可以用于手机开发,需要借助于 Weex) Vue.js 是前端的主流框架之一,和 Angular.js,React.js 一起,并成为前端三大主流框架 Vue.js 是一套构建用户界面的框架,只关注视图层,它易于上手,还便于第三方库或既有项目整合.(Vue 有配套的第三方类库,可以整合起来做大型项目的开发) 前端的主要工作,负责 MVC 中的 V 层,主要工作就是制作前端页面效果. 为什么要学习前端框架 提高开发效率 提高开发效率的发展历程:原生 JS-&gt;jQuery 类库-&gt;前端模板引擎-&gt;Angular.js/Vue.js(能够帮助我们减少不必要的 DOM 操作,提高渲染效率;双向数据绑带[通过框架提供的指令,前端程序员只需要关心业务逻辑,不必关心 DOM 是如何渲染了]); 在 Vue.js 中,一个核心的概念,就是让用户不再操作 DOM 元素,解放了用户的双手,让程序员可以更多的关注业务逻辑 框架和库的区别 框架: 是一套完整的解决方案;对项目的侵入性较大,项目如果需要更换框架,则需要重新架构整个项目. node 中的 express 库: 提供某一个小功能,对项目的侵入性小,如果某个库无法完成某些需求,可以很容易的切换到其他库实现需求. 后端(Node)中的 MVC 与前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念 MVVM 是前端视图层的概念,主要关注与视图层分层,也就是说:MVVM 把前端的视图层,把每个页面分成了 M,V 和 VM 层,VM 是 MVVM 思想的核心,因为 VM 层是 M 与 V 之间的调度者. - M 保存的是每个页面中单独的数据 - V 就是每个页面的 HTML 结构 - VM 是一个调度者,分割了 V 和 M,每当 V 层需要获取或保存数据的时候,都需要 VM 做中间处理. - 前端页面使用 MVVM 的思想,主要是为了使开发更方便,VM 提供了数据的双向绑定 Vue 中和 MVVM 之间的对应关系1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.导入Vue的包 --&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- MVVM中的V层 --&gt; &lt;!-- new的Vue实例,会控制这个元素中的内容 --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; // 2.创建一个Vue的实例 // 当我们导入包之后,在浏览器的内存中,就多了一个Vue的构造函数 // 这个vue对象就是MVVM中的调度者 // 其中的date就是MVVM中的M 数据 var vue = new Vue(&#123; el: \"#app\", //标书,当前我们new的这个vue实例,要控制页面上的哪个区域 data: &#123; //data属性中,存放的是el中要用到的数据 msg: \"Hello Vue.js\" //通过Vue提供的指令,很方便的就能把数据渲染到页面上,程序员不需要操作DOM元素了 &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/categories/Vue-js/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://yimchengjie.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://yimchengjie.github.io/tags/Vue-js/"}]},{"title":"jQuery笔记","slug":"前端基础/jQuery笔记","date":"2018-08-14T01:40:22.000Z","updated":"2020-02-26T14:52:51.853Z","comments":true,"path":"2018/08/14/前端基础/jQuery笔记/","link":"","permalink":"https://yimchengjie.github.io/2018/08/14/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/jQuery%E7%AC%94%E8%AE%B0/","excerpt":"","text":"jQuery1. 概念jQuery 是一个优秀的 JavaScript 库,而非 JavaScript,它是轻量级的库. 2. 作用jQuery 使用户能更方便的处理 HTML、events、实现动画效果,并且方便的为网站提供 Ajax 交互, 3. 优势它的文档说明齐全,而且应用详细,同时还有很多成熟的插件可供选择 4. 核心概念write less,do more 5. 语法 jQuery 入口函数 1234567$(document).ready(function() &#123; // 执行代码&#125;);或者;$(function() &#123; // 执行代码&#125;); 1234//对比JavaScript入口函数:window.onload = function() &#123; // 执行代码&#125;; jQuery 选择器 元素选择器$(&quot;p&quot;) #id 选择器$(&quot;#id&quot;) .class 选择器$(&quot;.class&quot;) DOM 操作 捕获和设置 text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容(包含 HTML 标签) val() - 设置或返回表单字段的值 attr() - 获取属性 添加和删除 HTML 元素 append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 获取和操作 CSS addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 遍历 DOM 树 parent() - 方法返回被选元素的直接父元素。 parents() - 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)。 parentsUntil() - 方法返回介于两个给定元素之间的所有祖先元素。 children() - 方法返回被选元素的所有直接子元素。 find() - 方法返回被选元素的后代元素，一路向下直到最后一个后代。 siblings() - 方法返回被选元素的所有同胞元素。 next() - 方法返回被选元素的下一个同胞元素。 nextAll() - 方法返回被选元素的所有跟随的同胞元素。 nextUntil() - 方法返回介于两个给定参数之间的所有跟随的同胞元素。 prev() , prevAll() , prevUntil() - 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yimchengjie.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yimchengjie.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://yimchengjie.github.io/tags/jQuery/"}]},{"title":"HTML5基础","slug":"前端基础/HTML5基础","date":"2018-08-13T01:15:32.000Z","updated":"2020-02-26T14:52:30.254Z","comments":true,"path":"2018/08/13/前端基础/HTML5基础/","link":"","permalink":"https://yimchengjie.github.io/2018/08/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/HTML5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTML5 基础HTML5 是最新的 HTML 标准 HTML5 新特性 在 HTML5 中,添加了新的 HTML 标签,比如&lt;article&gt;、&lt;footer&gt;、&lt;header&gt;、&lt;nav&gt;、&lt;section&gt;等 section 标签:&lt;section&gt;表示文档中的一个区域.比如章节、页眉、页脚或文档中的其他部分,一般来说会包含一个标题一般来说,一个&lt;section&gt;标签应该出现在文档大纲中. article 标签:&lt;article&gt;标签定义独立的内容,常用在论坛帖子,报纸文章,博客条目,用户评论等独立内容项目中. nav 标签:&lt;nav&gt;标签定义导航栏链接部分,描述一个包含多个链接的区域. header 标签:&lt;header&gt;标签定义文档页眉,通常是一些引导和导航信息 footer 标签:&lt;footer&gt;标签定义 section 或 document 的页脚 aside 标签:&lt;aside&gt;标签标示一个页与其余页面几乎无关的内容,表现为侧边栏或者嵌入内容 figure 标签:&lt;figure&gt;标签规定独立的流(图片,图像,代码等) HTML 视频音频在以前,想要在网页上展示视频音频通常需要使用 flash 这样的插件,很麻烦,而 HTML5 中提供了音频视频的标准接口 视频标签&lt;video&gt;video 元素允许多个 source 子元素,可以链接不同的视频文件,浏览器自动使用第一个可使用的视频(用来引入多种格式以支持不同浏览器访问) 1234&lt;video&gt; &lt;source src=\"\" type=\"video/mp4\" /&gt; &lt;source src=\"\" type=\"video/webm\" /&gt;&lt;/video&gt; 视频字幕的使用在&lt;video&gt;标签中使用&lt;track&gt;元素引入字幕.vtt格式的字幕文件 1234567891011&lt;video&gt; &lt;source src=\"\" type=\"video/mp4\" /&gt; &lt;track src=\"video_ch.vtt\" srclang=\"zh\" kind=\"subtitles\" label=\"中文\" default /&gt; &lt;video&gt;&lt;/video&gt;&lt;/video&gt; .vtt内容格式 123456WEBVTT00:00:01.000 --&gt; 00:00:04.000Don&apos;t play games in class！00:00:05.000 --&gt; 00:00:09.000Study hard and make progress every day！ 音频标签&lt;audio&gt;audio 标签也支持多种 source 子标签 1234&lt;audio&gt; &lt;source src=\"\" type=\"audio/mpeg\" /&gt; &lt;source src=\"\" type=\"audio/wav\" /&gt;&lt;/audio&gt; HTML5 拖放拖放是 HTML 标准的组成部分,任何元素都能进行拖放 首先要定义元素的 draggable 属性为 true,再加上全局处理事件函数 ondragstart 1&lt;img draggable=\"true\" ondragstart=\"drag(event)\" /&gt; 定义拖放数据每个 drag event 都有一个 dataTransfer 属性保存事件数据,setData()方法添加一个项目的拖拽数据html function drag(ev){ ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id); } 定义一个放置区ondragover 事件规定了在哪里放置拖动的数据,默认阻止,我们要开启html function allowDrop(ev) { ev.preventDefault(); } 进行放置放置被拖动数据时,会发生 drop 事件html function drop(ev) { //调用 preventDefault() 来避免浏览器对数据的默认处理 ev.preventDefault(); //通过 dataTransfer.getData(&quot;Text&quot;) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 var data = ev.dataTransfer.getData(&quot;Text&quot;); //被拖数据是被拖元素的 id (&quot;drag1&quot;),把被拖元素追加到放置元素（目标元素）中 ev.target.appendChild(document.getElementById(data)); } Canvas 画布Canvas 可以用于图形表示,图像绘制,游戏制作,,需要通过 js 控制来绘制 使用来操作 HTML 图形图标 HTML5 表单 datalist 元素,使用 &lt;datalist&gt; 元素来为表单小部件提供建议的、自动完成的值，并使用一些 &lt;option&gt; 子元素来指定要显示的值。然后使用 list 属性将数据列表绑定到一个文本域(通常是一个 &lt;input&gt;元素)。 123456789&lt;input type=\"text\" name=\"myColor\" id=\"myColor\" list=\"mySuggestion\" /&gt;&lt;datalist id=\"mySuggestion\"&gt; &lt;option value=\"black\"&gt; &lt;/option&gt; &lt;option value=\"blue\"&gt; &lt;/option&gt; &lt;option value=\"green\"&gt; &lt;/option&gt; &lt;option value=\"red\"&gt; &lt;/option&gt; &lt;option value=\"white\"&gt; &lt;/option&gt; &lt;option value=\"yellow\"&gt; &lt;/option&gt;&lt;/datalist&gt; autocomplete 属性规定表单是否应该启用自动完成功能,当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 form 属性,适用所有 input 标签,让其可以在 form 域之外,但仍属于 form 的一部分. multiple 属性规定输入域可以选择多个值,适用于以下 input:email 和 file novalidate 属性,规定在表单提交时不应该验证 form 域 pattern 属性,指定正则表达式,用于验证 required 属性规定提交时不能为空 HTML5 输入类型 input-email 类型,提交时自动验证 input-url 类型,自动验证 url 域的值 input-number,允许设置最大最小值和数字间隔 input-range 类型,显示为滑动条,也有最大最小值和数字间隔 input-Date Pickers 时间选择器 input-search 搜索域 input-color 颜色选择器 Web Storage 本地存储由于 Cookie 的限制,HTML5 支持了两种 Web Storage:永久性的本地存储（localStorage）和会话级别的本地存储（sessionStorage） HTML5 文件上传在 HTML4 标准中文件上传控件只接受一个文件，而在新标准中，只需要设置 multiple，就支持多文件上传。按住 Ctrl 或者 Shift 即可选择多个文件。可以限制文件的上传类型使用 accept 属性,使用 accept 接受一个逗号分隔的 MIME 类型字符串。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://yimchengjie.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yimchengjie.github.io/tags/HTML/"}]},{"title":"SpringBoot+Mybatis之动态SQL","slug":"Java开发框架/SpringBoot-Mybatis之动态SQL","date":"2018-07-25T08:28:07.000Z","updated":"2020-02-21T10:56:20.124Z","comments":true,"path":"2018/07/25/Java开发框架/SpringBoot-Mybatis之动态SQL/","link":"","permalink":"https://yimchengjie.github.io/2018/07/25/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/SpringBoot-Mybatis%E4%B9%8B%E5%8A%A8%E6%80%81SQL/","excerpt":"","text":"SpringBoot+Mybatis 之动态 SQL在 ssm 项目中,使用 xml 文件利用标签,可以实现复杂的动态 sql 语句,那在 SpringBoot+Mybatis 项目下,注解的方式如何实现动态 sql 1. 使用&lt;script&gt;标签包裹 XML 方式的语句12345678910111213141516public interface UserMapper &#123; @Select(\" &lt;script&gt; SELECT * FROM myuser \" + \" &lt;where&gt; \" + \" &lt;if test='uid!=null' &gt; \" + \" uid=#&#123;uid&#125; \" + \" &lt;/if&gt; \" + \" &lt;if test='uname!=null' &gt; \" + \" and uname like CONCAT('%',#&#123;uname&#125;,'%') \" + \" &lt;/if&gt; \" + \" &lt;if test='usex!=null' &gt; \" + \" and usex=#&#123;usex&#125; \" + \" &lt;/if&gt; \" + \" &lt;/where&gt; \" + \" &lt;/script&gt; \") List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user);&#125; 这个方式我们比较熟悉,但是用字符串包裹&lt;script&gt;语句就变得很复杂, 难以维护,所以不推荐, 这样的写法和 XML 的写法没有什么本质区别. 2. 在 Mapper 中创建内部类,构建 sql@SelectProvider等@XXXProvider注解允许我们指定一个类的方法来返回 sql 语句 123456789101112131415161718192021public interface UserMapper &#123; @SelectProvider(type = UserMapperProvider.class , method = \"userInfo\") List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user); class UserMapperProvider &#123; public String userInfo(User user) &#123; StringBuffer sql = new StringBuffer(); sql.append(\" SELECT * FROM myuser where 1=1 \"); if (user.getUid() != null) &#123; sql.append(\" AND uid=#&#123;uid&#125; \"); &#125; if (user.getUname() != null) &#123; sql.append(\" AND uname like CONCAT('%',#&#123;uname&#125;,'%') \"); &#125; if (user.getUsex() != null) &#123; sql.append(\" AND usex=#&#123;usex&#125; \"); &#125; return sql.toString(); &#125; &#125;&#125; 3. 创建内部类,使用结构化 SQL 方法1234567891011121314151617181920212223public interface UserMapper &#123; @SelectProvider(type = UserMapperProvider.class , method = \"userInfo\") List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user); class UserMapperProvider &#123; public String userInfo(User user) &#123; return new SQL()&#123;&#123; SELECT(\" * \"); FROM(\" myuser \"); if (user.getUid() != null) &#123; WHERE(\" uid=#&#123;uid&#125; \"); &#125; if (user.getUname() != null) &#123; WHERE(\" uname like CONCAT('%',#&#123;uname&#125;,'%') \"); &#125; if (user.getUsex() != null) &#123; WHERE(\" AND usex=#&#123;usex&#125; \"); &#125; &#125; &#125;.toString(); &#125; &#125;&#125; 总结 方法 1 是 XML 语法的注解方式实现,方法 2 和方法 3 比较相似,可读性高,易于维护, 方法 2 适用面可能更广,而且更加接近我们熟悉的自然 sql 语法, 推荐使用方法 2","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yimchengjie.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot+Mybatis整合","slug":"Java开发框架/SpringBoot-Mybatis整合","date":"2018-07-12T06:25:16.000Z","updated":"2020-02-21T10:56:17.336Z","comments":true,"path":"2018/07/12/Java开发框架/SpringBoot-Mybatis整合/","link":"","permalink":"https://yimchengjie.github.io/2018/07/12/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/SpringBoot-Mybatis%E6%95%B4%E5%90%88/","excerpt":"","text":"SpringBoot+MyBatis 整合以往我们需要用到 MyBatis 时,需要繁琐的 xml 配置,而且很容易造成 spring 和 mybatis 的 jar 冲突, 非常麻烦而在 SpringBoot 下,只需要添加 mybatis 的 starter 启动器,就能很方便的和 spring 整合了,无需 xml 配置 1. 添加 mybatis 的 starter 包12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 2. 在 application.properties 中添加数据源123456mybatis.type-aliases-package=com.ycj.entityspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ssmdemo?characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456 springboot 会自动加载 application.properties 然后注入 DateSource 类中 3. 在 springboot 启动类上添加 Mapper 包的扫描注解123@SpringBootApplication@MapperScan(\"com.ycj.mapper\")public class SpringBootApplicationMain 注意:也可以在每一个 mapper 接口上添加@Mapper注解, 不过比较麻烦,并且容易遗漏. 推荐直接扫描包 4. 添加 mapper 接口,并用注解实现1234public interface UserMapper &#123; @Select(\" SELECT * FROM myuser WHERE uname Like CONCAT('%',#&#123;uname&#125;,'%') \") List&lt;Map&lt;String,Object&gt;&gt; userInfo(User user);&#125; 5. 完善代码,service 层和 controller 层123456@ResponseBody@RequestMapping(\"/userInfo.do\")public List&lt;Map&lt;String, Object&gt;&gt; userInfo(User user)&#123; List&lt;Map&lt;String, Object&gt;&gt; list=userService.userInfo(user); return list;&#125; 浏览器访问 错误记录当mapper.xml放在src/main/java目录下是， 默认maven是不加载mapper.xml文件的 需要在pom.xml中配置加载xml文件 12345678910&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 最好还是将mapper.xml文件放在Resources目录下","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yimchengjie.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot入门","slug":"Java开发框架/SpringBoot入门","date":"2018-07-03T07:55:05.000Z","updated":"2020-02-21T10:56:23.271Z","comments":true,"path":"2018/07/03/Java开发框架/SpringBoot入门/","link":"","permalink":"https://yimchengjie.github.io/2018/07/03/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/SpringBoot%E5%85%A5%E9%97%A8/","excerpt":"","text":"SpringBoot 简介SpringBoot 是用来快速构建 Spring+SpringMvc 项目的框架,其设计就是为了尽可能的减少配置文件,快速开发 spring 应用 在使用 springboot 之前,我们开发一个 web 项目需要繁琐的配置, 还要担心 jar 的冲突和可行性 springboot 让一切都变得简单 springboot 内嵌 Tomcat 等 web 容器 提供 starter 简化 maven 配置 自动配置 spring 无代码生成,无需 xml 配置 提供完善的项目测试 采用 java 类来配置 可以说 SpringBoot 是一个简便快捷强大的 Spring+SpringMvc,也是目前非常主流的 javaWeb 技术 第一个 SpringBoot采用 maven 项目创建 springboot 新建 maven 项目,在 pom.xml 导入 springboot 所需包 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 springboot 启动入口该启动类位于 src 下,且与 controller,dao,service 等包同级 1234567@SpringBootApplicationpublic class SpringBootApplicationMain &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootApplicationMain.class,args); &#125;&#125; 创建一个 controller 123456789@Controller@RequestMapping(value = \"/user\", produces=\"application/json;charset=UTF-8\")@ResponseBodypublic class UserController &#123; @RequestMapping(\"/hello.do\") public String hello()&#123; return \"Hello SpringBoot\"; &#125;&#125; 运行启动类, 无需 XML 配置, 无需 tomcat 配置, 创建快速,一键启动 浏览器访问 SpringBoot 项目的基础依赖关系在项目目录使用命令:mvn dependency:tree 对于 SpringBoot 中的 starter 的理解starter 可以理解为启动器,它是一系列可以直接集成进 springboot 应用的依赖包的集合,只需要一站式的添加 starter 包,而不需要配置 XML,和解决包依赖、包冲突的问题。 SpringBoot 接口开发JSON 接口开发在 controller 类上使用@RestController 或者在 controller 类的方法上加上@ResponseBody","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://yimchengjie.github.io/tags/SpringBoot/"}]},{"title":"SSM框架整合","slug":"Java开发框架/SSM框架整合","date":"2018-06-16T12:50:53.000Z","updated":"2020-02-21T10:56:28.661Z","comments":true,"path":"2018/06/16/Java开发框架/SSM框架整合/","link":"","permalink":"https://yimchengjie.github.io/2018/06/16/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","excerpt":"","text":"SSM 框架整合Spring+SpringMVC+MyBatis 框架整合 1. 创建 maven 项目创建一个 maven 项目,在 pom.xml 文件中导入相关包基本包有: mysql 连接驱动 jar mybatis 的 jar mybatis 与 spring 整合的 jar spring 相关 jar springmvc 的 jar项目中会用到的日志记录包: log4j 的 jar slf4j 的接口 jar slf4j 和 log4j 的整合 jar项目中会用到的单元测试包: junit 的 jar可能会用到 jsp 时需要的包: servlet 的 jar servlet-jsp 的 jar jstl 标签支持的 jar 2. 创建项目结构 项目 pom.xml src test main java entity dao service impl controller util resources mapper mapper.xml jdbc.properties mybatis-config.xml applicationContext.xml springmvc.xml log4j.properties webapp WEB-INF web.xml index.jsp index.html 3. 配置各个框架的配置文件 配置 web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\"&gt; &lt;!--&lt;display-name&gt;ssmdemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;--&gt; &lt;!-- 加载spring的ApplicationContext容器 --&gt; &lt;context-param&gt; &lt;!-- 加载src目录下的 applicationContext.xml文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring中的监听器,可以在启动项目时自动装配spring的配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 加载springmvc的 DispatcherServlet (请求分发器)--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class &gt; &lt;!-- 需要加载的springmvc-servlet.xml配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理*.do的URL --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置过滤器,解决请求乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class &gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class &gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern &gt;&lt;!--拦截所有请求,过滤乱码--&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 配置 spring 监听器来创建容器,加载 spring 配置文件 配置 springmvc 分发器,加载 springmvc 配置文件 配置过滤器,解决乱码 applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--&amp;lt;!&amp;ndash;开启注解扫描&amp;ndash;&amp;gt; &lt;context:component-scan base-package=\"com.ycj\"/&gt; &amp;lt;!&amp;ndash;注解配置&amp;ndash;&amp;gt; &lt;context:annotation-config/&gt;--&gt; &lt;!--引入数据库properties文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" &gt;&lt;/context:property-placeholder&gt; &lt;!--&amp;lt;!&amp;ndash;配置数据源&amp;ndash;&amp;gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssmdemo?characterEncoding=utf8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt;--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\" &gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;pwd&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置spring整合mybatis的工厂类对象--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\" &gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.ycj.entity\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\" /&gt; &lt;/bean&gt; &lt;!--扫描Dao接口,装配mapper.xml--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.ycj.dao\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; &lt;!--指定需要扫描的包,使注解生效,dao包在上面已经扫描, 不需要了--&gt; &lt;context:component-scan base-package=\"com.ycj.service\" /&gt; &lt;!--事务管理--&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" &gt; &lt;!--注入DataSource--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--开启事务注解扫描--&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt;&lt;/beans&gt; 配置 mysql 数据源 配置 spring-mybatis 整合工厂类对象 加载数据源 扫描实体包 扫描 mapper.xml 文件 配置 mapper 注入工厂 扫描 dao 层包 加载 spring-mybatis 整合工厂类对象 扫描有注解的包,使注解生效 开启事务管理 开启事务管理注解扫描 配置 springmvc-servlet 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--配置spring创建I容器时要扫描的包--&gt; &lt;context:component-scan base-package=\"com.ycj.controller\"/&gt; &lt;!--开启注解驱动--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 123456&lt;!-- 配置Spring MVC的视图解析器 --&gt;&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 有时我们需要访问JSP页面,可理解为在控制器controller的返回值加前缀和后缀,变成一个可用的URL地址 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 扫描控制器包 开启注解驱动 配置视图解析器 包版本参考: 12345678910111213&lt;!--spring版本--&gt;&lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;&lt;!--mybatis版本--&gt;&lt;mybatis.version&gt;3.5.1&lt;/mybatis.version&gt;&lt;!--日志管理包--&gt;&lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;&lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;&lt;!--json版本--&gt;&lt;fastjson.version&gt;2.9.8&lt;/fastjson.version&gt;&lt;!--mysql驱动版本--&gt;&lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;&lt;!--mybatis-spring整合包版本--&gt;&lt;mybatis-spring.version&gt;1.3.2&lt;/mybatis-spring.version&gt; 4. 错误记录错误 1: tomcat 报错 org.apache.tomcat.util.modeler.BaseModelMBean.invoke Exception invoking method manageApp解决方案:检查 maven 包是否正确,clean-&gt;compile进入 maven 仓库删除相应包, 重新下载 错误 2: java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener解决方案:项目包中存在,打开项目结构,在 artifacts,将可选项添加到输出文件中,可以看到 WEB-INF 中多了一个 lib 文件,存放依赖的包. 找到原因,没有将项目中的包添加到输出 war 中 错误 3: 无法接收 json 数据解决方案:spring5 以上版本不需要在参数前添加@RequestBody,删除注解后成功 错误 4: 无法返回 json 格式数据解决方案:配置 json 转换器,需要正确的包(参考 spring5.1.5;fastjson2.9.8)spring5.0 以上版本,只要开启注解驱动即可&lt;mvc:annotation-driven /&gt;","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://yimchengjie.github.io/tags/SpringMVC/"}]},{"title":"Spring之SpringMVC","slug":"Java开发框架/Spring之SpringMVC","date":"2018-05-29T03:35:25.000Z","updated":"2020-02-21T10:56:14.133Z","comments":true,"path":"2018/05/29/Java开发框架/Spring之SpringMVC/","link":"","permalink":"https://yimchengjie.github.io/2018/05/29/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E4%B9%8BSpringMVC/","excerpt":"","text":"Spring 之 SpringMVCWeb 应用的分层通常是 MVC,对应着数据层-视图层-控制层SpringMVC 就是控制层框架 SpringMVC 工作流程Spring MVC 框架主要由 DispatcherServlet、处理器映射、控制器、视图解析器、视图组成 客户端请求提交到 DispatcherServlet。 由 DispatcherServlet 控制器寻找一个或多个 HandlerMapping，找到处理请求的 Controller。 DispatcherServlet 将请求提交到 Controller。 Controller 调用业务逻辑处理后返回 ModelAndView。 DispatcherServlet 寻找一个或多个 ViewResolver 视图解析器，找到 ModelAndView 指定的视图。 视图(JSP 等视图层)负责将结果显示到客户端。 从宏观角度考虑，DispatcherServlet 是整个 Web 应用的控制器；从微观考虑，Controller 是单个 Http 请求处理过程中的控制器，而 ModelAndView 是 Http 请求过程中返回的模型（Model）和视图（View）。 SpringMVC 的实现实例 在 web.xml 文件中配置部署 DispatcherServlet 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;springMVC&lt;/display-name&gt; &lt;!-- 部署 DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 加载springmvc-servlet.xml配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器再启动时立即加载servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 处理所有URL --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 创建 Controller 类 123456public class LoginController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; return new ModelAndView(\"/WEB-INF/jsp/register.jsp\"); &#125;&#125; 创建 springmvc-servlet.xml 配置 Controller 的映射信息 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- LoginController控制器类，映射到\"/login\" --&gt; &lt;bean name=\"/login\" class=\"controller.LoginController\" /&gt;&lt;/beans&gt; 在配置文件中定义视图解析器(ViewResolver) 12345678&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 上述视图解析器配置了前缀和后缀两个属性，因此 Controller 中只需要返回login,视图解析器就会自动添加前缀和后缀 通过注释实现 SpringMVC传统风格的控制器不仅需要在配置文件中部署映射，而且只能编写一个处理方法，不够灵活。在基于注解的控制器类中可以编写多个处理方法，进而可以处理多个请求（动作），这就允许将相关的操作编写在同一个控制器类中，从而减少控制器类的数量，方便以后的维护。基于注解的控制器不需要在配置文件中部署映射，仅需要使用 RequestMapping 注释类型注解一个方法进行请求处理。 注释实现的 Controller 类 12345678910111213141516171819202122232425262728/*** “@Controller”表示 IndexController 的实例是一个控制器** @Controller相当于@Controller(@Controller) 或@Controller(value=\"@Controller\")*/@Controller@RequestMapping(value=\"/index\")public class IndexController &#123; // 处理请求的方法 @RequestMapping(value = \"/login\") public String login(HttpSession session,HttpServletRequest request)&#123; /** * login代表逻辑视图名称，需要根据Spring MVC配置 * 文件中internalResourceViewResolver的前缀和后缀找到对应的物理视图 */ session.setAttribute(\"skey\", \"session范围的值\"); session.setAttribute(\"rkey\", \"request范围的值\"); return \"login\"; &#125; @RequestMapping(\"/register\") public String register(Model model) &#123; /*在视图中可以使用EL表达式$&#123;success&#125;取出model中的值*/ // model是一个包含 Map 的 Spring 框架类型。 // 可以保存数据,然后在视图层用EL表达式提取 model.addAttribute(\"success\", \"注册成功\"); return \"register\"; &#125;&#125; 使用注释需要在配置文件开启注释扫描 12&lt;!-- 使用扫描机制扫描控制器类，控制器类都在controller包及其子包下 --&gt;&lt;context:component-scan base-package=\"controller\" /&gt; SpringMVC 获取参数 把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。适用于 get 和 post 12345678910111213@RequestMapping(\"/register\")public String register(String uname,String upass,Model model) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; logger.info(\"成功\"); return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; logger.info(\"失败\"); // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过一个实体 Bean 来接收请求参数，Bean 的属性名称必须与请求参数名称相同.适用于 get 和 post 1234567891011@RequestMapping(\"/login\")public String login(UserForm user, HttpSession session, Model model) &#123; if (\"zhangsan\".equals(user.getUname()) &amp;&amp; \"123456\".equals(user.getUpass())) &#123; session.setAttribute(\"u\", user); return \"main\"; // 登录成功，跳转到 main.jsp &#125; else &#123; model.addAttribute(\"messageError\", \"用户名或密码错误\"); return \"login\"; &#125;&#125; 通过 HttpServletRequest 接收请求参数适用于 get 和 post 12345678910111213141516@RequestMapping(\"/register\")/*** 通过HttpServletRequest接收请求参数*/public String register(HttpServletRequest request,Model model) &#123; String uname = request.getParameter(\"uname\"); String upass = request.getParameter(\"upass\"); if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过 @PathVariable 获取 URL 中的参数,适用 get 123456789public String register(@PathVariable String uname,@PathVariable String upass,Model model) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过 @RequestParam 接收请求参数,适用于 get 和 post 1234567891011public String register(@RequestParam String uname, @RequestParam String upass, Model model) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; logger.info(\"成功\"); return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 在register.jsp页面上可以使用EL表达式取出model的uname值 model.addAttribute(\"uname\", uname); return \"register\"; // 返回 register.jsp &#125;&#125; 通过 @ModelAttribute 接收请求参数,适用于 get 和 post 12345678910@RequestMapping(\"/register\")public String register(@ModelAttribute(\"user\") UserForm user) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; return \"login\"; // 注册成功，跳转到 login.jsp &#125; else &#123; // 使用@ModelAttribute(\"user\")与model.addAttribute(\"user\",user)的功能相同 //register.jsp页面上可以使用EL表达式$&#123;user.uname&#125;取出ModelAttribute的uname值 return \"register\"; // 返回 register.jsp &#125;&#125; SpringMVC 的转发和重定向转发是服务器行为，重定向是客户端行为。转发地址栏不变,请求数据不丢失,重定向地址栏改变,请求数据丢失 在 Spring MVC 框架中，重定向与转发的示例代码如下： 123456789101112131415@RequestMapping(\"/login\")public String login() &#123; //转发到一个请求方法（同一个控制器类可以省略/index/） return \"forward:/index/isLogin\";&#125;@RequestMapping(\"/isLogin\")public String isLogin() &#123; //重定向到一个请求方法 return \"redirect:/index/isRegister\";&#125;@RequestMapping(\"/isRegister\")public String isRegister() &#123; //转发到一个视图 return \"register\";&#125; SpringMVC 的 JSON 数据交互Spring MVC 提供了 MappingJackson2HttpMessageConverter 实现类默认处理 JSON 格式请求响应。该实现类利用 Jackson 开源包读写 JSON 数据，将 Java 对象转换为 JSON 对象和 XML 文档，同时也可以将 JSON 对象和 XML 文档转换为 Java 对象。 在使用注解开发时需要用到两个重要的 JSON 格式转换注解，分别是 @RequestBody 和 @ResponseBody。 @RequestBody：用于将请求体中的数据绑定到方法的形参中，_该注解应用在方法的形参上_。把传来的 JSON 数据转换为响应 java 对象 @ResponseBody：用于直接返回 return 对象，_该注解应用在方法上_。表示该方法返回一个 JSON 格式数据","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://yimchengjie.github.io/tags/SpringMVC/"}]},{"title":"Spring之事务管理","slug":"Java开发框架/Spring之事务管理","date":"2018-05-21T11:46:10.000Z","updated":"2020-02-21T10:56:08.795Z","comments":true,"path":"2018/05/21/Java开发框架/Spring之事务管理/","link":"","permalink":"https://yimchengjie.github.io/2018/05/21/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","excerpt":"","text":"Spring 之事务管理什么是事务,就是一些列的步骤, 是一个整体,要么全都完成要么全都不完成.一个步骤失败,就要把已经完成的步骤全部回滚,回到没有运行之前.比如:银行取钱,你账户金额减少-&gt;银行 ATM 出钱, 要么两个都要完成,要么两个都不完成事务有四个特性: 原子性:事务是一些列步骤的组成,是一个整体,不可以分割 一致性:事务要么全部完成,要么全部不失败, 不能一部分完成一部分失败 隔离性: 持久性:一旦事务完成,结果不会受到影响,通常事务的结果会写入持久存储器 Spring 的事务管理, 是基于 AOP 面向切面编程来实现的. Spring 事务管理的三个核心接口 PlatformTransactionManager该接口是一个事务管理器,用于管理事务,提供了三个事务操作方法: TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。 void commit（TransactionStatus status）：用于提交事务。 void rollback（TransactionStatus status）：用于回滚事务。在项目中，Spring 将 xml 中配置的事务详细信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。 TransactionDefinition该接口是描述事务的对象,提供了五个事务相关信息的获取方法: String getName()：获取事务对象名称。 int getIsolationLevel()：获取事务的隔离级别。 int getPropagationBehavior()：获取事务的传播行为。 在事务管理过程中，传播行为可以控制是否需要创建事务以及如何创建事务。 int getTimeout()：获取事务的超时时间。 boolean isReadOnly()：获取事务是否只读。通常情况下，数据的查询不会改变原数据，所以不需要进行事务管理，而对于数据的增加、修改和删除等操作，必须进行事务管理。如果没有指定事务的传播行为，则 Spring3 默认的传播行为是 required。 TransactionStatus该接口是事务的状态,它描述事务在某一时间点上事务的状态信息.包含留个操作: void flush() 刷新事务 boolean hasSavepoint() 获取是否存在保存点 boolean isCompleted() 获取事务是否完成 boolean isNewTransaction() 获取是否是新事务 boolean isRollbackOnly() 获取是否回滚 void setRollbackOnly() 设置事务回滚 利用 XML 配置文件实现事务管理 新建 Dao 层接口 123456public interface AccountDao &#123; // 汇款 public void out(String outUser, int money); // 收款 public void in(String inUser, int money);&#125; 创建 Dao 的实现类 Impl 1234567891011121314151617public class AccountDaoImpl implements AccountDao &#123; // 注入JdbcTemplate,使用SpringJDBC访问数据库 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; // 汇款的实现方法 public void out(String outUser, int money) &#123; this.jdbcTemplate.update(\"update account set money =money-?\" + \"where username =?\", money, outUser); &#125; // 收款的实现方法 public void in(String inUser, int money) &#123; this.jdbcTemplate.update(\"update account set money =money+?\" + \"where username =?\", money, inUser); &#125;&#125; 创建 Service 以及其实现类 123456789101112131415public interface AccountService &#123; // 转账 public void transfer(String outUser, String inUser, int money);&#125;/*-----------------------------------------------------*/public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); this.accountDao.in(inUser, money); &#125;&#125; 配置 Spring 的 XML 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 配置数据源，读取properties文件信息 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\" /&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;!-- 配置dao --&gt;&lt;bean id=\"accountDao\" class=\"com.mengma.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt;&lt;/bean&gt;&lt;!-- 配置service --&gt;&lt;bean id=\"accountService\" class=\"com.mengma.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器，依赖于数据源 --&gt;&lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" rollback-for=\"Exception\" /&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" read-only=\"false\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt;&lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;!-- AspectJ表达式,代表com.mengma.service包中所有的方法 --&gt; &lt;aop:pointcut expression=\"execution(* com.mengma.service.*.*(..))\" id=\"txPointCut\" /&gt; &lt;!-- 切面：将切入点与通知整合 --&gt; &lt;aop:advisor pointcut-ref=\"txPointCut\" advice-ref=\"txAdvice\" /&gt;&lt;/aop:config&gt; 修改业务代码(模拟意外,比如断电) 123456public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); //模拟断电 int i = 1/0; this.accountDao.in(inUser, money);&#125; 测试 12345678910public class AccountTest &#123; @Test public void test() &#123; // 获得Spring容器，并操作 String xmlPath = \"applicationContext.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); AccountService accountService = (AccountService)applicationContext.getBean(\"accountService\"); accountService.transfer(\"zhangsan\", \"lisi\", 100); &#125;&#125; 利用 Annotation 注释方式实现事务管理省去 xml 中的编写通知和 AOP 编写 xml 中添加注册驱动 1&lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; 还有要注意, 使用注释,需要在 xml 中开启注释处理器,指定扫描注释 在业务代码(目标事务)中添加注释 @Transcational 12345678910111213@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)public class AccountServiceImpl &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); // 模拟断电 int i = 1 / 0; this.accountDao.in(inUser, money); &#125;&#125;","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring之JDBC支持","slug":"Java开发框架/Spring之JDBC支持","date":"2018-05-15T02:32:03.000Z","updated":"2020-02-21T10:56:11.436Z","comments":true,"path":"2018/05/15/Java开发框架/Spring之JDBC支持/","link":"","permalink":"https://yimchengjie.github.io/2018/05/15/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E4%B9%8BJDBC%E6%94%AF%E6%8C%81/","excerpt":"","text":"Spring 之 JDBC 支持Spring 框架针对数据库开发的应用提供了 JDBCTemplate 类,该类是 Spring 对 JDBC 支持的核心,提供了所有对数据库操作功能的支持 DataSource主要功能是获取数据库的连接,还可以引入数据库缓冲池和分布式事务的支持,可以作为访问数据库资源的标准接口 SQLExceptionTranslator该接口负责对 SQLException 进行转换,通过配置,可以使 JDBCTemplate 在需要处理 SQLException 时,完成一些转译工作 Spring 中 JDBC 的配置信息在 Spring 配置文件中配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http:/www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.dataSource.DriverManagerDataSource\" &gt; &lt;!--数据库驱动--&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;!--连接数据库的url--&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost/spring\" /&gt; &lt;!--连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;!--连接数据库的密码--&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.jdbcTemplate\"&gt; &lt;!--默认必须使用数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置注入类(Dao层)--&gt; &lt;bean id=\"xxx\" class=\"xxx\"&gt; &lt;!-- 在Dao层中注入jdbcTemplate --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; ...&lt;/beans&gt; 在 Dao 层中注入 jdbcTemplate 实例, 该实例提供了大量的查询和更新数据库的方法,比如query(),update()等","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring之面向切面AOP","slug":"Java开发框架/Spring之面向切面AOP","date":"2018-05-06T04:36:57.000Z","updated":"2020-02-21T10:56:02.375Z","comments":true,"path":"2018/05/06/Java开发框架/Spring之面向切面AOP/","link":"","permalink":"https://yimchengjie.github.io/2018/05/06/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E4%B9%8B%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2AOP/","excerpt":"","text":"Spring 之面向切面 AOPAOP 是指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式 AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。 AOP 基本概念 Aspect(切面): 通常是一个类，里面可以定义切入点和通知 JointPoint(连接点): 程序执行过程中明确的点，即调用的方法,方法名、当前传入的参数值等等都会封装在 JointPoint 的实例对象中,一般作为参数代入到具体的切入方法中 Advice(通知): AOP 在特定的切入点上执行增强处理，有 before,after,afterReturning,afterThrowing,around Pointcut(切入点): 就是带有通知的连接点，在程序中主要体现为书写切入点表达式,定义在方法上,添加要增强的一个或一组方法,该注释描述一个可重用的切入点,可以被 Adivce(通知)引用 Proxy(代理): AOP 框架创建的对象，代理就是目标对象的加强。Spring 中的 AOP 代理可以使 JDK 动态代理，也可以是 CGLIB 代理，前者基于接口，后者基于子类 SpringAOP 应用实例 编写业务代码 123456@Servicepublic class PrintService&#123; public void printStr(String str)&#123; System.out.println(str); &#125;&#125; 定义一个切面类 12345678910111213141516171819@Component@Aspectpublic class PrintAspect&#123; // 添加PrintService类中的public void printStr(String str)方法 @Pointcut(\"execution(public void PrintService.printStr(String str))\") public void printCut()&#123;&#125; @After(\"printCut()\") public void printAfter(JoinPoint jp)&#123; String name = jp.getSignature().getName(); System.out.println(\"After\"+name); &#125; @Before(\"printCut()\") public void printBefore(JoinPoint jp)&#123; String name = jp.getSignature().getName(); System.out.println(\"Before\"+name); &#125;&#125; 配置代理 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd\"&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;!-- 启动aop代理 --&gt; &lt;context:component-scan base-package=\"cn.outofmemory\" /&gt; &lt;!-- 自动扫描包内的Bean --&gt;&lt;/beans&gt; AOP 执行过程1. Spring 创建 IOC 容器2. 寻找切面类Spring 在创建完对象后,寻找由@Aspect 修饰的切面类,并获得切面类中的方法 3. 寻找切面类的方法中带有表达书的部分找到方法注解@execution()中的内容 4. 查找对应的方法随后, Spring 检查所有的类, 并将上面找到的表达书与所有类比对,符合表达式的方法就是需要被代理的类 5. 动态创建代理类Spring 根据目标类创建代理类, 添加切面逻辑方法,并将代理类返回给 IOC 容器","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring之容器和依赖注入","slug":"Java开发框架/Spring之容器和依赖注入","date":"2018-05-01T07:18:44.000Z","updated":"2020-02-21T10:56:05.297Z","comments":true,"path":"2018/05/01/Java开发框架/Spring之容器和依赖注入/","link":"","permalink":"https://yimchengjie.github.io/2018/05/01/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"Spring之容器和依赖注入Bean容器 BeanFactory是基础的容器,由 org.springframework.beans.facytory.BeanFactory 接口定义, 负责创建各种Bean创建BeanFactory实例时,需要提供Spring容器的详细配置文件applicationContext.xml ApplicationContext是BeanFactory的子接口,它相比于BeanFactory,多了国际化支持等功能,而且在项目初始化过程中,ApplicationContext会自检,避免后续使用getBean方法时抛出异常 通常使用ApplicationContext来创建Spring容器 在Web项目中,Spring容器的实例化通常是由ContextLoaderListener来实现,只需要在web.xml中对其进行配置例如: 12345678910111213141516&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--spring将加载src/config目录下的applicationContext.xml文件--&gt; &lt;param-value&gt; classpath:config/applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;!-- 它在启动Web容器时，自动装配ApplicationContext的配置信息。 --&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 它实现了ServletContextListener接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。 --&gt; Bean管理 applicationContext.xml文件中&lt;bean&gt;标签对Bean进行配置 1234&lt;bean id=\"UserDao\" class=\"com.spring.dao.Impl.UserDaoImpl\" /&gt;&lt;bean id=\"UserService\" class=\"com.spring.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\" /&gt;&lt;/bean&gt; 通过注释的方式配置Bean@Component该注释用来描述Spring中的Bean,该注释是泛化概念.@Repository用于数据访问层(Dao层)的类描述为Bean@Service用于业务层(Service层)的类描述为Bean@Controller用于描述控制层(Action层)的类为Bean@Autowired用于描述Bean的依赖实例(例如Service中的属性Dao对象),当Dao只有一个实现类时,默认按照类型来匹配,当有多个实现类存在,就需要在相应的实现类上标注其名称 例如: 1234567891011@Repository(\"DaoImpl1\")public class DaoImpl1 implements Dao&#123;&#125;@Repository(\"DaoImpl2\")public class DaoImpl2 implements Dao&#123;&#125;@Servicepublic class Service&#123; @Autowired private Dao DaoImpl1; 自动装配的是DaoImpl1实现类&#125; @Resource作用和@Autowired一样,区别在于它默认装配是按照名称,如果没有匹配再按照类型 @Qualifier一般配合@Autowired使用 SpringIoC依赖注入Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。例如:在Service中注入Dao接口的实现实例 依赖注入的两种方式 属性setter注入使用setter方法注入被依赖的实例, 123456public class UserService&#123; private UserDao userDao; public void setUserDao(UserDao userDao)&#123; this.userDao=userDao; &#125;&#125; 1234&lt;bean id=\"UserDao\" class=\"com.spring.dao.Impl.UserDaoImpl\" /&gt;&lt;bean id=\"UserService\" class=\"com.spring.service.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\" /&gt;&lt;/bean&gt; 构造方法注入(推荐这种方法)使用带参数的构造方法注入 123456public class UserService&#123; private UserDao userDao; public UserService(UserDao userDao)&#123; this.userDao=userDao; &#125;&#125; 1234&lt;bean id=\"UserDao\" class=\"com.spring.dao.Impl.UserDaoImpl\" /&gt;&lt;bean id=\"UserService\" class=\"com.spring.service.UserService\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\" /&gt;&lt;/bean&gt; SpringIoC常用的注解 @Configuration 相当于xml配置中的&lt;beans&gt; @Bean 相当于xml配置中的&lt;bean&gt; 定义initMethod和destroyMethod属性指定Bean的初始化和销毁方法@Bean(initMethod = “init”,destroyMethod = “destroy”) @Scope(“sigleton/prototype”)配置作用域”单例/多实例”, 默认为单例 @Lazy 懒加载,容器启动时不加载, 使用时才加载 @CompentScan 包扫描注解,在配置类上使用 @Import 直接导入组件,导入组件的id为全限定类名 @Conditionl(Condition.class),自定义一个Condition类实现Condition接口,重写matches方法限定条件 后置处理器BeanPostProcessor(Bean后置处理器)在Bean初始化前后会回调BeanPostProcessor中的postProcessBeforeInitialization(初始前)和postProcessAfterInitialization(初始后)方法 可以自定义一个Bean后置处理器, 重写这两个方法, 方法中会传递进Bean实例和BeanName BeanFactoryPostProcessor(Bean工厂的后置处理器)触发时机是在 Bean定义被注册进BeanFactory,Bean实例化之前 提供postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法, 可以在Bean初始化后,实例化前执行 BeanDefinitionRegistryPostProcessor(Bean定义注册前置处理器)继承了BeanFactoryPostProcessor,在Bean的定义注册之前触发 Aware接口Aware接口是为了让Bean能够意识到Bean自身在Spring容器中的属性,比如实现了ApplicationContextAware接口的类,能够获得ApplicationContext,实现了BeanFactoryAware接口的类,能够获取BeanFactory对象 自动装配@Autowired默认情况下, 按照类型进行装配, 如果有多个同类型组件, 那么就按照属性名来装配在同类型组件中,给一个组件加上@Primary注解, 可以优先加载这个组件 配合@Qualifier(“beanName”)可以指定装配的组件 @Resource按照类型装配,但是不支持@Primary和@Qualifier","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring入门","slug":"Java开发框架/Spring入门","date":"2018-04-29T08:55:38.000Z","updated":"2020-02-21T10:55:59.166Z","comments":true,"path":"2018/04/29/Java开发框架/Spring入门/","link":"","permalink":"https://yimchengjie.github.io/2018/04/29/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring%E5%85%A5%E9%97%A8/","excerpt":"","text":"Spring 入门spring 简介Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。 spring 架构图 Spring 是一个从实际项目开发经验中抽取的,可高度重用的应用框架. Spring 的主要作用 springBeanFactory:所有的实例可以都可以配置到 spring 工厂中,新建对象时通过工厂来新建,降低了耦合性. 并且可以配置对象的作用域 Spring 依赖注入(控制反转):相当于一个工厂管理对象之间的依赖关系用户只需要在 spring 中配置好依赖关系(在 bean 中配置属性的方式配置所依赖的对象)，在调用对象的时候，就不需要再管依赖关系了(不用 new 那些需要依赖的对象了)。比如一个对象需要另一个对象来协助完成,这时不需要主动创建所需对象,spring 容器会自动创建所需要的实例,然后注入进调用者中 SpringAOP(面向切面):实现在执行过程前后执行另外的代码,进行拦截、监控等功能也就是用来定义,在方法前后要完成的什么功能spring 的事务管理,就是基于 AOP 来实现的 总结 方便解耦,简化开发Spring 就是一个工厂,可以将所有对象的创建以及依赖关系的维护都交给它 AOP 编程的支持Spring 提供了面向切面编程,可以方便的进行权限拦截和运行监控 方便结合其他框架Spring 内部支持了和其他框架的整合,如 mybatis 方便程序测试Spring 支持 JUnit4,可以通过注释方便的测试 降低了调用 JavaEE 中一些 API 的难度比如对 JDBC 等进行了封装 声明式事务的支持只需要配置就可以完成对事务的管理","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yimchengjie.github.io/tags/Spring/"},{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}]},{"title":"idea新建maven项目","slug":"项目管理/idea新建maven项目","date":"2018-04-25T07:50:50.000Z","updated":"2020-02-26T14:56:17.917Z","comments":true,"path":"2018/04/25/项目管理/idea新建maven项目/","link":"","permalink":"https://yimchengjie.github.io/2018/04/25/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/idea%E6%96%B0%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"idea 新建 maven 项目 选择 maven 仓库目录File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;MavenMaven home directory:maven 解压目录User settings file:配置 settings.xml 文件位置Local repository:本地仓库路径 新建 maven 项目新建 project,选择 maven,next 填写信息GroupId:包名ArtifactId:项目名 选择 next,finish","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://yimchengjie.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://yimchengjie.github.io/tags/IDE/"},{"name":"maven","slug":"maven","permalink":"https://yimchengjie.github.io/tags/maven/"}]},{"title":"Mybatis之XML映射文件","slug":"Java开发框架/Mybatis之XML映射文件","date":"2018-04-22T09:04:03.000Z","updated":"2020-02-21T10:55:56.564Z","comments":true,"path":"2018/04/22/Java开发框架/Mybatis之XML映射文件/","link":"","permalink":"https://yimchengjie.github.io/2018/04/22/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Mybatis%E4%B9%8BXML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/","excerpt":"","text":"Mybatis 之 XML 映射文件MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： cache – 对给定命名空间的缓存配置。 cache-ref – 对其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 sql – 可被其他语句引用的可重用语句块这个元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中可以设置不同的值到参数占位符上。比如： 1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; CRUD 语句1234567891011121314151617&lt;select id=\"findCustomerById\" parameterType=\"Integer\" resultType=\"com.itheima.po.Customer\"&gt; SELECT * FROM t_customer WHERE id = #&#123;id&#125;&lt;/select&gt;&lt;insert id=\"addCustomer\" parameterType=\"com.itheima.po.Customer\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; INSERT INTO t_customer(username,jobs,phone) VALUES (#&#123;username&#125;, #&#123;jobs&#125;, #&#123;phone&#125;)&lt;/insert&gt;&lt;!-- update和delete和insert实现非常接近 --&gt; insert 和 update 的子标签 selectKey提供给你一个与数据库中自动生成主键类似的行为，同时保持了 Java 代码的简洁。 1234567&lt;insert id=\"addCustomer\" parameterType=\"com.itheima.po.Customer\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"Integer\" order=\"BEFORE\"&gt; select if(max(id) is null, 1, max(id)+1) as new newId from t_customer &lt;/selectKey&gt; INSERT INTO t_customer(id,username,jobs,phone) VALUES (#&#123;id&#125;,#&#123;username&#125;, #&#123;jobs&#125;, #&#123;phone&#125;)&lt;/insert&gt; 结果映射resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 1234567891011121314&lt;!-- 普通键值对存储 --&gt;&lt;!-- 没有显式指定 resultMap --&gt;&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 将规范的JavaBean 映射到 ResultSet --&gt;&lt;select id=\"selectUsers\" resultType=\"com.someapp.model.User\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt;&lt;!-- 如果列名和属性名没有精确匹配(不规范的JavaBean)，可以在 SELECT 语句中对列使用别名 --&gt;&lt;select id=\"selectUsers\" resultType=\"com.someapp.model.User\"&gt; select user_id as \"id\", user_name as \"userName\", hashed_password as \"hashedPassword\" from some_table where id = #&#123;id&#125;&lt;/select&gt; 高级结果映射我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们不总都是这样。比如，我们如何映射下面这个语句？ 123456789101112131415&lt;!-- 非常复杂的语句 --&gt;&lt;select id=\"selectBlogDetails\" resultMap=\"detailedBlogResultMap\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。 我们来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。 1234567891011121314151617181920212223242526272829&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=\"detailedBlogResultMap\" type=\"Blog\"&gt; &lt;constructor&gt; &lt;idArg column=\"blog_id\" javaType=\"int\"/&gt; &lt;/constructor&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt; &lt;/association&gt; &lt;collection property=\"posts\" ofType=\"Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;association property=\"author\" javaType=\"Author\"/&gt; &lt;collection property=\"comments\" ofType=\"Comment\"&gt; &lt;id property=\"id\" column=\"comment_id\"/&gt; &lt;/collection&gt; &lt;collection property=\"tags\" ofType=\"Tag\" &gt; &lt;id property=\"id\" column=\"tag_id\"/&gt; &lt;/collection&gt; &lt;discriminator javaType=\"int\" column=\"draft\"&gt; &lt;case value=\"1\" resultType=\"DraftPost\"/&gt; &lt;/discriminator&gt; &lt;/collection&gt;&lt;/resultMap&gt; 缓存默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：&lt;cache/&gt; 动态 SQL如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 if动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如： 123456&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的 BLOG 都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果 choose,when,otherwise有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where 12345678910111213141516&lt;!-- 应对使用if时出现的语句错误 --&gt;&lt;!-- where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。 --&gt;&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach 动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。 12345678910111213&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\" &gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt;","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"}]},{"title":"Mybatis之XML配置文件","slug":"Java开发框架/Mybatis之XML配置文件","date":"2018-04-22T07:38:49.000Z","updated":"2020-02-21T10:55:53.698Z","comments":true,"path":"2018/04/22/Java开发框架/Mybatis之XML配置文件/","link":"","permalink":"https://yimchengjie.github.io/2018/04/22/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Mybatis%E4%B9%8BXML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"XML 配置文件mybatis-config.xml配置文件包含了会影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） properties（属性）这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。 12345//resource属性,映入java属性文件`config.properties`,也可以用url属性来指定路径&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 其中的属性就可以在整个配置文件中被用来替换需要动态配置,引用语法为${property.name}也可以在 java 属性文件config.properties中来配置 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。 settings（设置）一个配置完整的 settings 元素的示例如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt; &lt;!-- 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\" /&gt; &lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\" /&gt; &lt;!-- 是否允许单一语句返回多结果集（需要驱动支持）。 --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\" /&gt; &lt;!-- 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\" /&gt; &lt;!-- 允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\" /&gt; &lt;!-- 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 --&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\" /&gt; &lt;!-- 指定发现自动映射目标未知列（或者未知属性类型）的行为。 NONE: 不做任何反应 WARNING: 输出提醒日志 ('org.apache.ibatis.session.AutoMappingUnknownColumnBehavior' 的日志等级必须设置为 WARN) FAILING: 映射失败 (抛出 SqlSessionException) --&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\" /&gt; &lt;!-- 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 --&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\" /&gt; &lt;!-- 设置超时时间，它决定驱动等待数据库响应的秒数。 --&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\" /&gt; &lt;!-- 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 --&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\" /&gt; &lt;!-- 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\" /&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\" /&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\" /&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\" /&gt; &lt;!-- 指定哪个对象的方法触发一次延迟加载。 --&gt;&lt;/settings&gt; typeAliases（类型别名）类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\" /&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\" /&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\" /&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\" /&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\" /&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\" /&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\" /&gt;&lt;/typeAliases&gt; typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\" /&gt; &lt;/plugin&gt;&lt;/plugins&gt; environments（环境配置）MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中 使用相同的 SQL 映射。有许多类似的使用场景。不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。 为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。例如 12SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 环境元素定义了如何配置环境。 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\" /&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; **注意这里的关键点: 默认使用的环境 ID（比如：default=”development”）。 每个 environment 元素定义的环境 ID（比如：id=”development”）。 事务管理器的配置（比如：type=”JDBC”）。 数据源的配置（比如：type=”POOLED”）。** databaseIdProvider（数据库厂商标识）mappers（映射器）既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。 但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如： 12345678910111213141516171819202122232425&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\" /&gt; &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\" /&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\" /&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\" /&gt; &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\" /&gt; &lt;mapper url=\"file:///var/mappers/PostMapper.xml\" /&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\" /&gt; &lt;mapper class=\"org.mybatis.builder.BlogMapper\" /&gt; &lt;mapper class=\"org.mybatis.builder.PostMapper\" /&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\" /&gt;&lt;/mappers&gt;","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"}]},{"title":"Mybatis入门","slug":"Java开发框架/Mybatis入门","date":"2018-04-21T03:20:38.000Z","updated":"2020-02-21T10:55:50.280Z","comments":true,"path":"2018/04/21/Java开发框架/Mybatis入门/","link":"","permalink":"https://yimchengjie.github.io/2018/04/21/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"什么是 MyBatisMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 Mybatis 的优点 简单小巧易于上手，方便浏览修改 SQL 语句 解除 SQL 与程序代码的耦合 提供映射标签，支持对象与数据库的 ORM 字段关系映射 提供 xml 标签，支持编写动态 SQL 安装在 maven 项目中,导入以下 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 配置 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 1234//引入mybatis-config.xml资源文件String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); mybatis-config.xml 文件包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）简单实例: 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 要注意 XML 头部的声明，它用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。 1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; 这里到底是怎么执行的?先看看上述 mybatis-config.xml 文件中包含的映射(mapper)文件:BlogMapper.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，允许你使用指定的完全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句.这和使用完全限定名调用 Java 对象的方法类似。这样，该命名就可以直接映射到在命名空间中同名的 Mapper 类，并将已映射的 select 语句中的名字、参数和返回类型匹配成方法。 因此你就可以像上面那样很容易地调用这个对应 Mapper 接口的方法，就像下面这样： 12BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101); 用注释来映射对于像 BlogMapper 这样的映射器类来说，还有另一种方法来处理映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可被替换如下： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; 使用注解来映射简单语句会使代码显得更加简洁，然而对于稍微复杂一点的语句，Java 注解就力不从心了，并且会显得更加混乱。 因此，如果你需要完成很复杂的事情，那么最好使用 XML 来映射语句。","categories":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/categories/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java开发框架","slug":"Java开发框架","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yimchengjie.github.io/tags/Mybatis/"}]},{"title":"Java程序运行堆栈分析","slug":"Java并发编程/Java程序运行堆栈分析","date":"2018-04-17T03:05:00.000Z","updated":"2020-02-26T15:28:20.779Z","comments":true,"path":"2018/04/17/Java并发编程/Java程序运行堆栈分析/","link":"","permalink":"https://yimchengjie.github.io/2018/04/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88%E5%88%86%E6%9E%90/","excerpt":"","text":"Java 程序运行堆栈分析class 文件包含 JAVA 程序执行的字节码,数据严格按照格式紧凑排列在 class 文件中的二进制流中间.java-&gt;编译-&gt;.class-&gt;JVM 运行时数据区 寄存器:最快的存储区,由编译器更具需求进行分配,我们在程序中无法控制 栈:存放函数中定义的基本类型的变量数据和对象的引用(指向堆中对应对象的地址,把对象的地址赋值给栈),但对象本身不存放在栈中,而是存放在堆(new 出来的对象)或者常量池中(字符串常量对象存放在常量池中.).栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。栈内存中的数据，没有默认初始化值，需要手动设置。 堆:存放所有 new 出来的对象.用完之后靠垃圾回收机制不定期自动消除(当栈中没有指向当前对象时,被视为垃圾,JVM 启动垃圾回收机制).堆内存中所有的实体都有内存地址值。堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。 123456Car c=new Car;c.num=5;Car c1=c;c1.color=\"green\";c.run();Car c1=c; 这句话相当于将对象复制一份出来，两个对象的内存地址值一样。所以指向同一个实体，对 c1 的属性修改，相当于 c 的属性也改了。 静态域:存放静态成员(static 定义的) 常量池:存放字符串常量和基本类型常量(public static final).编译期已经创建好(直接用双引号定义的)的就存储在常量池中 123456String s1 = \"china\";String s2 = \"china\";String s3 = \"china\";String ss1 = new String(\"china\");String ss2 = new String(\"china\");String ss3 = new String(\"china\"); s1 s2 s3 指向常量池中的同一个对象 ss1 ss2 ss3 指向堆中的三个不同对象但是 ss1 ss2 ss3 创建对象前会先去常量池中查找是否存在”china” 如果不存在 则需要在常量池中先创建一个对象,然后再在队中创建常量池中该对象的拷贝对象. 这也就是有道面试题：String s = new String(“xyz”);产生几个对象？一个或两个，如果常量池中原来没有”xyz”,就是两个。 非 RAM 存储:硬盘等永久存储空间 java 线程模型和 cpu 缓存模型cpu 缓存模型 java 线程模型 Java 线程内存模型跟 cpu 缓存模型类似，是基于 cpu 缓存模型来建立的 java 同步规则","categories":[{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java并发编程","slug":"Java并发编程","permalink":"https://yimchengjie.github.io/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java中equals的注意事项","slug":"JavaSE/Java中equals的注意事项","date":"2018-04-13T02:25:33.000Z","updated":"2020-02-26T15:47:17.374Z","comments":true,"path":"2018/04/13/JavaSE/Java中equals的注意事项/","link":"","permalink":"https://yimchengjie.github.io/2018/04/13/JavaSE/Java%E4%B8%ADequals%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"Java 中 equals 的注意事项对象的 equals 方法容易抛出空指针的异常,应尽量使用常量或者有确定值的对象来调用 equals 方法例如: 123456String str = null;if (str.equals(\"English\")) &#123; ...&#125; else &#123; ..&#125; 这样容易报空指针,应该采用以下写法 1\"English\".equals(str); 在 jdk7 中,有一个新的工具类java.util.Objects 更加推荐 1Objects.equals(str,\"English\");","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"maven项目构建工具","slug":"项目管理/maven项目构建工具","date":"2018-04-10T00:33:00.000Z","updated":"2020-02-26T14:56:36.666Z","comments":true,"path":"2018/04/10/项目管理/maven项目构建工具/","link":"","permalink":"https://yimchengjie.github.io/2018/04/10/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1. Maven 是什么Maven 是一个用于构建项目包依赖的工具它可以帮助统一维护项目中的 jar 包, 它把所有包都放在了仓库中,项目如果需要用到包,只需要引入 jar 包和对应的版本号就行了这样只需要在本地配置好一个仓库,所有的项目都可以引入,不需要再把包复制到每个项目当中了. 2.Maven 的安装和配置 从官网下载最新版本的 maven,下载完后,解压到本地 设置setting.xml文档","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://yimchengjie.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://yimchengjie.github.io/tags/maven/"},{"name":"包管理","slug":"包管理","permalink":"https://yimchengjie.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"}]},{"title":"GitHub使用","slug":"项目管理/GitHub使用","date":"2018-04-03T09:33:00.000Z","updated":"2020-02-23T07:56:26.119Z","comments":true,"path":"2018/04/03/项目管理/GitHub使用/","link":"","permalink":"https://yimchengjie.github.io/2018/04/03/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/GitHub%E4%BD%BF%E7%94%A8/","excerpt":"","text":"GitHub简介GitHub可以用来托管代码,也可以用来进行版本控制,它相比与其他版本控制工具的优势在于,可以非常方便的进行分支操作 1.注册账户2.新建一个仓库(repository) 3.配置GitHub公钥在Git终端输入ssh-keygen -t rsa -C &quot;email@email.com&quot;在系统用户下的/.ssh目录,找到id_rsa.pub文件,其中存放的就是秘钥. 再进入github个人设置,选择SSH and GPG keys,将id_rsa.pub文件中的内容复制进去如: 4. clone仓库使用 git clone &lt;项目链接&gt;将github仓库克隆到本地 5. 将本地项目上传到新建仓库 git init初始化项目 git add .添加文件索引 git commit -m “msg”提交到暂存区 git remote add origin git@XXXXXX添加为github仓库源点 git push -u origin master将源点作为主干推送到github 第5步上传被拒绝时git pull origin master –allow-unrelated-histories再重复回到第2步","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://yimchengjie.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://yimchengjie.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"代码托管","slug":"代码托管","permalink":"https://yimchengjie.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"},{"name":"Git","slug":"Git","permalink":"https://yimchengjie.github.io/tags/Git/"}]},{"title":"Git简单教程","slug":"项目管理/Git简单教程","date":"2018-03-31T00:33:00.000Z","updated":"2020-02-26T14:56:01.525Z","comments":true,"path":"2018/03/31/项目管理/Git简单教程/","link":"","permalink":"https://yimchengjie.github.io/2018/03/31/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Git%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/","excerpt":"","text":"什么是 GitGit 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 在 Windows 的安装和配置安装包下载地址 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 配置用户信息配置个人的用户名称和电子邮件地址： 12git config --g user.name \"yanchengjie\"git config --g user.email ycj996425271@live.com 查看配置信息要检查已有的配置信息，可以使用 git config –list 命令： 1git config --list Git 的工作流程Git 工作的一般流程为: 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 Git 工作区、暂存区和版本库工作区：就是你在电脑里能看到的目录。暂存区：英文叫 stage, 或 index。一般存放在 “.git 目录下” 下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。版本库：工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。 Git 创建仓库Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 Git 克隆仓库我们使用 git clone 从现有 Git 仓库中拷贝项目 1git clone git://github.com/XXXX/XXX Git 添加文件到缓存使用命令 git add &lt;fileName&gt; Git 移除缓存中的文件使用命令 git rm &lt;fileName&gt; Git 将缓存区添加到仓库使用命令git commit -m &quot;备注信息&quot; Git 分支管理列出分支命令:git branch(master 为主分支)创建分支命令:git branch (branchName)切换分支命令:git checkout (branchNaem)删除分支命令:git branch -d (branchName)合并分支命令:git merge (branchName) Git 查看提交历史使用命令 git log","categories":[{"name":"项目工具","slug":"项目工具","permalink":"https://yimchengjie.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://yimchengjie.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Git","slug":"Git","permalink":"https://yimchengjie.github.io/tags/Git/"}]},{"title":"Ajax","slug":"前端基础/Ajax","date":"2018-03-05T08:25:00.000Z","updated":"2020-02-26T14:51:02.382Z","comments":true,"path":"2018/03/05/前端基础/Ajax/","link":"","permalink":"https://yimchengjie.github.io/2018/03/05/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/Ajax/","excerpt":"","text":"AJAX1.Ajax 的作用获取服务器的数据 2.Ajax 的效果在不刷新整个页面的情况下,通过一个 url 地址获取服务器的数据,然后进行页面的局部刷新. 异布加载, 3.小结Ajax 的全称: Asychronous JavaScript And XML,就是使用 js 代码获取服务器数据. 4.Ajax 的使用Ajax 简单的来说,就是一个异布的 JavaScript 请求,用来获取后台服务端的数据,而并不是整个界面进行跳转. 在元素 js 中来实现 AJax 主要的类就是 XMLHttpRequest,它的使用一般有四个步骤; 创建 XMLHttpRequest 对象 准备发送网络请求 开始发送网络请求 指定回调函数 注意: 需要注意兼容处理.低版本浏览器不支持 XMLHttpRequest 对象,需要创建 ActiveXObject 对象; 指定请求方式,请求地址以及指定是否异步刷新 执行发送,POST 请求方式时,数据不写在地址中,放在请求数据体中.需要发送给服务器,同时设置请求头 异步的原理是通过请求浏览器进行网络数据的请求 5. 数据格式1. Xml 数据格式Xml 数据格式是将数据以标签的方式进行组装,必须以&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;开头,标签必须成对出现,xml 是一个通用标准,任何人都知道如何解析它;缺点:体积太大,传播慢,元数据太多,解析不方便,目前使用很少 2. JSON 数据格式Json 数据格式类似于 js 中的对象方式,通过 key-value 的形式组装,是一个通用的标准,任何人都知道如何解析它;优点:体积小,传输快,解析方便 3. 解析 Xml 数据格式获取 Xml 对象,在通过 getElementsBtTagName 获取标签内元素 123456789101112131415var result = xhr.responseXML;var books = result .getElementsByTagName(\"booklist\")[0] .getElementsByTagName(\"book\");var newHtml = document.getElementById(\"bookContariner\").innerHtml;for (var i = 0; i &lt; books.length; i++) &#123; var itemBook = books[i]; var name = itemBook.getElementsByTagName(\"name\")[0].textContent; var author = itemBook.getElementsByTagName(\"author\")[0].textContent; var desc = itemBook.getElementsByTagName(\"desc\")[0].textContent; var tempHtml = \"&lt;tr&gt;&lt;td&gt;\" + name + \"&lt;/td&gt;&lt;td&gt;\" + author + \"&lt;/td&gt;&lt;td&gt;\" + desc + \"&lt;/td&gt;&lt;td&gt;\"; newHtml += tempHtml;&#125;document.getElementById(\"bookContariner\").innerHtml = newHtml; 4. 解析 Json 数据格式获取 Json 对象,再通过对象直接获取对象的属性 12345678910111213var result = xhr.responseTest;//responseTest获取的是字符串,要转换成JSON对象result = JSON.parse(result);var newHtml = document.getElementById(\"bookContariner\").innerHtml;for (var i = 0; i &lt; result.length; i++) &#123;var item = result[i];var name = item.name;var author = item.author;var desc = item.desc;var tempHtml =\"&lt;tr&gt;&lt;td&gt;\" + name + \"&lt;/td&gt;&lt;td&gt;\" + author + \"&lt;/td&gt;&lt;td&gt;\" + desc + \"&lt;/td&gt;&lt;td&gt;\";newHtml += tempHtml;&#125;document.getElementById(\"bookContariner\").innerHtml = newHtml; 6.封装 Ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function myAjax(type, url, params, callback, async) &#123; var xhr = null; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; if (type == \"get\") &#123; if (params &amp;&amp; params != \"\") &#123; url += \"?\" + params; &#125; &#125; xhr.open(type, url, async); if (type == \"get\") &#123; xhr.send(null); &#125; else if (type == \"post\") &#123; xhr.setRequestHeader(\"Contend-Type\", \"application/x-www-from-urlencoded\"); xhr.send(params); &#125; if (async) &#123; xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.readyState == 200) &#123; var result = null; if (dataType == \"json\") &#123; result = xhr.responseText; result = JSON.parse(result); &#125; else if (dataType == \"xml\") &#123; result = xhr.responseXML; &#125; else &#123; result = xhr.responseText; &#125; if (callback) &#123; callback(result); &#125; &#125; &#125; &#125;; &#125; else &#123; if (xhr.readyState == 4) &#123; if (xhr.readyState == 200) &#123; var result = null; if (dataType == \"json\") &#123; result = xhr.responseText; result = JSON.parse(result); &#125; else if (dataType == \"xml\") &#123; result = xhr.responseXML; &#125; else &#123; result = xhr.responseText; &#125; if (callback) &#123; callback(result); &#125; &#125; &#125; &#125;&#125; 7 用 jQuery 实现 AjaxjQuery 对 Ajex 操作进行了封装,在 jQuery 中最底层的方法是$.ajax(),第二层是$.load()、$.get() 、$.post() 第三层是$.getJSON()、$.getScript() $.ajax()用法: + type：指定数据提交的方式 + url：提交数据的路径 + cache:是否存在缓存 + data：向后台发送的数据 + dataType：服务器端返回的数据类型，比如：xml，text，json, html，script + success：响应成功后执行的函数 + error：响应失败后执行的函数 123456789101112131415161718var subData=&#123; name:'张三'&#125; //提交的数据$.ajax(&#123; url : \"IndexController/getIndexImages.html\", type : \"POST\", async : true,//表示进行异步获取 data:subData,//提交的数据 dataType : 'json', contentType : 'application/x-www-form-urlencoded;charset=UTF-8', //contentType很重要 success : function(result) &#123; var obj = $.parseJSON(result); //在这里对返回的数据进行处理 &#125; error:function()&#123; //请求失败执行这个 &#125;&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yimchengjie.github.io/categories/JavaScript/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://yimchengjie.github.io/tags/Ajax/"},{"name":"异步请求","slug":"异步请求","permalink":"https://yimchengjie.github.io/tags/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"}]},{"title":"EL与JSTL表达式","slug":"JavaEE/EL与JSTL表达式","date":"2018-01-30T06:15:00.000Z","updated":"2020-02-26T15:33:25.002Z","comments":true,"path":"2018/01/30/JavaEE/EL与JSTL表达式/","link":"","permalink":"https://yimchengjie.github.io/2018/01/30/JavaEE/EL%E4%B8%8EJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"EL 表达式EL 表达式的功能:(让 JSP 编写更为简单) EL 是 Expression Language 的简称，即表达式语言； EL 在 JSP 中使用，服务器会对其进行解析翻译，生成相应的 Java 代码； EL 的作用是用来在 JSP 页面输出动态内容，可以替代 JSP 中的表达式元素&lt;%=%&gt; EL 表达式的一般格式:${EL表达式}例如:${param.username}等同于:&lt;%=request.getParameter(&quot;username&quot;)%&gt; EL 表达式的内置对象其中 2 个内置对象为了方便输出请求参数： param/paramValues； + 内置对象 param：用来输出请求参数的值，格式为${param.请求参数名字} + 内置对象 paramValues：用来获取一对多的参数值，返回一个数组。 4 个内置对象为了方便输出各个范围的属性： pageScope/ requestScope /sessionScope /applicationScope + 获取四个范围的属性数据 + 检索顺序：当不指定范围时，例如，${user.pwd}，将自动从 pageScope 开始查找，直到 applicationScope，如果没查到，则什么也不显示 2 个与请求头有关的内置对象：header/headerValues + 内置对象 header：用来输出输出某一个请求头的值，格式为${header.请求头名字} + 内置对象 headerValues：如果某个请求头的值有多个，则使用 headerValues 返回一个数组。 2 个其他内置对象：cookie/initParam + 内置对象 cookie：用来获取 cookie 的值 + 内置对象 initParam：用来输出上下文参数; 1 个特殊的内置对象 pageContext + 内置对象 pageContext：EL 中的 pageContext 对象可以调用 PageContext 类中所有符合规范的 getXxx 方法 使用 EL 取出内置对象的数据 普通对象和对象属性。服务器端：request.setAttribute(&quot;student&quot;, student);在浏览器上打印出服务器端绑定的数据： 123456$&#123; student &#125;&lt;!-- 相当于执行了 student.toString(); --&gt;$&#123; student.name &#125;&lt;!-- 相当于执行了 student.getName(); --&gt;$&#123; student.teacher.name &#125;&lt;!-- 相当于执行了 student.getTeacher().getName(); --&gt; 数组中的数据。服务器端： 1234567String[] nameArray = new String[]&#123;\"Tom\", \"Lucy\", \"Lilei\"&#125;;request.setAttribute(“nameArray”,nameArray);Student[] students = new Student[3];students[0] = stu1;students[1] = stu2;students[2] = stu3;request.setAttribute(“students”,students); 在浏览器上打印出服务器端绑定的数组数据： 123456789101112$&#123; nameArray[0] &#125;&lt;!-- Tom --&gt;$&#123; nameArray[1] &#125;&lt;!-- Lucy --&gt;$&#123; nameArray[2] &#125;&lt;!-- Lilei --&gt;$&#123; students[0].id &#125;&lt;!-- 输出第一个学生的ID --&gt;$&#123; students[1].name &#125;&lt;!-- 输出第二个学生的name --&gt;$&#123; students[2].teacher.name &#125;&lt;!-- 输出第三个学生的老师的name --&gt; List 中的数据。服务器端： 12345List&lt;Student&gt; studentList=new ArrayList&lt;Student&gt;();studentList.add(stu1);studentList.add(stu2);studentList.add(stu3);request.setAttribute(“studentList”,studentList); 在浏览器上打印出服务器端绑定的 List 数据： 123456$&#123; studentList[0].id &#125;&lt;!-- 输出第一个学生的ID --&gt;$&#123; studentList[1].name &#125;&lt;!-- 输出第二个学生的name --&gt;$&#123; studentList[2].teacher.name &#125;&lt;!-- 输出第三个学生的老师的name --&gt; Map 中的数据。服务器端： 12345Map&lt;String, Student&gt; studentMap = new HashMap&lt;String, Student&gt;();studentMap.put(\"Tom\", stu1);studentMap.put(\"Lucy\", stu2);studentMap.put(\"Lilei\", stu3);request.setAttribute(“studentMap”,studentMap); 在浏览器上打印出服务器端绑定的 Map 数据： 123456$&#123; studentMap.Tom.id &#125;&lt;!-- 输出第一个学生的ID --&gt;$&#123; studentMap.Lucy.name &#125;&lt;!-- 输出第二个学生的name --&gt;$&#123; studentMap.Lilei.teacher.name &#125;&lt;!-- 输出第三个学生的老师的name --&gt; EL 运算符EL 中提供了多种运算符，可以对变量或常量进行运算，输出运算结果；EL 中的运算符包括： 算术运算符 比较运算符 逻辑运算符 其他运算符 JSTLJSTL 是一套定义好的标签库，可以直接使用；JSTL 的全称是 Jsp Standard Tag Library，即 JSP 标准标签库；JSTL 包含很多标签，根据其作用可以分为：属性相关的标签、条件分支相关的标签、迭代标签、其他标签；标签库包括标签处理器类及描述文件 tld 文件，JSTL 也一样： 使用 JSTL 首先需要下载相关的 jar 文件并保存到工程的 lib 目录下；在 JSP 中使用 taglib 指令引入需要使用的标签库； forEach、set、if 等是 JSTL 中常用的标签； JSTL 标签库的使用是为类弥补 html 表的不足，规范自定义标签的使用而诞生的。在告别 modle1 模式开发应用程序后，人们开始注重软件的分层设计，不希望在 jsp 页面中出现 java 逻辑代码，同时也由于自定义标签的开发难度较大和不利于技术标准化产生了自定义标签库。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://yimchengjie.github.io/tags/JSP/"}]},{"title":"MVC模式","slug":"JavaEE/MVC模式","date":"2018-01-19T06:15:00.000Z","updated":"2020-02-26T15:36:49.938Z","comments":true,"path":"2018/01/19/JavaEE/MVC模式/","link":"","permalink":"https://yimchengjie.github.io/2018/01/19/JavaEE/MVC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"MVC 模式基本概念MVC（Model-View-Controller）是一种软件架构设计模式，最初应用在桌面应用程序； MVC 模式将软件的代码按照模型（M）、视图（V）、控制器（C）三部分组织 MVC 模式构建应用的优势: 耦合性低：视图层和业务层分离，耦合性降低，可以独立修改； 重用性高：可以用不同的视图访问模型部分，实现在不同终端上访问应用； 可维护性高：视图与业务分离，降低了维护成本； MVC 模式中的三个角色在控制器和视图之间共享数据: 在控制器和视图之间，常常需要共享数据；例如从数据查出来的商品列表信息，需要从控制器发送到视图； Servlet 和 JSP 之间共享数据一般使用请求、会话、上下文范围的属性进行； HttpServletRequest/HttpSession/ServletContext 接口中都定义了存取、查询、删除属性的方法【前面已经学习过】； 使用原则：尽量用范围小的属性，即，请求范围内共享即可就用请求，以此类推；否则会造成资源浪费，降低安全性； redirect\\forward\\include 几种跳转方式的功能与差异MVC 模式中，控制器和视图之间需要进行跳转，Servlet 规范中，有三种跳转方式： redirect：调用响应接口的 sendRedirect 方法，响应重定向，相当于重新请求新的资源，当前请求对象不会到目标资源； forward: 调用请求转发器接口的 forward 方法，请求转发，将当前的请求、响应对象转发到目标资源；(最常用) include：调用请求转发器接口的 include 方法，动态包含，将目标资源的请求、响应对象包含到当前资源； forword 带来的重复提交问题 使用 forward 转发请求后，再次刷新当前页面，会进行重复提交； 例如：使用 LoginServlet 进行登录，成功后跳转到 loginsuccess.jsp 页面： 刷新当前页面，再次进行了登录 为了能够解决重复提交问题，关键在于：能够标志一次提交，从而识别出该提交已经处理； 步骤一：在 JSP 中记录一个随机数，称为令牌（token），存储在 session 中&lt;%session.setAttribute(&quot;token&quot;,System.nanoTime())+&quot;&quot;%&gt; 步骤二：将 token 值作为表单的一个隐藏域&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;)%&gt;&quot; &gt; 步骤三：在 LoginServlet 中获取 token 值，并进行判断 12345//取出存储在请求参数中的tokenString requestToken = request.getParameter(\"token\");//取出存储在session中的tokenString sessionToken = (String)request.getSession().getAttribute(\"token\");.... 步骤四：将 token 值从会话中删除 1request.getSession().removeAttribute(\"token\");","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"}]},{"title":"JSP扩展","slug":"JavaEE/JSP扩展","date":"2017-12-29T02:25:00.000Z","updated":"2020-02-26T15:35:11.153Z","comments":true,"path":"2017/12/29/JavaEE/JSP扩展/","link":"","permalink":"https://yimchengjie.github.io/2017/12/29/JavaEE/JSP%E6%89%A9%E5%B1%95/","excerpt":"","text":"JSP 内置对象 内置对象指的是服务器已经创建好的对象，可以直接使用； 9 个内置对象: request response out out 的类型是 JspWriter out 可以用来输出内容到客户端，但是程序员一般不会使用，因为直接使用&lt;%=%&gt;即可以实现输出； page + page 即当前类对象 + page 也很少使用，与 this 相同 pageContext + 其他多数内置对象都是通过它获得 1234application = pageContext.getServletContext();config = pageContext.getServletConfig();session = pageContext.getSession();out = pageContext.getOut(); pageContext 对象是 JSP 中一个非常重要的对象，是javax.servlet.jsp.PageContext类型的对象，指的是页面的上下文，封装了其他的内置对象，同时代表的是四大作用域【页面、请求、会话、上下文】中的页面作用域，也可以在页面上下文范围添加属性，PageContext中与属性相关方法如下： 方法声明 方法描述 void setAttribute(java.lang.String name, java.lang.Object o) 将任意类型对象设置为属性，指定一个名字； java.lang.Object getAttribute(java.lang.String name) 通过属性的名字，获取属性的值； void removeAttribute(java.lang.String name) 通过属性的名字，删除属性； session + session 是 JSP 中的另一个内置对象，是HttpSession类型的对象，可以在 JSP 中调用 HttpSession 接口中的任何方法；默认存在 + application + application 是 JSP 中的另一个内置对象，是ServletContext类型的对 象，可以在 JSP 中调用ServlletContext接口中的任何方法； + exception + 内置对象 exception 比较特殊，默认情况下不存在；只有当 JSP 中使用指令指定该页面作为错误页面使用时才会翻译生成该内置对象。 + config + 在 JSP 中可以直接使用 config 对象调用 ServletConfig 接口中任意方法，例如，可以在 web.xml 中对 JSP 配置初始化参数，与前面学习的 Servlet 初始化参数相同的含义： 指令与动作 JSP 可以通过指令元素而影响容器翻译生成 Java 类的整体结构； 指令的语法为：&lt;%@ directive {attr=“value”}* %&gt;； 其中，directive 为指令名，attr 指该指令对应的属性名，一个指令可能有多个属性；JSP 中常用的指令有三个：page、include、taglib，前两个常用 page 指令作用于整个 JSP 页面，可以将指令放在 JSP 页面任何一个位置; import 属性:用来引入 JSP 文件需要使用的类； + 可以使用逗号同时引入多个包，也可以在一个 JSP 文件中多次使用 import； + 值得注意的是，import 是 page 指令中唯一一个可以在一个 JSP 文件中多次出现的属性，其他属性在一个 JSP 文件中只能出现一次； pageEncoding 属性:用来设置 JSP 文件的页面编码格式； + page 指令的 session 属性：用来设置 JSP 页面是否生成 session 对象。该属性默认值为 true，可以设置成 false。 + session 属性值设置为 false 后，该 JSP 翻译生成的类中将没有内置对象 session，该 JSP 不参与会话。 errorPage 属性:设置 JSP 页面的错误页面。当 JSP 中发生异常或错误却没有被处理时，容器将请求转发到错误页面； + 访问该页面将发生数学异常，而且并没有对异常进行处理，那么将跳转到错误页面 error.jsp isErrorPage 属性默认值是 false，可以设置为 true。在 JSP 的错误页面中，将 isErrorPage 设置为 true，则该页面翻译生成的 Java 类中，将生成 exception 内置对象。在 error.jsp 中加入代码：&lt;%@page isErrorPage=&quot;true&quot;%&gt; + 上述代码将 error.jsp 页面设置为错误页面，所以，在 error.jsp 翻译生成的 Java 类中的_jspService 方法中将生成 exception 内置对象 注意：即使一个页面没有设置 isErrorPage=“true”，也可以作为错误页面使用，区别在是否有内置对象 exception 内置对象产生。 include 指令是 JSP 中另外一个常用指令，用来静态包含其他页面； 在翻译期间，把包含的页面也翻译到当前页面的 Java 文件中，也就是 Java 源文件即实现“二合一”； &lt;%@include file=&quot;copyright.jsp&quot;%&gt; include 动作标签: JSP 规范中定义了一系列的标准动作。Web 容器按照规范进行了实现，可以解析并执行标准动作； 标准动作使用标准的 XML 语法。 12&lt;jsp:action_name attribute1=\"value1\" attribute2=\"value2\"&gt;&lt;/jsp:action_name&gt; 其中 action_name 表示标准动作的名字，attribute1 和 attribute2 是标准动作的若干个属性； include 标准动作:&lt;jsp:include&gt;是动态包含，即在运行期访问被包含的页面，并将响应结果同包含页面的响应结果合并，生成最终响应。类似在 Servlet 中调用RequestDispatcher的include方法进行包含。 include 标准动作和 include 指令的差异; include 标准动作与 include 指令都是实现包含其他页面的功能; include 标准动作的属性是 page，实现动态包含，发生在请求阶段； include 指令的属性是 file，实现静态包含，发生在翻译阶段。 include 其他动作 forward 动作：在 JSP 页面中进行请求转发，如下代码所示：&lt;jsp:forward page=“loginsuccess.jsp&quot;&gt; &lt;/jsp:forward&gt; param 动作：往往作为子动作使用，为 forward 和 include 动作传递参数，如下代码所示：&lt;jsp:forward page=&quot;copyright.jsp&quot;&gt; &lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt; &lt;/jsp:forward&gt; &lt;jsp:include page=&quot;copyright.jsp&quot;&gt; &lt;jsp:param name=&quot;author&quot; value=&quot;etc&quot;/&gt; &lt;/jsp:include&gt; 上述代码使用 param 为 forward 和 include 动作传递参数，参数将被作为请求参数传递。 使用标准动作时，一定注意正确结束标准动作，如&lt;jsp:include&gt;是标准动作的开始，一定要对应结束标记，如&lt;/jsp:include&gt;。 JavaBeanJavaBean 是用 Java 语言描述的软件组件模型，实际上是一个 Java SE 的类，这些类遵循一定的编码规范： 必须是 public 类 ； 必须有一个无参的 public 的构造方法； 返回属性的方法为 getXxxx()格式 ； 设置属性的方法为 setXxx(形式参数)格式； JSP 中还提供了 3 个与 JavaBean 有关的动作； useBean动作：&lt;jsp:useBean id=“” class=“” scope=“”&gt; useBean 标准动作用来使用 JavaBean 对象，JavaBean 对象是某一范围（用 scope 指定）的属性； Java Bean 对象名字用 id 指定，类型用 class 指定。如果对应范围没有该属性，则调用 class 指定类的无参构造方法，创建一个该类的对象，并将该对象存储为 scope 内的一个属性，属性名为 id； 其中 scope 有四种：page、request、session、application，分别为 PageContext 范围、HttpServletRequest 范围、HttpSession 范围、ServletContext 范围。如果不指定 scope 的值，默认为 page 范围。 setProperty 动作：&lt;jsp:setProperty name=“” property=“” param|value=“”/&gt; setProperty 标准动作可以用来对 JavaBean 对象的属性赋值，替代调用 setXxxx 方法； setProperty 的 name 属性表示 JavaBean 对象的 id 值，property 表示需要调用的 setXxx 方法中的 Xxx 部分，将首字母变小写。比如需要调用 setCustname 方法，则 property 即为 Custname 首字母变小写，即 custname； 如果 setXxx 方法的参数是某一个请求参数的值，则使用 param 属性指定请求参数名字即可； 如果 setXxx 方法的参数是一个常量，则使用 value 属性指定即可。 同时，setProperty 标准动作可以对一些常见数据类型直接转换，如字符串与 Integer 的转换就可以自动进行； getProperty 动作：&lt;jsp:getProperty name=”” property=””/&gt; getProperty 标准动作用来调用 JavaBean 对象的 getXxx 方法，将其返回值在当前位置输出。 name 是 JavaBean 对象的 id 值，property 的值是 getXxx 方法中的 Xxx 部分，首字母变小写。假设需要调用 getAddress 方法显示其返回值，那么 property 的值就是 Address 的首字母变小写，即 address。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://yimchengjie.github.io/tags/JSP/"}]},{"title":"Servlet上下文","slug":"JavaEE/JSP上下文","date":"2017-12-25T10:47:00.000Z","updated":"2020-02-26T15:35:27.234Z","comments":true,"path":"2017/12/25/JavaEE/JSP上下文/","link":"","permalink":"https://yimchengjie.github.io/2017/12/25/JavaEE/JSP%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"什么是上下文上下文 ServletContext 对象是用来存储全局范围信息的对象;换句话说,一个 Web 应用只有唯一一个上下文对象. 当服务器启动的时候，就会为每一个应用创建一个上下文对象； 当服务器关闭的时候，上下文对象就销毁； Servlet 中的 ServletContext 接口 方法声明 方法描述 java.io.InputStream getResourceAsStream(java.lang.String path) 将 path 所代表的资源以输入流返回，可以进一步进行读操作；可以用来读取服务器端的文件； RequestDispatcher getRequestDispatcher(java.lang.String path) 返回 RequestDispatcher 对象，路径是相对于上下文路径的； 上下文获取方法Servlet 规范中的多个接口中都定义了getServletContext方法获得上下文对象 上下文参数 在 web.xml 中可以配置上下文参数，使用ServletContext中的getInitParameter方法可以获取该参数；【之前学习过的 Servlet 初始化参数，只能在当前 Servlet 中使用】 上下文参数存储在上下文对象，所以应用下所有组件都可以使用； 获取上下文参数： 1234&lt;context-param&gt; &lt;param-name&gt;version&lt;/param-name&gt; &lt;param-value&gt;2.0&lt;/param-value&gt;&lt;/context-param&gt; 12345//返回ServletContext对象ServletContext ctxt=this.getServletContext();//获取上下文参数String version=ctxt.getinitParameter(\"version\");System.out.println(\"上下文参数version的值:\"+version); 利用 ServletContext 在应用中共享数据 方法声明 方法描述 void setAttribute(java.lang.String name, java.lang.Object o) 将任意类型对象设置为上下文属性，指定一个名字 java.lang.Object getAttribute(java.lang.String name) 通过属性的名字，获取属性的值； void removeAttribute(java.lang.String name) 通过属性的名字，删除属性； 四大作用范围在 Web 应用中，有四大作用域范围 页面范围PageContext：一个 Servlet 或 JSP 文件； 请求范围ServletRequest：一次请求中可以访问多个 Servlet 或 JSP； 访问的 Servlet 或 JSP 能够包含其他资源； 会话范围HttpSession：一次会话中可以包含多个请求； 上下文范围ServletContext：上下文包含所有会话；","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://yimchengjie.github.io/tags/JSP/"}]},{"title":"会话跟踪(前后端交互)","slug":"JavaEE/会话跟踪(前后端交互)","date":"2017-12-23T06:01:00.000Z","updated":"2020-02-26T15:32:36.441Z","comments":true,"path":"2017/12/23/JavaEE/会话跟踪(前后端交互)/","link":"","permalink":"https://yimchengjie.github.io/2017/12/23/JavaEE/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA(%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92)/","excerpt":"","text":"会话的概念和作用 会话: 对于 Web 应用来说,会话就是浏览器与服务器之间的一次连续的通讯过程. HTTP 协议是无状态的，也就是说，一次请求结束后，HTTP 协议就不再记录相关信息； 而实际应用中，却常常需要记住一些状态信息； ==会话跟踪==技术就是能够跟踪客户端和服务端的交互,保存和记忆相关信息,保存请求的状态信息. 常用的四种会话跟踪技术 URL 方式：需要保存的信息直接追加到 URL 后，例如：http://127.0.0.1:8080/chapter03/viewList?pageNo=12 隐藏域方式：可以使用表单中的隐藏域保存相关信息， 例如：&lt;input type=&quot;hidden&quot; name=“status&quot; value=“true&quot;&gt; Cookie 方式：将状态信息保存到客户端，服务器能够获得相关信息进行分析，从而生成对客户端的响应；例如简化登录功能就可以使用 Cookie 实现； Session 方式：将状态信息保存到服务器的会话对象中，通过唯一标记的 ID 值与客户端进行绑定使用；例如访问控制功能就可以使用 Session 实现； Cookie 的功能和特点 Cookie 是一段保存在客户端的小文本；能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪到用户的状态； Cookie 包含一系列属性:如: name：cookie 的名字，每个 cookie 都有一个名字； + content：cookie 的值，与名字一起作为键值对形式存在； + domain：域，该 cookie 的域名，例如 csdn.net，说明当前 cookie 来自 csdn.net; + path：路径，访问 csdn.net 下该路径时，当前 cookie 将被发送； + created：cookie 被创建的时间； + Expired：cookie 失效的时间； + 最大生命时间：失效时间和创建时间的时间差，就是 cookie 的最大生命时间，超过该时间，cookie 将失效，不再被发送到相应的域地址； 创建 cookie,设置 cookie 属性Servlet 规范中定了 Cookie 类，创建该类对象就可以创建 Cookie，并可以调用其中方法为 Cookie 设置属性； 方法声明 方法描述 Cookie(java.lang.String name, java.lang.String value) 创建 Cookie 对象，指定名字和对应的值； void setMaxAge(int expiry) 设置最大生命时间（秒），如果不设置，当前浏览器关闭，cookie 即失效； void setValue(java.lang.String newValue) 设置 Cookie 的值； setDomain(java.lang.String domain) 设置 cookie 的域名； cookie 创建好后并不能存储到客户端,要将 cookie 保存到客户端,必须添加到响应对象中,响应接口中定义了 Cookie 的方法:|方法声明|方法描述||:—:|:—:||void addCookie(Cookie cookie)|将 Cookie 对象保存到相应的响应对象中；| 当访问相同域名及路径时,没有超过有效时间的 cookie 将自动通关请求发送到网站; Servlet 在请求接口中定义了获取 cookie 的方法:|方法声明|方法描述||:—:|:—:||Cookie[] getCookies()|获取请求中的所有 Cookie 对象，返回数组；| Session 简介 Session 是会话跟踪的另一种实现手段； Session 是存储在服务器上的对象，该对象由服务器创建并维护； 服务器为客户端与服务器的每一次会话过程都创建并维护一个 Session 对象；每个服务器对 Session 的创建和维护的底层实现有所区别； session 创建的时间一个常见的误解是以为 session 在有客户端访问时就被创建，然而事实是直到某 server 端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果 JSP 没有显示的使用 &lt;% @page session=”false”%&gt; 关闭 session，则 JSP 文件在编译成 Servlet 时将会自动加上这样一条语句 HttpSession session = HttpServletRequest.getSession(true);这也是 JSP 中隐含的 session 对象的来历。 由于 session 会消耗内存资源，因此，如果不打算使用 session，应该在所有的 JSP 中关闭它。 session 的生命周期Session 生成后，只要用户继续访问，服务器就会更新 Session 的最后访问时间，并维护该 Session。用户每访问服务器一次，无论是否读写 Session，服务器都认为该用户的 Session“活跃（active）”了一次。 由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的 Session 从内存删除。这个时间就是 Session 的超时时间。如果超过了超时时间没访问过服务器，Session 就自动失效了。","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"Cookie","slug":"Cookie","permalink":"https://yimchengjie.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://yimchengjie.github.io/tags/Session/"}]},{"title":"JSP","slug":"JavaEE/JSP","date":"2017-12-15T06:37:00.000Z","updated":"2020-02-26T15:34:05.113Z","comments":true,"path":"2017/12/15/JavaEE/JSP/","link":"","permalink":"https://yimchengjie.github.io/2017/12/15/JavaEE/JSP/","excerpt":"","text":"什么是 JSPJSP（Java Server Page）是 Java 服务端的页面，所以它是动态的，它是需要经过 JDK 编译后把内容发给客户端去显示，我们都知道，Java 文件编译后会产生一个 class 文件，最终执行的就是这个 class 文件。翻译和编译的过程遵守 Servlet 规范，因此说==JSP 的本质也是 Servlet==；html 和 jsp 的表头不一样，这个是 JSP 的头&lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;在表头中有编码格式和倒入包等。也是很好区分的，在 jsp 中用&lt;%%&gt;就可以写 Java 代码了，而 html 没有&lt;%%&gt;。 简单说，jsp 在后台通过服务器解析为相应的 html，然后在供浏览器识别显示。 为什么要用 JSPServlet 生成动态页面比较繁琐，使用 JSP 生成动态页面比较便捷，因为其中的静态内容可以使用 HTML 生成； JSP 元素 脚本元素可以用来包含任意 Java 代码,格式为：&lt;%Java代码%&gt; 服务器翻译脚本元素时，将把其中 Java 代码直接翻译到jspService方法中，如果语法错误，将在浏览器中提示错误； 表达式元素用来向页面输出动态内容;格式为：&lt;%=Java代码%&gt; 服务器翻译表达式元素时，将把其中 Java 代码部分的返回值使用 out.write 语句输出 模块元素指 JSP 中静态 HTML 或者 XML 内容 注释元素有三种情况： 格式为&lt;%--JSP注释--%&gt;；JSP 的注释只有在源代码中可见，翻译时已经忽略； + 在 JSP 中，除了使用 JSP 注释外，还可以使用 HTML 注释，&lt;!--HTML注释--&gt;，HTML 注释会被返回到客户端，但是不显示到页面中； + JSP 中的 Java 代码部分，可以使用 Java 注释；Java 注释会翻译到.java 文件中，但是编译时忽略； 声明元素: 如果需要在 JSP 文件中定义类的成员变量或方法，可以使用声明元素，格式为&lt;%! 声明语句%&gt; 1&lt;%! private String path=\"WEB-INF\"; public void readPropertiesFile()&#123;&#125;&gt; 声明元素被翻译到 Java 类中，而不是_jspService 方法中； 内置对象内置对象指的是在 JSP 中可以直接使用的对象，不需要声明，直接使用固定的名字使用即可；例如&lt;%=request.getRemoteAddr()%&gt;中的request就是内置对象； jsp 中共有 9 种对象 request：用户端请求，此请求会包含来自 GET/Post 请求的参数； response：网页传回用户端的回应。 pageContext：页面的属性是在这里管理 session：与请求有关的回话期 application ：Servlet 正在执行的内容 out ：用来传递回应的输出 config ：servlet 的构架部件 pagejsp网页本身 exception ：针对错误的网页。未捕捉的例外 Servlet 和 JSP 的作用实际应用中，Servlet 是不会用来生成动态页面的，而是会用来接收来自 JSP 的请求，处理请求，然后调跳转到 JSP 页面把结果显示给客户端看； Servlet 与 JSP 之间的跳转方式 跳转方式一:响应重定向,响应接口中提供了该方法 void sendRedirect(java.lang.String location):响应重定向到 location，相当于客户端重新请求 location 所在的资源； 第一个 JSP 页面发送请求request到Servlet,Servlet接收请求后,响应response重定向到目标 JSP 页面,但是请求并没有传递过来.(重定向相当于是产生一个新的请求) 跳转方式二:请求转发,RequestDispatcher 接口定义了请求转发的方法 forward(ServletRequest request, ServletResponse response):将请求转发到服务器上的其他资源，包括其他的 Servlet，JSP 等； 要使用 forward 方法，需要先获得 RequestDispatcher 对象；请求接口(request)中提供了获得该对象的方法： RequestDispatcher getRequestDispatcher(java.lang.String path):使用 path 返回一个 RequestDispatcher 对象 请求转发把请求对象发送到了目标 JSP 页面,因此目标页面可以获得上一个页面的请求对象. 请求属性的使用如果需要在 Servlet，JSP 之间跳转时，同时把一些自定义的、或者通过数据库查询的、或者调用其他资源获得的数据传递到下一个资源时，就可以把这些数据设置为请求的属性即可。 请求接口中定义了一系列与属性有关的方法。|方法声明|方法描述||:——:|:—–:||void setAttribute(java.lang.String name, java.lang.Object o)|将任意类型对象设置为请求的属性，指定一个名字；||java.lang.Object getAttribute(java.lang.String name)|通过属性的名字，获取属性的值；||void removeAttribute(java.lang.String name)|通过属性的名字，删除属性；|可以将数据封装进请求对象中,在前后端传递例如:后台 Servlet 中将数据保存进 request(请求)中,跳转到前台 JSP 后,JSP 可以用&lt;%=request.getAttribute(&quot;name&quot;)%&gt;来获取(直接输出)也可以保存为变量(前提是需要强转,因为获取的是 Object 类型)","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"JSP","slug":"JSP","permalink":"https://yimchengjie.github.io/tags/JSP/"}]},{"title":"Servlet","slug":"JavaEE/Servlet","date":"2017-12-06T09:12:00.000Z","updated":"2020-02-26T15:37:29.113Z","comments":true,"path":"2017/12/06/JavaEE/Servlet/","link":"","permalink":"https://yimchengjie.github.io/2017/12/06/JavaEE/Servlet/","excerpt":"","text":"什么是 ServletJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet 的线程特性Web 应用服务器(Tomcat)将为每个客户端的连接启动一个线程来服务第一次访问 Servlet 时，服务器将创建一个该 Servlet 类的对象，并调用 doXXX 方法生成响应；多个客户端访问同一个 Servlet 时，不再创建新的对象，而是共用同一个 Servlet 对象。可以说，Servlet 是多线程单实例的。 Servlet 请求和响应接口通过浏览器提交给服务端的所有数据,都称为请求数据 通过服务器返回给客户端的所有数据,都称为响应数据 ServletAPI 中,定义了请求和响应接口,用来封装和操作请求和响应数据 请求接口: javax.servlet.ServletRequest javax.servlet.HttpServletRequest 响应接口: javax.servlet.ServletResponse javax.servlet.HttpServletResponse Servlet 类使用 doXXX 方法提供服务,这些方法继承于HttpServletdoXXX 方法中都有两个参数,分别是请求和响应;|方法|参数|作用||:–:|:–:|:–:||void doDelete|(HttpServletRequest request,HttpServletResponse response)|用来处理一个 HTTP DELETE 操作,这个操作允许客户端请求从服务器上删除 URL||void doGet|(HttpServletRequest request, HttpServletResponse response)|用来处理一个 HTTP GET 操作。这个操作允许客户端简单地从一个 HTTP 服务器“获得”资源||void doHead|(HttpServletRequest request, HttpServletResponse response)|用来处理一个 HTTP HEAD 操作。默认的情况是，这个操作会按照一个无条件的 GET 方法来执行||void doOptions|(HttpServletRequest request, HttpServletResponse response)|用来处理一个 HTTP OPTION 操作。这个操作自动地决定支持哪一种 HTTP 方法。例如，一个 Servlet 写了一个 HttpServlet 的子类并重载了 doGet 方法，doOption 会返回下面的头： Allow:GET,HEAD,TRACE,OPTIONS||void doPost|(HttpServletRequest request, HttpServletResponse response)|用来处理一个 HTTP POST 操作。这个操作包含请求体的数据，Servlet 应该按照他行事。||void doPut|(HttpServletRequest request, HttpServletResponse response)|用来处理一个 HTTP PUT 操作。这个操作类似于通过 FTP 发送文件。||void doTrace|(HttpServletRequest request, HttpServletResponse response)|用来处理一个 HTTP TRACE 操作。这个操作的默认执行结果是产生一个响应，这个响应包含一个反映 trace 请求中发送的所有头域的信息。||long getLastModified|(HttpServletRequest request)|返回这个请求实体的最后修改时间。||void service|(HttpServletRequest request, HttpServletResponse response)|这是一个 Servlet 的 HTTP-specific 方案，它分配请求到这个类的支持这个请求的其他方法。当你开发 Servlet 时，在多数情况下你不必重载这个方法。|也就是说：服务器会创建请求对象和响应对象传递给 doXXX 方法，doXXX 方法中可以直接使用请求和响应对象;doXXX 方法中可以使用方法参数 request，response 去调用请求和响应接口中的方法； 利用 Servlet 对客户端不同方式请求作出动态响应客户端访问服务器端 Servlet 的三种方式: 直接从地址栏输入 URL 访问；是 GET 方式，调用 doGet 方法; 在网页中点击超级链接访问；是 GET 方式，调用 doGet 方法; 在网页中通过表单提交访问；取决 form 的 method 属性的值，默认是 get，指定为 post 时，调用 doPost 方法; Servlet 中获取请求参数的方法: 可以在 URL 后使用 name=value&amp;name=value 的形式传递，例如： 12&lt;a href=“TestPramServlet?page=1&amp;author=wangxh”&gt;&lt;!-- 传递两个请求参数，名字分别为page和author，值分别为1和wangxh；--&gt; 可以在使用表单提交，表单中的元素值将作为请求参数传递，元素的 name 是参数名字，value 的值是参数的值 当客户端请求服务器端的 Servlet 时，请求参数都会被发送到服务器，服务器会将请求参数封装到请求对象中； Servlet 初始化参数 如果某个 Servlet 需要使用一些可以配置的参数，可以在 web.xml 进行配置，称为初始化参数； 这些参数在服务器初始化 Servlet 实例时被初始化到配置信息中，可以在 Servlet 中获取并使用； 一个 Servlet 可以配置多个初始化参数，所有的初始化参数只能在当前 Servlet 类中使用； Servlet 加载启动选项 默认情况下，只有当第一次访问 Servlet 时，服务器才会初始化 Servlet 实例； 如果需要更早实例化 Servlet，可以在 web.xml 中进行配置，使得在启动容器的时候就能初始化 Servlet 实例； Servlet 配置中通配符*的用法 _.扩展名 ： 比如 _.do、*.action 以 / 开头，同时以 /_ 结尾，比如 /_ 、/admin/* web.xml 中首页及错误页面等其他配置信息 配置默认页面:当不指定具体访问路径时,默认访问默认页面 12345678&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 配置错误页面:当应用中出现响应错误或者异常时,可以跳转到错误页面; Servlet 中获取请求头属性的方法客户端请求服务端的 Servlet,会传递给服务器一系列的 HTTP 请求头属性,请求接口中定义了系列方法获取请求属性","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"Servlet","slug":"Servlet","permalink":"https://yimchengjie.github.io/tags/Servlet/"}]},{"title":"Java线程","slug":"JavaSE/Java线程","date":"2017-11-30T00:43:00.000Z","updated":"2020-02-26T15:46:57.311Z","comments":true,"path":"2017/11/30/JavaSE/Java线程/","link":"","permalink":"https://yimchengjie.github.io/2017/11/30/JavaSE/Java%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"Java 多线程程序.进程和多任务 程序（program） 是对数据描述与操作的代码的集合，是应用程序执行的脚本。 进程（process） 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。 多任务（multi task） 在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程。 线程 线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序 一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。 如何创建多线程 创建 java.lang.Thread 类的子类，重写该类的 run 方 法 创建 java.lang.Runnable 接 口的实现类，实现接口中的 run 方法(用的更多) Runnable 接口与 Thread 类之间的区别 Runnable 接口必须实现 run 方法，而 Thread 类中的 run 方法是一个空方法，可以不重写 Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必须依靠 Thread 类 Runnable 接口适合于资源的共享 多线程的四种状态 新建（New） 可执行（Runnable） 运行（Running) 阻塞（Blocking) 死亡（Dead) 状态之间的相互转化可执行&lt;—-&gt;阻塞 wait()方法: 中断方法的执行，使本线程等待，暂时让出 cpu 的使用权，并允许其他线程使用这个同步方法。 notify()方法： 唤醒由于使用这个同步方法而处于等待线程的 某一个结束等待 notifyall()方法： 唤醒所有由于使用这个同步方法而处于等待的线程结束等待","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"线程","slug":"线程","permalink":"https://yimchengjie.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"SteamAPI","slug":"JavaSE/SteamAPI","date":"2017-11-25T03:30:00.000Z","updated":"2020-02-26T15:50:03.735Z","comments":true,"path":"2017/11/25/JavaSE/SteamAPI/","link":"","permalink":"https://yimchengjie.github.io/2017/11/25/JavaSE/SteamAPI/","excerpt":"","text":"Stream APIStream 位于包 java.util.stream .* 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 流(Stream)到底是什么呢是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。集合讲的是数据，流讲的是计算！ 注意 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream 的操作三步骤 创建 Stream一个数据源（如：集合、数组），获取一个流 中间操作一个中间操作链，对数据源的数据进行处理 终止操作（终端操作）一个终止操作，执行中间操作链，并产生结果 1. 创建 Stream 可以通过Collection系列集合提供的stream()或parallelStream()方法default Stream&lt; E&gt; stream() : 返回一个顺序流default Stream&lt; E&gt; parallelStream() : 返回一个并行流 通过 Arrays 中的静态方法stream()获取数组流static &lt;T&gt; Stream&lt;T&gt; stream( T[] array): 返回一个流重载形式，能够处理对应基本类型的数组：public static IntStream stream(int[] array)public static LongStream stream(long[] array)public static DoubleStream stream(double[] array) 通过 Stream 类中的静态方法 of()，通过显示值创建一个流。它可以接收任意数量的参数。public static&lt; T&gt; Stream&lt; T&gt; of(T… values) : 返回一个流 创建无限流可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流。迭代 public static&lt; T&gt; Stream&lt; T&gt; iterate(final T seed, final UnaryOperator&lt; T&gt; f)生成 public static&lt; T&gt; Stream&lt; T&gt; generate(Supplier&lt; T&gt; s)java //创建Stream @Test public void test1(){ //1.可以通过Collection 系列集合提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); //2.通过 Arrays 中的静态方法stream()获取数组流 Employee[] emps=new Employee[10]; Stream&lt;Employee&gt; stream2=Arrays.stream(emps); //3.通过Stream 类中的静态方法of() Stream&lt;String&gt; stream3=Stream.of(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;); //4.创建无限流 //迭代 Stream&lt;Integer&gt; stream4=Stream.iterate(0, (x) -&gt; x+2); stream4.limit(10).forEach(System.out::println); //生成 Stream.generate(() -&gt; Math.random()).limit(5).forEach(System.out::println); } 2.中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性处理，成为“惰性求值”。 筛选与切片 filter(Predicate p): 接收 lambda,从流中排除某些元素 distinct(): 筛选,通过流所生成元素的hashCode()和equals去除重复元素 limit(long maxSize): 截断流,使元素不超过给定数量 skip(long n): 跳过元素,返回一个扔掉了前 n 个元素的流,若流中元素不足 n 个,则返回一个空流,与limit(n)互补 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//中间操作 List&lt;Employee&gt; employees=Arrays.asList( new Employee(\"张三\",18,9999.99), new Employee(\"李四\",58,5555.55), new Employee(\"王五\",26,3333.33), new Employee(\"赵六\",36,6666.66), new Employee(\"田七\",12,8888.88), new Employee(\"田七\",12,8888.88) ); /* 筛选与切片 * filter--接收Lambda，从流中排除某些元素。 * limit--截断流，使其元素不超过给定数量。 * skip(n)--跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补 * distinct--筛选，通过流所生成元素的 hashCode() 和 equals() 去掉重复元素 */ //内部迭代：迭代操作由 Stream API 完成 @Test public void test1()&#123; //中间操作：不会执行任何操作 Stream&lt;Employee&gt; stream=employees.stream().filter((e) -&gt; e.getAge()&gt;35 ); //终止操作：一次性执行全部内容，即 惰性求值 stream.forEach(System.out::println); &#125; //外部迭代 @Test public void test2()&#123; Iterator&lt;Employee&gt; it=employees.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125; @Test public void test3()&#123;//发现“短路”只输出了两次，说明只要找到 2 个 符合条件的就不再继续迭代 employees.stream().filter((e)-&gt;&#123; System.out.println(\"短路！\"); return e.getSalary()&gt;5000; &#125;).limit(2).forEach(System.out::println); &#125; @Test public void test4()&#123; employees.stream().filter((e)-&gt;e.getSalary()&gt;5000).skip(2)//跳过前两个 .distinct()//去重，注意：需要Employee重写hashCode 和 equals 方法 .forEach(System.out::println); &#125; 映射 1234567891011121314151617181920212223/* 映射* map--接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。* flatMap--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流*/@Testpublic void test5()&#123; List&lt;String&gt; list=Arrays.asList(\"aaa\",\"bbb\",\"ccc\",\"ddd\"); list.stream() .map((str)-&gt;str.toUpperCase()) .forEach(System.out::println); System.out.println(\"------------------------\"); employees.stream().map(Employee::getName) .forEach(System.out::println); System.out.println(\"------------------------\"); Stream&lt;Character&gt; sm=list.stream() .flatMap(TestStream::filterChatacter); sm.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterChatacter(String str)&#123; List&lt;Character&gt; list=new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125; 排序 1234567891011121314151617/*排序* sorted()-自然排序（按照对象类实现Comparable接口的compareTo()方法 排序）* sorted(Comparator com)-定制排序（Comparator）*/@Testpublic void test7()&#123; List&lt;String&gt; list=Arrays.asList(\"ccc\",\"bbb\",\"aaa\"); list.stream().sorted().forEach(System.out::println); System.out.println(\"------------------------\"); employees.stream().sorted((e1,e2)-&gt;&#123; if(e1.getAge().equals(e2.getAge()))&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e1.getAge().compareTo(e2.getAge()); &#125; &#125;).forEach(System.out::println);&#125; 3. 终止操作终止操作会从流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。 查找与匹配 1234567891011121314151617181920212223242526272829/** 查找与匹配*/@Testpublic void test1()&#123; //allMatch-检查是否匹配所有元素 boolean b1=employees.stream().allMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b1);//false boolean b2=employees.stream().anyMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b2);//true //noneMatch-检查是否没有匹配所有元素 booleanb3=employees.stream().noneMatch((e)-&gt;e.getStatus().equals(Status.BUSY)); System.out.println(b3);//false //findFirst-返回第一个元素//Optional是Java8中避免空指针异常的容器类 Optional&lt;Employee&gt; op=employees.stream().sorted((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).findFirst(); System.out.println(op.get()); //findAny-返回当前流中的任意元素 Optional&lt;Employee&gt; op2=employees.parallelStream().filter((e)-&gt;e.getStatus().equals(Status.FREE)).findAny(); System.out.println(op2.get()); //count-返回流中元素的总个数 Long count=employees.stream().count(); System.out.println(count);//5 //max-返回流中最大值 Optional&lt;Employee&gt; op3=employees.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op3.get()); //min返回流中最小值 Optional&lt;Double&gt;op4=employees.stream().map(Employee::getSalary).min(Double::compare); System.out.println(op4.get());//3333.33 &#125; 归约 1234567891011121314/*归约* reduce(T identity,BinaryOperator b) / reduce(BinaryOperator b)-可以将流中元素反复结合起来，得到一个值。*/@Testpublic void test3()&#123; List&lt;Integer&gt; list=Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum=list.stream() reduce(T identity,BinaryOperator b).reduce(0, (x,y)-&gt;x+y); //0为起始值 System.out.println(sum); System.out.println(\"--------------------------\"); Optional&lt;Double&gt; op=employees.stream().map(Employee::getSalary).reduce(Double::sum); System.out.println(op.get());&#125; 收集 1234567891011121314151617181920212223242526272829303132333435/** 收集* collect-将流转换为其他形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。*/@Testpublic void test4()&#123; List&lt;String&gt; list=employees.stream().map(Employee::getName).collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(\"----------------------------\"); Set&lt;String&gt; set=employees.stream().map(Employee::getName).collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println(\"----------------------------\"); //总和 Long count=employees.stream().collect(Collectors.counting()); System.out.println(count); //平均值 Double avg=employees.stream().collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); //总和 Double sum=employees.stream().collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); //最大值 Optional&lt;Employee&gt; max=employees.stream().collect(Collectors.maxBy((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(max.get()); //最小值 Optional&lt;Double&gt; min=employees.stream().map(Employee::getSalary).collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); System.out.println(\"----------------------------\"); //分组 Map&lt;Status,List&lt;Employee&gt;&gt; map=employees.stream().collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(map); //分区 Map&lt;Boolean,List&lt;Employee&gt;&gt; map3=employees.stream().collect(Collectors.partitioningBy((e)-&gt;e.getSalary()&gt;8000)); System.out.println(map3);)","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"Lambda","slug":"JavaSE/Lambda","date":"2017-11-18T05:40:00.000Z","updated":"2020-02-26T15:47:31.071Z","comments":true,"path":"2017/11/18/JavaSE/Lambda/","link":"","permalink":"https://yimchengjie.github.io/2017/11/18/JavaSE/Lambda/","excerpt":"","text":"函数式接口我们把只拥有一个方法的接口称为函数式接口.我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个 Object 已经提供的方法，比如 toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过 API 作者们可以通过 @FunctionalInterface 注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。 函数式接口的实现引入了一个全新的结构化函数类型.我们也称为是”箭头”类型. Java8 中加入新的包：java.util.function它包含了常用的函数式接口: Predicate&lt;T&gt;: 接收T并返回boolean Consumer&lt;T&gt;: 接收T,不返回值 Function&lt;T, R&gt;: 接收T,返回R Supplier&lt;T&gt;: 提供T,不接收值 Unaryoperator&lt;T&gt;: 接收T,返回T Binary0perator&lt;T&gt;: 接收两个T,返回T Lambda 表达式lambda 表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的语法过于冗余. 下面是一些表达式: 123(int x,int y)-&gt;x+y()-&gt;42(String s)-&gt;System.out.println(s); lambda 表达式的语法由参数列表、箭头符号 -&gt; 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块： 表达式:表达式会被执行然后返回执行结果. 语句块:语句块中的语句会被依次执行,就像方法中的语句一样 return语句会把控制权交给匿名方法的调用者 break和continue只能在循环中使用 如果函数体有返回值,那么函数体内部的每一条路径都必须返回值 目标类型: 编译器负责推导lambda表达式类型,它利用 lambda 表达式所在上下文所期待的类型进行推导,这个被期待的类型被称为==目标类型==.lambda表达式只能出现在目标类型为函数式接口的上下文中. 当然lambda对于目标类型也是有要求的,编译器会检查 lambda 表达式的类型和目标类型的方法签名是否一致,当且仅当下面所有条件均满足时,lambda 表达式才可以被赋给目标类型T: T是一个函数式接口 lambda表达式的参数和T的方法参数在数量和类型上一一对应 lambda表达式的返回值和T的方法返回值相兼容 lambda表达式内锁抛出的异常和T的方法throws类型相兼容 Java 内置函数式接口为了免去用户每次使用 Lamdba 表达式时,都自行创建函数式接口,java 中提供了四大核心内置函数式接口: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Consumer&lt;T&gt; :消费型接口 * void accept(T t); * * Supplier&lt;T&gt; :供给型接口 * T get(); * * Function&lt;T,R&gt; :函数型接口 * R apply(T t); * * Predicate&lt;T&gt; :断言型接口 * boolean test(T t); */public class TestLambda3 &#123; //Consumer&lt;T&gt; 消费型接口： public void happy(double money,Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125; @Test public void test1()&#123; happy(1000,(m) -&gt;System.out.println(\"消费：\"+m+\"元\")); &#125; //Supplier&lt;T&gt; 供给型接口: //需求：产生指定个数的整数，并放入集合中 public List&lt;Integer&gt; getNumList(int num,Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n=sup.get(); list.add(n); &#125; return list; &#125; @Test public void test2()&#123; List&lt;Integer&gt; numList=getNumList(10, ()-&gt;(int)(Math.random()*100)); for (Integer num : numList) &#123; System.out.println(num); &#125; &#125; //Function&lt;T,R&gt; 函数型接口: //需求：处理字符串 public String strHandler(String str,Function&lt;String,String&gt; fun)&#123; return fun.apply(str); &#125; @Test public void test3()&#123; String newStr=strHandler(\"\\t\\t\\t 哈哈哈 \", (str)-&gt;str.trim()); System.out.println(newStr); String subStr=strHandler(\"abcdef\", (str)-&gt;str.substring(2,4)); System.out.println(subStr); &#125; //Predicate&lt;T&gt; 断言型接口： //需求：将满足条件的字符串，放入集合中 public List&lt;String&gt; filterStr(List&lt;String&gt; list,Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList=new ArrayList&lt;&gt;(); for ( String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList; &#125; @Test public void test4()&#123; List&lt;String&gt; list=Arrays.asList(\"Hello\",\"jj\",\"Lambda\",\"www\",\"ok\"); List&lt;String&gt; strList=filterStr(list, (s)-&gt;s.length()&gt;3); for (String string : strList) &#123; System.out.println(string); &#125; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Lambda","slug":"Lambda","permalink":"https://yimchengjie.github.io/tags/Lambda/"}]},{"title":"Java输入输出","slug":"JavaSE/Java输入输出","date":"2017-11-14T02:01:00.000Z","updated":"2020-02-26T15:46:35.930Z","comments":true,"path":"2017/11/14/JavaSE/Java输入输出/","link":"","permalink":"https://yimchengjie.github.io/2017/11/14/JavaSE/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"第 1 节:文件 File 类型 java.io.File类的对象可以表示文件和目录，在程序中一个 File 类对象可以代表一个文件或目录 当创建一个 File 对象后，就可以利用它来对文件或目录的属性进行操作，如：文件名、最后修改日期、文件大小等等 需要注意的是，File 对象并不能直接对文件内容进行读/写操作，只能查看文件的属性 第 2 节:输出输出流 输入输出流的概念与作用 流的特点: 流是一串连续不断的数据的集合,只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的 输入流：从外存读取数据到内存，输出流：将数据从内存写到外存中 Java 中输入输出流的类型 对于输入和输出流，由于传输格式的不同，又分为字节流和字符流： Java 的输入输出流的继承树 Java I/O 主要包括: 流式部分:IO 的主体部分； 非流式部分:主要包含一些辅助流式部分的类，如：File 类、RandomAccessFile类和FileDescriptor等类； 其他类:文件读取部分的与安全相关的类，如：SerializablePermission 类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。 字节输出流 OutputStream 提供了 3 个 write 方法来做数据的输出，这个是和 InputStream 是相对应的 OutputStream OutputStream 是一个抽象类，提供了 Java 向流中以字节为单位写入数据的公开接口，大部分字节输出流都继承自 OutputStream 类 DataOutput DataOutput 接口规定一组操作，用于直接向流中写入基本类型的数据和字符串： DataInput 对基本数据类型的写入分别提供了不同的方法，方法名满足writeXXX()的规律,如writeInt()表示向流中写入一个 int 型数据，写入字符串的方法为writeUTF() 常见字节输出流工具的作用与使用 FileOutputStream 类用来处理以文件作为数据输出目的数据流；一个表示文件名的字符串，也可以是 File 或 FileDescriptor 对象。 创建一个文件流对象有以下方法: 方式 1： 12File f=new File(“d:/abc.txt”);FileOutputStream out=new FileOutputStream (f); 方式 2： 1FileOutputStream out=new FileOutputStream(“d:/abc.txt”); 方式 3：构造函数将 FileDescriptor()对象作为其参数。 12FileDescriptor() fd=new FileDescriptor();FileOutputStream f2=new FileOutputStream(fd); 方式 4：构造函数将文件名作为其第一参数，将布尔值作为第二参数。 1FileOutputStream f=new FileOutputStream(“d:/abc.txt”,true); 字节输入流 InputStream 是输入字节数据用的类，所以 InputStream 类提供了 3 种重载的 read 方法. InputStream InputStream 也是一个抽象类，提供了 Java 中从流中以字节为单位读取数据的公开接口，大部分字节输入流都继承自 InputStream 类 DataInput DataInput 接口规定一组操作，用于以一种与机器无关（当前操作系统等）的方式，直接在流中读取基本类型的数据和字符串： DataInput 对基本数据类型的读取分别提供了不同的方法，方法名满足 readXXX()的规律,如 readInt()表示从流中读取一个 int 型数据读取字符串的方法为 readUTF() 常见的字节输入流工具的作用与使用 FileInputStream 类是 InputStream 类的子类，用来处理以文件作为数据输入源的数据流。 使用方法: 方式 1： 12File fin=new File(“d:/abc.txt”);); 方式 2： 1FileInputStream in=new FileInputStream(“d: /abc.txt”); 方式 3: 12FileDescriptor() fd=new FileDescriptor();FileInputStream f2=new FileInputStream(fd); 程序对应的基本输入为键盘输入，基本输出为显示器输出。Java 中，System 类的 in 和 out 两个成员代表了基本输入输出的抽象System.in:基本输入，对应 InputStreamSystem.out:基本输出，对应 PrintStream RandomAccessFile RandomAccessFile 类可以在文件中==任何位置==查找或写入数据 RandomAccessFile==同时实现了 DataInput 和 DataOutput 接口== 磁盘文件都是可以随机访问的， 但是从网络而来的数据流却不是 ByteArrayOutpuStream/ByteArrayInputStream 一对输入输出工具为我们提供了在内存中利用 byte[]进行缓冲流操作的工具 ByteArrayOutputStream 提供工具将内存中以串行序列存在的流式数据以一个字节为单位进行切分，形成一个 byte[]数组 而 ByteArrayInputStream 则正好相反，提供工具将内存中的 byte[]数组中的数据进行串行序列化拼接，形成一个可供操作的流式数据 从功能上看，ByteArrayOutpuStream 可以将任意数据组合转换为 byte[]，而 ByteArrayInputStream 可以将这个数组还原，从而以流的形式读取任意数据组合 字符输出流 考虑到 Java 是跨平台的语言，要经常操作 Unicode 编码的文件，使用基于字符为读、写基本单元的字符流操作文件是有必要的,以字符为单位进行数据输出的工具继承自 Writer 字符输出流的统一数据写入方法 Writer 和 OutputStream 类似也提供了统一的往流中写入数据的方法，和 OutputStream 不同的是，写入数据的单位由字节变成了字符 字符输出流工具的作用与使用 FileWriter 类称为文件写入流，以字符流的形式对文件进行写操作 FileWriter 将逐个向文件写入字符，效率比较低下，因此一般将该类对象包装到缓冲流中进行操作 还可以使用 PrintWriter 对流进行包装，提供更方便的字符输出格式控制 字符输入流 以字符为单位进行数据读取的工具继承自 Reader，Reader 会将读取到的数据按照标准的规则转换为 Java 字符串对象 字符输入流的统一数据读取方法 字符输入流 Reader 也提供的统一读取数据的方法（和 InputStream 不同，实际开发时更多的调用不同 Reader 提供的特殊读取方法，如 BufferedReader 的 readLine()，能够简化操作） 常见的字符输入流工具的作用与使用 FileReader 类称为文件读取流，允许以字符流的形式对文件进行读操作 与 FileWriter 相似，该类将从文件中逐个地读取字符，效率比较低下，因此一般也将该类对象包装到缓冲流中进行操作 字节流与字符流的适配器 在某些时候虽然我们操作的是字符串，但是不得不面对数据来源是 InputStream（字节输入流）的情况，在这种情况下，Java 提供了将 InputStream 和 Reader 之间进行转换的工具，事实上，字节输出流和字符输出流之间也存在这种工具，称为：字节流与字符流的适配器： InputStreamReader： + 字节流通向字符流的桥梁，它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集 + 每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节 + OutputStreamWriter： + 字符流通向字节流的桥梁，使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集 + 每次调用 write() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 write() 方法的字符没有缓冲 第 3 节:对象序列化Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，就可能要求在 JVM 停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能 对象序列化的作用 使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量 除了在持久化对象时会用到对象序列化之外，在网络中传递对象时，也会用到对象序列化。Java 序列化 API 为处理对象序列化提供了一个标准机制 序列化接口 在 Java 中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化 java.io.Serializable是一个标识接口，即意味着它仅仅是为了说明类的可序列化属性，接口没有包含任何需要子类实现的抽象方法 对象序列化和反序列化 将对象的状态信息保存到流中的操作，称为序列化，可以使用 Java 提供的工具ObjectOutputStream. writeObject(Serializable obj)来完成 从流中读取对心状态信息的操作称为反序列化，可以使用 Java 提供的工具ObjectInputStream.readObject()来完成","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"Java核心API","slug":"JavaSE/Java核心API","date":"2017-11-10T02:09:00.000Z","updated":"2020-02-26T15:39:26.535Z","comments":true,"path":"2017/11/10/JavaSE/Java核心API/","link":"","permalink":"https://yimchengjie.github.io/2017/11/10/JavaSE/Java%E6%A0%B8%E5%BF%83API/","excerpt":"","text":"Object Object 类是 Java 语言中所有类的根,所有的类都直接或间接的继承了 Object 类; 数组也继承了 Object 类; Object 类中定义了equals(Object obj)方法,用来比较两个对象的虚拟地址,如果虚拟地址相同则返回 true,否则返回 false; Object 类中的equals()方法的作用,与==相同,都是比较两个对象的虚地址 很多类覆盖了equals方法,用来比较两个对象的属性值,如果属性值相同,则认为两个对象相等,例如[String 类就覆盖了 equals 方法,用来比较两个字符串的字符序列值] Object 类中定义了hashCode方法public int hashCode()，用来返回对象的哈希码； hashCode方法主要为了配合基于哈希的集合类一起工作，例如 HashSet、HashMap 等； 默认情况下(即没有重新 hashCode 方法时)，当两个引用的虚地址相同时，hashCode 返回相同的值，否则返回不同的值； 事实上，基于哈希的集合在使用 hashCode 的时候，基本都是和 equals 一起使用；先用 hashCode 初步比较,再用 equals 比较 注意:使用的时候一起使用,重写的时候也要一起重写 Object 类中定义了toString方法 字符串类型是编程时最常用的类型，Object 类中定义了 toString 方法public String toString()，可以把任意类型对象转换成字符串返回； 默认情况（没有重写 Object 类中的 toString 方法）下，返回字符串的格式为：对象类型@对象调用 hashCode 方法的返回值； 返回 Object 类中默认格式的字符串几乎没有实用意义，因此很多时候，都会重写一些实体类的 toString 方法，返回需要的字符串格式； Object 类中定义了克隆方法clone Clone方法能够“复制”一个对象，生成一个新的引用，分配新的内存空间； 一个类必须实现 Cloneable 接口，才能被克隆，否则抛出异常； 克隆是生成了一个新的对象，然而，对象的属性如果有引用类型，实际上还是公用； 深克隆时，属性不仅值相同，同时又都存储在完全不同的内存中 StringString 类中定义了一系列字符串相关方法，可以根据 API 文档进行学习，练习 子串截取方法: String substring(int beginIndex) String substring(int beginIndex,int endIndex) 检索相关方法: int indexOf(int ch) int indexOf(int ch,int fromIndex) int indexOf(String str) int indexOf(String str,int fromIndex) int lastIndexOf(int ch) int lastIndexOf(int ch,int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str,int fromIndex) char charAt(int index) 类型转换相关的方法: static String valueOf(boolen b) static String valueOf(char c) static String valueOf(char[] data) static String valueOf(char[] data,int offset,int count) static String valueOf(double d) static String valueOf(float f) static String valueOf(int i) static String valueOf(long l) static String valueOf(Object obj) 其他方法: int compareTo(String anotherString) boolean endsWith(String suffix) byte[] getBytes() byte[] getBytes(Charset charset) int length() boolean startsWith(String prefix) boolean startsWith(String prefix,int toffset) String trim() 正则表达式正则表达式就是用来描述字符串逻辑规则的工具 正则表达式本身也是个字符串，不过这些字符串是使用系列“元字符”组成； 所谓“元字符”就是预先定义的，有特殊意义的字符；例如\\d 用来匹配一个数字； \\w 用来匹配字母或数字或下划线或汉字等； 很多语言多对正则表达式提供了支持，例如 JavaScript、Java 等； 不同语言中使用正则表达式时，正则表达式的具体编写规则会有些小的差别，但是大体相同； 正大表达式在 Java 中的使用123456789101112131415161718192021String regex=\"^((13[0-9])|(15[0-3,5-9])|(18[0,2,3,5-9])|(17[0-8])|(147))\\\\d&#123;8&#125;$\";//检验的手机号码String string=\"15123569087\";//第一种方式//将正则表达式编译成Pattern对象Pattern pattern=Pattern.compile(regex);//使用Pattern对象为每个手机号码产生一个匹配器Matcher matcher=pattern.matcher( string);boolean flag=matcher.matches();System.out.println(flag==true?\"手机号正确\":\"手机号错误\");//第二种方式//将正则表法式编译成Pattern对象Pattern pattern2=Pattern.compile(regex);boolean flag2=pattern2.matches(regex, string);System.out.println(flag2==true?\"手机号正确\":\"手机号错误\");//第三种方式boolean flag3=string.matches(regex);System.out.println(flag3==true?\"手机号正确\":\"手机号错误\"); 对象的自然比较内部比较器 一个类如果想【支持排序】，那么就必须实现接口Comparable&lt;T&gt;，该接口被称为对象的内部比较器； 该接口中只有一个方法；int compareTo(T o) 外部比较器 一个类实现 Comparable 这个内部比较器后，该类支持排序，然而只能有一种排序逻辑，比较受限制； 可以使用外部比较器 Comparator，灵活为类定义多种比较器，此时类本身不需要实现 Comparable 接口； Comparator 接口中有两个方法int compareTo(T o1,T o2)和boolean equals(Object obj) 对象数组的排序 java.util.Arrays类是一个针对数组进行操作的工具类，其中提供了对对象数组进行排序的方法； 两个常用的对象数组排序方法如下：static void sort(Object[] a)static &lt;T&gt;void sort(T[] a,ComparaTor&lt;? super T?&gt; c) 数学 APIMath 类提供的数学运算方法: Math 类位于 java.lang 包中，是一个 final 类，不能被继承； Math 类中所有方法都是 static 方法，可以直接使用类名 Math 调用； Math 中定义了大量与数学运算有关的方法，包括求绝对值、三角函数、平方根等； Math 类是 final 类，不能被继承，所有方法都是 static 方法，可以直接用类名调用； Math 中的 round 方法是四舍五入，ceil 是返回大于参数且最接近参数的整数，floor 是返回小于参数且最接近参数的整数； Math 中的 random 方法返回[0.0,1.0)范围的值； Math 类中还定义了很多数学计算方法； Java 中的大整数 API: + Java 中整数最大范围是 long 型，64 位，如果需要使用超过 long 范围的大整数，可以使用 BigInteger 类； + BigInteger 位于 java.math 包中，定义了一系列的数学运算方法，调用这些方法可以进行计算，不能使用运算符计算； + java.math 包中还有一个类叫 BigDecimal，虽然和整数无关，我们也在此一起学习； + BigDecimal 是用来针对浮点型进行精确运算的； + BigInteger 用来对超过 long 范围整数进行运算； + BigDecimal 用来对 double、float 类型进行精确计算； Java 中的随机 API Math 类中的 random 方法可以产生随机数，然而，该方法只能生成[0.0,1.0)范围的 double 值；很多时候，可能需要生成不同类型不同范围的随机值； java.util 包中的 Random 类可以用来生成不同类型的随机值，功能更为强大； Random 类有两个构造方法，无参的构造方法创建对象后，每次都生成不同的随机数；有参的构造方法创建对象后，如果种子参数值一样，那么每次生成的随机数也相同； Random 类功能强大，能生成 int,float,double,boolean 各种类型的随机数； random.nextInt生成不定范围的 int 随机数，而带参数的 nextInt 生成的随机数有范围； UUID UUID 指的是通用唯一识别码，常用于分布式系统； 有多种生成 UUID 的策略，包括基于时间、基于名字、随机等； Java API 中定义了 java.util.UUID 类，对 UUID 的生成提供了支持； DateAPI java.util.Date 类表示时间，不过由于对国际化支持有限，所以 JDK1.1 之后推荐使用 java.util.Calendar 类； JDK1.1 版本开始，增加 Calendar 类，建议使用 Calendar 类代替 Date 类； Calendar 是抽象类，不能直接使用 new 创建对象； Calendar 类中定义了获得实例的方法getInstance(),得到的实际是子类GregorianCalendar的对象!! 获得日历对象后，可以为该对象的年、月、日、时、分、秒等进行赋值： 实际编程中，往往需要对时间用不同的格式进行展示; SimpleDateFormat中定义了对时间进行格式化的方法；该类继承了抽象父类 DateFormat，某些方法在父类中定义，查阅 API 文档时注意； 可以自定义一个模式字符串来构建 SimpleDateFormat 对象： 通常使用 format 方法进行格式化； JDK8 中的新 API JDK8 中定义了java.time.LocalDate，用来表示日期，默认格式是 yyyy-MM-dd；该类不包含时间信息；","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"Java异常处理","slug":"JavaSE/Java异常处理","date":"2017-11-03T10:14:00.000Z","updated":"2020-02-26T15:47:13.673Z","comments":true,"path":"2017/11/03/JavaSE/Java异常处理/","link":"","permalink":"https://yimchengjie.github.io/2017/11/03/JavaSE/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"异常处理和错误的区别异常: 异常指的是程序运行时发生的不正常的时间;异常能够被程序处理,保证程序继续运行下去;例如除数为 0,文件没有找到,输入的数字格式不对;错误: 错误程序没法处理,例如内存泄漏,发生错误后,一般虚拟机会选择终止程序运行,程序员需要修改代码才能解决相关错误; 运行时异常与非运行时异常Exception 有很多子类,这些子类又可以分为两大类;即运行时异常和非运行时异常运行时异常: 也称为非检测异常,这些异常在编译期不检测,程序中可以选择处理,也可以不处理,如果不处理运行时会中断,但编译没问题.非运行时异常: 也称为检测异常,是必须进行处理的异常,如果不处理,将发生编译期错误. 异常处理的标准流程 抛出异常运行时异常 JVM 自行抛出,非运行时异常使用throw抛出 捕获异常catch语句捕获异常 如捕获成功,异常被处理,程序继续运行catch的异常类型与抛出的异常类型匹配时 如捕获失败,异常未被处理,程序中断运行catch的异常类型与抛出的异常类型不匹配 常见的异常类型 Exception: 异常层次结构的父类 ArithmeticException:算术错误情况,如以 0 作除数 ArrayIndexOutOfBoundsException: 数组下标越界 NullPointerException: 尝试访问 null 对象成员 ClassNotFoundException: 不能加载所需的类 ClassCastException:对象强制类型转换出错 NumberFormatException: 数字格式转换异常,如把”abc”转成数字了 Try-catch 代码块1234567891011try &#123; // 代码段 1 // 产生异常的代码段 2 // 代码段 3&#125; catch (异常类型1 e) &#123; // 对异常进行处理的代码段4&#125; catch (异常类型2 e) &#123; // 对异常进行处理的代码段5&#125; finally &#123; // 无论是否发生异常,代码总能执行&#125; Throw,Throws 关键字 throw: 抛出异常(一般用于代码块和方法中) throws: 声明异常(一般用于方法中) 1234567public void setAge(int age)throws Exception&#123; if(age&lt;=0||age&gt;100)&#123; throw new Exception(); //处理方法 try-catch &#125;else&#123; this.age=age; &#125;&#125; 自定义异常123456public class AgeException extends Exception()&#123; public AgeException()&#123;&#125; public AgeException(String msg)&#123; super(msg); &#125;&#125; 断言assert 5&lt;3==false “断言信息”","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java异常处理","slug":"Java异常处理","permalink":"https://yimchengjie.github.io/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"集合框架","slug":"JavaSE/集合框架","date":"2017-10-25T00:58:00.000Z","updated":"2020-02-26T15:38:28.991Z","comments":true,"path":"2017/10/25/JavaSE/集合框架/","link":"","permalink":"https://yimchengjie.github.io/2017/10/25/JavaSE/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"泛型的作用1. 泛型的定义泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数.这种参数类型,可以在类 接口 和方法中创建,分别称为泛型类、泛型接口、泛型方法。 Java 语言引入泛型的好处是安全简单。 2. 泛型的作用引入泛型的好处是安全简单 可以将运行时类型相关错误提前到编译时错误. 3. 泛型的特点 所有的泛型类的参数在编译时都会被擦除,虚拟机运行时没有泛型. java 泛型不支持基本类型 在泛型内部,无法获得有关系泛型参数类型的信息,如果传入的类型参数为 T,那么在泛型代码内部你不知道 T 有什么方法,属性,关于 T 的一切信息都丢失了 创建泛型对象时,清指明类型. java 的泛型类型不能用于 new 构建对象,也不能用于初始化数组. 集合接口1.为什么要使用集合接口如果并不知道程序运行时会需要多少对象，或者需要更复杂方式存储对象——可以使用 Java 集合框架 2. 集合框架组成Java 容器主要包括 Collection 和 Map 两种,Collection 存储这对象的集合,而 Map 存储着键值对(两个对象)的映射表 Collection 接口是最基本的集合接口. SetTreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作，但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1),TreeSet 则为 O(logN)HashSet：基于哈希表（实际上是一个 HashMap 的实例）实现，内部使用 HashMap 来存储数据,数据存储在 HashMap 的 key 中,value 都是同一个默认的 Object 值，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的linkedHashSet：具有 HashSet 的查找效率,且内部使用双向链表维护元素的插入顺序，与 HashMap 的区别是内部使用 LinkHashMap 来存储数据，意义是保证元素的顺序 ListArrayList：基于动态数组(Object[])实现，支持随机访问。动态数组是当容量不够时，创建一个大约 1.5 倍于原数组的空数组，然后将旧数组拷贝至新创建的数组中。 Vector：和 ArrayList 类似，但它是线程安全的LinkedList：基于双向链表实现，只能随机访问，但是可以快速的在链表中插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue：LinkedList：可以用它来实现双向队列。PriorityQueue：基于堆结构，可以用它来实现优先队列。 Map 接口(实现类:HasMap . TreeMap) TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同 一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为它引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"Java集合容器","slug":"Java集合容器","permalink":"https://yimchengjie.github.io/tags/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"}]},{"title":"面向接口编程","slug":"JavaSE/面向接口编程","date":"2017-10-23T10:27:00.000Z","updated":"2020-02-26T15:38:53.199Z","comments":true,"path":"2017/10/23/JavaSE/面向接口编程/","link":"","permalink":"https://yimchengjie.github.io/2017/10/23/JavaSE/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"什么是接口,为什么要用接口 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。 接口(interface)是抽象方法和常量值的定义的集合。 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。 接口定义举例 123456public interface Runner &#123; int id = 1; public void start(); public void run(); public void stop();&#125; 接口的特点 用 interface 来定义。 接口中的所有成员变量都默认是由 public static final 修饰的。 接口中的所有方法都默认是由 public abstract 修饰的。接口没有构造方法。 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口也可以继承另一个接口，使用 extends 关键字 实现接口的类中必须提供接口中所有方法的具体实现内容。 多个无关的类可以实现同一个接口 一个类可以实现多个无关的接口 与继承关系类似，接口与实现类之间存在多态性 接口的使用 编写接口 123456public interface UsbInterface&#123; /** *USB接口提供服务 */ void service();&#125; 实现接口 12345public class UDisk implements UsbInterface&#123; public void service()&#123; System.out.println(\"连接USB口,开始传输数据.\"); &#125;&#125; 使用接口 12UsbInterface uDisk = new UDisk();uDisk.service();","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"interface","slug":"interface","permalink":"https://yimchengjie.github.io/tags/interface/"}]},{"title":"深入面向对象","slug":"JavaSE/深入面向对象","date":"2017-10-15T01:13:00.000Z","updated":"2020-02-26T15:39:05.969Z","comments":true,"path":"2017/10/15/JavaSE/深入面向对象/","link":"","permalink":"https://yimchengjie.github.io/2017/10/15/JavaSE/%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象的三个基本特征:封装 . 继承 . 多态封装(属性 . 对象) 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象 继承 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法 一个新类可以从现有的类中派生，这个过程称为类继承，新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类） 派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要 多态 多态性是指允许不同类的对象对同一消息作出响应 多态性语言具有灵活、抽象、行为共享、代码共享的优势 封装的意义 适当的封装可以让代码更容易理解和维护，也加强了代码的安全性。 包机制 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间 包的作用 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也提供了限定了访问权限的一个控制范围，拥有包访问权限的类才能访问某个包中的类 类的访问控制符 default: 默认的（不提供访问控制符）仅可被同包的其他代码访问 public：可以被任何代码访问 protected: private: 私有的 继承的意义继承是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的数据或新的功能,也可以用父类的功能,通过使用继承,我们能够非常方便的复用代码,大大提高开发效率 对象向上造型:所谓的向上造型就是父类的引用指向子类的对象 instanceof 运算符:instanceof 运算符用来判断对象是否属于某个类的实例","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"},{"name":"面向对象","slug":"面向对象","permalink":"https://yimchengjie.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java类的基本结构","slug":"JavaSE/Java类的基本结构","date":"2017-10-10T02:13:00.000Z","updated":"2020-02-26T15:40:05.487Z","comments":true,"path":"2017/10/10/JavaSE/Java类的基本结构/","link":"","permalink":"https://yimchengjie.github.io/2017/10/10/JavaSE/Java%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","excerpt":"","text":"面向对象的概念什么是类同时将具有相同特征的对象抽象成一种新的数据类型—-类(具有相同特征和行为的多个对象的集合) 封装的好处一个类把属性算法(逻辑处理)封装起来,只留必要的方法(接口)让用户使用,一个类该暴露什么,不该暴露什么,由类的设计者更具需求设计决定的.private 属性用户不能直接访问,如果设计者提供相应的接口方法,那么用户可以通过该接口方法访问.一个类,不直接修改属性而通过方法来修改,可以在方法里做相应的处理避免用户输入的一些非法数据而造成系统故障 什么是构造方法 构造方法是与类同名的方法 没返回值，也不能写 void 主要作用是完成新建对象的初始化工作 一般不能显式地直接调用，而是用 new 来调用（后面会存在使用 this/super 调用） 创建一个类的新对象的同时，系统自动调用该类的构造函数，为新建对象的初始化 构造方法重载 构造方法是一种特殊的方法，它也能重载 构造函数的重载是指同一个类中存在着若干个具有不同参数列表的构造函数 this 关键字this 用于表示当前对象自身的引用，可以用于访问被局部变量隐藏的成员变量，也可以将本对象作为参数传递给其他对象操作 类初始化代码块 staticstatic 代码块的执行时机 用 Class.forName(类名)显式加载的时候（反射、JDBC 时详细讲解） new 或反射实例化一个类的对象时候 调用类的 static 方法的时候（后续详细讲解） 调用类的 static 变量的时候（后续详细讲解） 调用类的静态常量（后续详细讲解）的时候，是不会加载类的，即不会执行 static{}语句块当访问类的静态常量时，如果编译器可以计算出常量的值，则不会加载类，否则会加载类 用 Class.forName()形式的时候，也可以自己设定要不要加载类，如将Class.forName(&quot;Test&quot;)改为 Class.forName(&quot;Test&quot;,false,StaticBlockTest.class.getClassLoader())，你会发现 Test 没有被加载，static{}没有被执行","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"Java数组","slug":"JavaSE/Java数组","date":"2017-10-08T08:21:00.000Z","updated":"2020-02-26T15:46:47.029Z","comments":true,"path":"2017/10/08/JavaSE/Java数组/","link":"","permalink":"https://yimchengjie.github.io/2017/10/08/JavaSE/Java%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组 数组是一组类型相同的数据的集合 数组可以存储多个数据,但类型必须相同 数组能作为数据的容器使用,把多个数据集中存储 存储在数组中的数据,都有相应的索引值,可以方便获取或修改 当需要同时保存多个类型相同的变量并进行处理时,可以考虑用数组 数组的特性 Java 的数组是引用类型， 数组与类、接口、枚举、注解并列，是引用类型中的一种， Java 的数组长度一经确定不能改变； 数组在内存中是连续分配，所以读取速度快 实际应用中，常常无法确定变量的数量，后续我们将学习集合框架，实现可变长度的数据容器； 数组的元素 数组中存储的数据称为数组的元素(Element)， 数组本身是引用类型，但是数组中的元素可以是基本数也可以是引用类型， 也就是说，即可以有存储基本数据类型 int 的数组，也可以有存储引用类型 String 的数组，但是数组本身是引用类型 数组中的元素有索引值，索引值从 0 开始 也就是说，如果一个数组的长度是 10，那么索引值就是 0-9，也就是第一个元素的索引值是 0，第二个的索引值是 1，以此类准，通过索引值可以方便访问元素 数组的维数 如果一个数组中存储数据结构如下所示，元素都是单个数据，称为一维数组，67 78 54 89 12 45 87 97 79 9 其中，67 被称为第 0 个元素，78 称为第 1 个元素…… 如果个数组中存储数据结构如下所示，元素是一维数组，称为二维数组，[67 78 54][89 12] [45 87 79][3] 数组声明一维数组的声明:数组元素类型[] 变量名称 或数组元素类型 变量名称[]","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"Java基础","slug":"JavaSE/Java基础","date":"2017-10-05T05:43:00.000Z","updated":"2020-02-26T15:39:46.200Z","comments":true,"path":"2017/10/05/JavaSE/Java基础/","link":"","permalink":"https://yimchengjie.github.io/2017/10/05/JavaSE/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"为什么学习 javaJava 是 Sun Microsystems 于 1995 年推出的高级编程语言Java 领域的 JavaSE、JavaEE 技术已发展成为同 C#和.NET 平分天下的应用软件开发平台和技术 java 语言的特点 跨平台性;一处编写,处处运行. 面向对象(三大特征);封装.继承.多态. 健壮性;强类型机制,异常处理机制,自动垃圾回收机制 分布式; 多线程; 动态性; JVM(Java Virtual Machine)介绍JVM 称为 java 虚拟机;JVM 可以理解为 Java 编译器和操作系统之间的虚拟处理器; 编译器编译的字节码只要 JVM 认识即可 JVM 再将字节码解释成操作系统认识的机器码 只要需要运行 Java 程序的设备,都需要安装 JVM JDK 与 JRE JDK 是 Java 开发工具包(Java Development Kit)的简称,是一个软件;如果要用 Java 语言编写程序,就必须在计算机上安装 JDK; JRE 是 Java 运行环境(Java Runtime Environment)的简称如果要在机器上运行 Java 程序,就必须要有 JRE; JDK 的一些常用工具 javac: 编译器,将源程序转为字节码; java: 运行编译后的 java 程序(.class 后缀的); jar: 打包工具,将相关的类文件打包成一个文件; javadoc: 文档生成器,从源码注释中提取文档; Java 项目结构src 目录：存放包和源文件JRE 系统库目录：存放程序运行必须的系统库文件bin 目录：存放可执行的字节码文件 注释文本注释: 1234/*** version ycj* data 2017-03-05* / 标识符命名规则 某一个区域中是唯一的，在不同的区域中可以使用同一名字 必须由字母、数字、下划线和$符号组成 不能以数字开头 不能使非法的字符，如：#，％……“&amp;等 不能使系统关键字 不能使空格来分隔 长度无限制 严格区分大小写 不同的标识符有一定的命名规矩，后续学习 成员变量和局部变量的区别成员变量是作用于整个类,局部变量作用于某个方法,局部变量没有默认值,必须初始化,成员变量有默认值. 数据类型数据类型分为基本数据类型和引用数据类型; 数据类型(8 个基本数据类型):byte, short, int, long, float, double, boolean, char 引用数据类型:String, 数组, 接口, 类, 枚举, 包装类型 String、StringBufferStringBuilder 的区别String类是不可变的，对象一旦被创建，就不能被修改；可以使用=直接赋值，此时使用常量池；也可以使用 new 创建，不使用常量池；StringBuffer是可变的，对象创建后，可以修改；必须使用 new 关键字；StringBuilder是不同步的，在单线程情况下使用比 StringBuffer 高效；必须使用 new 关键字； 堆,栈,常量池,方法区基本数据类型保存在栈中,引用数据类型保存在堆中;堆:存放所有 new 出来的对象栈:存放基本类型的变量数据和对象的应用方法区:包含所有的 class 和 static 变量常量区:存放基本类型和字符串常量 运算符从功能角度分，Java 中的运算符可以分为算术、关系、位、逻辑运算符四类算术运算符:用来对操作数进行数学运算.关系运算符:又叫比较运算符,用来运算操作两个数的大小关系.位运算符:针对操作数的二进制位进行运算逻辑运算符:针对布尔值或返回值为布尔值的表达式进行运算","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://yimchengjie.github.io/tags/JavaSE/"}]},{"title":"Web开发入门","slug":"JavaEE/Web开发入门","date":"2017-09-30T09:12:00.000Z","updated":"2020-02-26T15:37:36.395Z","comments":true,"path":"2017/09/30/JavaEE/Web开发入门/","link":"","permalink":"https://yimchengjie.github.io/2017/09/30/JavaEE/Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"C/S B/S 网络应用C/S就是(客户机/服务器)的简称,桌面应用程序采用的多是这种结构.B/S就是(浏览器/服务器)的简称,特点是客户端无需安装特定的软件,只需要安装一个浏览器就可以与系统进行交互 C/S 优缺点由于 C/S 结构没有像 B/S（下一个基本概念介绍）结构中服务器向客户端发送的数据还包含了大量的非实际交换数据，比如请求响应头，还有页面数据等等，它的==相应时间还是相对较快==的；由于 C/S 结构安装的客户端软件，很多的业务逻辑、算法逻辑处理都在客户端进行，这样就==减轻了服务器的压力==，这是优点，但是带来的问题也显而易见，不但==有被反编译的安全隐患==，而且不断的安装各种客户端软件，会使==客户端越来越臃肿==；在升级维护等工作上带来的麻烦也是令人不愉快，因为每发生一次升级都需要重新更新客户端的软件，这样做的后果就是在==开发上的工作量加大==，而且用户每次都要更新自己终端上的软件，这些都是令人非常头疼的问题；由于需要在客户端进行安装特定软件，因此==对操作系统有一定的限制==； Web 站点、Web 应用、HTTP 服务器、Web 应用服务器==Web 站点:==即 Web Site,也被成为 Web 网站;比如某公司逛完就是 Web 站点==Web 应用:==即 Web Application,简单来说,就是通过浏览器访问的应用程序,从而为客户提供相应服务==Http 服务器:==即 Web 服务器,主要功能是提供网上信息浏览服务,例如 Apache、Nginx、IIS 是比较常用的 HTTP 服务器.==Web 应用服务器:==Web 应用服务器能够运行服务器上的应用程序,并将结果返回给客户端浏览器;例如 Tomcat,通常 Web 应用服务器兼具部分 Http 服务器的功能.==Servlet 的概念及功能:== Servlet 运行在服务器端，需要 Servlet 容器的支持，例如 Tomcat； 可以通过浏览器访问 Servlet，Servlet 可以生成动态页面返回给浏览器； Servlet 也是一段代码，是一个 Java 类，这个 Java 类需要遵守一定的编写规范，例如，必须继承于 javax.servlet.http.HttpServlet 类；","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/categories/JavaEE/"}],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://yimchengjie.github.io/tags/JavaEE/"},{"name":"Servlet","slug":"Servlet","permalink":"https://yimchengjie.github.io/tags/Servlet/"}]}]}